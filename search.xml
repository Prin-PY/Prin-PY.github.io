<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>遇到的问题及解决</title>
      <link href="2023/07/25/Unreal-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>2023/07/25/Unreal-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>修改代码不生效：需要在VS中Rebuild，或者在UE中对Module进行Recompile</p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见问题</title>
      <link href="2023/07/25/Unreal-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>2023/07/25/Unreal-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>adaptive icon 问题： <a href="https://www.unrealengine.com/en-US/tech-blog/adding-adaptive-icons-to-a-ue4-project-for-android" target="_blank" rel="noopener">https://www.unrealengine.com/en-US/tech-blog/adding-adaptive-icons-to-a-ue4-project-for-android</a></p><p>接入插件后，无法用Unreal Editor启动工程</p><p>要把插件编译成与Unreal Editor版本一致的版本。并且要把Development Editor Win64版本的编译出来，因为Unreal Editor是在Windows上启动的，即使工程是Android工程，也不能只编译Android的。ban’ben</p><p>Output乱码：<a href="https://blog.csdn.net/netyeaxi/article/details/81206896" target="_blank" rel="noopener">https://blog.csdn.net/netyeaxi/article/details/81206896</a></p><h1 id="“error-LNK2019-无法解析的外部符号”"><a href="#“error-LNK2019-无法解析的外部符号”" class="headerlink" title="“error LNK2019: 无法解析的外部符号”"></a><a href="https://www.cnblogs.com/hiloves/p/4678848.html" target="_blank" rel="noopener">“error LNK2019: 无法解析的外部符号”</a></h1><p>函数声明了，但是没有写实现</p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CI】Mac自动导入证书</title>
      <link href="2023/07/25/Unreal-%E3%80%90CI%E3%80%91Mac%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E8%AF%81%E4%B9%A6/"/>
      <url>2023/07/25/Unreal-%E3%80%90CI%E3%80%91Mac%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p><code>csharp pipeline { stages { stage(&#39;Code Sign&#39;) { steps { sh &quot;&quot;&quot; # Create Temp Keychain and Import security create-keychain -p $TEMP_KEYCHAIN_PASSWORD $TEMP_KEYCHAIN_NAME security import $CERT_FILE_PATH -k $TEMP_KEYCHAIN_NAME -P $CERT_PASSPHRASE -T /usr/bin/codesign # Set Partition List security set-key-partition-list -S apple-tool:,apple: -s -k $TEMP_KEYCHAIN_PASSWORD $TEMP_KEYCHAIN_NAME # Set Search List security list-keychains -s `security list-keychains | xargs` $TEMP_KEYCHAIN_NAME # Other Settings security set-keychain-settings -t 3600 $TEMP_KEYCHAIN_NAME security unlock-keychain -p $TEMP_KEYCHAIN_PASSWORD $TEMP_KEYCHAIN_NAME # Show Identities security find-identity -vp codesigning # Do your own work here &quot;&quot;&quot; } } } post { cleanup { sh &quot;&quot;&quot; # Remove Temp Keychain security delete-keychain $TEMP_KEYCHAIN_NAME || true &quot;&quot;&quot; } }}</code> </p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术笔记</title>
      <link href="2023/07/25/Unreal-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
      <url>2023/07/25/Unreal-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>UE_LOG:</p><p><a href="https://blog.csdn.net/zhang1461376499/article/details/113351948" target="_blank" rel="noopener">https://blog.csdn.net/zhang1461376499/article/details/113351948</a></p><p><a href="https://blog.csdn.net/liulong1567/article/details/52449000" target="_blank" rel="noopener">https://blog.csdn.net/liulong1567/article/details/52449000</a></p><p><a href="https://unrealcommunity.wiki/logging-lgpidy6i" target="_blank" rel="noopener">https://unrealcommunity.wiki/logging-lgpidy6i</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与API</title>
      <link href="2023/07/25/Unreal-%E7%B1%BB%E4%B8%8EAPI/"/>
      <url>2023/07/25/Unreal-%E7%B1%BB%E4%B8%8EAPI/</url>
      
        <content type="html"><![CDATA[<ul><li>UObject </li></ul><h2 id="UObject"><a href="#UObject" class="headerlink" title="UObject"></a>UObject</h2>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题笔记</title>
      <link href="2023/07/25/Unreal-%E6%97%A0%E6%A0%87%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>2023/07/25/Unreal-%E6%97%A0%E6%A0%87%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】常用预处理指令</title>
      <link href="2023/07/25/Unreal-%E3%80%90C-%E3%80%91%E5%B8%B8%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/"/>
      <url>2023/07/25/Unreal-%E3%80%90C-%E3%80%91%E5%B8%B8%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/cartzhang/article/details/22726167" target="_blank" rel="noopener">https://blog.csdn.net/cartzhang/article/details/22726167</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal资源管理</title>
      <link href="2023/07/25/Unreal-Unreal%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>2023/07/25/Unreal-Unreal%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>说明：较大的篇幅整理自知乎答主quabqi的文章。链接：<a href="https://zhuanlan.zhihu.com/p/357904199" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/357904199</a></p><h2 id="UE4的资源文件和内存里对象的关系是什么？"><a href="#UE4的资源文件和内存里对象的关系是什么？" class="headerlink" title="UE4的资源文件和内存里对象的关系是什么？"></a>UE4的资源文件和内存里对象的关系是什么？</h2><p>Content目录下的资源：uasset（大部分）, umap 作为后缀<br>在打包时，这些文件可能会根据平台需要，被cook成更小的平台专用文件，然后被放在后缀是pak的压缩包里。<br>游戏运行时，程序就会挂载解压这些pak包，然后加载包中的资源文件来使用。<br>程序在用资源的时候，把这些文件转化为UObject或其他程序可以用的内存对象。</p><p>Asset is a UObject that can be dumped down to file (uasset package) and can be loaded back to the memory from that file and in is mainly used to store game resources, when you load them they are avable in memory as UObject objects like UBlueprint, UTexture2D, USkeletalMesh. USoundWave and so on. Every type of asset you see in content browser has corresponding class and each asset you see in “content Browser” is a UObject that is in memory or can be loaded in memory.</p><blockquote><p>网格资源文件，程序用的实际是UStaticMesh对象</p></blockquote><h2 id="资源-gt-UObject对象"><a href="#资源-gt-UObject对象" class="headerlink" title="资源-&gt;UObject对象"></a>资源-&gt;UObject对象</h2><p>把资源文件，转变为内存里的UObject对象</p><ul><li>读取资源文件的数据到内存</li><li>根据内存的二进制数据，把空壳对象反序列化成实际的对象</li><li>如果这个对象有依赖其他对象，就递归的去做1和2的操作，直到这个对象完整可用</li><li>调用对象的初始化函数，并将对象加入到引擎的对象管理中</li></ul><h2 id="加载与查找"><a href="#加载与查找" class="headerlink" title="加载与查找"></a>加载与查找</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>FindObject<br>FindObjectFast<br>FindObjectChecked<br>FindObjectSafe<br>FSoftObjectPath::ResolveObject</p><p>在内存中查找对象，找到就会返回，找不到会返回nullptr，不会触发加载。<br>如果传入了Outer，就会在Outer所在的Package下面找对应的资源对象，如果没有Outer就会在全局找这个资源对象。</p><h3 id="同步加载资源"><a href="#同步加载资源" class="headerlink" title="同步加载资源"></a>同步加载资源</h3><p>LoadObject<br>LoadClass<br>LoadPackage</p><p>先调用FindObject在内存中找，找到了直接返回，没找到就会进入同步加载。再深入底层可以看到，最终调用的是LoadPackageAsync函数，这就是异步加载的入口，并且最后FlushAsyncLoading，内部阻塞等待，将异步加载转为同步</p><p>FSoftObjectPath::TryLoad<br>FStreamableManager::RequestSyncLoad<br>FStreamableManager::LoadSynchronous<br>FStreamableManager::RequestAsyncLoad<br>FlushAsyncLoading（异步转同步）</p><p>更上层的封装，最终走到LoadPackageAsync</p><h3 id="异步加载资源"><a href="#异步加载资源" class="headerlink" title="异步加载资源"></a>异步加载资源</h3><p>LoadPackageAsync<br>FStreamableManager::RequestAsyncLoad</p><h3 id="判断加载状态"><a href="#判断加载状态" class="headerlink" title="判断加载状态"></a>判断加载状态</h3><p>GIsSavingPackage<br>IsGarbageCollectingOnGameThread<br>IsLoading<br>GetNumAsyncPackages<br>GetAsyncLoadPercentage<br>FStreamableManager::IsAsyncLoadComplete</p><h3 id="加载底层深入"><a href="#加载底层深入" class="headerlink" title="加载底层深入"></a>加载底层深入</h3><p><img src="Unreal资源管理/Image.png" alt=""></p><p>一个UPackage文件就是这样的，有很多UObject序列化的二进制数据</p><p><a href="https://zhuanlan.zhihu.com/p/357904199" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/357904199</a></p><p>加载的模式：</p><p>加载的模式引擎加载资源内部有两种模式，一个是Async，一个是EDL（EventDrivenLoader）<br>Async：会启动一个专门的加载线程负责Tick资源加载<br>EDL：在主线程Tick加载，加载的每一个步骤通过事件串联起来  </p><p><img src="Unreal资源管理/Image_1.png" alt=""></p><h3 id="硬引用-amp-软引用"><a href="#硬引用-amp-软引用" class="headerlink" title="硬引用 &amp; 软引用"></a>硬引用 &amp; 软引用</h3><p>硬引用就是自己的对象上，用UProperty标记的那些UObject指针变量，当在反序列化对象时，因为这些变量引用的资源必须跟着一起序列化好才能保证当前的对象是好的，所以这些变量在存储时会反应到Import表里面。自己写的UProperty资源越多，这个资源加载的就越慢</p><p>软引用就是FSoftObjectPath或TSoftObjectPtr引用的资源变量，这些不会随着当前对象一起加载，但是需要业务逻辑在需要用的时候手动调用加载代码来加载。</p><h2 id="Asset-Registry-amp-Object-Libraries"><a href="#Asset-Registry-amp-Object-Libraries" class="headerlink" title="Asset Registry &amp; Object Libraries"></a>Asset Registry &amp; Object Libraries</h2><h3 id="Asset-Registry"><a href="#Asset-Registry" class="headerlink" title="Asset Registry"></a>Asset Registry</h3><p>Background:</p><ul><li>As assets are UObjects normally you would seek them out from reflection system.</li><li>Searching them in reflection system is pointless if they are not loaded first.</li></ul><p>The asset registry is a system that stores metadata about assets and allows searches and queries about those assets.</p><p>It <strong>keep track of Assets regardless if they are loaded or not</strong>.<br>It allows you to list out assets, get there regestry entry (FAssetData) and load them up, it also a to more optimized way to seek assets that are loaded already, as well as edit there registry information.</p><p>“Content Browser” in reality is Asset Registry explorer and it mainly use AssetRegistry to list and edit assets in there.</p><h3 id="ObjectLibrary"><a href="#ObjectLibrary" class="headerlink" title="ObjectLibrary"></a>ObjectLibrary</h3><p>An ObjectLibrary is an object that contains a list of either loaded objects or FAssetData for unloaded objects.</p><p><code>csharp if (!ObjectLibrary) { ObjectLibrary = UObjectLibrary::CreateLibrary(BaseClass, false, GIsEditor); ObjectLibrary-&gt;AddToRoot(); } ObjectLibrary-&gt;LoadAssetDataFromPath(TEXT(&quot;/Game/PathWithAllObjectsOfSameType&quot;); if (bFullyLoad) { ObjectLibrary-&gt;LoadAssetsFromAssetData(); }</code> </p><h3 id="StreamableManager-amp-Asynchronous-Loading"><a href="#StreamableManager-amp-Asynchronous-Loading" class="headerlink" title="StreamableManager &amp; Asynchronous Loading"></a>StreamableManager &amp; Asynchronous Loading</h3><p>FStreamableManager::RequestSyncLoad<br>FStreamableManager::LoadSynchronous<br>FStreamableManager::RequestAsyncLoad</p><p>pass your <strong>FSoftObjectPath</strong> into it and start a load</p><blockquote><p>You can use the same method to asynchronously load a <strong>FAssetData</strong> , just call ToStringReference on them, add them to an array, and call RequestAsyncLoad with a delegate.</p></blockquote><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><img src="Unreal资源管理/Image_2.png" alt=""></p><p><img src="Unreal资源管理/Image_3.png" alt=""></p><h2 id="文档连接"><a href="#文档连接" class="headerlink" title="文档连接"></a>文档连接</h2><p>Asset Registry：<a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Assets/Registry/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Assets/Registry/</a></p><p>Asynchronous Asset Loading:<a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Assets/AsyncLoading/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Assets/AsyncLoading/</a></p><p>UObjectLibrary:<a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Engine/UObjectLibrary/CreateLibrary/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Engine/UObjectLibrary/CreateLibrary/</a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/357904199" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/357904199</a><br><a href="https://blog.csdn.net/qq_40947718/article/details/108521495" target="_blank" rel="noopener">https://blog.csdn.net/qq_40947718/article/details/108521495</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal工程目录结构</title>
      <link href="2023/07/25/Unreal-Unreal%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>2023/07/25/Unreal-Unreal%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://muyunsoft.com/blog/Unreal4/Basic/DirectoryStructure.html#%E6%A0%B9%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">https://muyunsoft.com/blog/Unreal4/Basic/DirectoryStructure.html#%E6%A0%B9%E7%9B%AE%E5%BD%95</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal插件开发</title>
      <link href="2023/07/25/Unreal-Unreal%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>2023/07/25/Unreal-Unreal%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>Engine /[UE4 Root]/Engine/Plugins/[Plugin Name]/</p><p>Game /[Project Root]/Plugins/[Plugin Name]/<br>(will be detected and loaded at Engine or Editor start-up time)</p><p>Public/Classes的父目录名就是module名</p><h3 id="Plugin-Descriptor-Files"><a href="#Plugin-Descriptor-Files" class="headerlink" title="Plugin Descriptor Files"></a>Plugin Descriptor Files</h3><p>Plugin descriptor Files: <code>.uplugin</code><br>API: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Projects/FPluginDescriptor/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/API/Runtime/Projects/FPluginDescriptor/</a></p><p>Category：类目名即在插件浏览器中所属的类目。<br>Installed：默认启用或禁用状态，在插件浏览器中可以控制加载卸载插件模块。<br>Modules：描述模块名、运行类型、加载时机、支持平台等信息。<br>Type：Runtime，RuntimeNoCommandlet，Developer，Editor，EditorNoCommandlet，Program。<br>LoadingPhase：Default，PreDefault，PostConfigInit，PostConfigInit。<br>WhitelistPlatforms：支持的平台<br>BlacklistPlatforms：不支持的平台</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>unreal的理念是开发工作都是在工程目录进行，包括插件开发</p><h3 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h3><p><a href="https://blog.csdn.net/jxyb2012/article/details/88839224" target="_blank" rel="noopener">https://blog.csdn.net/jxyb2012/article/details/88839224</a></p><p><code>csharp &quot;E:\Program Files\Epic Games\UE_4.25\Engine\Build\BatchFiles\RunUAT.bat&quot; BuildPlugin Plugin=&quot;D:\work\UE4_25\PluginFactory\Plugins\MyNewPlugin\MyNewPlugin.uplugin&quot; Package=&quot;D:\work\UE4_25\PluginPackaged&quot;</code> </p><h2 id="插件编译执行过程"><a href="#插件编译执行过程" class="headerlink" title="插件编译执行过程"></a>插件编译执行过程</h2><p>Plugins will automatically be compiled by UBT when compiling your game project.</p><p><code>csharp #pragma once #include &quot;CoreMinimal.h&quot; #include &quot;ModuleManager.h&quot; class FPanoCamModule : public IModuleInterface { public: /** IModuleInterface implementation */ virtual void StartupModule() override; virtual void ShutdownModule() override; };</code> </p><p>每个独立模块都有一个类继承自 IModuleInterface，重写了插件加载卸载的方法。</p><p>.uplugin文件中Modules下的LoadingPhase字段说明了模块加载的时机，当满足这个时机时此模块StartupModule函数将被调用。此插件的功能入口就是从这里开始。当程序关闭或主动调用ShutdownModule函数时，模块将被卸载。</p><h2 id="编辑器拓展开发接口"><a href="#编辑器拓展开发接口" class="headerlink" title="编辑器拓展开发接口"></a>编辑器拓展开发接口</h2><p>LevelEditorModule.GetToolBarExtensibilityManager()可以拓展关卡编辑器的工具栏，GetMenuExtensibilityManager()可以拓展菜单栏。<br>GEditor-&gt;GetEditorSubsystem<UAssetEditorSubsystem>()-&gt;OnAssetOpenedInEditor()，可以监听UE中，任意编辑器打开的事件。<br>FCoreUObjectDelegates::OnObjectPropertyChanged可以监听任意Object，任意属性的变化事件。</p><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><h3 id="Include"><a href="#Include" class="headerlink" title="Include"></a>Include</h3><blockquote><p>unreal中所有头文件都可以include。只是ue建议只include public目录或Classes的头文件，不建议include private目录的。</p></blockquote><h4 id="Include-public"><a href="#Include-public" class="headerlink" title="Include public"></a>Include public</h4><p>在XXX.Build.cs文件中添加依赖Module：PublicDependencyModuleNames.AddRange<br>然后在某个源码文件，直接include。（从Public/Classes开始算路径）</p><h4 id="Include-private"><a href="#Include-private" class="headerlink" title="Include private"></a>Include private</h4><p>在当前插件模块的build.cs文件中添加Private目录:</p><p><code>csharp var EngineDir = Path.GetFullPath(Target.RelativeEnginePath); PrivateIncludePaths.AddRange( new string[] { Path.Combine(EngineDir, &quot;Source/Editor/AnimationBlueprintEditor/Private/&quot;), });</code> <code>csharp // 用尖括号也可以 #include &quot;AnimationBlueprintEditor.h&quot;</code> </p><h3 id="添加第三方依赖库"><a href="#添加第三方依赖库" class="headerlink" title="添加第三方依赖库"></a>添加第三方依赖库</h3><p>PublicIncludePaths.Add(zlibPath + “include” + platform); //把（.h）头文件路径引入。<br>PublicLibraryPaths.Add(zlibPath + “lib” + platform); //把（.lib）库文件路径引入。<br>PublicAdditionalLibraries.Add(“zlibstatic.lib”); //把（.lib）库文件引入。</p><p><a href="https://blog.csdn.net/jxyb2012/article/details/88839224" target="_blank" rel="noopener">https://blog.csdn.net/jxyb2012/article/details/88839224</a></p><h4 id="链接错误的解决方法"><a href="#链接错误的解决方法" class="headerlink" title="链接错误的解决方法"></a>链接错误的解决方法</h4><ol><li>确保：把所属module添加到PublicDependencyModuleNames中</li><li>确保：如果缺失的函数or类是某个插件中的，需要标识为API，在函数前加入对应API宏。</li></ol><blockquote><p>例如module名为SamplePlg，则API宏为：SAMPLEPLG_API</p></blockquote><h3 id="访问private或protected的UPROPERTY"><a href="#访问private或protected的UPROPERTY" class="headerlink" title="访问private或protected的UPROPERTY"></a>访问private或protected的UPROPERTY</h3><p><code>csharp USTRUCT() struct FAnimLinkableElement { GENERATED_USTRUCT_BODY() protected: /** The slot index we are currently using within LinkedMontage */ UPROPERTY(EditAnywhere, Category=AnimLink) int32 SlotIndex; };</code> <code>csharp int32* GetSlotIndex(void *pAnimLinkableElement) { static UScriptStruct* Struct = FindObjectSafe&lt;UScriptStruct&gt;(ANY_PACKAGE, TEXT(&quot;AnimLinkableElement&quot;)); auto Prop = Struct-&gt;FindPropertyByName(TEXT(&quot;SlotIndex&quot;)); check(Prop); return Prop-&gt;ContainerPtrToValuePtr&lt;int32&gt;(pAnimLinkableElement); }</code> </p><h2 id="Build-cs"><a href="#Build-cs" class="headerlink" title="Build.cs"></a>Build.cs</h2><p>配置文件属性详细说明：<a href="https://blog.csdn.net/jxyb2012/article/details/88839224" target="_blank" rel="noopener">https://blog.csdn.net/jxyb2012/article/details/88839224</a></p><p><code>csharp using UnrealBuildTool; using System.IO; //路径获取需要用到IO public class TestPlugin : ModuleRules ｛ private string ModulePath //当前TestPlugin.Build.cs文件所在的路径 ｛ get ｛ return Path.GetDirectoryName(RulesCompiler.GetModuleFilename(this.GetType().Name)); ｝ ｝ private string ThirdPartyPath //这个插件引用的第三方库的目录 ｛ get ｛ return Path.GetFullPath(Path.Combine(ModulePath, &quot;../../ThirdParty/&quot;)); ｝ ｝ private string MyTestLibPath //第三方库MyTestLib的目录 ｛ get ｛ return Path.GetFullPath(Path.Combine(ThirdPartyPath, &quot;MyTestLib&quot;)); ｝ ｝ public TestPlugin(TargetInfo Target) ｛ PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs; PublicIncludePaths.AddRange( //公有文件搜索路径 new string[] ｛ &quot;TestPlugin/Public&quot; // ... add public include paths required here ... ｝ ); PrivateIncludePaths.AddRange( new string[] ｛ &quot;TestPlugin/Private&quot; //私有文件搜索路径 // ... add other private include paths required here ... ｝ ); PublicDependencyModuleNames.AddRange( new string[] ｛ &quot;Core&quot; // ... add other public dependencies that you statically link with here ... ｝ ); PrivateDependencyModuleNames.AddRange( new string[] ｛ &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;Slate&quot;, &quot;SlateCore&quot;, // ... add private dependencies that you statically link with here ... ｝ ); DynamicallyLoadedModuleNames.AddRange( new string[] ｛ // ... add any modules that your module loads dynamically here ... ｝ ); LoadThirdPartyLib(Target); //加载第三方库 ｝ public bool LoadThirdPartyLib(TargetInfo Target) ｛ bool isLibrarySupported = false; if ((Target.Platform == UnrealTargetPlatform.Win64) || (Target.Platform == UnrealTargetPlatform.Win32))//平台判断 ｛ isLibrarySupported = true; System.Console.WriteLine(&quot;\----- isLibrarySupported true&quot;); string PlatformSubPath = (Target.Platform == UnrealTargetPlatform.Win64) ? &quot;Win64&quot; : &quot;Win32&quot;; string LibrariesPath = Path.Combine(MyTestLibPath, &quot;Lib&quot;); PublicAdditionalLibraries.Add(Path.Combine(LibrariesPath, PlatformSubPath, &quot;TestLib.lib&quot;));//加载第三方静态库.lib ｝ if (isLibrarySupported) //成功加载库的情况下，包含第三方库的头文件 ｛ // Include path System.Console.WriteLine(&quot;\----- PublicIncludePaths.Add true&quot;); PublicIncludePaths.Add(Path.Combine(MyTestLibPath, &quot;Include&quot;)); ｝ return isLibrarySupported; ｝ ｝</code> </p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.jianshu.com/p/ec0ae889f417" target="_blank" rel="noopener">https://www.jianshu.com/p/ec0ae889f417</a><br><a href="https://www.jianshu.com/p/49684c1b6011" target="_blank" rel="noopener">https://www.jianshu.com/p/49684c1b6011</a><br><a href="https://gameinstitute.qq.com/community/detail/121298" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/121298</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal操作</title>
      <link href="2023/07/25/Unreal-Unreal%E6%93%8D%E4%BD%9C/"/>
      <url>2023/07/25/Unreal-Unreal%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="入门配置"><a href="#入门配置" class="headerlink" title="入门配置"></a>入门配置</h2><p>VS配置：<a href="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/VisualStudioSetup/UnrealVS/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/VisualStudioSetup/UnrealVS/</a></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="VS快捷键"><a href="#VS快捷键" class="headerlink" title="VS快捷键"></a>VS快捷键</h3><p>UnrealVS.BuildStartupProject: Ctrl + Shift + Alt + B<br>UnrealVS.CompileSingleFile: Ctrl+F7</p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal c++常见问题</title>
      <link href="2023/07/25/Unreal-Unreal-c-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>2023/07/25/Unreal-Unreal-c-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="类中静态成员变量-amp-amp-无法解析的外部符号：https-blog-csdn-net-u012911202-article-details-103532273"><a href="#类中静态成员变量-amp-amp-无法解析的外部符号：https-blog-csdn-net-u012911202-article-details-103532273" class="headerlink" title="类中静态成员变量 &amp;&amp; 无法解析的外部符号：https://blog.csdn.net/u012911202/article/details/103532273"></a>类中静态成员变量 &amp;&amp; 无法解析的外部符号：<a href="https://blog.csdn.net/u012911202/article/details/103532273" target="_blank" rel="noopener">https://blog.csdn.net/u012911202/article/details/103532273</a></h1><p>Unreal中使用Windows API：</p><p>D:\Windows Kits\10\include\10.0.20348.0\um\winnt.h(169): fatal error C1189: #error: “No Target Architecture”</p><p><img src="assets/Unreal%20c++常见问题/Image.png" alt=""></p><p>winnt.h这个头文件依赖windows.h这个头文件</p><p>但是Unreal又不能直接 #include “windows.h”，因为一些API有冲突，Unreal在windows的api上包了一层</p><p>Unreal用windows的api要用这种形式</p><p><img src="assets/Unreal%20c++常见问题/Image_1.png" alt=""></p><p><a href="https://forums.unrealengine.com/t/how-to-include-windows-h/308000" target="_blank" rel="noopener">https://forums.unrealengine.com/t/how-to-include-windows-h/308000</a></p><p>其他相关：<a href="https://stackoverflow.com/questions/4845198/fatal-error-no-target-architecture-in-visual-studio" target="_blank" rel="noopener">https://stackoverflow.com/questions/4845198/fatal-error-no-target-architecture-in-visual-studio</a></p><h1 id="error-C4668-没有将“-WIN32-WINNT-WIN10-TH2”定义为预处理器宏，用“0”替换“-if-elif”"><a href="#error-C4668-没有将“-WIN32-WINNT-WIN10-TH2”定义为预处理器宏，用“0”替换“-if-elif”" class="headerlink" title="error C4668: 没有将“_WIN32_WINNT_WIN10_TH2”定义为预处理器宏，用“0”替换“#if/#elif”"></a>error C4668: 没有将“_WIN32_WINNT_WIN10_TH2”定义为预处理器宏，用“0”替换“#if/#elif”</h1><p>一般为Windows中的宏和UE4冲突所致，需要用如下头文件包裹冲突的头文件：</p><h1 id="include-“Windows-AllowWindowsPlatformTypes-h”"><a href="#include-“Windows-AllowWindowsPlatformTypes-h”" class="headerlink" title="include “Windows/AllowWindowsPlatformTypes.h”"></a>include “Windows/AllowWindowsPlatformTypes.h”</h1><h1 id="include-“Windows-PreWindowsApi-h”"><a href="#include-“Windows-PreWindowsApi-h”" class="headerlink" title="include “Windows/PreWindowsApi.h”"></a>include “Windows/PreWindowsApi.h”</h1><h1 id="include-“冲突的头文件”"><a href="#include-“冲突的头文件”" class="headerlink" title="include “冲突的头文件”"></a>include “冲突的头文件”</h1><h1 id="include-“Windows-PostWindowsApi-h”"><a href="#include-“Windows-PostWindowsApi-h”" class="headerlink" title="include “Windows/PostWindowsApi.h”"></a>include “Windows/PostWindowsApi.h”</h1><h1 id="include-“Windows-HideWindowsPlatformTypes-h”"><a href="#include-“Windows-HideWindowsPlatformTypes-h”" class="headerlink" title="include “Windows/HideWindowsPlatformTypes.h”"></a>include “Windows/HideWindowsPlatformTypes.h”</h1><p>[TODO]Speed Up Shader Compiling</p><p><a href="https://www.techarthub.com/seven-tricks-to-speed-up-shader-compilation-in-unreal-engine-4/" target="_blank" rel="noopener">https://www.techarthub.com/seven-tricks-to-speed-up-shader-compilation-in-unreal-engine-4/</a></p><p><a href="https://forums.unrealengine.com/t/turn-off-auto-compile-shaders/353474" target="_blank" rel="noopener">https://forums.unrealengine.com/t/turn-off-auto-compile-shaders/353474</a></p><p><a href="https://realtimevfx.com/t/ue4-compiling-shaders-is-super-slow/3163/27" target="_blank" rel="noopener">https://realtimevfx.com/t/ue4-compiling-shaders-is-super-slow/3163/27</a></p><p><a href="https://medium.com/gamedev4k/reducing-shader-compile-time-for-unreal-engine-landscape-a7a6c7e2ca20" target="_blank" rel="noopener">https://medium.com/gamedev4k/reducing-shader-compile-time-for-unreal-engine-landscape-a7a6c7e2ca20</a></p><p>程序里include过，VS中不报错，但是编译报错：无法解析外部符号。</p><p>很可能在Build文件里面，没有把 依赖的相关模块 添加进来。</p><p><img src="assets/Unreal%20c++常见问题/Image_2.png" alt=""></p><p>unable to load module:</p><p><a href="https://blog.ch-wind.com/ue4-transition-log/" target="_blank" rel="noopener">https://blog.ch-wind.com/ue4-transition-log/</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal Plugin多个模块开发与编译</title>
      <link href="2023/07/25/Unreal-Unreal-Plugin%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
      <url>2023/07/25/Unreal-Unreal-Plugin%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E4%B8%8E%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>要写与模块名称相同的Module类，实现StartupModule、ShutdownModule函数，模块才能加载进来。</p><p><img src="assets/Unreal%20Plugin多个模块开发与编译/Image.png" alt=""></p><p>模块的类型，如果要暴露给其他模块使用，要用 MODULENAME_API 来进行标记</p><p><img src="assets/Unreal%20Plugin多个模块开发与编译/Image_1.png" alt=""></p><p>模块之间互相引用只要使用 PublicDependencyModuleNames.AddRange 即可。</p><p>至于说代码的头文件include，是否要添加PublicIncludePaths，取决于include的时候的方式，因为Paths是提供搜索的目标路径的，为了使搜索头文件的时候能搜索到。如果include命令保证头文件能搜索到就OK，如果搜索不到，就添加Public IncludePaths</p><p>Unreal C++代码的的Compile是以Module为单位的，可以在Unreal Editor的UI上，点击Compile，单独对某个模块进行编译。</p><p><img src="assets/Unreal%20Plugin多个模块开发与编译/Image_2.png" alt=""></p><p>UI按钮的本质也是命令行语句，所以是存在语句用来编译单个模块的，只是现在还没有对RunUAT的命令行使用方法摸清楚，不知道如何编译单个模块。</p><p>只要Compile，就会把模块的所有代码都进行编译，至于说Private和Public源码是否保留，看我们如何设定。</p><p>Private和Public文件夹对于编译程序来说，并没有什么区别，只是对于开发者来设定的。Public一般是开源的部分。</p><p>Unreal中插件通常的使用方式是，把代码编译好成dll、so等后，留下来一部分头文件，开放给用户，用户就可以在自己的工程当中引用这个头文件了。</p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal C++资料整理</title>
      <link href="2023/07/25/Unreal-Unreal-C-%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>2023/07/25/Unreal-Unreal-C-%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>文件管理系统（FPlatformFileManager）</p><p><a href="https://unrealcommunity.wiki/file-and-folder-management-create-find-delete-et2g64gx" target="_blank" rel="noopener">https://unrealcommunity.wiki/file-and-folder-management-create-find-delete-et2g64gx</a></p><p><a href="https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/GenericPlatform/IPlatformFile/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/GenericPlatform/IPlatformFile/</a></p><p><a href="https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/HAL/FPlatformFileManager/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/HAL/FPlatformFileManager/</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal - 蓝图Blueprint</title>
      <link href="2023/07/25/Unreal-Unreal-%E8%93%9D%E5%9B%BEBlueprint/"/>
      <url>2023/07/25/Unreal-Unreal-%E8%93%9D%E5%9B%BEBlueprint/</url>
      
        <content type="html"><![CDATA[<h2 id="语言概述"><a href="#语言概述" class="headerlink" title="语言概述"></a>语言概述</h2><h3 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h3><p>Python，Lua，Blueprint</p><p>特点：无需编译过程，方便调试，开发效率高<br>由虚拟机执行，运行效率不如编译语言快（中间层VM上运行）</p><h2 id="Blueprint"><a href="#Blueprint" class="headerlink" title="Blueprint"></a>Blueprint</h2><p>可视化脚本<br>使用引线将节点、事件、函数及变量连接起来。创建出复杂的Gameplay元素。基于事件，以控制游戏内Actor的各种运行行为。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h3 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h3><h4 id="执行引脚"><a href="#执行引脚" class="headerlink" title="执行引脚"></a>执行引脚</h4><p>用于将节点连接起来以创建执行流。</p><h4 id="数据引脚"><a href="#数据引脚" class="headerlink" title="数据引脚"></a>数据引脚</h4><h3 id="引线"><a href="#引线" class="headerlink" title="引线"></a>引线</h3><p>引脚之间的连接线。表示执行流或数据流。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>难点：Executable Actions函数太多了，不容易记住。</p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal C++</title>
      <link href="2023/07/25/Unreal-Unreal-C/"/>
      <url>2023/07/25/Unreal-Unreal-C/</url>
      
        <content type="html"><![CDATA[<ul><li>概念 </li><li>Compiling <ul><li><ul><li>我的Q&amp;A </li></ul></li></ul></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Forward Declaration  </p><p><img src="assets/Unreal%20C++/Image.png" alt=""></p><h2 id="Compiling"><a href="#Compiling" class="headerlink" title="Compiling"></a>Compiling</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p><a href="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/CompilingProjects/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/CompilingProjects/</a></p><h2 id="我的Q-amp-A"><a href="#我的Q-amp-A" class="headerlink" title="我的Q&amp;A"></a>我的Q&amp;A</h2><h3 id="Class-Naming-Prefix"><a href="#Class-Naming-Prefix" class="headerlink" title="Class Naming Prefix"></a>Class Naming Prefix</h3><p>Actor - A</p><p>Object - U<br>Enums - E<br>Interface - I<br>Template - T<br>SWidget - S<br>F - else</p><h2 id="关于宏定义"><a href="#关于宏定义" class="headerlink" title="关于宏定义"></a>关于宏定义</h2><h3 id="C-宏定义"><a href="#C-宏定义" class="headerlink" title="C++宏定义"></a>C++宏定义</h3><p>编译过程  </p><p><img src="assets/Unreal%20C++/Image_1.png" alt=""></p><p><img src="assets/Unreal%20C++/Image_2.png" alt=""></p><p><a href="https://blog.csdn.net/yanggangclcsdn/article/details/49704089" target="_blank" rel="noopener">https://blog.csdn.net/yanggangclcsdn/article/details/49704089</a></p><p>每个#define行（即逻辑行）由三部分组成：</p><p><code>csharp #define 宏名 替换文本</code> </p><p>指令 - “#”表示这是一条预处理命令，“define”为宏命令<br>宏（macro） - 一般为缩略语，其名称（宏名）一般大写，而且不能有空格，遵循C变量命令规则<br>替换文本”-任意常数、表达式、字符串等</p><p>包括 有参宏 和 无参宏 两种</p><h4 id="可变宏"><a href="#可变宏" class="headerlink" title="可变宏"></a>可变宏</h4><p><code>csharp #define PR2(X, ...) printf(&quot;Message&quot;#X&quot;:&quot;__VA_ARGS__) //宏定义 double msg = 10; PR2(1, &quot;msg = %.2f\n&quot;, msg); //宏调用 //输出结果：Message1:msg = 10.00</code> </p><h4 id="运算符：-，"><a href="#运算符：-，" class="headerlink" title="运算符：#，"></a>运算符：#，</h4><p><code>csharp #define SUM(a,b) printf(#a &quot; \+ &quot;#b&quot; = %d\n&quot;,((a) + (b))) //宏定义，运用 # 运算符 SUM(1 \+ 2, 3 \+ 4); //宏调用 //输出结果：1 + 2 + 3 + 4 = 10</code> <code>csharp #define NAME(n) num ## n //宏定义，使用 ## 运算符 int num0 = 10; printf(&quot;num0 = %d\n&quot;, NAME(0)); //宏调用</code> </p><p>“##” 运算符也可以用在替换文本中，而它的作用是起到粘合的作用，即将两个语言符号组合成一个语言符号，所以又称为“ <strong>预处理器的粘合剂（Preprocessor Glue）</strong> ”。</p><h4 id="宏定义-vs-typedef"><a href="#宏定义-vs-typedef" class="headerlink" title="宏定义 vs. typedef"></a>宏定义 vs. typedef</h4><p><code>csharp #define INT1 int * typedef int * INT2; INT1 a1, b1; INT2 a2, b2; b1 = &amp;m; //... main.c:185:8: Incompatible pointer to integer conversion assigning to &#39;int&#39; from &#39;int *&#39;; remove &amp; b2 = &amp;n; // OK</code> </p><p>宏定义只是简单的字符串代换，在预处理阶段完成。而typede不是简单的字符串代换，而是可以用来做类型说明符的重命名的，类型的别名可以具有类型定义说明的功能，在编译阶段完成的。</p><h4 id="宏定义-vs-函数"><a href="#宏定义-vs-函数" class="headerlink" title="宏定义 vs. 函数"></a>宏定义 vs. 函数</h4><p>所以在宏定义中：#define COUNT(M) M * M 中的形参不分配内存单元，所以不作类型定义。而函数 int count(int x)中形参是局部变量，会在栈区分配内存单元，所以要作类型定义，而且实参与形参之间是“值传递”。而宏只是符号代换，不存在值传递。</p><p><code>csharp #define COUNT(M) M * M //定义有参宏 int x = 6; printf(&quot;COUNT = %d\n&quot;, COUNT(x + 1));// 输出结果： COUNT = 13 printf(&quot;COUNT = %d\n&quot;, COUNT(++x)); // 输出结果： COUNT = 56 //warning:... main.c:161:34: Multiple unsequenced modifications to &#39;x&#39;</code> </p><p>COUNT(++x) 被替换为 ++x <em> ++x，即为 7 </em> 8 = 56，而不是想要 7 * 7 = 49<br>不要在有参宏用使用到“++”、“–”等</p><h4 id="其他技巧与细节"><a href="#其他技巧与细节" class="headerlink" title="其他技巧与细节"></a>其他技巧与细节</h4><p>换行：在结尾加反斜杠，可使多行连接</p><p>宏定义必须写在函数之外，其作用域是 #define 开始，到源程序结束。</p><p>如果重复定义宏，则不同的编译器采用不同的重定义策略。</p><h3 id="Unreal宏定义"><a href="#Unreal宏定义" class="headerlink" title="Unreal宏定义"></a>Unreal宏定义</h3><h4 id="UCALSS"><a href="#UCALSS" class="headerlink" title="UCALSS"></a>UCALSS</h4><p>The UCLASS macro gives the UObject a reference to a UCLASS that describes its Unreal-based type.<br>UE4有一个管理游戏对象的强大系统。UObject是这个系统中所有对象的基类。UCLASS宏用于标记这些UObject的派生类，目的是把它们告知UObject管理系统。UCLASS的宏参数可以更加具体地指定该类型的各种行为。</p><p>每个 UCLASS 保留一个称作“类默认对象（Class Default Object）”的对象，简称 CDO。</p><p>The UCLASS() macro is used to indicate that a C++ class will be part of Unreal’s <strong>Reflection system</strong>. This is necessary for the C++ class to be recognized by the Unreal Engine editor.<br>Another advantage of using UCLASS() is that you can use <strong>Unreal Engine’s memory management system</strong> in the C++ class.</p><blockquote><p>UCLASS宏只能修饰UObject的子类。</p></blockquote><p>类型说明符（Class Specifiers）  </p><p><img src="assets/Unreal%20C++/Image_3.png" alt=""></p><p>元数据说明符（Metadata Specifiers）  </p><p><img src="assets/Unreal%20C++/Image_4.png" alt=""></p><h4 id="MYPROJECT-API"><a href="#MYPROJECT-API" class="headerlink" title="MYPROJECT_API"></a>MYPROJECT_API</h4><p>Specifying MYPROJECT_API is necessary if MyProject wishes to expose the UMyObject class to other modules.</p><h4 id="Unreal宏编译"><a href="#Unreal宏编译" class="headerlink" title="Unreal宏编译"></a>Unreal宏编译</h4><p>The compilation of an Unreal C++ project happens in two phases.</p><ol><li>In the first phase, UnrealHeaderTool (UHT) reads the C++ headers files looking for Unreal macros and generates the necessary code that will replace the macros.</li><li>In the second phase, the C++ compiler compiles the resulting code.</li></ol><p><code>csharp #pragma once #include &quot;CoreMinimal.h&quot; #include &quot;GameFramework/Actor.h&quot; #include &quot;TutoProjectCollectable.generated.h&quot; UCLASS() class TUTOPROJECT_API ATutoProjectCollectable : public AActor { GENERATED_BODY()</code> </p><p>For this class, UnrealHeaderTool will generate code that will be placed in the TutoProjectCollectable.generated.h file and code that will replace the GENERATED_BODY() macro.</p><h4 id="宏定义的方式"><a href="#宏定义的方式" class="headerlink" title="宏定义的方式"></a>宏定义的方式</h4><p>C++代码中定义</p><p>Build.cs文件和Target.cs文件中</p><p><code>csharp PublicDefinitions.Add(&quot;WITH_DIRECTXMATH=1&quot;);</code> </p><p>在UBT代码的文件夹（<code>\Engine\Source\Programs\UnrealBuildTool</code>）中搜索Definitions.Add就可以看到编译时添加的宏定义。</p><h4 id="常用宏配置与Unreal-Editor中的效果"><a href="#常用宏配置与Unreal-Editor中的效果" class="headerlink" title="常用宏配置与Unreal Editor中的效果"></a>常用宏配置与Unreal Editor中的效果</h4><p><a href="https://blog.csdn.net/qq_29523119/article/details/85255854" target="_blank" rel="noopener">https://blog.csdn.net/qq_29523119/article/details/85255854</a></p><h2 id="Objects-amp-GC"><a href="#Objects-amp-GC" class="headerlink" title="Objects &amp; GC"></a>Objects &amp; GC</h2><p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Objects/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Objects/</a></p><p>内存分配与容器：<a href="https://www.cnblogs.com/kekec/p/12012537.html" target="_blank" rel="noopener">https://www.cnblogs.com/kekec/p/12012537.html</a></p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><h3 id="Destroy"><a href="#Destroy" class="headerlink" title="Destroy"></a>Destroy</h3><h2 id="Memory-Management-amp-GC"><a href="#Memory-Management-amp-GC" class="headerlink" title="Memory Management &amp; GC"></a>Memory Management &amp; GC</h2><p><strong>UE4 uses the reflection system to implement a garbage collection system.</strong></p><p>Your classes need to derive from <strong>UObject</strong> in order to be enabled for garbage collection.</p><p>An object will <strong>not be garbage collected</strong> as long as <strong>there is a path of references from an object in the root set to the object</strong> in question.</p><p>If no such path to the root set exists for an object, it is called <strong>unreachable</strong> and will be <strong>collected (deleted)</strong> the next time the garbage collector runs.</p><p>The engine runs the garbage collector at certain <strong>intervals</strong>.</p><blockquote><p>UStructs cannot be garbage collected.</p></blockquote><h3 id="Root-Set"><a href="#Root-Set" class="headerlink" title="Root Set"></a>Root Set</h3><p>UObject pointer stored<br>in a UPROPERTY<br>in a UE4 container</p><p>Actors:<br>GC druing a level’s shutdown<br>Once spawned, you must manually call Destroy on them to remove them from the Level without ending the Level.</p><p>This is important since, as mentioned before, <strong>actors that have had Destroy called on them are not removed until the garbage collector runs again</strong>. You can check the <strong>IsPendingKill</strong> method to see if a UObject is awaiting its deletion.</p><p>RootSet操作与判断</p><p><code>csharp /** * Add an object to the root set. This prevents the object and all * its descendants from being deleted during garbage collection. */ FORCEINLINE void AddToRoot() { GUObjectArray.IndexToObject(InternalIndex)-&gt;SetRootSet(); } /** Remove an object from the root set. */ FORCEINLINE void RemoveFromRoot() { GUObjectArray.IndexToObject(InternalIndex)-&gt;ClearRootSet(); } /** * Returns true if this object is explicitly rooted * * @return true if the object was explicitly added as part of the root set. */ FORCEINLINE bool IsRooted() const { return GUObjectArray.IndexToObject(InternalIndex)-&gt;IsRootSet(); }</code> </p><h3 id="Non-UObject-References"><a href="#Non-UObject-References" class="headerlink" title="Non-UObject References"></a>Non-UObject References</h3><p>Normal C++ objects (not derived from UObject) can also have the ability to add a reference to an object and prevent garbage collection —- derive from <strong>FGCObject</strong> and override its <strong>AddReferencedObjects</strong> method</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h2 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h2><h3 id="Numeric-Types"><a href="#Numeric-Types" class="headerlink" title="Numeric Types"></a>Numeric Types</h3><p>int8/uint8: 8-bit signed/unsigned integer</p><p>int16/uint16: 16-bit signed/unsigned integer</p><p>int32/uint32: 32-bit signed/unsigned integer</p><p>int64/uint64: 64-bit signed/unsigned integer</p><p>float (32-bit) and double (64-bit) types</p><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><h4 id="FString"><a href="#FString" class="headerlink" title="FString"></a>FString</h4><p>FString is a mutable string, analogous to std::string.</p><p><code>csharp FString MyStr = TEXT(&quot;Hello, Unreal 4!&quot;).</code> </p><h4 id="FText"><a href="#FText" class="headerlink" title="FText"></a>FText</h4><p>localized text ???</p><p><code>csharp FText MyText = NSLOCTEXT(&quot;Game UI&quot;, &quot;Health Warning Message&quot;, &quot;Low Health!&quot;)</code> <code>csharp // In GameUI.cpp #define LOCTEXT_NAMESPACE &quot;Game UI&quot; //... FText MyText = LOCTEXT(&quot;Health Warning Message&quot;, &quot;Low Health!&quot;) //... #undef LOCTEXT_NAMESPACE // End of file</code> </p><h4 id="FName"><a href="#FName" class="headerlink" title="FName"></a>FName</h4><p>Rather than storing the complete string many times across every object that references it, FName uses a smaller storage footprint index that maps to a given string.</p><ul><li>save memory when that string is used across many objects</li><li>save CPU time when comparing them- UE4 can simply check their index values to see if they match</li></ul><h4 id="TCHAR"><a href="#TCHAR" class="headerlink" title="TCHAR"></a>TCHAR</h4><p>The TCHAR type is used as a way of storing characters independent of the character set being used</p><p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/CharacterEncoding/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/CharacterEncoding/</a></p><h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><p>相关资料：v</p><p><code>csharp void RemoveDeadEnemies(TSet&lt;AEnemy*&gt;&amp; EnemySet){ // Start at the beginning of the set, and iterate to the end of the set for (auto EnemyIterator = EnemySet.CreateIterator(); EnemyIterator; ++EnemyIterator) { // The * operator gets the current element AEnemy* Enemy = *EnemyIterator; if (Enemy.Health == 0) { // &#39;RemoveCurrent&#39; is supported by TSets and TMaps EnemyIterator.RemoveCurrent(); } } }</code> </p><h4 id="TArray-std-vector"><a href="#TArray-std-vector" class="headerlink" title="TArray - std::vector"></a>TArray - std::vector</h4><p>like std::vector, offers a lot more functionality</p><p><code>csharp TArray&lt;AActor*&gt; ActorArray = GetActorArrayFromSomewhere(); // Tells how many elements (AActors) are currently stored in ActorArray. int32 ArraySize = ActorArray.Num(); // TArrays are 0-based (the first element will be at index 0) int32 Index = 0;// Attempts to retrieve an element at the given indexAActor* FirstActor = ActorArray[Index]; // Adds a new element to the end of the arrayAActor* NewActor = GetNewActor();ActorArray.Add(NewActor); // Adds an element to the end of the array only if it is not already in the arrayActorArray.AddUnique(NewActor); // Won&#39;t change the array because NewActor was already added // Removes all instances of &#39;NewActor&#39; from the arrayActorArray.Remove(NewActor); // Removes the element at the specified index// Elements above the index will be shifted down by one to fill the empty spaceActorArray.RemoveAt(Index); // More efficient version of &#39;RemoveAt&#39;, but does not maintain order of the elementsActorArray.RemoveAtSwap(Index); // Removes all elements in the arrayActorArray.Empty();</code> </p><h4 id="TMap-std-map"><a href="#TMap-std-map" class="headerlink" title="TMap - std::map"></a>TMap - std::map</h4><p>has quick methods for finding, adding, and removing elements based on their key</p><h4 id="TSet-std-set"><a href="#TSet-std-set" class="headerlink" title="TSet - std::set"></a>TSet - std::set</h4><p>AddUnique, Contains - <strong>faster</strong></p><h4 id="Cumtom-TSet-TMap"><a href="#Cumtom-TSet-TMap" class="headerlink" title="Cumtom TSet/TMap"></a>Cumtom TSet/TMap</h4><p>you will need to provide a <strong>hash function</strong> that takes a const pointer or reference to your type and returns a uint32<br>This return value is known as the object’s <strong>hash code</strong> , and should uniquely identify the object.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/yanggangclcsdn/article/details/49704089" target="_blank" rel="noopener">https://blog.csdn.net/yanggangclcsdn/article/details/49704089</a><br><a href="https://romeroblueprints.blogspot.com/2020/10/the-uclass-macro.html" target="_blank" rel="noopener">https://romeroblueprints.blogspot.com/2020/10/the-uclass-macro.html</a><br><a href="https://www.geek-share.com/detail/2802042559.html" target="_blank" rel="noopener">https://www.geek-share.com/detail/2802042559.html</a><br><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/IntroductionToCPP/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/IntroductionToCPP/</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Unreal</title>
      <link href="2023/07/25/Unreal-Unity-Unreal/"/>
      <url>2023/07/25/Unreal-Unity-Unreal/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-gt-Unreal"><a href="#Unity-gt-Unreal" class="headerlink" title="Unity-&gt;Unreal"></a>Unity-&gt;Unreal</h1><p>可以通过Unity那边的概念、结构、操作方式来理解Unreal。但是又不能完全类比，不能期待一方中的操作方法在另一方里面一定有，如果完全一致的话，两个就变成同一个引擎了。接近本质的点上可以对照去看，比如序列化、反序列化，比如内存管理、资源管理等，是独立于引擎的，都要有的。而上层的、操作习惯上的点就不能一一对照了。</p><h2 id="Unity-gt-UE-官方"><a href="#Unity-gt-UE-官方" class="headerlink" title="Unity-&gt;UE 官方"></a>Unity-&gt;UE 官方</h2><h3 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h3><p>Unity -&gt; Unreal</p><hr><p>Prefab -&gt; Blueprint Class<br>Mesh -&gt; Static Mesh<br>Skinned Mesh -&gt; Skeletal Mesh<br>Shader -&gt; Material, Material Editor<br>Material -&gt; Material Instance<br>Material Instance -&gt; ?<br>Sprite -&gt; EditorPaper2D<br>Mecanim -&gt; Persona , Animation Blueprint<br>UI -&gt; UMG (Unreal Motion Graphics)</p><p>Raycast -&gt; Line Trace, Shape Trace</p><p>Rigid Body -&gt; Collision, Physics</p><h3 id="Projects-and-Files"><a href="#Projects-and-Files" class="headerlink" title="Projects and Files"></a>Projects and Files</h3><p>Content - Assets</p><p>Map file - Scene, Map files store data about your Level and the objects in it, as well as lighting data and certain level-specific settings.</p><p>Edit-&gt;Project Settings-&gt;Platforms-&gt;Android/… - “player settings” in Unity</p><p>Source sub-folder -</p><h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>In Unity, GameObject is C# class which you cannot directly extend.<br>In UE4, Actor is a C++ class which you can extend and customize using inheritance.</p><ul><li><p>任意可以被放置到关卡中的游戏物体都是一个 Actor</p></li><li><p>Actor 可以被认为维系了一些特殊 Object 的容器，这些特殊 Object 被称为组件（Component）</p></li><li><p>Actor像是Prefab一样，可以在场景中实例化多个，当Actor进行了修改，那么场景中的物体会同样被修改</p></li></ul><h3 id="Blueprint-vs-Prefab"><a href="#Blueprint-vs-Prefab" class="headerlink" title="Blueprint vs. Prefab"></a>Blueprint vs. Prefab</h3><p>UE4中，Unity的Prefab使用Blueprint Class替代。Blueprint Class支持继承，修改公共的Function很方便。</p><p>蓝图-Code挂Asset<br>Prefab-Asset挂code</p><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>BeginPlay = Initialize Component = Unity Start()<br>Tick Component = Unity Update</p><h3 id="Blueprint-or-C"><a href="#Blueprint-or-C" class="headerlink" title="Blueprint or C++?"></a>Blueprint or C++?</h3><p>Most projects will use a mix of Blueprints and C++. Many developers prototype game functionality using Blueprints, because it is so easy and fun, and later move some or all of it to C++ for performance and engineering rigor.</p><h3 id="Transform-Components"><a href="#Transform-Components" class="headerlink" title="Transform Components"></a>Transform Components</h3><p>Root Component - any subclass of Scene Component</p><p>A Scene Component gives the Actor a location, rotation, and scale in the world which is applied hierarchically to all components underneath it.</p><h3 id="Actor-1"><a href="#Actor-1" class="headerlink" title="Actor"></a>Actor</h3><p>Actors are most common class used for gameplay in UE4 and the only type that can be Spawned into the World. So everything you place in your level will be an Actor.</p><p>Object is actually the base class of all Unreal classes, including Actor and many others.</p><h3 id="Gameplay-Framework"><a href="#Gameplay-Framework" class="headerlink" title="Gameplay Framework"></a>Gameplay Framework</h3><p><a href="https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Framework/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Framework/</a><br>customized built-in Actor classes<br>replication and networking features</p><h3 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h3><h4 id="Event-Functions"><a href="#Event-Functions" class="headerlink" title="Event Functions"></a>Event Functions</h4><p>Remember, in UE4 it is important to call the parent class’ version of method.</p><p>A - Actor sub-class<br>U - Object sub-class<br>F - plain data structures or non-UObject classes</p><h4 id="Unity功能在Unreal中实现"><a href="#Unity功能在Unreal中实现" class="headerlink" title="Unity功能在Unreal中实现"></a>Unity功能在Unreal中实现</h4><p>文档中查阅：<a href="https://docs.unrealengine.com/4.27/en-US/Basics/UnrealEngineForUnityDevs/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/Basics/UnrealEngineForUnityDevs/</a></p><p>Instantiating GameObject / Spawning Actor<br>Casting from One Type to Another</p><p>Destroying GameObject / Actor<br>Destroying GameObject / Actor (With 1 Second Delay)<br>Disabling GameObjects / Actors</p><p>Accessing the GameObject / Actor from a Component<br>Accessing a Component from the GameObject / Actor<br>Finding GameObjects / Actors<br>Adding tags to GameObjects / Actors<br>Adding tags to MonoBehaviours / ActorComponents<br>Comparing tags on GameObjects / Actors and MonoBehaviours / ActorComponents</p><h5 id="Physics-RigidBody-vs-Primitive-Component"><a href="#Physics-RigidBody-vs-Primitive-Component" class="headerlink" title="Physics: RigidBody vs. Primitive Component"></a>Physics: RigidBody vs. Primitive Component</h5><p>Layers vs Channels<br>RayCast vs RayTrace<br>Triggers</p><p>Kinematic Rigidbodies</p><h5 id="Input-events"><a href="#Input-events" class="headerlink" title="Input events"></a>Input events</h5><p>Engine-Input</p><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>check() - You can pass in an error message.<br>ensure() - log an error with a full call stack</p><h2 id="Unity-gt-UE经验博客"><a href="#Unity-gt-UE经验博客" class="headerlink" title="Unity-&gt;UE经验博客"></a>Unity-&gt;UE经验博客</h2><h3 id="Actor-Lifecycle"><a href="#Actor-Lifecycle" class="headerlink" title="Actor Lifecycle"></a>Actor Lifecycle</h3><p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/</a><br>Destroy<br>EndPlay<br>OnDestroy - 不要用这个，要用EndPlay</p><h4 id="销毁对象"><a href="#销毁对象" class="headerlink" title="销毁对象"></a>销毁对象</h4><p><code>csharp // 针对AActor子类可调用 MyActor-&gt;Destroy(); // 针对UObject的子类，可调用 MyObj-&gt;MarkPendingKill(); MyObj = nullptr;</code> </p><h3 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h3><h4 id="Advanced-GC"><a href="#Advanced-GC" class="headerlink" title="Advanced GC"></a>Advanced GC</h4><p>Clustering -: builds clusters of objects that are all destroyed together</p><p>Cluster Merging - For example, a particle system asset may reference a material asset, but if cluster merging is turned off, the material and the particle system will remain in separate clusters for garbage collection purposes. With cluster merging turned on, the particle asset cluster will be merged with the material cluster due to the particle system referencing the material.</p><h3 id="对象查找"><a href="#对象查找" class="headerlink" title="对象查找"></a>对象查找</h3><p><code>csharp // Find Actor by name (also works on UObjects) AActor* MyActor = FindObject&lt;AActor&gt;(nullptr, TEXT(&quot;MyNamedActor&quot;)); // Find Actors by type (needs a UWorld object) for (TActorIterator&lt;AMyActor&gt; It(GetWorld()); It; ++It){ AMyActor* MyActor = *It; // ... } // Find UObjects by type for (TObjectIterator&lt;UMyObject&gt; It; It; ++It){ UMyObject* MyObject = *It; // ... } // Find Actors by tag (also works on ActorComponents, use TObjectIterator instead) for (TActorIterator&lt;AActor&gt; It(GetWorld()); It; ++It){ AActor* Actor = *It; if (Actor-&gt;ActorHasTag(FName(TEXT(&quot;Mytag&quot;)))) { // ... }}</code> </p><h3 id="Referencing-Assets"><a href="#Referencing-Assets" class="headerlink" title="Referencing Assets"></a>Referencing Assets</h3><p>Direct Property Reference<br>Construction Time Reference<br>Indirect Property Reference</p><h3 id="Actor与蓝图的加载、生成"><a href="#Actor与蓝图的加载、生成" class="headerlink" title="Actor与蓝图的加载、生成"></a>Actor与蓝图的加载、生成</h3><p><code>csharp void ATestBPProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit){ …… DEFINE_LOG_CATEGORY_STATIC(LogBPDynamicLoad, Warning, All); // 方法1：通过蓝图对象的GeneratedClass取得类型描述 UBlueprint* BlueprintObj = LoadObject&lt;UBlueprint&gt;(nullptr, TEXT(&quot;Blueprint&#39;/Engine/Tutorial/SubEditors/TutorialAssets/Character/TutorialCharacter.TutorialCharacter&#39;&quot;)); UE_LOG(LogBPDynamicLoad, Warning, TEXT(&quot;Blueprint GeneratedClass:%s&quot;), *BlueprintObj-&gt;GeneratedClass-&gt;GetName()); GetWorld()-&gt;SpawnActor(BlueprintObj-&gt;GeneratedClass, &amp;GetTransform()); // 方法2：加载蓝图对象的UClass，注意资源路径后要加_C，不然加载出来为null UClass* BlueprintClass = LoadClass&lt;AActor&gt;(nullptr, TEXT(&quot;Blueprint&#39;/Engine/Tutorial/SubEditors/TutorialAssets/Character/TutorialCharacter.TutorialCharacter_C&#39;&quot;)); UE_LOG(LogBPDynamicLoad, Warning, TEXT(&quot;Blueprint Class:%s&quot;), *BlueprintClass-&gt;GetName()); GetWorld()-&gt;SpawnActor(BlueprintClass, &amp;GetTransform());}</code> </p><h3 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h3><p><img src="Unity-Unreal/Image.png" alt=""></p><p>目前UE4采用每个资源一个包，以前UE3和UE2时代，一个包中可以有多个资源对象，因此现在包名和资源名都是一样的，除非有手动重命名过。</p><p><code>csharp Material&#39;/Game/Geometry/Meshes/CubeMaterial.CubeMaterial&#39; World&#39;/Game/FirstPersonCPP/Maps/FirstPersonExampleMap.FirstPersonExampleMap&#39; Blueprint&#39;/Game/FirstPersonCPP/Blueprints/FirstPersonCharacter.FirstPersonCharacter&#39; Texture2D&#39;/Game/FirstPerson/Textures/FirstPersonCrosshair.FirstPersonCrosshair&#39; SoundWave&#39;/Game/FirstPerson/Audio/FirstPersonTemplateWeaponFire02.FirstPersonTemplateWeaponFire02&#39; AnimBlueprint&#39;/Game/FirstPerson/Animations/FirstPerson_AnimBP.FirstPerson_AnimBP&#39; AnimSequence&#39;/Game/FirstPerson/Animations/FirstPerson_Fire.FirstPerson_Fire&#39; AnimMontage&#39;/Game/FirstPerson/Animations/FirstPersonFire_Montage.FirstPersonFire_Montage&#39; StaticMesh&#39;/Engine/BasicShapes/Cone.Cone&#39; Material&#39;/Engine/BufferVisualization/AmbientOcclusion.AmbientOcclusion&#39; Blueprint&#39;/Engine/EditorBlueprintResources/ActorMacros.ActorMacros&#39; SoundCue&#39;/Engine/EditorSounds/GamePreview/EjectFromPlayer_Cue.EjectFromPlayer_Cue&#39; Texture2D&#39;/Engine/EngineMaterials/Grid.Grid&#39;</code> </p><h2 id="Unreal-vs-Unity"><a href="#Unreal-vs-Unity" class="headerlink" title="Unreal vs. Unity"></a>Unreal vs. Unity</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/444044071" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/444044071</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI方案</title>
      <link href="2023/07/25/Unreal-UI%E6%96%B9%E6%A1%88/"/>
      <url>2023/07/25/Unreal-UI%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="技术方案说明"><a href="#技术方案说明" class="headerlink" title="技术方案说明"></a>技术方案说明</h2><h3 id="Why-Should-we-Use-C"><a href="#Why-Should-we-Use-C" class="headerlink" title="Why Should we Use C++?"></a>Why Should we Use C++?</h3><p><img src="UI方案/Image.png" alt=""></p><p><a href="https://benui.ca/unreal/ui-cpp-basics/" target="_blank" rel="noopener">https://benui.ca/unreal/ui-cpp-basics/</a></p><h3 id="mix-Blueprints-and-C"><a href="#mix-Blueprints-and-C" class="headerlink" title="mix Blueprints and C++"></a>mix Blueprints and C++</h3><p>put all <strong>the data-related logic in C++</strong> , and <strong>the visual logic in Blueprints</strong>.</p><h3 id="UMG-vs-Slate"><a href="#UMG-vs-Slate" class="headerlink" title="UMG vs. Slate"></a>UMG vs. Slate</h3><p>Slate is the old Unreal UI system, and is what the UMG and the editor are built on. It uses some funky-looking C++ to simplify setting up widgets. It’s important to understand that just because it’s the “old” system doesn’t mean it’s obsolete. You will gradually need to learn Slate in order to add more complicated functionality to your UIs.</p><p>UMG is the newer UI system that was added as part of Unreal 4. It is designed to be more Blueprint-friendly and let designers visually lay out their UIs in the editor. Each UMG widget generally has an almost-identically named Slate class inside it. The <strong>xxSlate</strong> class handles most of the logic, and its corresponding UMG class is a wrapper around it. e.g. UImage is the UMG class, and it contains a SImage instance inside it.</p><p>UMG is simply a editor- and Blueprint-friendly <strong>wrapper for Slate</strong>.</p><h4 id="同行经验"><a href="#同行经验" class="headerlink" title="同行经验"></a>同行经验</h4><p>UE引擎内如果开发Editor插件的话，界面UI是用UMG还是Slate比较合适?<br>Slate.<br>UMG是针对runtime的，因此一些editor的控件不会提供，比如propertyEditor<br>当然slate也会更底层一些，性能更高<br>一般是尽量做个slate底层，然后导出各种蓝图接口，然后就可以用脚本植入主体逻辑</p><h2 id="UMG"><a href="#UMG" class="headerlink" title="UMG"></a>UMG</h2><p>Unreal Motion Graphics UI Designer (UMG)</p><p>最好的UI Dev上手方法： <strong>try out each widget and see what you can do with it</strong></p><p>Slots - When a widget is put inside another, we can customise how it behaves inside its parent through its Slot property.</p><h3 id="Widgets"><a href="#Widgets" class="headerlink" title="Widgets"></a>Widgets</h3><p><img src="UI方案/Image_1.png" alt=""></p><h3 id="UserWidgets"><a href="#UserWidgets" class="headerlink" title="UserWidgets"></a>UserWidgets</h3><p>UserWidgets are used to create reusable objects with custom logic for user interfaces.</p><h4 id="Creating-a-UserWidget-in-C"><a href="#Creating-a-UserWidget-in-C" class="headerlink" title="Creating a UserWidget in C++"></a>Creating a UserWidget in C++</h4><p><code>csharp #pragma once #include &quot;CoreMinimal.h&quot; #include &quot;Blueprint/UserWidget.h&quot; #include &quot;ExampleWidget.generated.h&quot; // We make the class abstract, as we don&#39;t want to create // instances of this, instead we want to create instances // of our UMG Blueprint subclass.UCLASS(Abstract) class UExampleWidget : public UUserWidget{ GENERATED_BODY() protected: // Doing setup in the C++ constructor is not as // useful as using NativeConstruct. virtual void NativeConstruct() override;};</code> <code>csharp #include &quot;ExampleWidget.h&quot; void UExampleWidget::NativeConstruct(){ Super::NativeConstruct(); // Here is where I typically bind delegates, // and set up default appearance }</code> </p><h4 id="Creating-new-UWidgets-in-C"><a href="#Creating-new-UWidgets-in-C" class="headerlink" title="Creating new UWidgets in C++"></a>Creating new UWidgets in C++</h4><p><code>csharp // .h file UCLASS() class UExampleOverlay : public UOverlay { GENERATED_UCLASS_BODY() public: #if WITH_EDITOR virtual const FText GetPaletteCategory() override;#endif protected: // UWidget interface virtual TSharedRef&lt;SWidget&gt; RebuildWidget() override; // End of UWidget interface };</code> <code>csharp // .cpp file #define LOCTEXT_NAMESPACE &quot;ExampleUMG&quot; TSharedRef&lt;SWidget&gt; UExampleOverlay::RebuildWidget() { auto Result = Super::RebuildWidget(); for (UPanelSlot* InSlot : Slots) { // Do something custom } return Result; } #if WITH_EDITOR const FText UExampleOverlay::GetPaletteCategory() { return LOCTEXT(&quot;ExampleUI&quot;, &quot;ExampleOverlay&quot;); } #endif</code> </p><h2 id="Slate"><a href="#Slate" class="headerlink" title="Slate"></a>Slate</h2><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://benui.ca/unreal/ui-cpp-basics/" target="_blank" rel="noopener">https://benui.ca/unreal/ui-cpp-basics/</a><br><a href="https://benui.ca/unreal/ui-introduction/" target="_blank" rel="noopener">https://benui.ca/unreal/ui-introduction/</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE 移动设备调试</title>
      <link href="2023/07/25/Unreal-UE-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E8%B0%83%E8%AF%95/"/>
      <url>2023/07/25/Unreal-UE-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=hEtu-ciPc7g" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hEtu-ciPc7g</a></p><p>adb logcat</p><p>Android Studio 是发现最优的源码级别调试方式</p><p><img src="assets/UE%20移动设备调试/Image.png" alt=""></p><p>常用调试方法：</p><h1 id="define-PRINT-String-if-GEngine-GEngine-gt-AddOnScreenDebugMessage-1-10-0f-FColor-Red-String"><a href="#define-PRINT-String-if-GEngine-GEngine-gt-AddOnScreenDebugMessage-1-10-0f-FColor-Red-String" class="headerlink" title="define PRINT(String) {if (GEngine){GEngine-&gt;AddOnScreenDebugMessage(-1,10.0f,FColor::Red,*(String));}}"></a>define PRINT(String) {if (GEngine){GEngine-&gt;AddOnScreenDebugMessage(-1,10.0f,FColor::Red,*(String));}}</h1><p>GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Red,</p><p>TEXT(“Log by GEngine.AddOnScreenDebugMessage”));</p><p>GEngine-&gt;AddOnScreenDebugMessage(-1, 10.0f, FColor::Red, FString::Printf(TEXT(“Server not connected yet.”)));</p><p><a href="https://blog.csdn.net/m0_51819222/article/details/122511585" target="_blank" rel="noopener">https://blog.csdn.net/m0_51819222/article/details/122511585</a></p><p><a href="https://blog.csdn.net/Jason6620/article/details/128404026" target="_blank" rel="noopener">https://blog.csdn.net/Jason6620/article/details/128404026</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE - Rendering Pipeline</title>
      <link href="2023/07/25/Unreal-UE-Rendering-Pipeline/"/>
      <url>2023/07/25/Unreal-UE-Rendering-Pipeline/</url>
      
        <content type="html"><![CDATA[<h2 id="静态网格"><a href="#静态网格" class="headerlink" title="静态网格"></a>静态网格</h2><h3 id="HLOD-Hierarchical-Level-of-Detail"><a href="#HLOD-Hierarchical-Level-of-Detail" class="headerlink" title="HLOD (Hierarchical Level of Detail )"></a>HLOD (Hierarchical Level of Detail )</h3><ul><li><p>合并网格</p></li><li><p>合并材质</p></li><li><p>减少Draw Call</p></li></ul><h2 id="Demos"><a href="#Demos" class="headerlink" title="Demos"></a>Demos</h2><p>Content Examples</p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDIM贴图</title>
      <link href="2023/07/25/Unreal-UDIM%E8%B4%B4%E5%9B%BE/"/>
      <url>2023/07/25/Unreal-UDIM%E8%B4%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>U-Dimension (or “UDIM”) is a texture naming convention that enables multiple texture images to map to separate UV regions on a Static Mesh or Skeletal Mesh model.</p><p>UDIM（U-Dimension）是一套多想先贴图映射技术，是目前UV Mapping中比较流行的技术。  是对 UV 贴图和纹理工作流程的增强</p><p>UDIM 只是一个自动 UV 偏移系统，它将图像分配到特定的 UV 平铺上，它允许您对相邻表面使用多个较低分辨率的纹理贴图，从而产生更高分辨率的结果，而不必求助于使用单个、超高分辨率图像。</p><p>UV 映射是将三维表面转换为平面位图图像的二维坐标系.  原始表面的每个顶点在 UV 贴图上都有一个坐标，中间的像素值在平坦的多边形表面上进行插值，以实现高度精确的纹理控制。UV贴图坐标值被组织到一个网格系统中，其中图像本身出现在网格的0-1区域中，而此图块外部的区域仅向外重复图像。因此，传统上实际上只使用过UV 0-1空间（好在控制表面如何平铺图像的方式之外）。</p><p>使用 UDIM 工作流，每个完整的切片部分（0-1、1-2、2-3 等）都可以分配给它自己的独立图像映射，所有这些都在同一表面内。每个图像也可以有自己的分辨率。</p><p>普通的UV是在其他象限图像都不断重复的UDIM，UDIM是每个象限图像都不同的UV。</p><p>Maya操作：</p><p>材质 - 贴图 -UVTilingMode:UDIM</p><p>把1001贴图选中，会自动识别UDIM贴图序列。</p><p>引擎实现：</p><p>编辑 - 项目设置 - 渲染 - 启用虚拟纹理支持，重启UE。 会编译Shader（空工程要等41分钟）</p><p>选择UDIM的第一张导入UE Editor，就会自动生成VT</p><p>纹理赋值给基础颜色</p><p>Shader实现原理：能根据U的值确定使用哪张纹理，也能根据V的值决定使用哪张纹理，那么，完成逻辑：分别根据U和V的范围，决定使用哪张纹理即可。</p><p><img src="UDIM贴图/Image.png" alt=""></p><p><img src="UDIM贴图/Image_1.png" alt=""></p><p><img src="UDIM贴图/Image_2.png" alt=""></p><p>可以把一大段材质的逻辑打包成材质函数。  </p><p>UDIM贴图：组成的贴图数量太多的情况下，双击打开时，可能会挂掉</p><p>相关资源：<a href="https://sketchfab.com/tags/udim" target="_blank" rel="noopener">https://sketchfab.com/tags/udim</a></p><p><a href="https://sketchfab.com/3d-models/high-quality-mulberry-tree-scan-419735850f414ff98c8d417b508585da" target="_blank" rel="noopener">https://sketchfab.com/3d-models/high-quality-mulberry-tree-scan-419735850f414ff98c8d417b508585da</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI实践：Cross-platform build automation for UE4</title>
      <link href="2023/07/25/Unreal-CI%E5%AE%9E%E8%B7%B5%EF%BC%9ACross-platform-build-automation-for-UE4/"/>
      <url>2023/07/25/Unreal-CI%E5%AE%9E%E8%B7%B5%EF%BC%9ACross-platform-build-automation-for-UE4/</url>
      
        <content type="html"><![CDATA[<p>projects with Jenkins</p><p><a href="https://www.maygames.net/2020/07/03/cross-platform-build-automation-for-ue4-proj" target="_blank" rel="noopener">https://www.maygames.net/2020/07/03/cross-platform-build-automation-for-ue4-proj</a></p><p><code>csharp pipeline{ agent none parameters { choice( name: &#39;PLATFORM_FILTER&#39;, choices: [&#39;windows&#39;, &#39;mac&#39;, &#39;all&#39;], description: &#39;&#39;) choice( name: &#39;ENGINE_VERSION&#39;, choices: [ &#39;UE_4_24_3&#39; ], description: &#39;&#39;) choice( name: &#39;BUILD_CONFIGURATION&#39;, choices: [ &#39;Development&#39;, &#39;Shipping&#39; ], description: &#39;&#39;) booleanParam( name: &#39;COMPILE_GAME&#39;, defaultValue: true, description: &#39;&#39;) } environment { BUILD_PROJECT_NAME = &quot;$env.JOB_BASE_NAME&quot; } options { // Default checkout may not have git-lfs and may have bad timeouts. skipDefaultCheckout(true) } stages { stage(&#39;BuildAndDeploy&#39;) { matrix { agent { label &quot;${PLATFORM}&quot; } when { anyOf { expression { params.PLATFORM_FILTER == &#39;all&#39; } expression { params.PLATFORM_FILTER == env.PLATFORM } } } axes { axis { name &#39;PLATFORM&#39; values &#39;windows&#39;, &#39;mac&#39; } } stages { stage(&#39;Preparation&#39;) { environment { BUILD_ARCHIVE_DIR = getBuildArchivePath() } steps { // Checkout code changes. checkout poll: false, scm: [$class: &#39;GitSCM&#39;, branches: [[name: &#39;*/master&#39;]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: &#39;CleanBeforeCheckout&#39;], [$class: &#39;GitLFSPull&#39;], [$class: &#39;CheckoutOption&#39;, timeout: 60], [$class: &#39;CloneOption&#39;, noTags: false, reference: &#39;&#39;, shallow: false, timeout: 60]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &#39;scm&#39;, url: &#39;https://bitbucket.org/replace_with_your/project.git&#39;]]] // Create project files (e.g. Visual Studio Solution). pwsh script: startProcess(getUnrealBuildToolPath(), &quot;-projectfiles -project=`\&quot;${env.WORKSPACE}/${env.BUILD_PROJECT_NAME}.uproject`\&quot; -game -engine&quot;) // Build editor dlls for project. pwsh script: startProcess(getUnrealBuildToolPath(), &quot;${env.BUILD_PROJECT_NAME}Editor &quot; + getUnrealPlatformName() + &quot; Development `\&quot;${env.WORKSPACE}/${env.BUILD_PROJECT_NAME}.uproject`\&quot; -engine&quot;) // Create folders for later steps. pwsh script: &#39;if (!(Test-Path -Path &quot;$env:BUILD_ARCHIVE_DIR/$env:BUILD_PROJECT_NAME&quot;)) { md &quot;$env:BUILD_ARCHIVE_DIR/$env:BUILD_PROJECT_NAME&quot; -Force }&#39; } } stage(&#39;Compile Blueprints&#39;) { steps { pwsh script: startProcess(getUnrealEditorCmdPath(), &quot;`\&quot;${env.WORKSPACE}/${env.BUILD_PROJECT_NAME}.uproject`\&quot; -run=CompileAllBlueprints -IgnoreFolder=/Engine -Unattended&quot;) } } stage(&#39;Build Game&#39;) { when { expression { params.COMPILE_GAME } } environment { BUILD_ARCHIVE_DIR = getBuildArchivePath() } steps { pwsh script: &#39;Remove-Item &quot;$env:BUILD_ARCHIVE_DIR/$env:BUILD_PROJECT_NAME/WindowsNoEditor&quot; -Force -Recurse -ErrorAction SilentlyContinue&#39; pwsh script: startProcess(getUnrealAutomationToolPath(), getBuildArgsClient() + &quot; -targetplatform=&quot; + getUnrealPlatformName()) } } } } } }} def getBuildArchivePath(){ if (env.PLATFORM == &#39;mac&#39;) { return &#39;/Volumes/X5/Packages&#39; } else if (env.PLATFORM == &#39;windows&#39;) { return &#39;C:/Projects/Archive&#39; } else { throw new Exception(&#39;Unsupported platform&#39;) }} def getUnrealEngineRoot(){ if (env.PLATFORM == &#39;mac&#39;) { return &quot;/Volumes/X5/Shared/$env.ENGINE_VERSION&quot; } else if (env.PLATFORM == &#39;windows&#39;) { return &quot;C:/Projects/$env.ENGINE_VERSION&quot; } else { throw new Exception(&#39;Unsupported platform&#39;) }} def getUnrealBuildToolPath(){ if (env.PLATFORM == &#39;mac&#39;) { return getUnrealEngineRoot() + &#39;/Engine/Build/BatchFiles/Mac/Build.sh&#39; } else if (env.PLATFORM == &#39;windows&#39;) { return getUnrealEngineRoot() + &#39;/Engine/Build/BatchFiles/Build.bat&#39; } else { throw new Exception(&#39;Unsupported platform&#39;) }} def getUnrealAutomationToolPath(){ if (env.PLATFORM == &#39;mac&#39;) { return getUnrealEngineRoot() + &#39;/Engine/Build/BatchFiles/RunUAT.command&#39; } else if (env.PLATFORM == &#39;windows&#39;) { return getUnrealEngineRoot() + &#39;/Engine/Build/BatchFiles/RunUAT.bat&#39; } else { throw new Exception(&#39;Unsupported platform&#39;) }} def getUnrealEditorCmdPath(){ if (env.PLATFORM == &#39;mac&#39;) { return getUnrealEngineRoot() + &#39;/Engine/Binaries/Mac/UE4Editor-Cmd&#39; } else if (env.PLATFORM == &#39;windows&#39;) { return getUnrealEngineRoot() + &#39;/Engine/Binaries/Win64/UE4Editor-Cmd.exe&#39; } else { throw new Exception(&#39;Unsupported platform&#39;) }} def getUnrealPlatformName(){ if (env.PLATFORM == &#39;mac&#39;) { return &#39;Mac&#39; } else if (env.PLATFORM == &#39;windows&#39;) { return &#39;Win64&#39; } else { throw new Exception(&#39;Unsupported platform&#39;) }} def getBuildArgsClient(){ return &quot;BuildCookRun -project=`\&quot;${env.WORKSPACE}/${env.BUILD_PROJECT_NAME}.uproject`\&quot; -nocompileeditor -nop4 -cook -stage -archive -archivedirectory=`\&quot;$env.BUILD_ARCHIVE_DIR/$env.BUILD_PROJECT_NAME`\&quot; -package -clean -compressed -pak -prereqs -distribution -nodebuginfo -build -target=$env.BUILD_PROJECT_NAME -clientconfig=$env.BUILD_CONFIGURATION -utf8output -compile&quot;} def startProcess(String program, String parameters){ String cmd = &#39;$batch = Start-Process -FilePath &quot;&#39; + program + &#39;&quot; -ArgumentList &quot;&#39; + parameters + &#39;&quot; -Wait -PassThru -NoNewWindow -ErrorAction Stop; exit $batch.ExitCode&#39; echo cmd return cmd}</code> </p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slate UI</title>
      <link href="2023/07/25/Unreal-Slate-UI/"/>
      <url>2023/07/25/Unreal-Slate-UI/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/418944210" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/418944210</a></p><p><a href="https://blog.csdn.net/weixin_40301728/article/details/119841875" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40301728/article/details/119841875</a></p><p><a href="https://blog.csdn.net/weixin_40301728/article/details/119851108" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40301728/article/details/119851108</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mipmap与Texture Streaming</title>
      <link href="2023/07/25/Unreal-Mipmap%E4%B8%8ETexture-Streaming/"/>
      <url>2023/07/25/Unreal-Mipmap%E4%B8%8ETexture-Streaming/</url>
      
        <content type="html"><![CDATA[<p>Texture Streaming：</p><p><a href="https://zhuanlan.zhihu.com/p/544892912" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/544892912</a></p><p><a href="https://zhuanlan.zhihu.com/p/520393454" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/520393454</a></p><p><a href="https://zhuanlan.zhihu.com/p/546756533" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/546756533</a></p><p><a href="https://zhuanlan.zhihu.com/p/474701022" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/474701022</a></p><p>Mipmap：</p><h1 id="【纹理优化（三）】善用Mipmap：https-zhuanlan-zhihu-com-p-351712352"><a href="#【纹理优化（三）】善用Mipmap：https-zhuanlan-zhihu-com-p-351712352" class="headerlink" title="【纹理优化（三）】善用Mipmap：https://zhuanlan.zhihu.com/p/351712352"></a>【纹理优化（三）】善用Mipmap：<a href="https://zhuanlan.zhihu.com/p/351712352" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/351712352</a></h1><p>Mipmap会额外消耗内存</p><p>纹理大小和实际上最终图元在屏幕上显示的大小差别很大。Mipmap可以用来解决：失真、摩尔纹现象；GPU带宽过大问题；</p><p>Streaming：</p><p>只加载部分Mipmap图片以节省更多的内存及显存空间。</p><p>通过消耗少量 CPU 资源来节省潜在的大量 GPU 内存。</p><hr><p>UE Streaming介绍：</p><p>UE 的 Texture Streaming基于纹理的mipmap技术，为了优化Texture对于内存的占用而存在。对于生成了mipmap的纹理，会根据一套规则来计算纹理资源所需要的理想的Mipmap层级，结合内存池的大小，来对纹理进行动态地流式送入、送出内存，这样就避免了纹理的所有mipmap都进内存。</p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test2</title>
      <link href="2023/07/25/Unreal-Test2/"/>
      <url>2023/07/25/Unreal-Test2/</url>
      
        <content type="html"><![CDATA[<p>UE_LOG:</p><p><a href="https://blog.csdn.net/zhang1461376499/article/details/113351948" target="_blank" rel="noopener">https://blog.csdn.net/zhang1461376499/article/details/113351948</a></p><p><a href="https://blog.csdn.net/liulong1567/article/details/52449000" target="_blank" rel="noopener">https://blog.csdn.net/liulong1567/article/details/52449000</a></p><p><a href="https://unrealcommunity.wiki/logging-lgpidy6i" target="_blank" rel="noopener">https://unrealcommunity.wiki/logging-lgpidy6i</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build - 踩坑</title>
      <link href="2023/07/25/Unreal-Build-%E8%B8%A9%E5%9D%91/"/>
      <url>2023/07/25/Unreal-Build-%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>网络问题导致gradle打包失败 - 解析jar包时，无法下载所依赖的库</p><p>修改为国内源头的方式尝试多次失败。</p><p>使用代理的方式成功：</p><p>修改 \Engine\Build\Android\Java\gradle\gradle\wrapper\目录下的 gradle-wrapper.properties 文件，添加http、https代理即可。</p><h2 id="For-more-details-on-how-to-configure-your-build-environment-visit"><a href="#For-more-details-on-how-to-configure-your-build-environment-visit" class="headerlink" title="For more details on how to configure your build environment visit"></a>For more details on how to configure your build environment visit</h2><h1 id="http-www-gradle-org-docs-current-userguide-build-environment-html"><a href="#http-www-gradle-org-docs-current-userguide-build-environment-html" class="headerlink" title="http://www.gradle.org/docs/current/userguide/build_environment.html"></a><a href="http://www.gradle.org/docs/current/userguide/build_environment.html" target="_blank" rel="noopener">http://www.gradle.org/docs/current/userguide/build_environment.html</a></h1><p>#</p><h1 id="Specifies-the-JVM-arguments-used-for-the-daemon-process"><a href="#Specifies-the-JVM-arguments-used-for-the-daemon-process" class="headerlink" title="Specifies the JVM arguments used for the daemon process."></a>Specifies the JVM arguments used for the daemon process.</h1><h1 id="The-setting-is-particularly-useful-for-tweaking-memory-settings"><a href="#The-setting-is-particularly-useful-for-tweaking-memory-settings" class="headerlink" title="The setting is particularly useful for tweaking memory settings."></a>The setting is particularly useful for tweaking memory settings.</h1><h1 id="Default-value-Xmx1024m-XX-MaxPermSize-256m"><a href="#Default-value-Xmx1024m-XX-MaxPermSize-256m" class="headerlink" title="Default value: -Xmx1024m -XX:MaxPermSize=256m"></a>Default value: -Xmx1024m -XX:MaxPermSize=256m</h1><h1 id="org-gradle-jvmargs-Xmx2048m-XX-MaxPermSize-512m-XX-HeapDumpOnOutOfMemoryError-Dfile-encoding-UTF-8"><a href="#org-gradle-jvmargs-Xmx2048m-XX-MaxPermSize-512m-XX-HeapDumpOnOutOfMemoryError-Dfile-encoding-UTF-8" class="headerlink" title="org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8"></a>org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8</h1><p>#</p><h1 id="When-configured-Gradle-will-run-in-incubating-parallel-mode"><a href="#When-configured-Gradle-will-run-in-incubating-parallel-mode" class="headerlink" title="When configured, Gradle will run in incubating parallel mode."></a>When configured, Gradle will run in incubating parallel mode.</h1><h1 id="This-option-should-only-be-used-with-decoupled-projects-More-details-visit"><a href="#This-option-should-only-be-used-with-decoupled-projects-More-details-visit" class="headerlink" title="This option should only be used with decoupled projects. More details, visit"></a>This option should only be used with decoupled projects. More details, visit</h1><h1 id="http-www-gradle-org-docs-current-userguide-multi-project-builds-html-sec-decoupled-projects"><a href="#http-www-gradle-org-docs-current-userguide-multi-project-builds-html-sec-decoupled-projects" class="headerlink" title="http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects"></a><a href="http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects" target="_blank" rel="noopener">http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects</a></h1><h1 id="org-gradle-parallel-true"><a href="#org-gradle-parallel-true" class="headerlink" title="org.gradle.parallel=true"></a>org.gradle.parallel=true</h1><h1 id="Sat-Jan-23-16-06-06-CST-2021"><a href="#Sat-Jan-23-16-06-06-CST-2021" class="headerlink" title="Sat Jan 23 16:06:06 CST 2021"></a>Sat Jan 23 16:06:06 CST 2021</h1><h1 id="systemProp-http-proxyHost-127-0-0-1"><a href="#systemProp-http-proxyHost-127-0-0-1" class="headerlink" title="systemProp.http.proxyHost=127.0.0.1"></a>systemProp.http.proxyHost=127.0.0.1</h1><h1 id="systemProp-http-proxyPort-1081"><a href="#systemProp-http-proxyPort-1081" class="headerlink" title="systemProp.http.proxyPort=1081"></a>systemProp.http.proxyPort=1081</h1><h1 id="systemProp-https-proxyHost-127-0-0-1"><a href="#systemProp-https-proxyHost-127-0-0-1" class="headerlink" title="systemProp.https.proxyHost=127.0.0.1"></a>systemProp.https.proxyHost=127.0.0.1</h1><h1 id="systemProp-https-proxyPort-1081"><a href="#systemProp-https-proxyPort-1081" class="headerlink" title="systemProp.https.proxyPort=1081"></a>systemProp.https.proxyPort=1081</h1>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础补充-2</title>
      <link href="2023/07/25/Unreal-C-%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85-2/"/>
      <url>2023/07/25/Unreal-C-%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85-2/</url>
      
        <content type="html"><![CDATA[<p>C++单例模式</p><p><a href="https://www.cnblogs.com/sunchaothu/p/10389842.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunchaothu/p/10389842.html</a></p><p><a href="https://segmentfault.com/a/1190000015950693" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015950693</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础补充</title>
      <link href="2023/07/25/Unreal-C-%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/"/>
      <url>2023/07/25/Unreal-C-%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h2 id="cpp编译"><a href="#cpp编译" class="headerlink" title="cpp编译"></a>cpp编译</h2><p><a href="https://blog.csdn.net/leonliu06/article/details/78229534" target="_blank" rel="noopener">https://blog.csdn.net/leonliu06/article/details/78229534</a></p><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><pre><code class="lang-csharp">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; template &lt;class T1,class T2&gt;class Pair { public: T1 key; //关键字T2 value; //值Pair(T1 k,T2 v):key(k),value(v) { }; bool operator &lt; (const Pair&lt;T1,T2&gt; &amp; p) const; }; template&lt;class T1,class T2&gt;bool Pair&lt;T1,T2&gt;::operator &lt; (const Pair&lt;T1,T2&gt; &amp; p) const//Pair的成员函数 operator &lt;{ //&quot;小&quot;的意思就是关键字小return key &lt; p.key; } int main(){ Pair&lt;string,int&gt; student(&quot;Tom&quot;,19); //实例化出一个类 Pair&lt;string,int&gt;cout &lt;&lt; student.key &lt;&lt; &quot; &quot; &lt;&lt; student.value; return 0; } ``` ```csharp #include &lt;iostream&gt;using namespace std; template &lt;class T&gt;class A { public: template &lt;class T2&gt;void Func(T2 t) { cout &lt;&lt; t; } //成员函数模板}; int main(){ A&lt;int&gt; a; a.Func&lt;int&gt;(123); //成员函数模板Func被实例化a.Func&lt;string&gt;(&quot; hello&quot;); return 0; }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Actor Lifecycle</title>
      <link href="2023/07/25/Unreal-Actor-Lifecycle/"/>
      <url>2023/07/25/Unreal-Actor-Lifecycle/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build - UE CI</title>
      <link href="2023/07/25/Unreal-Build-UE-CI/"/>
      <url>2023/07/25/Unreal-Build-UE-CI/</url>
      
        <content type="html"><![CDATA[<p>run Setup.bat for checking dependencies</p><p>run GenerateProjectFiles.bat for generating your project files</p><p>build engine in the configuration we needed</p><p>D:\UnrealEngineSource\Setup.bat</p><p>D:\UnrealEngineSource\GenerateProjectFiles.bat</p><p>“c:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\MSBuild.exe” “D:\UnrealEngineSource\UE4.sln” -target:”Engine\UE4” -property:Platform=Win64;Configuration=”Development Editor” -verbosity:diagnostic</p><p>“C:\Program Files\Microsoft Visual Studio\2022\Community\Msbuild\Current\Bin\MSBuild.exe” “D:\Unreal\UnrealEngine\UE_5\UE5.sln” -target:”Engine\UE5” -property:Platform=Win64;Configuration=”Development Editor” -verbosity:diagnostic</p><p><a href="https://blog.mi.hdm-stuttgart.de/index.php/2017/02/11/uat-automation/" target="_blank" rel="noopener">https://blog.mi.hdm-stuttgart.de/index.php/2017/02/11/uat-automation/</a></p><p><a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x68;&#x74;&#x74;&#112;&#115;&#x3a;&#x2f;&#x2f;&#109;&#101;&#100;&#105;&#x75;&#109;&#x2e;&#99;&#x6f;&#109;&#x2f;&#64;&#x6c;&#105;&#102;&#x65;&#x65;&#120;&#101;&#47;&#117;&#x6e;&#114;&#101;&#97;&#x6c;&#x2d;&#x65;&#x6e;&#103;&#105;&#x6e;&#x65;&#x2d;&#x63;&#x69;&#x2d;&#112;&#x61;&#x72;&#x74;&#45;&#105;&#45;&#115;&#x6f;&#117;&#x72;&#x63;&#x65;&#45;&#x63;&#x6f;&#100;&#x65;&#x2d;&#x62;&#x75;&#105;&#108;&#x64;&#115;&#x2d;&#x38;&#x30;&#x30;&#x30;&#x63;&#x61;&#49;&#x64;&#x61;&#x37;&#50;&#x33;">&#x68;&#x74;&#x74;&#112;&#115;&#x3a;&#x2f;&#x2f;&#109;&#101;&#100;&#105;&#x75;&#109;&#x2e;&#99;&#x6f;&#109;&#x2f;&#64;&#x6c;&#105;&#102;&#x65;&#x65;&#120;&#101;&#47;&#117;&#x6e;&#114;&#101;&#97;&#x6c;&#x2d;&#x65;&#x6e;&#103;&#105;&#x6e;&#x65;&#x2d;&#x63;&#x69;&#x2d;&#112;&#x61;&#x72;&#x74;&#45;&#105;&#45;&#115;&#x6f;&#117;&#x72;&#x63;&#x65;&#45;&#x63;&#x6f;&#100;&#x65;&#x2d;&#x62;&#x75;&#105;&#108;&#x64;&#115;&#x2d;&#x38;&#x30;&#x30;&#x30;&#x63;&#x61;&#49;&#x64;&#x61;&#x37;&#50;&#x33;</a></p><p><a href="https://www.cnblogs.com/WoodJim/p/15965121.html" target="_blank" rel="noopener">https://www.cnblogs.com/WoodJim/p/15965121.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build - Unreal Build System</title>
      <link href="2023/07/25/Unreal-Build-Unreal-Build-System/"/>
      <url>2023/07/25/Unreal-Build-Unreal-Build-System/</url>
      
        <content type="html"><![CDATA[<h2 id="Build-Engine-from-Source"><a href="#Build-Engine-from-Source" class="headerlink" title="Build Engine from Source"></a>Build Engine from Source</h2><h2 id="Build-Project-的步骤与原理"><a href="#Build-Project-的步骤与原理" class="headerlink" title="Build Project 的步骤与原理"></a>Build Project 的步骤与原理</h2><p>整体的打包流程如下：Build-&gt;Cook-&gt;Stage-&gt;Pakage-&gt;Archive</p><p>Build: This stage compiles the executeables for the selected platform.</p><p>Cook: This stage cooks content by executing the Editor in a special mode.</p><p>Stage: This stage copies the executables and content to a staging area; a standalone directory outside of the development directory.<br>build cook</p><p>(run )</p><p>package</p><p>platform</p><p>task</p><h2 id="Build-Project-工具与自动化"><a href="#Build-Project-工具与自动化" class="headerlink" title="Build Project 工具与自动化"></a>Build Project 工具与自动化</h2><p><img src="assets/Build%20-%20Unreal%20Build%20System/Image.png" alt=""></p><p>via. <a href="https://www.maygames.net/2020/07/03/cross-platform-build-automation-for-ue4-projects-with-jenkins/" target="_blank" rel="noopener">https://www.maygames.net/2020/07/03/cross-platform-build-automation-for-ue4-projects-with-jenkins/</a></p><h3 id="UnrealBuildTool-UBT"><a href="#UnrealBuildTool-UBT" class="headerlink" title="UnrealBuildTool (UBT)"></a>UnrealBuildTool (UBT)</h3><p>a custom tool that manages the process of building Unreal Engine 4 (UE4) source code across a variety of build configurations.</p><p>Unreal Build Tool is a console application that does a lot of magic like generating project files, invoking unreal header tool, invoking the compiler and linker for different platforms and flavours of build.</p><h3 id="UnrealHeaderTool-UHT"><a href="#UnrealHeaderTool-UHT" class="headerlink" title="UnrealHeaderTool (UHT)"></a>UnrealHeaderTool (UHT)</h3><p>a custom parsing and code-generation tool that supports the UObject system</p><h3 id="AutomationTool"><a href="#AutomationTool" class="headerlink" title="AutomationTool"></a>AutomationTool</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>building<br>cooking<br>running games<br>running automation tests<br>scripting other operations to be executed on our build farm</p><h4 id="How-AT-Works"><a href="#How-AT-Works" class="headerlink" title="How AT Works"></a>How AT Works</h4><p>finds all automation projects (saved as Visual Studio C# projects with an .Automation.csproj extension), compiles them, and then uses reflection to find the appropriate command to be executed.</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>RunUAT.bat/.sh: Unreal提供了bat/shell脚本，来调用UnreaAutomationTool.exe。</p><ol><li>根据情况判断是否要编译UnreaAutomationTool.exe本身</li><li>启动UnreaAutomationTool.exe</li></ol><p>位置<br>Windows: Engine/Build/BatchFiles/RunUAT.bat<br>Mac: Engine/Build/BatchFiles/RunUAT.sh</p><p><code>csharp RunUAT.bat Command1 [-Arg1 -Arg2...] Command2 [-Arg3 -Arg4…] ...</code> </p><p>参数解释：<a href="https://zhuanlan.zhihu.com/p/41931214" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41931214</a></p><h3 id="GenerateProjectFiles"><a href="#GenerateProjectFiles" class="headerlink" title="GenerateProjectFiles"></a>GenerateProjectFiles</h3><p>当使用Unreal Source时，there are no Visual Studio (VS) or Xcode project files included for compiling and running the engine or example games.</p><p>generates your Visual Studio solution and projects for Windows</p><p>the first step is building the build tool. This happens invoking MSBuild on Source\Programs\UnrealBuildTool\UnrealBuiltTool.csproj.</p><p>如果安装预编译好的Unreal引擎，那么是没有GenerateProjectFiles.bat脚本的。可以右键uproject文件，点击Generate Visual Studio Project Files来生成Project文件，也可以直接使用Unreal Build Tool来实现</p><p><code>csharp &quot;\path\to\UE_4.22\Engine\Binaries\DotNET\UnrealBuildTool.exe&quot; -ProjectFiles -UsePrecompiled -Game &quot;absolute\path\to\your\project\file.uproject&quot; # 在Windows上生成Visual Studio Project # 在Mac上生成 XCode Project，(Visual Studio for Mac cannot be used, because it does not support C++)</code> </p><h3 id="BuildGraph"><a href="#BuildGraph" class="headerlink" title="BuildGraph"></a>BuildGraph</h3><p>BuildGraph integrates with UnrealBuildTool, AutomationTool, and the editor, and can be extended and customized for your projects.</p><p>More: <a href="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/BuildTools/AutomationTool/BuildGraph/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/BuildTools/AutomationTool/BuildGraph/</a></p><h2 id="Unreal-CI-实践"><a href="#Unreal-CI-实践" class="headerlink" title="Unreal CI 实践"></a>Unreal CI 实践</h2><p>注意：Unreal的配置保存在Config目录下的 XXX.ini 文件当中，这个文件配置好之后，需要进版本管理的，否则在更新工程后会出现配置失效的问题。尤其是iOS打包时配置的证书问题。</p><p>UE4游戏开发基础命令【部署环境、编译引擎、构建代码】：<a href="https://www.cnblogs.com/kekec/p/8684068.html" target="_blank" rel="noopener">https://www.cnblogs.com/kekec/p/8684068.html</a></p><h3 id="Windows-Build-Android"><a href="#Windows-Build-Android" class="headerlink" title="Windows Build Android"></a>Windows Build Android</h3><h4 id="GenerateProjFiles"><a href="#GenerateProjFiles" class="headerlink" title="GenerateProjFiles"></a>GenerateProjFiles</h4><p>UnrealBuildTool.exe -projectfiles -project=”%UPROJECT_PATH%” -game -rocket -progress</p><h4 id="Compile-Codes"><a href="#Compile-Codes" class="headerlink" title="Compile Codes"></a>Compile Codes</h4><p>可以用MSBuild进行编译：<br>“%MSBUILD_EXE%” “%PROJ_VS_SLN%” /t:build /p:Platform=%PLATFORM%;verbosity=diagnostic</p><h4 id="BuildCook"><a href="#BuildCook" class="headerlink" title="BuildCook"></a>BuildCook</h4><p><code>csharp &quot;%RUN_UAT_BAT%&quot; BuildCookRun -project=&quot;%UPROJECT_PATH%&quot; -noP4 -platform=%PLATFORM% -clientconfig=Development -cook -allmaps -build -stage -pak -archive -NoCompile -archivedirectory=&quot;%ARCHIVE_DIR%&quot; -nocompile</code> </p><h4 id="RunUAT"><a href="#RunUAT" class="headerlink" title="RunUAT"></a>RunUAT</h4><p>RunUAT可以把编译到出包的工作全部自动化地执行，一键出包，只需要配置参数，来决定开启哪些功能、执行哪些步骤就可以了。</p><p><a href="https://blog.csdn.net/zhangxiaofan666/article/details/79567017" target="_blank" rel="noopener">https://blog.csdn.net/zhangxiaofan666/article/details/79567017</a></p><p><code>csharp &quot;%RUN_UAT_BAT%&quot; BuildCookRun -project=&quot;%UPROJECT_PATH%&quot;-noP4 -platform=%PLATFORM% -clientconfig=Development -serverconfig=Development -cook -allmaps -build -stage -pak -archive -archivedirectory=&quot;%ARCHIVE_DIR%&quot; -nocompileeditor</code> </p><p>如果不执行某个阶段，把某个参数去掉就可以了。</p><h3 id="Mac-Build-iOS"><a href="#Mac-Build-iOS" class="headerlink" title="Mac Build iOS"></a>Mac Build iOS</h3><h4 id="GenerateProjFiles-1"><a href="#GenerateProjFiles-1" class="headerlink" title="GenerateProjFiles"></a>GenerateProjFiles</h4><p><code>csharp U_BUILD_TOOL_EXE=&quot;/Users/Shared/Epic Games/UE_4.27/Engine/Binaries/DotNET/UnrealBuildTool.exe&quot; echo ${UPROJECT_PATH} mono &quot;${U_BUILD_TOOL_EXE}&quot; -projectfiles -project=&quot;${UPROJECT_PATH}&quot; -game -rocket -progress</code> </p><h4 id="Xcode-Build-Engine-Build-Project"><a href="#Xcode-Build-Engine-Build-Project" class="headerlink" title="Xcode Build Engine, Build Project"></a>Xcode Build Engine, Build Project</h4><p><code>csharp xcodebuild -workspace PROJECT_NAME.xcworkspace -scheme Engine xcodebuild -workspace PROJECT_NAME.xcworkspace -scheme PROJECT_NAME</code> </p><h4 id="证书与签名问题"><a href="#证书与签名问题" class="headerlink" title="证书与签名问题"></a>证书与签名问题</h4><p>注意：配置要进版本管理。</p><p>理论上，只要在Config当中，配置好BundlID、证书的名称等信息，使用UAT就可以直接打包了，工具会自动查找、使用证书来进行签名。只需要 unlock keychain就可以了</p><p><code>csharp security unlock-keychain -p &quot;enter password&quot;</code> </p><p>签名失败：</p><ul><li>Code Signing Error： <a href="https://medium.com/@ceyhunkeklik/how-to-fix-ios-application-code-signing-error-4818bd331327" target="_blank" rel="noopener">https://medium.com/@ceyhunkeklik/how-to-fix-ios-application-code-signing-error-4818bd331327</a></li><li><a href="https://developer.apple.com/forums/thread/669328" target="_blank" rel="noopener">https://developer.apple.com/forums/thread/669328</a></li><li><a href="https://stackoverflow.com/questions/24023639/xcode-command-usr-bin-codesign-failed-with-exit-code-1-errsecinternalcomponen" target="_blank" rel="noopener">https://stackoverflow.com/questions/24023639/xcode-command-usr-bin-codesign-failed-with-exit-code-1-errsecinternalcomponen</a></li></ul><p>自动导入证书：<a href="https://zhuanlan.zhihu.com/p/400261513" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/400261513</a><br>说明：证书是自动导入到Keychain里面，UE在使用UAT打包的时候，会自动在里面找Keychain，所以UE配置证书，只是配一个证书的名字。上文中，导入证书是向Keychain当中导入。</p><hr><h4 id="RunUAT-1"><a href="#RunUAT-1" class="headerlink" title="RunUAT"></a>RunUAT</h4><p><code>csharp &quot;%RUN_UAT_BAT%&quot; BuildCookRun -project=&quot;%UPROJECT_PATH%&quot;-noP4 -platform=%PLATFORM% -clientconfig=Development -serverconfig=Development -cook -allmaps -build -stage -pak -archive -archivedirectory=&quot;%ARCHIVE_DIR%&quot; -nocompileeditor</code> </p><h3 id="Windows-Remote-Mac-Build-iOS"><a href="#Windows-Remote-Mac-Build-iOS" class="headerlink" title="Windows Remote Mac Build iOS"></a>Windows Remote Mac Build iOS</h3><p>手动打包教程：<br><a href="https://www.jianshu.com/p/04188aa411b4" target="_blank" rel="noopener">https://www.jianshu.com/p/04188aa411b4</a><br><a href="https://blog.csdn.net/u011047958/article/details/78300086" target="_blank" rel="noopener">https://blog.csdn.net/u011047958/article/details/78300086</a></p><p>使用IPhonePackager.exe，自动导入证书：<a href="https://ue5wiki.com/wiki/32489/" target="_blank" rel="noopener">https://ue5wiki.com/wiki/32489/</a></p><h3 id="错误排坑"><a href="#错误排坑" class="headerlink" title="错误排坑"></a>错误排坑</h3><h4 id="Android-SDK问题"><a href="#Android-SDK问题" class="headerlink" title="Android SDK问题"></a>Android SDK问题</h4><p><a href="https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted" target="_blank" rel="noopener">https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted</a></p><p>Installed Build Tools revision 31.0.0 is corrupted. Remove and install again using the SDK Manager.</p><p>The main problem is the two files missing in SDK build tool 31 that are:<br>dx.bat<br>dx.jar</p><p>The solution is that these files are named d8 in the file location so changing their name to dx will solve the error.</p><h4 id="引用丢失问题"><a href="#引用丢失问题" class="headerlink" title="引用丢失问题"></a>引用丢失问题</h4><p>问题：删除插件，打包失败 。<br>原因：场景还在引用这个插件。右键场景-&gt;Reference Viewer，可见场景对插件中组件的引用关系。</p><p>Unreal比较奇怪的一点是，如果场景对Actor有引用，但是Actor资源被删除了，World Outliner里面是看不到的。</p><p>解决方法：找到引用这个资源的场景，啥都不做，save一下，None引用就没有了。</p><h4 id="Adding-Adaptive-Icons-to-a-UE4-project-for-Android"><a href="#Adding-Adaptive-Icons-to-a-UE4-project-for-Android" class="headerlink" title="Adding Adaptive Icons to a UE4 project for Android"></a>Adding Adaptive Icons to a UE4 project for Android</h4><p><a href="https://www.unrealengine.com/en-US/tech-blog/adding-adaptive-icons-to-a-ue4-project-for-android" target="_blank" rel="noopener">https://www.unrealengine.com/en-US/tech-blog/adding-adaptive-icons-to-a-ue4-project-for-android</a></p><h4 id="丢失dSYM"><a href="#丢失dSYM" class="headerlink" title="丢失dSYM"></a>丢失dSYM</h4><p>-SkipBuildEditor: 不编译编辑器</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://ericlemes.com/2018/11/23/understanding-unreal-build-tool/" target="_blank" rel="noopener">https://ericlemes.com/2018/11/23/understanding-unreal-build-tool/</a></p><p><a href="https://zhuanlan.zhihu.com/p/144656367" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/144656367</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9999 Unreal学习与拓展规划</title>
      <link href="2023/07/25/Unreal-9999-Unreal%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8B%93%E5%B1%95%E8%A7%84%E5%88%92/"/>
      <url>2023/07/25/Unreal-9999-Unreal%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8B%93%E5%B1%95%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="Unreal-CI"><a href="#Unreal-CI" class="headerlink" title="Unreal CI"></a>Unreal CI</h1><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo.png" alt=""><br><a href="https://github.com/botman99/ue4-unreal-automation-tool" target="_blank" rel="noopener">https://github.com/botman99/ue4-unreal-automation-tool</a></li></ul><h2 id="基本自动化构建"><a href="#基本自动化构建" class="headerlink" title="基本自动化构建"></a>基本自动化构建</h2><h3 id="Source-Code-Automation"><a href="#Source-Code-Automation" class="headerlink" title="Source Code Automation"></a>Source Code Automation</h3><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_1.png" alt=""><br><a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#104;&#x74;&#x74;&#x70;&#x73;&#58;&#x2f;&#47;&#x6d;&#x65;&#100;&#x69;&#117;&#109;&#x2e;&#x63;&#111;&#x6d;&#x2f;&#x40;&#108;&#x69;&#102;&#x65;&#101;&#120;&#101;&#47;&#x75;&#x6e;&#x72;&#x65;&#x61;&#x6c;&#45;&#101;&#x6e;&#103;&#x69;&#x6e;&#101;&#x2d;&#x63;&#x69;&#x2d;&#x70;&#x61;&#x72;&#x74;&#x2d;&#105;&#45;&#x73;&#111;&#117;&#114;&#x63;&#101;&#x2d;&#x63;&#x6f;&#x64;&#101;&#x2d;&#98;&#x75;&#105;&#108;&#x64;&#115;&#x2d;&#x38;&#48;&#x30;&#x30;&#x63;&#97;&#x31;&#x64;&#x61;&#55;&#50;&#51;">&#104;&#x74;&#x74;&#x70;&#x73;&#58;&#x2f;&#47;&#x6d;&#x65;&#100;&#x69;&#117;&#109;&#x2e;&#x63;&#111;&#x6d;&#x2f;&#x40;&#108;&#x69;&#102;&#x65;&#101;&#120;&#101;&#47;&#x75;&#x6e;&#x72;&#x65;&#x61;&#x6c;&#45;&#101;&#x6e;&#103;&#x69;&#x6e;&#101;&#x2d;&#x63;&#x69;&#x2d;&#x70;&#x61;&#x72;&#x74;&#x2d;&#105;&#45;&#x73;&#111;&#117;&#114;&#x63;&#101;&#x2d;&#x63;&#x6f;&#x64;&#101;&#x2d;&#98;&#x75;&#105;&#108;&#x64;&#115;&#x2d;&#x38;&#48;&#x30;&#x30;&#x63;&#97;&#x31;&#x64;&#x61;&#55;&#50;&#51;</a></li></ul><h3 id="Client-Game-Automation"><a href="#Client-Game-Automation" class="headerlink" title="Client Game Automation"></a>Client Game Automation</h3><p>学习路径：</p><ul><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_2.png" alt=""><br>先把Mac打包走出来（直接打包 &amp; 脚本自动打包）</p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_3.png" alt=""><br>解答一个个困惑</p><ul><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_4.png" alt=""><br>Cook和Build、Compile究竟是做什么</p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_5.png" alt=""><br>AutomationTool和BuildTool之间的关系</p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_6.png" alt=""><br>Graph的用法</p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_7.png" alt=""><br>UAT的运行机制</p></li></ul></li><li><p>学习打包相关知识体系，整套工具的结构和用法</p><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_8.png" alt=""><br>从runUAT脚本看到UAT源码</li></ul></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_9.png" alt=""><br>整理一套打包工具集</p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_10.png" alt=""><br>进阶 - 分布式打包，效率提升</p></li></ul><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_11.png" alt=""><br><a href="https://www.youtube.com/watch?v=2zkrhspvPls" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2zkrhspvPls</a></p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_12.png" alt=""><br><a href="https://patricevignola.com/post/automation-jenkins-unreal#automatically-build-your-game" target="_blank" rel="noopener">https://patricevignola.com/post/automation-jenkins-unreal#automatically-build-your-game</a></p></li></ul><h4 id="Mac-iOS"><a href="#Mac-iOS" class="headerlink" title="Mac iOS"></a>Mac iOS</h4><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_13.png" alt=""><br><a href="https://imzlp.com/posts/1948/" target="_blank" rel="noopener">https://imzlp.com/posts/1948/</a></p><ul><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_14.png" alt=""><br>UAT参数 <a href="https://zhuanlan.zhihu.com/p/41931214" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41931214</a></p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_15.png" alt=""></p></li></ul><h3 id="Server-Client-Automation"><a href="#Server-Client-Automation" class="headerlink" title="Server + Client Automation"></a>Server + Client Automation</h3><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><p>Understanding Unreal Build Tool: <a href="https://ericlemes.com/2018/11/23/understanding-unreal-build-tool/" target="_blank" rel="noopener">https://ericlemes.com/2018/11/23/understanding-unreal-build-tool/</a></p><h2 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h2><h3 id="Distributed-Build"><a href="#Distributed-Build" class="headerlink" title="Distributed Build"></a>Distributed Build</h3><p>FastBuild</p><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_16.png" alt=""><br><a href="https://zhuanlan.zhihu.com/p/158400394" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/158400394</a></li></ul><h2 id="CI体系"><a href="#CI体系" class="headerlink" title="CI体系"></a>CI体系</h2><p>Jenkins, CI and Test-Driven Development:</p><p><a href="https://unrealcommunity.wiki/jenkins-ci-amp-test-driven-development-6912tx0c" target="_blank" rel="noopener">https://unrealcommunity.wiki/jenkins-ci-amp-test-driven-development-6912tx0c</a></p><h3 id="Local-Project-Scan"><a href="#Local-Project-Scan" class="headerlink" title="Local Project Scan"></a>Local Project Scan</h3><h3 id="Unit-Tests-Automation"><a href="#Unit-Tests-Automation" class="headerlink" title="Unit Tests Automation"></a>Unit Tests Automation</h3><hr><h1 id="Unreal游戏客户端技术"><a href="#Unreal游戏客户端技术" class="headerlink" title="Unreal游戏客户端技术"></a>Unreal游戏客户端技术</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>见 《Unreal入门路线》 文档</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_17.png" alt=""><br>Compiling C++ <a href="https://ericlemes.com/2018/11/21/compiling-c-code/" target="_blank" rel="noopener">https://ericlemes.com/2018/11/21/compiling-c-code/</a></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>Unreal资源检测工具学习：</p><hr><h1 id="Unreal游戏服务端技术"><a href="#Unreal游戏服务端技术" class="headerlink" title="Unreal游戏服务端技术"></a>Unreal游戏服务端技术</h1><hr><h1 id="Unreal源码"><a href="#Unreal源码" class="headerlink" title="Unreal源码"></a>Unreal源码</h1><p><a href="https://zhuanlan.zhihu.com/p/160917246" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/160917246</a></p><h1 id="资料集合"><a href="#资料集合" class="headerlink" title="资料集合"></a>资料集合</h1><ul><li><p>Exploring in UE4: <a href="https://zhuanlan.zhihu.com/p/34256771" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34256771</a></p></li><li><p>循迹研究室：<a href="https://imzlp.com/" target="_blank" rel="noopener">https://imzlp.com/</a></p></li><li><p>UE知识库：<a href="https://ue5wiki.com/" target="_blank" rel="noopener">https://ue5wiki.com/</a></p></li><li><p>UE博客：<a href="https://blog.csdn.net/u013412391/category_9736201.html" target="_blank" rel="noopener">https://blog.csdn.net/u013412391/category_9736201.html</a></p></li><li><p><a href="https://romeroblueprints.blogspot.com/p/table-of-contents-c.html" target="_blank" rel="noopener">https://romeroblueprints.blogspot.com/p/table-of-contents-c.html</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/49518229" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49518229</a></p></li><li><p>UE4:<a href="https://blog.csdn.net/jxyb2012/category_8644878.html" target="_blank" rel="noopener">https://blog.csdn.net/jxyb2012/category_8644878.html</a></p></li><li><p>UEC++基础：<a href="https://www.zhihu.com/column/ue4cpp" target="_blank" rel="noopener">https://www.zhihu.com/column/ue4cpp</a></p></li><li><p>Inside UE5: <a href="https://zhuanlan.zhihu.com/p/24319968" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24319968</a></p></li></ul><p>GC相关原理与经验：</p><p><a href="https://zhuanlan.zhihu.com/p/219588301" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/219588301</a></p><p><a href="https://zhuanlan.zhihu.com/p/341137213" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/341137213</a></p><p><a href="https://www.cxymm.net/article/qq_29523119/119860186" target="_blank" rel="noopener">https://www.cxymm.net/article/qq_29523119/119860186</a></p><p><a href="https://blog.csdn.net/qq826364410/article/details/97691497" target="_blank" rel="noopener">https://blog.csdn.net/qq826364410/article/details/97691497</a></p><p><a href="https://www.wyfnote.com/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">https://www.wyfnote.com/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/</a></p><h1 id="个人问题"><a href="#个人问题" class="headerlink" title="个人问题"></a>个人问题</h1><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_18.png" alt=""><br>Unreal加载，Unity可以把资源做成Prefab，打到AB里面，加载使用。Unreal资源如何打包？目前看来，蓝图相当于Prefab，Map当中会对Actor及其引用关系，进行序列化。不用蓝图的话，有没有类似于prefab、AB包的东西？</li></ul><h1 id="零碎知识学习"><a href="#零碎知识学习" class="headerlink" title="零碎知识学习"></a>零碎知识学习</h1><ul><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_19.png" alt=""><br>反射系统使用：<a href="https://zhuanlan.zhihu.com/p/61042237" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61042237</a></p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_20.png" alt=""><br>Extending C++ To BP: <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ClassCreation/CodeAndBlueprints/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ClassCreation/CodeAndBlueprints/</a></p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_21.png" alt=""><br>Architecture <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/</a></p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_22.png" alt=""><br>Programming Basics <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Basics/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Basics/</a></p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_23.png" alt=""><br>UE Containers:<a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Containers/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Containers/</a></p></li><li><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_24.png" alt=""><br>UE对工程进行DEBUG：<a href="https://stonelzp.github.io/ue4-debug-your-project/" target="_blank" rel="noopener">https://stonelzp.github.io/ue4-debug-your-project/</a></p></li></ul><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_25.png" alt=""><br>Unreal 源码解析：<a href="https://edu.uwa4d.com/course-intro/0/374?purchased=false" target="_blank" rel="noopener">https://edu.uwa4d.com/course-intro/0/374?purchased=false</a></p><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_26.png" alt=""><br>资源打包：<a href="https://imzlp.com/posts/22570/#more" target="_blank" rel="noopener">https://imzlp.com/posts/22570/#more</a></li></ul><p>UnrealBuildTool</p><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_27.png" alt=""><br><a href="http://jazzlost.me/2019/11/24/Unreal-UBT-Modules/" target="_blank" rel="noopener">http://jazzlost.me/2019/11/24/Unreal-UBT-Modules/</a></li></ul><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_28.png" alt=""><br><a href="https://www.apude.com/blog/1712.html" target="_blank" rel="noopener">https://www.apude.com/blog/1712.html</a></p><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_29.png" alt=""><br><a href="https://zhuanlan.zhihu.com/p/57186557" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57186557</a></p><p><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_30.png" alt=""><br>UE研发基础命令：<a href="https://www.cnblogs.com/kekec/p/8684068.html" target="_blank" rel="noopener">https://www.cnblogs.com/kekec/p/8684068.html</a></p><ul><li><img src="assets/9999%20Unreal学习与拓展规划\\en_todo_31.png" alt=""><br>UE Pipeline？ <a href="https://dev.epicgames.com/community/learning/courses/qEl/unreal-engine-technical-guide-to-linear-content-creation-pipeline-development/OP88/unreal-engine-overview-of-pipeline-development" target="_blank" rel="noopener">https://dev.epicgames.com/community/learning/courses/qEl/unreal-engine-technical-guide-to-linear-content-creation-pipeline-development/OP88/unreal-engine-overview-of-pipeline-development</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9999 Unreal入门路线</title>
      <link href="2023/07/25/Unreal-9999-Unreal%E5%85%A5%E9%97%A8%E8%B7%AF%E7%BA%BF/"/>
      <url>2023/07/25/Unreal-9999-Unreal%E5%85%A5%E9%97%A8%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<hr><p>烟雨迷离的经验</p><ul><li><p>VS编译C++</p></li><li><p>IDE： Rider for UE</p></li><li><p>架构：知乎InsideUE4 公认比较好</p></li></ul><p><img src="assets/9999%20Unreal入门路线/Image.png" alt=""></p><p>其他资料</p><ul><li><p>Exploring in UE4</p></li><li><p>虚幻引擎 知乎专栏</p></li><li><p>UE4性能优化</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/55335907" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55335907</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/381890846" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/381890846</a></p></li></ul></li><li><p>官方文档</p><ul><li><p>从Unity角度入门UE4</p></li><li><p>C++编程教程</p></li><li><p>动作RPG Sample文档</p></li><li><p>三消例子文档</p></li></ul></li></ul><p>我的入门路径：</p><ul><li><p><img src="assets/9999%20Unreal入门路线\\en_todo.png" alt=""><br>环境、IDE配置</p><ul><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_1.png" alt=""><br><a href="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/VisualStudioSetup/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/VisualStudioSetup/</a></p></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_2.png" alt=""><br><a href="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/VisualStudioSetup/UnrealVS/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/VisualStudioSetup/UnrealVS/</a></p></li></ul></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_3.png" alt=""><br>Unity 入门Unreal<a href="https://docs.unrealengine.com/4.27/en-US/Basics/UnrealEngineForUnityDevs/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/Basics/UnrealEngineForUnityDevs/</a></p></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_4.png" alt=""><br>Android <a href="https://docs.unrealengine.com/4.27/en-US/SharingAndReleasing/Mobile/Android/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/SharingAndReleasing/Mobile/Android/</a></p><ul><li><img src="assets/9999%20Unreal入门路线\\en_todo_5.png" alt=""><br>QuickStart</li></ul></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_6.png" alt=""><br>集成UWA SDK打包，测试并上传数据</p></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_7.png" alt=""><br>批处理自动打包Android，Jenkins集成</p></li><li></li><li><p>FPS Tutorial熟悉 <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/</a></p><ul><li><p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/CPPProgrammingQuickStart/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/CPPProgrammingQuickStart/</a></p></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/PlayerInput/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/PlayerInput/</a></p></li></ul></li><li><p>NativizingBlueprints:<a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/TechnicalGuide/NativizingBlueprints/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/TechnicalGuide/NativizingBlueprints/</a></p></li></ul><hr><p><img src="assets/9999%20Unreal入门路线\\en_todo_8.png" alt=""><br>C++和蓝图关系介绍：<a href="https://its201.com/article/weixin_44739495/121107248" target="_blank" rel="noopener">https://its201.com/article/weixin_44739495/121107248</a></p><p>UEC++官方教程：</p><ul><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_9.png" alt=""><br>编程：<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/</a></p></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_10.png" alt=""><br>快速入门：<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPProgrammingQuickStart/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPProgrammingQuickStart/</a></p></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_11.png" alt=""><br>基础知识 <a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ClassCreation/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ClassCreation/</a></p></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_12.png" alt=""><br>仅使用C++：<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ClassCreation/CodeOnly/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ClassCreation/CodeOnly/</a></p></li><li><p><img src="assets/9999%20Unreal入门路线\\en_todo_13.png" alt=""><br>有空看-compiling：<a href="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/CompilingProjects/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/CompilingProjects/</a></p></li></ul><p>零碎性学习（遇到什么学什么）：</p><ul><li><img src="assets/9999%20Unreal入门路线\\en_todo_14.png" alt=""><br>BluePrint: Unreal中的教程看完</li></ul><p><a href="https://zhuanlan.zhihu.com/p/34256771" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34256771</a></p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源管理工具</title>
      <link href="2023/07/25/Unity3D-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>2023/07/25/Unity3D-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/GameBuildingBlocks/UnityComponent/tree/2b5ca4c2d6bf0f036c8bd60adf244d89655b3438" target="_blank" rel="noopener">https://github.com/GameBuildingBlocks/UnityComponent/tree/2b5ca4c2d6bf0f036c8bd60adf244d89655b3438</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源路径与文件加载</title>
      <link href="2023/07/25/Unity3D-%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/"/>
      <url>2023/07/25/Unity3D-%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>路径相关的测试：<br><a href="https://zhuanlan.zhihu.com/p/58710435" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58710435</a><br><a href="https://github.com/Zhunity/UnityPractice/blob/master/Assets/PathTest/PathTest.cs" target="_blank" rel="noopener">https://github.com/Zhunity/UnityPractice/blob/master/Assets/PathTest/PathTest.cs</a></p><h2 id="特殊文件夹"><a href="#特殊文件夹" class="headerlink" title="特殊文件夹"></a>特殊文件夹</h2><h3 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h3><p>可以在根目录下，也可以在子目录里，只要名子叫Editor就可以。<br>Editor下面放的所有资源文件或者脚本文件都不会被打进发布包中，并且脚本也只能在编辑时使用。一般呢会把一些工具类的脚本放在这里，或者是一些编辑时用的DLL。</p><h3 id="Editor-Default-Resources"><a href="#Editor-Default-Resources" class="headerlink" title="Editor Default Resources"></a>Editor Default Resources</h3><p>中间是有空格的，必须放在Project视图的根目录下，如果你想放在/xxx/xxx/Editor Default Resources 这样是不行的。<br>把编辑器用到的一些资源放在这里，比如图片、文本文件、等等。它和Editor文件夹一样都不会被打到最终发布包里，仅仅用于开发时使用。你可以直接通过EditorGUIUtility.Load去读取该文件夹下的资源。</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>可以在根目录下，也可以在子目录里，只要名子叫Resources就可以。比如目录：/xxx/xxx/Resources 和 /Resources 是一样的，无论多少个叫Resources的文件夹都可以。Resources文件夹下的资源 <strong>不管你用还是不用都会被打包进.apk或者.ipa</strong></p><blockquote><p>一下建议：<br> 强烈不建议使用Resources系统，原因如下：</p><ul><li><p>使用Resources文件夹将会使细粒度的内存管理变得更难</p></li><li><p>对Resources文件夹的不恰当使用会导致应用程序构架和启动时间变长</p></li><li><p>随着Resources文件夹数量的增加，在这些文件夹中管理Asset将会变得越来越难</p></li><li><p>使用Resources系统会降低项目向不同平台提供定制内容的能立，并且导致项目无法进行增量内容更新</p></li><li><p>AssetBundle变体是Unity用来在设备层面调整内容的首选工具。</p></li></ul><p>哪些情况下Resources系统很有用？</p><ul><li><p>Resources系统简单易用的特点使其非常适合用于快速开发原型。不过，当项目进入正式开发阶段时，应该停止使用Resources文件夹。</p></li><li><p>Resources文件夹可以用于处理一些简单的内容：</p></li><li><p>在项目的整个生命周期中都被使用的内容</p></li><li><p>非内存密集型内容</p></li><li><p>不太可能添加补丁或者不受平台和设备影响的内容</p></li><li><p>用于最小化引导的内容 </p></li></ul></blockquote><h4 id="Resource-Load"><a href="#Resource-Load" class="headerlink" title="Resource.Load()"></a>Resource.Load()</h4><p>编辑时和运行时都可以通过Resource.Load来直接读取。</p><h4 id="Resources-LoadAssetAtPath"><a href="#Resources-LoadAssetAtPath" class="headerlink" title="Resources.LoadAssetAtPath()"></a>Resources.LoadAssetAtPath()</h4><p>它可以读取Assets目录下的任意文件夹下的资源，它可以在 <strong>编辑时或者编辑器运行时用</strong> ，它但是它 <strong>不能在真机上用</strong> ，它的路径是 <strong>“Assets/xx/xx.xxx”</strong> 必须是这种路径，并且 <strong>要带文件的后缀名</strong> 。</p><h4 id="AssetDatabase-LoadAssetAtPath"><a href="#AssetDatabase-LoadAssetAtPath" class="headerlink" title="AssetDatabase.LoadAssetAtPath()"></a>AssetDatabase.LoadAssetAtPath()</h4><p>它可以读取Assets目录下的任意文件夹下的资源，它 <strong>只能在编辑时用</strong> 。它的路径是” <strong>Assets/xx/xx.xxx</strong> ” 必须是这种路径，并且 <strong>要带文件的后缀名</strong> 。</p><p>我觉得在电脑上开发的时候尽量来用Resource.Load() 或者 Resources.LoadAssetAtPath() ，假如手机上选择一部分资源要打assetbundle，一部分资源Resource.Load().那么在做.apk或者.ipa的时候 现在都是用脚本来自动化打包，在打包之前 可以用AssetDatabase.MoveAsset()把已经打包成assetbundle的原始文件从Resources文件夹下移动出去在打包，这样打出来的运行包就不会包行多余的文件了。打完包以后再把移动出去的文件夹移动回来。</p><h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><p>这个文件夹下的资源也会全都打包在.apk或者.ipa 它和Resources的区别是， <strong>Resources会压缩文件</strong> ，但是 <strong>它不会压缩</strong> 原封不动的打包进去。并且它是一个 <strong>只读</strong> 的文件夹，就是程序运行时只能读 不能写。它在各个平台下的路径是不同的，不过你可以用Application.streamingAssetsPath 它会根据当前的平台选择对应的路径。</p><p>一般把预制的二进制文件放在里面。</p><p>有些游戏为了让所有的资源全部使用assetbundle，会把一些初始的assetbundle放在StreamingAssets目录下，运行程序的时候在把这些assetbundle拷贝在Application.persistentDataPath目录下，如果这些assetbundle有更新的话，那么下载到新的assetbundle在把Application.persistentDataPath目录下原有的覆盖掉。</p><h3 id="Application-persistentDataPath"><a href="#Application-persistentDataPath" class="headerlink" title="Application.persistentDataPath"></a>Application.persistentDataPath</h3><p>可读可写。可以是程序的沙盒，也可以是SD Card<br>在打包Android的时候，ProjectSetting页面有个选项: WriteAccess，可以设置他的路径是沙盒还是SD Card。<br>Android上如果保存在沙盒中，需要root才能取出文件。</p><p>只有运行时才能在这个路径下写文件。如果要写android交互插件，.java类中是无法访问Unity中的资源的。那么，把资源放在Resources文件夹，在比如Awake函数中把二进制文件copy到persistentDataPath下面，这样C# java两边就都可以访问他了。</p><pre><code class="lang-csharp">string imagePath = Application.persistentDataPath + &quot;/momo.png&quot;; if(!System.IO.File.Exists(imagePath)) { Texture2D o = Resources.Load(&quot;momo&quot;) as Texture2D; System.IO.File.WriteAllBytes(imagePath, o.EncodeToPNG()); }</code></pre><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>如果做手机游戏开发一般 andoird 或者 ios 要接一些sdk 可以把sdk依赖的库文件放在这里，比如 .so .jar .a 文件。这样打完包以后就会自动把这些文件打在你的包中。</p><h3 id="Gizmos"><a href="#Gizmos" class="headerlink" title="Gizmos"></a>Gizmos</h3><p>可以在Scene视图里给某个坐标绘制一个icon。</p><pre><code class="lang-csharp">void OnDrawGizmos() { Gizmos.DrawIcon(transform.position, &quot;0.png&quot;, true); }</code></pre><p>OnDrawGizmos()方法:<br>比如要做摄像机轨迹，那么肯定是要在Scene视图中做一个预览的线，那么用Gizmos.DrawLine 和Gizmos.DrawFrustum就再好不过了。</p><h2 id="PC上读取文件"><a href="#PC上读取文件" class="headerlink" title="PC上读取文件"></a>PC上读取文件</h2><p>Application.dataPath路径在PC上：无论是Editor还是运行时都毫无压力非常万能(但在手机上无用)</p><h3 id="读取XML文件并生成一个类"><a href="#读取XML文件并生成一个类" class="headerlink" title="读取XML文件并生成一个类"></a>读取XML文件并生成一个类</h3><pre><code class="lang-csharp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;test&gt;&lt;name&gt;chenjd&lt;/name&gt;&lt;blog&gt;http://www.cnblogs.com/murongxiaopifu/&lt;/blog&gt;&lt;organization&gt;Fanyoy&lt;/organization&gt;&lt;age&gt;25&lt;/age&gt;&lt;/test&gt;``` ```csharp void Start() { XElement result = LoadXML(&quot;Assets/aa/bb/Test.xml&quot;); } void LoadXML(string path) { XElement xml = XElement.Load(path); return xml; }</code></pre><h2 id="移动平台的资源路径"><a href="#移动平台的资源路径" class="headerlink" title="移动平台的资源路径"></a>移动平台的资源路径</h2><h3 id="Application-streamingAssetsPath"><a href="#Application-streamingAssetsPath" class="headerlink" title="Application.streamingAssetsPath"></a>Application.streamingAssetsPath</h3><p>只读路径。</p><p>在Unity的Assets/目录下创建名为StreamingAssets文件夹即可。</p><p>Application.dataPath: 程序的数据文件所在文件夹。在Editor中就是Assets<br>安卓: /data/app/xxx.xxx.xxx.apk<br>iOS: Application/xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data</p><p>Application.streamingAssetsPath: 流数据的缓存目录，为相对路径，适合设置一些外部数据文件<br>安卓: jar:file:///data/app/xxx.xxx.xxx.apk/!/assets<br>iOS: Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw</p><p>Application.persistentDataPath: 持久化数据存储目录的路径，可用于存储一些持久化的数据文件<br>安卓: /data/data/xxx.xxx.xxx/files<br>iOS: Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</p><p>Application.temporaryCachePath: 临时数据的缓存目录<br>安卓: /data/data/xxx.xxx.xxx/cache<br>iOS: Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</p><p>dataPath和streamingAssetsPath一般是相对程序的安装目录位置<br>persistentDataPath和temporaryCachePath一般是与系统有关的固定位置</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/FudgeBear/p/10513784.html" target="_blank" rel="noopener">https://www.cnblogs.com/FudgeBear/p/10513784.html</a><br><a href="https://www.xuanyusong.com/archives/4033" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4033</a><br><a href="http://www.xuanyusong.com/archives/2656" target="_blank" rel="noopener">http://www.xuanyusong.com/archives/2656</a><br><a href="https://www.xuanyusong.com/archives/3229" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/3229</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-3 Unreal_index</title>
      <link href="2023/07/25/Unreal-4-3-Unreal-index/"/>
      <url>2023/07/25/Unreal-4-3-Unreal-index/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="UE%20-%20Rendering%20Pipeline.html">UE - Rendering Pipeline</a></li><li><a href="Unreal%20-%20蓝图Blueprint.html">Unreal - 蓝图Blueprint</a></li><li><a href="9999%20Unreal入门路线.html">9999 Unreal入门路线</a></li><li><a href="Unreal操作.html">Unreal操作</a></li><li><a href="Unity-Unreal.html">Unity-&gt;Unreal</a></li><li><a href="【Private】Unreal%20Glossary.html">【Private】Unreal Glossary</a></li><li><a href="Build%20-%20Unreal%20Build%20System.html">Build - Unreal Build System</a></li><li><a href="9999%20Unreal学习与拓展规划.html">9999 Unreal学习与拓展规划</a></li><li><a href="CI实践：Cross-platform%20build%20automation%20for%20UE4%20.html">CI实践：Cross-platform build automation for UE4 projects with Jenkins</a></li><li><a href="【CI】Mac自动导入证书.html">【CI】Mac自动导入证书</a></li><li><a href="常见问题.html">常见问题</a></li><li><a href="UI方案.html">UI方案</a></li><li><a href="Unreal插件开发.html">Unreal插件开发</a></li><li><a href="Unreal%20C++.html">Unreal C++</a></li><li><a href="【C++】常用预处理指令.html">【C++】常用预处理指令</a></li><li><a href="Unreal工程目录结构.html">Unreal工程目录结构</a></li><li><a href="C++基础补充.html">C++基础补充</a></li><li><a href="类与API.html">类与API</a></li><li><a href="Actor%20Lifecycle.html">Actor Lifecycle</a></li><li><a href="Unreal资源管理.html">Unreal资源管理</a></li><li><a href="技术笔记.html">技术笔记</a></li><li><a href="遇到的问题及解决.html">遇到的问题及解决</a></li><li><a href="Unreal%20c++常见问题.html">Unreal c++常见问题</a></li><li><a href="C++基础补充-2.html">C++基础补充-2</a></li><li><a href="Unreal%20C++资料整理.html">Unreal C++资料整理</a></li><li><a href="%5BTODO%5D解决困惑-Actor与component关系.html">[TODO]解决困惑-Actor与component关系</a></li><li><a href="Unreal%20Plugin多个模块开发与编译.html">Unreal Plugin多个模块开发与编译</a></li><li><a href="Slate%20UI.html">Slate UI</a></li><li><a href="无标题笔记.html">无标题笔记</a></li><li><a href="Mipmap与Texture%20Streaming.html">Mipmap与Texture Streaming</a></li><li><a href="UDIM贴图.html">UDIM贴图</a></li><li><a href="Build%20-%20踩坑.html">Build - 踩坑</a></li><li><a href="Build%20-%20UE%20CI.html">Build - UE CI</a></li><li><a href="UE%20移动设备调试.html">UE 移动设备调试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑器扩展</title>
      <link href="2023/07/25/Unity3D-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95/"/>
      <url>2023/07/25/Unity3D-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="菜单项"><a href="#菜单项" class="headerlink" title="菜单项"></a>菜单项</h2><h3 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h3><h4 id="常用的菜单那位置"><a href="#常用的菜单那位置" class="headerlink" title="常用的菜单那位置"></a>常用的菜单那位置</h4><ol><li><p>整个Unity编辑器顶头的菜单栏；</p></li><li><p>Inspector挂Component的；</p></li><li><p>Hierarchy游戏物体节点树的；</p></li><li><p>Project游戏资源文件的。</p></li></ol><h4 id="验证菜单栏"><a href="#验证菜单栏" class="headerlink" title="验证菜单栏"></a>验证菜单栏</h4><p>为某个菜单项写一个bool方法。<br>第二个参数表示，是否为验证函数</p><pre><code class="lang-csharp">[MenuItem(&quot;MyMenu/LogTransFormname&quot;)] static void LogTransformName(){ Debug.Log(&quot;TransformName is &quot;+Selection.activeTransform.name); } [MenuItem(&quot;MyMenu/LogTransFormname&quot;,true)] static bool ValidatedLogTransformName(){ return Selection.activeTransform!=null; }</code></pre><h4 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h4><p>菜单名称+空格+快捷键<br>_g 按下字母g<br>修饰符: % Ctrl; # Shift; &amp; Alt<br>LEFT、RIGHT、UP、DOWN、F1..F12、HOME、END、PGUP、PGDN</p><pre><code class="lang-csharp">[MenuItem(&quot;MyMenu/AddKey %j&quot;)] static void AddKey(){ Debug.Log(&quot;this is addKey&quot;); }</code></pre><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>默认为1000<br>差距为11以上分组</p><h4 id="给组件或脚本添加右键方法（Inspector）"><a href="#给组件或脚本添加右键方法（Inspector）" class="headerlink" title="给组件或脚本添加右键方法（Inspector）"></a>给组件或脚本添加右键方法（Inspector）</h4><p>传入参数 MenuCommand<br>command.context : 被右键点击的脚本对象</p><pre><code class="lang-csharp">[MenuItem(&quot;CONTEXT/Transform/DoubleTran&quot;)] static void DoubleTran(MenuCommand command){ Transform body =(Transform)command.context; body.position*=2; Debug.Log(&quot;doubleTrans is&quot;+body.position); }</code></pre><h4 id="其他位置"><a href="#其他位置" class="headerlink" title="其他位置"></a>其他位置</h4><pre><code class="lang-csharp">//Hierarchy窗口下[MenuItem(&quot;GameObject/Test2&quot;, false, 11)] public static void PasteTRValue(){ Debug.Log(&quot;Test2&quot;); } //Project窗口下[MenuItem(&quot;Assets/Test3&quot;, false)] public static void Test3(){ Debug.Log(&quot;Test3&quot;); }</code></pre><h3 id="ContextMenu-amp-ContextMenuItem"><a href="#ContextMenu-amp-ContextMenuItem" class="headerlink" title="ContextMenu &amp; ContextMenuItem"></a>ContextMenu &amp; ContextMenuItem</h3><ul><li><p>写在本身Component脚本中，隶属于UnityEngine命名空间，会被打包。</p></li><li><p>功能和参数与MenuItem完全一致</p></li><li><p>非静态</p></li></ul><p>ContextMenuItem: 给你在右键变量名称时添加菜单<br>参数:1.菜单的名称；2.菜单执行的方法，要求脚本中必须有；3.按钮的先后顺序。</p><pre><code class="lang-csharp">using UnityEngine; public class Clock : MonoBehaviour{ [ContextMenuItem(&quot;Add Hour&quot;, &quot;AddHour&quot;, order = 1)] public int Hour = 10; public void AddHour(){ Hour += 1; } [ContextMenu(&quot;Sub Hour&quot;, false, 10)] public void SubHour(){ Hour -= 1; } }</code></pre><h3 id="注册撤销操作"><a href="#注册撤销操作" class="headerlink" title="注册撤销操作"></a>注册撤销操作</h3><p>Undo.RegisterCreatedObjectUndo方法注册撤销操作</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究Unity引擎的技巧</title>
      <link href="2023/07/25/Unity3D-%E7%A0%94%E7%A9%B6Unity%E5%BC%95%E6%93%8E%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
      <url>2023/07/25/Unity3D-%E7%A0%94%E7%A9%B6Unity%E5%BC%95%E6%93%8E%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="调用Editor内部的函数"><a href="#调用Editor内部的函数" class="headerlink" title="调用Editor内部的函数"></a>调用Editor内部的函数</h1><p>参考:<br><a href="https://www.xuanyusong.com/archives/4263（获取资源内存和硬盘大小" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4263（获取资源内存和硬盘大小</a>)</p><p>Unity Editor实现的一些功能，调用了Editor本身的一些函数。这些函数可能没有作为API提供出来。如果想要调用，可以看Editor的源码：用dnSpy反编译一下，找到相关的代码与函数。<br>然后利用反射，根据函数名调用相应函数。</p><p>此外，该方法提供了一个思路：想要深入理解UnityEditor的实现，就多看看Editor的包文件，反编译看看源码。一个是顺藤摸瓜，看相应功能的实现。一个是看包的整体结构组织，了解各个模块的功能以及实现，理解模块之间的关系。<br>d<br>一个小工具（用来调用内部函数）：</p><p><code>csharp private static object InvokeInternalAPI(string type, string method, params object[] parameters) { var assembly = typeof(AssetDatabase).Assembly; var custom = assembly.GetType(type); var methodInfo = custom.GetMethod(method, BindingFlags.Public | BindingFlags.Static); return methodInfo != null ? methodInfo.Invoke(null, parameters) : 0; }</code> <code>csharp [MenuItem(&quot;ProfilingTools/GetTextureMem&quot;)] public static void GetTextureMem() { Texture target = Selection.activeObject as Texture; Assembly editorAssembly = Assembly.Load(&quot;UnityEditor&quot;); var type = editorAssembly.GetType(&quot;UnityEditor.TextureUtil&quot;); MethodInfo methodInfo = type.GetMethod(&quot;GetStorageMemorySize&quot;, BindingFlags.Static | BindingFlags.Instance | BindingFlags.Public); Debug.Log(&quot;内存占用：&quot; \+ EditorUtility.FormatBytes(UnityEngine.Profiling.Profiler.GetRuntimeMemorySizeLong(Selection.activeObject))); Debug.Log(&quot;硬盘占用：&quot; \+ EditorUtility.FormatBytes((int)methodInfo.Invoke(null, new object[] { target }))); }</code> </p><h1 id="监听Unity编辑器关闭的事件"><a href="#监听Unity编辑器关闭的事件" class="headerlink" title="监听Unity编辑器关闭的事件"></a>监听Unity编辑器关闭的事件</h1><p><code>csharp using UnityEditor; public class Test { [InitializeOnLoadMethod] static void InitializeOnLoadMethod() { EditorApplication.wantsToQuit -= Quit; EditorApplication.wantsToQuit += Quit; } static bool Quit() { EditorUtility.DisplayDialog(&quot;我就是不让你关闭unity&quot;, &quot;我就是不让你关闭unity&quot;, &quot;呵呵&quot;); return false; //return true表示可以关闭unity编辑器 } }</code> </p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源与内存(加载、卸载、Destroy)</title>
      <link href="2023/07/25/Unity3D-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%86%85%E5%AD%98-%E5%8A%A0%E8%BD%BD%E3%80%81%E5%8D%B8%E8%BD%BD%E3%80%81Destroy/"/>
      <url>2023/07/25/Unity3D-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%86%85%E5%AD%98-%E5%8A%A0%E8%BD%BD%E3%80%81%E5%8D%B8%E8%BD%BD%E3%80%81Destroy/</url>
      
        <content type="html"><![CDATA[<h2 id="Unity文件，文件引用，meta详解"><a href="#Unity文件，文件引用，meta详解" class="headerlink" title="Unity文件，文件引用，meta详解"></a>Unity文件，文件引用，meta详解</h2><h3 id="Assets目录下常见的文件类型"><a href="#Assets目录下常见的文件类型" class="headerlink" title="Assets目录下常见的文件类型"></a>Assets目录下常见的文件类型</h3><h4 id="资源文件-ImportedAsset"><a href="#资源文件-ImportedAsset" class="headerlink" title="资源文件(ImportedAsset)"></a>资源文件(ImportedAsset)</h4><p>创建好的，并且不再修改的文件：FBX文件，贴图文件，音频文件，视频文件，动画文件<br>导入时进行转化，每一个类型都对应一个AssetImporter<br>点击这样的资源，在Inspector面板会出现设置界面</p><h4 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h4><p>代码文件包括所有的代码文件，代码库文件，shader文件等，在导入时，unity会进行一次编译。</p><h4 id="序列化文件-Native-Asset"><a href="#序列化文件-Native-Asset" class="headerlink" title="序列化文件(Native Asset)"></a>序列化文件(Native Asset)</h4><p>序列化文件通常是指unity能够序列化的文件，一般是unity自身的一些类型。比如prefab(预制体)，unity3d(场景)文件，asset(ScriptableObject)文件.mat文件(材质球)，这些文件能够在运行时直接反序列化为对应类的一个实例。</p><h4 id="文本文档"><a href="#文本文档" class="headerlink" title="文本文档"></a>文本文档</h4><p>不是序列化文件，但是unity可以识别为TextAsset。<br>很像资源文件，但是又不需要资源文件那样进行设置和转化。<br>如txt、xml文件等等</p><h4 id="非序列化文件"><a href="#非序列化文件" class="headerlink" title="非序列化文件"></a>非序列化文件</h4><p>非序列文件是Unity无法识别的文件，比如文件夹</p><h4 id="Meta文件"><a href="#Meta文件" class="headerlink" title="Meta文件"></a>Meta文件</h4><p>meta文件在unity中的作用非常关键，它有2个作用</p><ul><li><p>定义在它同目录下，同名的非meta文件的唯一ID：GUID。而对于unity的序列化文件来说，引用的对象用的就是这个GUID。所以一旦meta中的GUID变更了，就要注意，它很可能引起一场引用丢失的灾难</p></li><li><p>存储资源文件的ImportSetting数据。在上文中资源文件是有ImportSetting数据的，这个数据正数存储在meta文件中。ImportSetting中专门有存储Assetbundle相关的数据。这些数据帮助编辑器去搜集所有需要打包的文件并分门别类。所以每一次修改配置都会修改meta文件。</p></li></ul><h3 id="Meta文件详解——Unity-GUID-LocalID系统"><a href="#Meta文件详解——Unity-GUID-LocalID系统" class="headerlink" title="Meta文件详解——Unity GUID/LocalID系统"></a>Meta文件详解——Unity GUID/LocalID系统</h3><p>meta文件——文本文档，YAML格式写的（序列化文件都是用这个格式写）</p><h4 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h4><p>guid代表该文件，无论什么类型（甚至是文件夹）。<br>通过GUID就可以找到工程中的这个文件，无论它在项目的什么位置。<br>在编辑器中使用AssetDatabase.GUIDToAssetPath和AssetDatabase.AssetPathToGUID进行互转。</p><h4 id="ImportSetting数据"><a href="#ImportSetting数据" class="headerlink" title="ImportSetting数据"></a>ImportSetting数据</h4><p>根据不同的文件类型，它的数据是不同的ImportSetting数据（Inspector面板设置），比如上面的NativeFormatImporter，ModelImporter，AudioImporter等等。把一个文件和这个文件的meta文件从一个Unity工程复制到另一个Unity工程中，它的配置是不会变的。（将fbx和它的meta文件拷贝到另一个工程，不需要重新裁剪动画）</p><h4 id="FileID（LocalID）"><a href="#FileID（LocalID）" class="headerlink" title="FileID（LocalID）"></a>FileID（LocalID）</h4><p>如果是一个图集，下面有若干个图片，那么就需要另外一个ID来表示，这就是LocalID（meta文件名为: FileID。）</p><ul><li><p>对于资源文件，非序列化文件，由于一般不会去更改源文件，所以FileID存储在meta文件中。</p></li><li><p>对于序列化文件，自身数据里面会存储自身的FileID，也会记录所有子文件的FileID</p></li></ul><blockquote><p>所以在每次svn提交时如果发现有meta文件变更，一定要打开看一下。看看这个guid是否被更改。理论上是不需要更改的。</p></blockquote><h3 id="序列化文件详解——Unity文件引用系统"><a href="#序列化文件详解——Unity文件引用系统" class="headerlink" title="序列化文件详解——Unity文件引用系统"></a>序列化文件详解——Unity文件引用系统</h3><p>用sublime打开一个Scene文件(.unity)，<br>大概的数据：</p><ul><li><p>OcclusionCullingSettings裁剪数据（菜单Window-&gt;Occlusion面板中的数据）</p></li><li><p>RenderSettings（菜单Window-&gt;Lighting-&gt;Settings面板中的部分数据）</p></li><li><p>LightmapSettings（菜单Window-&gt;Lighting-&gt;Settings面板中的其他部分数据）</p></li><li><p>NavMeshSettings（菜单Window-&gt;Navigation面板中的数据）</p></li><li><p>之后就是场景中的GameObject的数据</p></li></ul><h4 id="GameObject数据"><a href="#GameObject数据" class="headerlink" title="GameObject数据"></a>GameObject数据</h4><p>Name就是Main Camera<br>某个物体上有4个组件，每个组件有一个FileID，然后在需要引用时，使用这些FileID即可。实例化一个这样的GameObject时，只要依照次序，依次创建物体，组件，初始化数据并进行引用绑定即可在场景中生成一个实例。</p><blockquote><p>在Inspector面板中的右上角点击，然后选择Debug转成Debug模式下的Inspector面板。<br> 在Hierarchy面板中选中Main Camera可以看到如图所示，所有的组件的LocalIdentfierInFile的值就是刚刚在Sublime中看到的数据</p></blockquote><ul><li><p><strong>InstanceID</strong> 是unity中一个实例的ID。</p></li><li><p>每一个Unity实例都会有一个InstanceID。在运行时，用UnityEngine.Object的GetInstanceID获取（《Unity编辑器下和运行时的加载过程》）</p></li></ul><h4 id="组件数据"><a href="#组件数据" class="headerlink" title="组件数据"></a>组件数据</h4><p>在GameObject之后就是组件数据。可以结合Unity中这个组件的面板来了解每一个数据的意义。</p><blockquote><p>组件FlareLayer，在YAML里面只是一个Behaviour（所有Behaviour组件都看不到类型名字），怎么样才能知道他是一个FlareLayer？<br> FileID左边我们看到一个124。每一个unity类型都有一个对应的数字。<br> 参考：<a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/ClassIDReference.html</a></p></blockquote><p>任何一个文件都可以通过GUID找到，然后通过FileID找到它内部的子文件。所以这样就能识别出这个具体是什么类了。</p><h4 id="Prefab数据"><a href="#Prefab数据" class="headerlink" title="Prefab数据"></a>Prefab数据</h4><p>在YAML的最下面有一个数据是Prefab数据，保存了最重要的几个数据：<br>Modification：每个组件的修改数据列表，但凡修改的数据，都会在这里体现。记录了：哪个资源（GUID）的哪个组件(FileID)的哪个成员(PropertyPath)的值(value)发生了改变。<br>ParentPrefab：表示是哪一个Prefab。</p><p><img src="资源与内存\(加载、卸载、Destroy\" alt="Alt text"><br>_files/289969-20180402204239871-1854753914.png)</p><h2 id="资源导入"><a href="#资源导入" class="headerlink" title="资源导入"></a>资源导入</h2><p>Unity automatically imports assets and manages various kinds of additional data about them for you, such as what import settings should be used to import the asset, and where the asset is used throughout your project. </p><h3 id="What-happens-when-Unity-imports-an-Asset"><a href="#What-happens-when-Unity-imports-an-Asset" class="headerlink" title="What happens when Unity imports an Asset?"></a>What happens when Unity imports an Asset?</h3><ol><li>A Unique ID is assigned<br>This ID is used internally by Unity to refer to the asset which means the asset can be moved or renamed without references to the asset breaking.</li></ol><blockquote><p>the editor frequently checks the contents of the Assets folder against the list of assets it already knows about.</p></blockquote><ol><li>A .meta file is created</li></ol><blockquote><p>If an asset loses its meta file (for example, if you moved or renamed the asset outside of Unity, without moving/renaming the corresponding .meta file), any reference to that asset will be broken. Unity would generate a new .meta file for the moved/renamed asset as if it were a brand new asset, and delete the old “orphaned” .meta file.</p></blockquote><ol><li>The source asset is processed<br>Unity reads and processes any files that you add to the Assets folder, converting the contents of the file to internal game-ready versions of the data. The actual asset files remain unmodified, and the processed and converted versions of the data are stored in the project’s <strong>Library</strong> folder.</li></ol><blockquote><p>the Photoshop file format is convenient to work with and can be saved directly into your Assets folder, but hardware such as mobile devices and PC graphics cards can’t accept that format directly to render as textures. All the data for Unity’s internal representation of your assets is stored in the Library folder which can be thought of as similar to a cache folder. As a user, you should never have to alter the Library folder manually and attempting to do so may affect the functioning of the project in the Unity editor. However, it is always safe to delete the Library folder (while the project is not open in Unity) as all its data is generated from what is stored in the Assets and ProjectSettings folders. This also means that the Library folder should not be included in version control. </p><p>Sometimes multiple assets are created from an import</p><ul><li><p>A 3D file, such as an FBX, defines Materials and/or contains embedded Textures.</p></li><li><p>An image file imported as multiple sprites.</p></li><li><p>A 3D file contains multiple animation timelines, or has multiple separate clips defined within its animation import settings.</p></li></ul></blockquote><h3 id="The-import-settings-can-alter-the-processing-of-the-asset"><a href="#The-import-settings-can-alter-the-processing-of-the-asset" class="headerlink" title="The import settings can alter the processing of the asset"></a>The import settings can alter the processing of the asset</h3><p>As well as the unique ID assigned to the asset, the meta files contain values for all the import settings you see in the inspector when you have an asset selected in your project window. For a texture, this includes settings such as the Texture Type, Wrap Mode, Filter Mode and Aniso Level.</p><p>If you change the import settings for an asset, those changed settings are stored in the .meta file accompanying the asset. The asset will be re-imported according to your new settings, and the corresponding imported “game-ready” data will be updated in the project’s Library folder.</p><h2 id="AssetDatabase"><a href="#AssetDatabase" class="headerlink" title="AssetDatabase"></a>AssetDatabase</h2><p>AssetDatabase is an API which allows you to access the assets contained in your project. Among other things, it provides methods to find and load assets and also to create, delete and modify them. The Unity Editor uses the AssetDatabase internally to keep track of asset files and maintain the linkage between assets and objects that reference them.</p><h3 id="Importing-an-Asset"><a href="#Importing-an-Asset" class="headerlink" title="Importing an Asset"></a>Importing an Asset</h3><h3 id="Loading-an-Asset"><a href="#Loading-an-Asset" class="headerlink" title="Loading an Asset"></a>Loading an Asset</h3><h3 id="File-Operations-using-the-AssetDatabase"><a href="#File-Operations-using-the-AssetDatabase" class="headerlink" title="File Operations using the AssetDatabase"></a>File Operations using the AssetDatabase</h3><h3 id="Using-AssetDatabase-Refresh"><a href="#Using-AssetDatabase-Refresh" class="headerlink" title="Using AssetDatabase.Refresh"></a>Using AssetDatabase.Refresh</h3><p>When you have finished modifying assets, you should call AssetDatabase.Refresh to commit your changes to the database and make them visible in the project.</p><h3 id="CreateAssets-amp-FindAssets-amp-ScriptableObject"><a href="#CreateAssets-amp-FindAssets-amp-ScriptableObject" class="headerlink" title="CreateAssets &amp; FindAssets &amp; ScriptableObject"></a>CreateAssets &amp; FindAssets &amp; ScriptableObject</h3><ol><li><p>对于ScriptableObject，使用CreateInstance来创建Asset实例对象<br><code>testI = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj));</code></p></li><li><p>对于其他资源类型，使用new来创建对象</p></li><li><p>然后调用 <code>AssetDatabase.CreateAsset</code>函数，将实例对象作为资源存储在Assets路径当中。</p></li><li><p>最后使用<code>AssetDatabase.FindAssets</code>获取相应资源的GUID</p></li><li><p>由 <code>AssetDatabase.GUIDToAssetPath</code> 获取相应资源的路径。</p></li></ol><pre><code class="lang-csharp">// This script file has two CS classes. The first is a simple Unity ScriptableObject script.// The class it defines is used by the Example class below.// (This is a single Unity script file. You could split this file into a ScriptObj.cs and an// Example.cs file which is more structured.)using UnityEngine; using UnityEditor; public class ScriptObj : ScriptableObject{ public void Awake(){ Debug.Log(&quot;ScriptObj created&quot;); } } // Use ScriptObj to show how AssetDabase.FindAssets can be usedpublic class Example{ static ScriptObj testI; static ScriptObj testJ; static ScriptObj testK; [MenuItem(&quot;Examples/FindAssets Example two&quot;)] static void ExampleScript(){ CreateAssets(); NamesExample(); LabelsExample(); TypesExample(); } static void CreateAssets(){ testI = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); AssetDatabase.CreateAsset(testI, &quot;Assets/AssetFolder/testI.asset&quot;); testJ = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); AssetDatabase.CreateAsset(testJ, &quot;Assets/AssetFolder/testJ.asset&quot;); // create an asset in a sub-folder and with a name which contains a spacetestK = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); AssetDatabase.CreateAsset(testK, &quot;Assets/AssetFolder/SpecialFolder/testK example.asset&quot;); // an asset with a material will be used laterMaterial material = new Material(Shader.Find(&quot;Standard&quot;)); AssetDatabase.CreateAsset(material, &quot;Assets/AssetFolder/SpecialFolder/MyMaterial.mat&quot;); } static void NamesExample(){ Debug.Log(&quot;*** FINDING ASSETS BY NAME ***&quot;); string[] results; results = AssetDatabase.FindAssets(&quot;testI&quot;); foreach (string guid in results) { Debug.Log(&quot;testI: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } results = AssetDatabase.FindAssets(&quot;testJ&quot;); foreach (string guid in results) { Debug.Log(&quot;testJ: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } results = AssetDatabase.FindAssets(&quot;testK example&quot;); foreach (string guid in results) { Debug.Log(&quot;testK example: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } Debug.Log(&quot;*** More complex asset search ***&quot;); // find all assets that contain test (which is all assets)results = AssetDatabase.FindAssets(&quot;test&quot;); foreach (string guid in results) { Debug.Log(&quot;name:test - &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } } static void LabelsExample(){ Debug.Log(&quot;*** FINDING ASSETS BY LABELS ***&quot;); string[] setLabels; setLabels = new string[] {&quot;wrapper&quot;}; AssetDatabase.SetLabels(testI, setLabels); setLabels = new string[] {&quot;bottle&quot;, &quot;banana&quot;, &quot;carrot&quot;}; AssetDatabase.SetLabels(testJ, setLabels); setLabels = new string[] {&quot;swappable&quot;, &quot;helmet&quot;}; AssetDatabase.SetLabels(testK, setLabels); // label searching:// testI has wrapper, testK has swappable, so both have &#39;app&#39;// testJ has bottle, so have a label searched as &#39;bot&#39;string[] getGuids = AssetDatabase.FindAssets(&quot;l:app l:bot&quot;); foreach (string guid in getGuids) { Debug.Log(&quot;label lookup: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } } static void TypesExample(){ Debug.Log(&quot;*** FINDING ASSETS BY TYPE ***&quot;); string[] guids; // search for a ScriptObject called ScriptObjguids = AssetDatabase.FindAssets(&quot;t:ScriptObj&quot;); foreach (string guid in guids) { Debug.Log(&quot;ScriptObj: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } guids = AssetDatabase.FindAssets(&quot;t:ScriptObj l:helmet&quot;); foreach (string guid in guids) { Debug.Log(&quot;ScriptObj+bottle: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } } }</code></pre><h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><p><a href="https://blog.csdn.net/qq_35361471/article/details/82854560" target="_blank" rel="noopener">https://blog.csdn.net/qq_35361471/article/details/82854560</a></p><h2 id="资源卸载（Unload-amp-Destroy）"><a href="#资源卸载（Unload-amp-Destroy）" class="headerlink" title="资源卸载（Unload &amp; Destroy）"></a>资源卸载（Unload &amp; Destroy）</h2><h3 id="Destroy"><a href="#Destroy" class="headerlink" title="Destroy"></a>Destroy</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>UNITY Destroy()和DestroyImadiate()都不会立即释放对象内存<br>DestroyImadiate是立即将物体从场景hierachy中移除，并标记为 “null”，注意 是带引号的null。这是UNITY内部的一个处理技巧。关于这个技巧有很争议。<br>Destroy要等到帧末才会将物体从场景层级中移除并标记为”null”。</p><p>不管如何，二者都只是UNITY引擎层面的标记与处理，但在.NET底层，对象的内存都没有释放，只有手动GC.Collect()或等待NET去GC时才会释放掉对象内存。<br>如果该对象在其他地方还有引用的话，GC也无法将对象的内存释放。</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>（1）obj并不会立即销毁，而是需要等待下一个Update更新，所以还是可以被print出来；<br>（2）DestroyImmediate立即对对像进行销毁，print出来是null；<br>（3）Destroy销毁场景中的物体，但内存中还存在，当令它需要销毁时，只是给一个标识。而内存中它依然是存在的，只有当内存不够，或一段时间没有再次被引用时（或者更多合理的条件满足），机制才会将它销毁并释放内存；<br>（4）这样做的目的就是为了避免频繁对内存的读写操作。回收器会定时清理一次内存中引用计数为0的对象，很可能你的要销毁的对象在其他地方还有引用而你自己不清楚，直接销毁可能导致其他地方空引用错误；<br>（5）建议使用平常Destroy函数，而不是DestroyImmediate函数；</p><h4 id="作用对象"><a href="#作用对象" class="headerlink" title="作用对象"></a>作用对象</h4><p>GameObject、Component这样的在内存当中的实例，可以直接销毁，销毁掉后对硬盘上的资源是没有影响的。<br>Load进来的资源文件（Texture等）不可以使用DestroyImmediate(obj)直接销毁。如果使用DestroyImmediate(obj, true)接口，可以销毁。对于序列化文件等Unity可以直接识别和接管的文件，相应的资源文件会销毁掉，而对于Texture这样的资源，Unity无法识别资源原始的图片，只能识别导入后加入Library中的文件，则会销毁Library中相应的资源，并断掉对该资源的引用（路径上就找不到该资源了）。而对于图片，由于原始文件没有被销毁，重新打开项目后，该图片会重新被Import进来。</p><p>总之，Destroy接口本身是不应该用来销毁资源的。</p><p>如果在游戏当中把资源Destroy掉，下次打开游戏，这个资源就没有了，加载不到了。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试代码如下：点ADD按钮不断创建对象，点DEL按钮清除所有对象，通过观察进程内存数值来察看对象内存是否释放。</p><pre><code class="lang-csharp">using System.Collections; using System.Collections.Generic; using System.Diagnostics; using UnityEngine; using UnityEngine.UI; public class MyGo : MonoBehaviour{ byte[] data = new byte[83000]; } public class testad : MonoBehaviour { Transform objs; Text txt; Process proc; void Start () { var btnadd = transform.Find(&quot;btnAdd&quot;).GetComponent&lt;Button&gt;(); btnadd.onClick.AddListener(OnClckAdd); var btndel = transform.Find(&quot;btnDel&quot;).GetComponent&lt;Button&gt;(); btndel.onClick.AddListener(OnClckDel); objs = transform.Find(&quot;objs&quot;); txt = transform.Find(&quot;Text&quot;).GetComponent&lt;Text&gt;(); proc = Process.GetCurrentProcess(); } void OnClckAdd(){ for (int i = 0; i &lt; 20; ++i) { var go = new GameObject(); go.AddComponent&lt;MyGo&gt;(); go.transform.SetParent(objs); } } void OnClckDel(){ for (int i = objs.childCount - 1; i &gt;= 0; i--) { GameObject.DestroyImmediate(objs.GetChild(i).gameObject); } System.GC.Collect(); } // Update is called once per framefloat timer = 0; void Update () { if (timer &gt; 0.5f) { timer = 0; txt.text = ((int)(proc.WorkingSet64 / 1024)).ToString(); } timer += Time.deltaTime; } }</code></pre><h4 id="Resources-UnloadUnusedAssets"><a href="#Resources-UnloadUnusedAssets" class="headerlink" title="Resources.UnloadUnusedAssets"></a>Resources.UnloadUnusedAssets</h4><p>运行中卸载，可能是在帧末尾卸载</p><h4 id="Resources-UnloadAsset"><a href="#Resources-UnloadAsset" class="headerlink" title="Resources.UnloadAsset()"></a>Resources.UnloadAsset()</h4><p>对于场景当中的特定资源，如果相机照射到他或者在脚本中有对资源的引用的话就无法卸载。<br>如果相机没有看到他，并且没有被引用到，那么该资源会在内存当中被卸载。而若下次引用到他，或者相机照射到他，那么该资源会被重新加载到内存当中。</p><h4 id="EditorUtility-UnloadUnusedAssets"><a href="#EditorUtility-UnloadUnusedAssets" class="headerlink" title="EditorUtility.UnloadUnusedAssets"></a>EditorUtility.UnloadUnusedAssets</h4><p>编辑器下的卸载资源接口。</p><h2 id="资源卸载与内存管理问题的处理经验"><a href="#资源卸载与内存管理问题的处理经验" class="headerlink" title="资源卸载与内存管理问题的处理经验"></a>资源卸载与内存管理问题的处理经验</h2><ol><li><p>Editor中的脚本对物体的引用无法用Memory Profiler检测到，因为Editor脚本对MemoryProfiler是不可见的。</p></li><li><p>只要脚本中有对Texture等资源实例的引用，那么相应的资源就无法卸载掉。</p></li><li><p>EditorUtility.UnloadUnusedAssets确实可以卸载没有被引用的资源对象，但是不会一调用就立即卸载掉，可能稍等一会儿才会卸载掉。所以，在这个函数调用过后立即检测内存，是看不出来卸载的效果的，过一小段时间后，再打印内存，就可以看到卸载的效果。根据对内存的监控可以判断：刚刚调用Unload资源函数的时候，内存不会立即释放，在下次加载资源的时候，会进行内存释放操作。</p></li><li><p>把加载进内存的对象直接Destroy掉，就不会占用内存，不需要调用Unload函数也可以。 如果把对资源的引用设置为null，不调用unload函数的话，资源会留在内存当中，只有调用unload之后，资源才会被卸载</p></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/CodeGize/p/8697227.html" target="_blank" rel="noopener">https://www.cnblogs.com/CodeGize/p/8697227.html</a><br><a href="https://www.cnblogs.com/timeObjserver/p/7575035.html" target="_blank" rel="noopener">https://www.cnblogs.com/timeObjserver/p/7575035.html</a><br><a href="https://docs.unity3d.com/2017.2/Documentation/Manual/BehindtheScenes.html" target="_blank" rel="noopener">https://docs.unity3d.com/2017.2/Documentation/Manual/BehindtheScenes.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取场景点数和面数</title>
      <link href="2023/07/25/Unity3D-%E8%8E%B7%E5%8F%96%E5%9C%BA%E6%99%AF%E7%82%B9%E6%95%B0%E5%92%8C%E9%9D%A2%E6%95%B0/"/>
      <url>2023/07/25/Unity3D-%E8%8E%B7%E5%8F%96%E5%9C%BA%E6%99%AF%E7%82%B9%E6%95%B0%E5%92%8C%E9%9D%A2%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><pre><code class="lang-csharp">int tris = 0, verts = 0; //GameObject[] gameObjects = Resources.FindObjectsOfTypeAll&lt;GameObject&gt;();GameObject[] gameObjects = GameObject.FindObjectsOfType&lt;GameObject&gt;() as GameObject[]; foreach (GameObject go in gameObjects) { //Component[] filters;//filters = go.GetComponentsInChildren&lt;MeshFilter&gt;();//Debug.Log(filters.Length);//foreach (MeshFilter f in filters)//{// tris += f.sharedMesh.triangles.Length / 3;// verts += f.sharedMesh.vertexCount;//}MeshFilter filter; filter = go.GetComponent&lt;MeshFilter&gt;(); if(filter != null) { Debug.Log(go.name); tris += filter.sharedMesh.triangles.Length / 3; verts += filter.sharedMesh.vertexCount; } } Debug.Log(&quot;verts number: &quot; \+ verts); Debug.Log(&quot;trises number: &quot; \+ tris); Debug.Log(gameObjects.Length); Debug.Log(&quot;Code Test---&quot;);</code></pre><h4 id="z"><a href="#z" class="headerlink" title="z"></a>z</h4>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小知识点与小工具</title>
      <link href="2023/07/25/Unity3D-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>2023/07/25/Unity3D-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Gizmos"><a href="#Gizmos" class="headerlink" title="Gizmos"></a>Gizmos</h2><p><strong>Gizmos</strong> 在编辑模式下Gizmos可以提供可视化的提示。它们只在Scene场景中显示不在Play模式下显示，但是你可以通过工具栏调整它们。</p><p><strong>Gizmos公共类</strong> 允许你绘制图标，线条，和其他的东西。Gizmos在<code>OnDrawGizmos</code>方法中执行绘制，它被Unity编辑器自动调用。另一个可选的方法是<code>OnDrawGizmosSelected</code>，它只能被可选的对象调用。</p><p>Demo: 绘制顶点的位置，利用OnDrawGizmos在每个顶点绘制一个小球。</p><p><code>csharp private void OnDrawGizmos () { Gizmos.color = Color.black; for (int i = 0; i &lt; vertices.Length; i++) { Gizmos.DrawSphere(vertices[i], 0.1f); } }</code> </p><h2 id="OnValidate"><a href="#OnValidate" class="headerlink" title="OnValidate"></a>OnValidate</h2><p>调用时机:</p><ul><li>脚本被加载时</li><li>Inspector 中的任何值被修改时</li></ul><p>Cases：<br>设置循环值</p><p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { public float objectRotation; void OnValidate() { // objectRotation objectRotation = objectRotation % 360; } }</code> </p><p>需要设计人员输入 16 到 4096 之间 2的整数次幂时。<br>Unity提供了ClosestPowerOfTwo函数，方便我们取得最接近的值。同时我们使用RangeAttribute 属性来限定一下输入数值的区间，同时能更好的看出来处理后的值跟原始输入值的区别。</p><p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { [RangeAttribute(16, 4096)] public int textureSize; void OnValidate() { // textureSize textureSize = Mathf.ClosestPowerOfTwo(textureSize); } }</code> </p><p>使用场景 -需要“Nitro”车的速度比其他车的速度大至少20mph.</p><p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { [RangeAttribute(10, 300)] [Tooltip(&quot;mph&quot;)] public int maxCarSpeed; [RangeAttribute(10, 300)] [Tooltip(&quot;mph&quot;)] public int maxNitroSpeed; const int minNitroSpeedExtra = 20; void OnValidate() { // speed check if (maxNitroSpeed &lt; maxCarSpeed + minNitroSpeedExtra) maxNitroSpeed = maxCarSpeed + minNitroSpeedExtra; } }</code> </p><h2 id="动态添加tag"><a href="#动态添加tag" class="headerlink" title="动态添加tag"></a>动态添加tag</h2><p><code>csharp #region 动态添加tag static void AddTag(string tag, GameObject obj) { if (!isHasTag(tag)) { SerializedObject tagManager = new SerializedObject(obj);//序列化物体 SerializedProperty it = tagManager.GetIterator();//序列化属性 while (it.NextVisible(true))//下一属性的可见性 { if (it.name == &quot;m_TagString&quot;) { Debug.Log(it.stringValue); it.stringValue = tag; tagManager.ApplyModifiedProperties(); } } } } static bool isHasTag(string tag) { for (int i = 0; i &lt; UnityEditorInternal.InternalEditorUtility.tags.Length; i++) { if (UnityEditorInternal.InternalEditorUtility.tags[i].Equals(tag)) return true; } return false; } #endregion</code> </p><h2 id="关于enable-false"><a href="#关于enable-false" class="headerlink" title="关于enable=false"></a>关于enable=false</h2><p>When a Behaviour is disabled, it will still be on the object and you can even change its properties and call its methods, but the engine will no longer call its Update method.<br>When a Renderer is disabled, the object turns invisible.<br>When a Collider is disabled, it won’t cause any collision events to happen.<br>When an UI component is disabled, the player can’t interact with it anymore, but it will still be rendered, unless you also deactivate its renderer.</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强哥UI课</title>
      <link href="2023/07/25/Unity3D-%E5%BC%BA%E5%93%A5UI%E8%AF%BE/"/>
      <url>2023/07/25/Unity3D-%E5%BC%BA%E5%93%A5UI%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><h3 id="Canvas组件"><a href="#Canvas组件" class="headerlink" title="Canvas组件"></a>Canvas组件</h3><p>Render Mode</p><ul><li><p>Screen Space - Overlay</p></li><li><p>Screen Space - Camera</p></li><li><p>World Space</p></li></ul><p>Pixel Perfect 在要提高清晰度的时候才选择。 一般不推荐选择</p><h3 id="Rect-Transform"><a href="#Rect-Transform" class="headerlink" title="Rect Transform"></a>Rect Transform</h3><h3 id="CanvasRenderer"><a href="#CanvasRenderer" class="headerlink" title="CanvasRenderer"></a>CanvasRenderer</h3><h3 id="EventSystem-amp-GraphicRaycaster"><a href="#EventSystem-amp-GraphicRaycaster" class="headerlink" title="EventSystem &amp; GraphicRaycaster"></a>EventSystem &amp; GraphicRaycaster</h3><p>找被点中的物体</p><h3 id="Event-Trigger"><a href="#Event-Trigger" class="headerlink" title="Event Trigger"></a>Event Trigger</h3><p>这个是UGUI里面封装好的一个Component，里面预设了很多UGUI支持的UI事件，方便大家用来自定义一些消息响应，比如点击事件，也可以用来制作一些特殊的UI响应，例如长按事件</p><h2 id="Lesson2"><a href="#Lesson2" class="headerlink" title="Lesson2"></a>Lesson2</h2><h3 id="分辨率适配"><a href="#分辨率适配" class="headerlink" title="分辨率适配"></a>分辨率适配</h3>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化与反序列化</title>
      <link href="2023/07/25/Unity3D-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>2023/07/25/Unity3D-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Ref: <a href="https://zhuanlan.zhihu.com/p/27990334" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27990334</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>序列化</strong> 又称串行化，是.NET运行时环境用来支持用户定义类型的流化的机制。其目的是以某种存储形式使自定义对象持久化，或者将这种对象从一个地方传输到另一个地方。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化是指把 <strong>对象</strong> 转换为 <strong>字节序列</strong> 的过程</p><p>对象序列化的最主要的用处就是在 <strong>传递和保存对象</strong> 的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了 <strong>对象的状态以及相关的描述信息</strong> 。序列化机制的核心作用就是对象状态的保存与重建。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列化是指把 <strong>字节序列</strong> （有序字节流）恢复为 <strong>对象</strong> 的过程</p><p>客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化 <strong>重建对象，恢复对象状态</strong></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>永久性保存对象，保存对象的字节序列到本地文件或者数据库中；</p></li><li><p>通过序列化以字节流的形式使对象在网络中进行传递和接收；</p></li><li><p>通过序列化在进程间传递对象；</p></li></ol><h2 id="Unity序列化"><a href="#Unity序列化" class="headerlink" title="Unity序列化"></a>Unity序列化</h2><p>Unity的场景文件和预制体默认就是以二进制的文件保存在工程目录下。<br>在 <strong>检视面板</strong> 中可以看到的，就是被 <strong>成功序列化了的参数</strong> 。与序列化相关的常用的关键字如下，可以组合使用。</p><ul><li><p>SerializeField : 表示变量可被序列化。众所周知，公有变量可以在检视面板中看到并编辑，而私有和保护变量不行。SerializeField与private，protected结合使用可以达到让脚本的变量在检视面板里可视化编辑，同时保持它的私有性的目的。</p></li><li><p>HideInInspector : 将原本显示在检视面板上的序列化值隐藏起来。</p></li><li><p>NonSerialized :通过此方法可以将一个公有变量不序列化并且不显示在检视面板中。</p></li><li><p>Serializable：用在类的前面，表示该类可被序列化。</p></li></ul><p><strong>相关API</strong><br>SerializedObject: <a href="https://docs.unity3d.com/ScriptReference/SerializedObject.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/SerializedObject.html</a><br>SerializedProperty: <a href="https://docs.unity3d.com/ScriptReference/SerializedProperty.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/SerializedProperty.html</a></p><blockquote><p>注意：并非所有的公有变量都是可以被序列化的。其中const，static是静态的，属于类而非对象，无法序列化。链表和字典在内存中的存储是不连续的，也无法序列化。其中const，static，readonly的区别可参考文章：<a href="https://www.cnblogs.com/suizhikuo/p/4739388.html" target="_blank" rel="noopener">https://www.cnblogs.com/suizhikuo/p/4739388.html</a></p></blockquote><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="二进制方法（Binary-Formatter）"><a href="#二进制方法（Binary-Formatter）" class="headerlink" title="二进制方法（Binary Formatter）"></a>二进制方法（Binary Formatter）</h3><pre><code class="lang-csharp">void WriteTest(){ DemoClass demo = new DemoClass (100, &quot;RCD&quot;); FileStream fs = new FileStream (&quot;demo.bin&quot;, FileMode.OpenOrCreate); BinaryFormatter bf = new BinaryFormatter (); bf.Serialize (fs, demo); fs.Close (); Debug.LogError (&quot;write done&quot;); } void ReadTest(){ FileStream fs = new FileStream(&quot;demo.bin&quot;, FileMode.Open); BinaryFormatter bf = new BinaryFormatter(); DemoClass demo = bf.Deserialize(fs) as DemoClass; fs.Close(); demo.Output(); }</code></pre><blockquote><p>注意：二进制方法可以序列化私有变量，不能序列化被[NonSerialized ]修饰的变量且类需要被[Serializable ]标识。</p></blockquote><h3 id="Xml序列化"><a href="#Xml序列化" class="headerlink" title="Xml序列化"></a>Xml序列化</h3><p>XML(Extensible Markup Language, 可扩展标记语言), 标准通用标记语言(Standard Generalized Markup language, SGML)的子集。是一种用于标记电子文件使其具有结构性的标记语言。<br>提供统一的方法来描述和交换独立于应用程序或供应商的 <strong>结构化数据</strong> 。</p><pre><code class="lang-csharp">using System.IO; using System.Xml.Serialization; using UnityEditor; 先定义一个类： public class Studnet{ public string m_Name = &quot;仑仑&quot;; } public class SerializeDemo : MonoBehaviour { void Start(){ //序列化：Student student = new Student(); //第一要确定储存的位置//Application.dataPath就是unity中的Asset文件夹 StreamWriter sw = new StreamWriter(Application.dataPath + &quot;/Demo.xml&quot;); //第二要对什么类型序列化XmlSerializer xs = new XmlSerializer(typeof(Student)); //第三对对象序列化xs.Serialize(sw, student); //关闭流sw.Close(); //刷新Asset文件AssetDatabase.Refresh(); //运行程序会在Asset目录下看到Demo.xml文件//反序列化//第一确定对哪个文件进行反序列化StreamReader sr = new StreamReader(Application.dataPath + &quot;/Demo.xml&quot;); //第二要确定对什么类型反序列化XmlSerializer xs1 = new XmlSerializer(typeof(Student)); //第三反序列化Student student1 = xs1.Deserialize(sr) as Student; //关闭流sr.Close(); //会在控制台看到 “仑仑”print(student1.m_Name); } } SerializeDemo</code></pre><h2 id="其他Unity数据存储方法"><a href="#其他Unity数据存储方法" class="headerlink" title="其他Unity数据存储方法"></a>其他Unity数据存储方法</h2><h3 id="ScriptableObject-自动序列化"><a href="#ScriptableObject-自动序列化" class="headerlink" title="ScriptableObject(自动序列化)"></a>ScriptableObject(自动序列化)</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h5><p>需要指定创建的目录和资源名称，如果资源已经存在，则不会创建新资源；</p><pre><code class="lang-csharp">public class MakeScriptableObject { [MenuItem(&quot;Assets/Create/My Scriptable Object&quot;)] public static void CreateMyAsset(){ MyScriptableObjectClass asset = ScriptableObject.CreateInstance&lt;MyScriptableObjectClass&gt;(); AssetDatabase.CreateAsset(asset, &quot;Assets/NewScripableObject.asset&quot;); AssetDatabase.SaveAssets(); EditorUtility.FocusProjectWindow(); Selection.activeObject = asset; } }</code></pre><h5 id="CreateAssetMenu"><a href="#CreateAssetMenu" class="headerlink" title="CreateAssetMenu"></a>CreateAssetMenu</h5><p>可以在Assets下任意目录创建资源，而且可以创建多个资源；</p><pre><code class="lang-csharp">[CreateAssetMenu(fileName = &quot;data&quot;, menuName = &quot;ScriptableObjects/SpawnManagerScriptableObject&quot;, order = 1)] public class SpawnManagerScriptableObject : ScriptableObject { public string prefabName; public int numberOfPrefabsToCreate; public Vector3[] spawnPoints; }</code></pre><p>在Assets下创建一个可编程对象资源，设置好所需数据；如果需要在其它脚本中获取该数据，是需要声明一个该类型变量，然后为其赋值或加载该数据资源；然后，就像使用用一个类中的公有变量一样使用即可；</p><pre><code class="lang-csharp">public SpawnManagerScriptableObject spawnManagerValues; //spawnManagerValues.prefabName</code></pre><h3 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a>PlayerPrefs</h3><p>Ref: <a href="https://www.jianshu.com/p/579be3b8e1e3" target="_blank" rel="noopener">https://www.jianshu.com/p/579be3b8e1e3</a><br>PlayerPrefs是Unity内置的一个静态类，可以用于存储一些简单的数据类型：int ,string ,float。可以用它来做成计分板这类需要可持续化存储的小地方。</p><h4 id="PlayerPrefs数据存储在哪里"><a href="#PlayerPrefs数据存储在哪里" class="headerlink" title="PlayerPrefs数据存储在哪里?"></a>PlayerPrefs数据存储在哪里?</h4><p>1.在Mac OS X上存储在~/Library/PlayerPrefs文件夹，名为unity.[company name].[product name].plist,这里company和product名是在project Setting中设置的<br>2.在windows下，playerPrefs被存储在注册的HKCU\Software[company name][product name]键下，这里company和product名是在project setting中设置的。<br>3.在Android上，数据存储（持久化）在设备上。数据保存在SharedPreferences中。</p><h4 id="PlayerPrefs有哪些方法？"><a href="#PlayerPrefs有哪些方法？" class="headerlink" title="PlayerPrefs有哪些方法？"></a>PlayerPrefs有哪些方法？</h4><p>分为五类：SetXXX , GetXXX , DeleteXXX, HasKey , Save.<br>传送门：<a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/PlayerPrefs.html</a></p><ol><li><p>SetXXX : 是你要储存的数据类型，这里必须是一组键值对，第一个参数是Key,第二个参数是对应的Value。</p></li><li><p>GetXXX：这里是获取数据的函数，只有一个参数Key,用来获取对应Key的Value.<br>3.HasKey: 这个可以用来做判断。比如有两组数据一组有XX这个Key,另一组没有XX这个Key,这个时候我们就可以对这两组数据进行差异化操作。</p></li><li><p>DeleteXX:用于删除数据。</p></li><li><p>Save:用于在突发退出程序时，保存数据以备恢复时使用，但是会导致程序间断所以不建议调用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题</title>
      <link href="2023/07/25/Unity3D-%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%EF%BC%9AOnRenderImage%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84RT%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>2023/07/25/Unity3D-%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%EF%BC%9AOnRenderImage%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84RT%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>By Prin@UWA</p><h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h3 id="windows查看nvidia显卡（GPU）的利用率和温度"><a href="#windows查看nvidia显卡（GPU）的利用率和温度" class="headerlink" title="windows查看nvidia显卡（GPU）的利用率和温度"></a>windows查看nvidia显卡（GPU）的利用率和温度</h3><p>对可执行程序nvidia-smi.exe直接调用就可以显示显卡相关信息：<br>GPU的名称、温度、显存占用情况、GPU利用率、正在工作的GPU进程</p><p>笔者的nvidia-smi.exe程序在C:\Windows\System32目录下。</p><h3 id="Android上查看程序占用内存大小"><a href="#Android上查看程序占用内存大小" class="headerlink" title="Android上查看程序占用内存大小"></a>Android上查看程序占用内存大小</h3><h4 id="adb-dumpsys-命令查看每个程序的内存信息"><a href="#adb-dumpsys-命令查看每个程序的内存信息" class="headerlink" title="adb dumpsys 命令查看每个程序的内存信息"></a>adb dumpsys 命令查看每个程序的内存信息</h4><p>以下命令查看程序的PID（app_name可以不全）</p><pre><code class="lang-csharp">adb shell top | grep app_name</code></pre><p>以下命令查看程序的内存使用情况</p><pre><code class="lang-csharp">adb shell dumpsys meminfo &lt;package_name&gt;adb shell dumpsys meminfo &lt;PID&gt;</code></pre><p>Total 的 PSS 信息就是你的应用真正占据的内存大小</p><h4 id="查看整体内存信息"><a href="#查看整体内存信息" class="headerlink" title="查看整体内存信息"></a>查看整体内存信息</h4><pre><code class="lang-csharp">adb shell cat /proc/meminfo</code></pre><p>其他有用命令：</p><blockquote><ul><li><p>adb shell kill PIDNumber 死你想杀死的后台进程来模拟某种 bug 的复现条件。</p></li><li><p>adb shell ps 查看当前终端中的进程信息</p></li></ul></blockquote><h3 id="DontSave——保留对象到新场景"><a href="#DontSave——保留对象到新场景" class="headerlink" title="DontSave——保留对象到新场景"></a>DontSave——保留对象到新场景</h3><p>如果GameObject对象被HideFlags.DontSave标识，则在新scene中GameObject的所有组件将被保留下来</p><ol><li><p>其子类GameObject对象不会被保留到新scene中</p></li><li><p>不可以对GameObject对象的某个组件如Transform进行HideFlags.DontSave标识，否则无效。</p></li><li><p>即使程序已经退出，被HideFlags.DontSave标识的对象会一直存在于程序中，造成内存泄漏，对HideFlags.DontSave标识的对象在不需要或程序退出时需要使用DestroyImmediate手动销毁。</p></li></ol><p>Demo:</p><pre><code class="lang-csharp">using UnityEngine; using System.Collections; public class DontSave_ts : MonoBehaviour { public GameObject go; public Transform t; void Start(){ //GameObject对象使用HideFlags.DontSave可以在新scene中被保留go.hideFlags = HideFlags.DontSave; GameObject Pl = GameObject.CreatePrimitive(PrimitiveType.Plane); Pl.hideFlags = HideFlags.DontSave; //不可以对GameObject的组件设置HideFlags.DontSave，否则无效Transform tf = Instantiate(t, go.transform.position + new Vector3(2.0f, 0.0f, 0.0f), Quaternion.identity) as Transform; tf.hideFlags = HideFlags.DontSave; //导入名为newScene_unity的新sceneApplication.LoadLevel(&quot;newScene2_unity&quot;); } }</code></pre><p>在场景2中：</p><pre><code class="lang-csharp">using UnityEngine; using System.Collections; public class NewScene2_ts : MonoBehaviour { GameObject cube, plane; void Start () { Debug.Log(&quot;这是NewScene2！&quot;); } //当程序退出时用DestroyImmediate()销毁被HideFlags.DontSave标识的对象//否则即使程序已经退出，被HideFlags.DontSave标识的对象依然在Hierarchy面板中//即每运行一次程序就会产生多余对象，造成内存泄漏void OnApplicationQuit(){ cube = GameObject.Find(&quot;Cube0&quot;); plane = GameObject.Find(&quot;Plane&quot;); if (cube) { Debug.Log(&quot;Cube0 DestroyImmediate&quot;); DestroyImmediate(cube); } if (plane) { Debug.Log(&quot;Plane DestroyImmediate&quot;); DestroyImmediate(plane); } } }</code></pre><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>给场景添加以下脚本：</p><pre><code class="lang-csharp">public class Test_OnRenderImage : MonoBehaviour{ private void OnRenderImage(RenderTexture source, RenderTexture destination){ Graphics.Blit(source, destination); } }</code></pre><p>Build后在安卓设备上运行，使用Profiler进行分析，会发现Detailed信息当中多了一张较大的RenderTexture：TempBuffer 1，如下图，其大小为60+MB：</p><p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/QQ截图20200921190054.png" alt="Alt text"></p><p>而在统计的（Used/Reserved）Unity内存和GfxDriver内存都低与60MB。</p><p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Simple.png" alt="Alt text"></p><p>也就是说，Unity Profiler并没有把这个RT占用的内存统计到Unity或GfxDriver当中。笔者比较好奇，这个RT是什么情况下才会生成？放在内存的哪一部分？为什么不会统计到Unity或GfxDriver当中？什么样的会统计到什么样的不会被统计到？于是做了如下实验。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>创建空场景，在任意物体上添加上文提到的 <code>Test_OnRenderImage</code> 脚本。</p><h3 id="PC平台上测试"><a href="#PC平台上测试" class="headerlink" title="PC平台上测试"></a>PC平台上测试</h3><p>首先在PC Standalone上进行测试。按照是否添加Test_OnRenderImage 脚本和屏幕分辨率的高低进行组合，分别导出4个包，运行时通过<code>nvidia-smi.exe</code>获取显存信息，通过UnityProfiler分析内存情况，实验结果如下（使用黄色填充标注发生变化的值）：</p><p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Test_PC.png" alt="Alt text"></p><p>（注：TSMU表示Total System Memory Usage）<br>结论：在屏幕上绘制需要把绘制的信息放在 <strong>TempBuffer</strong> 中，也就是一张RenderTexture当中。这张RT存储在 <strong>显存</strong> 当中，其 <strong>大小可以跟所绘制的分辨率有关</strong> ，分辨率越大，其占用空间越大。</p><p>在PC平台上，不论是否重写<code>OnRenderImage</code>函数，都会在显存当中存在一个TempBuffer，其占用空间不会被Profiler统计到Unity当中。会在Texture当中统计到，也可以在在Detailed当中找到。</p><blockquote><p><strong>官方对Profiler的介绍</strong> ：The values in the Profiler are different to those displayed in your operating system’s task manager, because the Memory Profiler does not track all memory usage in your system. This includes memory some drivers and plug-ins use, and memory used for executable code. On platforms that support getting the total memory size of the application from the operating system, the <strong>Total System Memory Usage</strong> is over 0 and is <strong>the same size in a task manager.</strong></p></blockquote><h3 id="Android平台测试"><a href="#Android平台测试" class="headerlink" title="Android平台测试"></a>Android平台测试</h3><p>在PC平台上的测试已经可以说明TempBuffer的大小与分辨率之间的关系，在Android平台上主要测试OnRenderImage函数与该TempBuffer的存在与否以及与所占据的Android内存之间的关系：</p><p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Android.png" alt="Alt text"></p><p>（注：程序占用的Android总内存通过命令<code>adb shell dumpsys meminfo &lt;PID&gt;</code>得到。）</p><p>结论：通过OnRenderImage函数调用Blit，会在Android设备中产生一张额外的RT（TempBuffer），占用一定的内存，其大小取决于屏幕分辨率。若不调用OnRenderImage函数，就不会生成该RT，不会占据额外内存。</p><blockquote><p>另外，笔者通过另一个实验证明，若只写OnRenderImage函数，函数体为空，不写Blit，也会生成RT：TempBuffer。只是由于RenderTexture destination为空，屏幕显示黑屏。</p><p>OnRenderImage的实现原理可参考：<a href="https://gameinstitute.qq.com/community/detail/112744" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/112744</a></p></blockquote><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/29005381" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29005381</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化知识点链接收藏</title>
      <link href="2023/07/25/Unity3D-%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/"/>
      <url>2023/07/25/Unity3D-%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<p>Mesh压缩：<a href="https://www.cnblogs.com/murongxiaopifu/p/10447076.html" target="_blank" rel="noopener">https://www.cnblogs.com/murongxiaopifu/p/10447076.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于脚本的生命周期、函数的执行顺序</title>
      <link href="2023/07/25/Unity3D-%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>2023/07/25/Unity3D-%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Editor和Engine脚本的执行顺序"><a href="#Editor和Engine脚本的执行顺序" class="headerlink" title="Editor和Engine脚本的执行顺序"></a>Editor和Engine脚本的执行顺序</h2><p>在Editor中，非PlayMode下，编辑器执行函数会在一帧里面跑。<br>进入PlayMode时，会Reload程序集（Assemblies），Reset脚本（Scripts），没有明确的回调函数可以注册，使Editor脚本中函数可以在刚进入PlayMode的时候调用。</p><p>脚本使用<code>[InitializeOnLoad]</code>属性，可以使脚本可以在刚进入PlayMode的时候初始化（调用静态构造函数）。而这个初始化的时机处在开始进入PlayMode和真正开始Play之前，此时</p><ul><li><p>EditorApplication.isPlaying 为 false</p></li><li><p>EditorApplication.isPlayingOrWillChangePlaymode 为 true</p></li><li><p>Unity已经完成了程序集的Reload和脚本的Reset</p></li></ul><p>在此时实例化物体，Unity会报错：Some objects were not cleaned up when closing the scene. (Did you spawn new GameObjects from OnDestroy?)。<br>这个时候实例化的物体加不到Hierarchy当中，但是会加载到内存当中，显示在Scene当中，Unity会判断内存当中有一块儿不属于当前场景的Object。 判断的结果类似于内存泄漏。</p><p>因此，解决方法是，在Static 实例化方法中，使用<code>EditorApplication.update += Update</code>给编辑器程序的Update注册函数，想要执行的逻辑在Update当中执行，也就是在下一帧（完全进入Play Mode）时执行。<br>静态初始化函数调用后到PlayMode第一次Update的时间段中，bu’y’h</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="lang-csharp"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出错汇总</title>
      <link href="2023/07/25/Unity3D-%E5%87%BA%E9%94%99%E6%B1%87%E6%80%BB/"/>
      <url>2023/07/25/Unity3D-%E5%87%BA%E9%94%99%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p><code>csharp //transform.position.x = 1.0;//position 是transform的属性，不是成员变量 var pos = transform.position; pos.x = 1.0f; transform.poition = pos;</code> </p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】RenderTexture及其用途</title>
      <link href="2023/07/25/Unity3D-%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91RenderTexture%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94/"/>
      <url>2023/07/25/Unity3D-%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91RenderTexture%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94/</url>
      
        <content type="html"><![CDATA[<pre><code>* 转自：https://www.jianshu.com/p/fa73c0f6762d</code></pre><h2 id="什么是RenderTexture"><a href="#什么是RenderTexture" class="headerlink" title="什么是RenderTexture?"></a>什么是RenderTexture?</h2><p>RenderTexture是unity定义的一种特殊的Texture类型,它是连接着一个FrameBufferObject的存在于GPU端的Texture(Server-Side Texture),从上面对RenderTexture的解释我们了解到要先知道Texture和FrameBufferObject是什么</p><h2 id="从Texture到FrameBuffer"><a href="#从Texture到FrameBuffer" class="headerlink" title="从Texture到FrameBuffer"></a>从Texture到FrameBuffer</h2><p>纹理是如何被渲染到屏幕上的 ,起初纹理存在硬盘(RAM)里,它被cpu解压缩(数据在cpu端它就只是二进制数据),如果想要显示它,那么数据将会被发送给(上传到,cpu和gpu之间的通信可以理解成client和server之间的通信)GPU,gpu将它放在显存(VARM)中,显存中有一块内存区域叫做RenderBuffer(渲染缓存),RenderBuffer只是数据缓存,它还不能用作Texture渲染,尽管它现在已经是一个texture了,在这里 texture等待着被渲染,当要渲染这个Texture时,会生成一个FrameBuffer(帧缓存),当这个帧缓存被添加到默认的帧缓存物体上(FrameBufferObject)时,它就会被绘制到屏幕上.FrameBuffer指向的是显存中RenderBuffer的地址,简单的来说,RenderBuffer需要附加在FrameBuffer上,它才能是五颜六色的图片,否则它只是显存上的一堆数据,</p><h2 id="FrameBufferObject"><a href="#FrameBufferObject" class="headerlink" title="FrameBufferObject"></a>FrameBufferObject</h2><p>FrameBufferObject是一个集合,集合了FrameBuffer,通过快速刷新Framebuffer实现动态效果,最典型的FBO就是Unity的Main Camera,它是默认的FBO,是gpu里渲染结果的目的地.但是现代gpu通常可以创建很多其他的FBO(Unity中可以创建多个Camera)，这些FBO不连接窗口区域，这种我们创建的FBO的存在目的就是允许我们将渲染结果保存在gpu的一块存储区域，待之后使用,这种用法叫做离屏渲染，这是一个非常有用的东西。Camera 输出的FBO,可以嵌在另一个FBO中,Unity中使用RenderTexture来接收FBO(可视化FBO),Game窗口是一个特殊的RenderTexture,它允许多个FBO叠加渲染,当Camera的RenderTarget都设置为null时表示输出到game窗口(没有摄像机的RenderTaget为null会显示没有摄像机进行渲染),设置不为null表示输出到某个RT.</p><h2 id="如何使用FrameBufferObject"><a href="#如何使用FrameBufferObject" class="headerlink" title="如何使用FrameBufferObject?"></a>如何使用FrameBufferObject?</h2><p>1.将这个FBO上的结果传回CPU这边的贴图，在gles中的实现一般是ReadPixels（）这样的函数，这个函数是将当前设为可读的FBO拷贝到cpu这边的一个存储buffer，没错如果当前设为可读的FBO是那个默认FBO，那这个函数就是在截屏，如果是你自己创建的FBO，那就把刚刚绘制到上面的结果从gpu存储拿回内存。</p><ol><li>将这个FBO上的结果拷贝到一个gpu上的texture，在gles中的实现一般是CopyTexImage2D（），它一般是将可读的FBO的一部分拷贝到存在于gpu上的一个texture对象中，直接考到server-sider就意味着可以马上被gpu渲染使用</li></ol><p>3.将这个fbo直接关联一个gpu上的texture对象，这样就等于在绘制时就直接绘制到这个texure上，这样也省去了拷贝时间，gles中一般是使用FramebufferTexture2D（）这样的接口。</p><h2 id="unity是如何使用FBO的"><a href="#unity是如何使用FBO的" class="headerlink" title="unity是如何使用FBO的?"></a>unity是如何使用FBO的?</h2><p>Unity通过上面说的第三个方法将FBO输出到RenderTexture,在unity里要使用这个FBO,只能基于这个RenderTexture(目前我知道的是这样,可能有我不知道的用法).</p><p>在Unity固定渲染管线中(Unity2019.3以后 自定义渲染管线脱离预览版,新的通用渲染管线Camera设置发生了改变,如果依然使用固定渲染管线则以下通用),通过Camera组件来使用FBO,多摄像机使用下,根据ClearFlags来决定渲染内容:</p><p>需要强调的是Clear操作, 多Camera下,DepthOnly 和Don’t Clear实际上都使Clear操作失效了 ,</p><h2 id="RenderTexture的用途"><a href="#RenderTexture的用途" class="headerlink" title="RenderTexture的用途?"></a>RenderTexture的用途?</h2><p>1.屏幕后处理,3d游戏最基本的后处理是抗锯齿,从Unity的FrameDebugger(可以看到所有FrameBuffer,不管它们属于哪个FBO)中可以看到抗锯齿的操作在OverlayUI之前,所以各位做2d游戏的可以选择把抗锯齿关掉,其他的后处理如bloom,HDR等都是操作屏幕这个默认的RenderTexture,配合上相关效果的Material </p><p>2.在Scene中直接将RT作为Texture传给其他材质球,操作是调用Material.SetTexture 为该RT,即可实现在另一个表面渲染另一个Camera的内容.可以制作后视镜功能</p><p>3.copy回cpu端的内存:基本操作是在当前帧渲染完毕后(协程中, yield return new WaitForEndOfFrame()),设置RenderTexture.active为目标RenderTexture(因为当前帧已渲染过,所以该RenderTexture不会被渲染).Texture.ReadPixels保存到显存.Texture.GetRawTextureData()读回cpu内存,可以保存到硬盘或者通过互联网通信(在unity中实现的截屏,录屏,实时共享屏幕).</p><p>以上2,3都属于离屏渲染的应用.</p><h2 id="转自：https-www-jianshu-com-p-fa73c0f6762d"><a href="#转自：https-www-jianshu-com-p-fa73c0f6762d" class="headerlink" title="转自：https://www.jianshu.com/p/fa73c0f6762d"></a>转自：<a href="https://www.jianshu.com/p/fa73c0f6762d" target="_blank" rel="noopener">https://www.jianshu.com/p/fa73c0f6762d</a></h2>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些属性</title>
      <link href="2023/07/25/Unity3D-%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/"/>
      <url>2023/07/25/Unity3D-%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="InitializeOnLoad"><a href="#InitializeOnLoad" class="headerlink" title="InitializeOnLoad"></a>InitializeOnLoad</h2><p>InitializeOnLoad 属性应用的对象是 <strong>静态构造函数</strong> ，它可以保证在 <strong>编辑器启动</strong> 的时候调用此函数。调用静态构造函数，就会 <strong>重新初始化静态变量</strong> 。</p><p>标注了该属性的类需要 <strong>static constructor</strong> ！</p><pre><code class="lang-csharp">using UnityEngine; using UnityEditor; [InitializeOnLoad] public class Startup { static Startup(){ Debug.Log(&quot;Up and running&quot;); } }</code></pre><p>此外，每次 <strong>重新编译后</strong> ，以及每次 <strong>对Game进行Play时</strong> ，会调用对象的静态构造函数。</p><p>即：对于定义了该属性的静态类，只要编辑器在启动状态，就会立即调用该类的静态构造函数。 若一个类刚刚写好，刚刚编译好，也会立即调用qi</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协</title>
      <link href="2023/07/25/Unity3D-%E4%BB%8EEnumerator%E5%88%B0StartCoroutine%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%8F/"/>
      <url>2023/07/25/Unity3D-%E4%BB%8EEnumerator%E5%88%B0StartCoroutine%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%8F/</url>
      
        <content type="html"><![CDATA[<p>程、异步执行究竟有什么关系？</p><p>程、异步执行究竟有什么关系？</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code class="lang-csharp">yield return &lt;expression&gt;; yield break;</code></pre><p>如果你在语句中使用 yield 上下文关键字，则意味着它在其中出现的方法、运算符或 get 访问器是迭代器，向编译器指示它所在的方法是迭代器块。 </p><p>使用 yield return 语句可一次返回一个元素。可通过使用 foreach 语句或 LINQ 查询来使用从迭代器方法返回的序列。 foreach 循环的每次迭代都会调用迭代器方法。 迭代器方法运行到 yield return 语句时，会返回一个 expression，并保留当前在代码中的位置。 下次调用迭代器函数时，将从该位置重新开始执行。</p><p>在 yield return 语句中，将计算 expression 并将结果以值的形式返回给枚举器对象；expression 必须可以隐式转换为 yield 类型的迭代器。</p><p>可以使用 yield break 语句来终止迭代。</p><p>实现原理 - 编辑器遇到上面的情况会将生成一些类来保存yield return的所有调用都一一做分支处理（状态机分支），下次对IEnumerator.moveNext时会从上次的状态开始（如：迭代到第几个）</p><h2 id="迭代器模式的实现与Enumerator"><a href="#迭代器模式的实现与Enumerator" class="headerlink" title="迭代器模式的实现与Enumerator"></a>迭代器模式的实现与Enumerator</h2><h3 id="foreach的原理"><a href="#foreach的原理" class="headerlink" title="foreach的原理"></a>foreach的原理</h3><p>在 C# 中，foreach 其实是一个语法糖，在编译成 IL 代码时，foreach 会变成基于迭代器 IEnumerator 的调用方式。</p><p>foreach编译成的IL代码如下：</p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615789031828.png" alt="Alt text"></p><p>以下两段代码效果相同：</p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615789060736.png" alt="Alt text"></p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615789081096.png" alt="Alt text"></p><h3 id="迭代器模式的实现"><a href="#迭代器模式的实现" class="headerlink" title="迭代器模式的实现"></a>迭代器模式的实现</h3><p>有许多种方法可以把对象堆起来成为一个集合，你可以把它们放进数组、链表、树、散列表等等不同的数据结构中，每一种对象的组织方式都有它的优点和适合的使用场景。<br>迭代器模式使我们在遍历集合时，不需要清楚集合的内部实现方式。不同集合存储方式的细节不同，但遍历方式的统一的。</p><blockquote><p>设计思想原则：隐藏细节，开放接口</p></blockquote><p>遍历集合时，处理好三件事即可：</p><ul><li><p>能够以某种顺序一个一个访问集合中的元素</p></li><li><p>能够获得当前元素的值</p></li><li><p>能够重新回到集合的开头</p></li></ul><p>为此，IEnumerator接口分别定义了三个方法：MoveNext, get_Current, Reset</p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615789423446.png" alt="Alt text"></p><p>.NET 系统库提供的 List、ArrayList、Dictionary 等集合都实现了 Enumerator。以List为例看看具体的实现：<br><code>List&lt;T&gt;</code>实现了<code>IEnumerable&lt;T&gt;</code>和<code>IEnumerable</code>接口，这两个接口也就定义了<code>GetEnumerator</code>方法：</p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615790017077.png" alt="Alt text"></p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615790081591.png" alt="Alt text"></p><p>而<code>Enumerator</code>是List类中的一个结构体类型，该结构体实现了<code>IEnumerator</code>接口。</p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615790157682.png" alt="Alt text"></p><p>当对<code>List&lt;T&gt;</code>调用GetEnumerator()方法时，返回的的<code>List&lt;T&gt;.Enumerator</code>类的一个对象。</p><blockquote><p>使用迭代器进行遍历时，不能进行Remove和Add操作，因为这两个操作会导致元素整体移动，导致当前Index指向的元素位置偏移，遍历结果错误。</p></blockquote><h3 id="自己实现一个List"><a href="#自己实现一个List" class="headerlink" title="自己实现一个List"></a>自己实现一个List</h3><pre><code class="lang-csharp">using System.Collections; using System; public class MyList&lt;T&gt; : IEnumerable{ private static readonly T[] _emptyArray = new T[0]; private const int _defaultCapacity = 4; private T[] _items; private int _size; private int _version; private Func&lt;T, bool&gt; _filterFunc; public int Count =&gt; _size; IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public MyList(){ this._items = _emptyArray; } /// &lt;param name=&quot;func&quot;&gt;&lt;/param&gt;public MyList(Func&lt;T, bool&gt; func){ this._items = _emptyArray; _filterFunc = func; } public IEnumerator GetEnumerator(){ return new Enumerator(this); } public void Add(T item){ if (this._size == this._items.Length) this.EnsureCapacity(this._size + 1); this._items[this._size++] = item; ++this._version; } /// &lt;summary&gt;/// 扩容机制/// &lt;/summary&gt;/// &lt;param name=&quot;min&quot;&gt;&lt;/param&gt;private void EnsureCapacity(int min){ if (this._items.Length &gt;= min) return; int num = this._items.Length == 0 ? 4 : this._items.Length * 2; if ((uint)num &gt; 2146435071U) num = 2146435071; if (num &lt; min) num = min; this.Capacity = num; } public int Capacity { get =&gt; this._items.Length; set //有点子监听的感觉{ if (value == this._items.Length) return; if (value &gt; 0) { T[] objArray = new T[value]; if (this._size &gt; 0) //扩容真正实现在这里Array.Copy((Array)this._items, 0, (Array)objArray, 0, this._size); this._items = objArray; } elsethis._items = _emptyArray; } } /// &lt;summary&gt;/// 迭代器定义/// &lt;/summary&gt;public struct Enumerator : IEnumerator { private MyList&lt;T&gt; _list; private int _index; private int _version; private T current; internal Enumerator(MyList&lt;T&gt; list){ this._list = list; this._index = 0; this._version = list._version; this.current = default(T); } public bool MoveNext(){ if (this._version != _list._version || (uint)this._index &gt;= (uint)_list._size) return this.MoveNextRare(); this.current = _list._items[this._index]; ++this._index; //当不满足过滤条件时，foreach遍历Current返回为空if (_list._filterFunc != null &amp;&amp; !_list._filterFunc(this.current)) this.current = default(T); return true; } private bool MoveNextRare(){ this._index = this._list._size + 1; this.current = default(T); return false; } public object Current =&gt; this.current; public void Reset(){ _index = 0; current = default(T); } } }</code></pre><h2 id="Enumerator与yield-return"><a href="#Enumerator与yield-return" class="headerlink" title="Enumerator与yield return"></a>Enumerator与yield return</h2><p>You use a yield return statement to <strong>return each element one at a time</strong>.</p><p>When a yield return statement is reached in the iterator method, <strong>expression is returned</strong> , and <strong>the current location in code is retained</strong>. Execution is restarted <strong>from that location the next time</strong> that the iterator function is called.</p><pre><code class="lang-csharp">public static void TestGetVs(){ IEnumerator&lt;int&gt; enumerator = GetVs(); while(enumerator.MoveNext()) { int current = enumerator.Current; Debug.Log(current); } } public static IEnumerator&lt;int&gt; GetVs(){ //for (int i = 0; i &lt; 3; i++)//{// yield return i;//}yield return 3; yield return 4; yield return 5; }</code></pre><p>底层原理：<br>如果写了一个函数，返回值类型为IEnumerator，方法体中有yield return，那么编译器会为这个方法自动定义一个类型，这个类型实现IEnumerator接口。</p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615794880255.png" alt="Alt text"></p><p>这个类型有两个字段：</p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615794868354.png" alt="Alt text"></p><p>state保存当前执行到的位置，current为当前的返回值。</p><p>使用foreach对这个方法的返回值进行遍历，实质上就是对这个迭代器进行遍历。每次调用MoveNext()，从state指向的位置开始执行，直到遇到下一个yield return，将返回的结果存到current当中，保存当前位置到state中。MoveNext函数的IL语言形式如下：</p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615795022810.png" alt="Alt text"></p><p>总结：使用IEnumerator与yield return的方式，可以实现有多个返回值的方法，对多个返回值进行遍历，每访问一个值，执行一段代码，不需要先计算出所有的值，再进行遍历。其本质是把函数(例子当中为GetVs)的代码放到Enumerator类型的MoveNext当中，用state进行控制，每调用一次，执行不同的段落。</p><h2 id="Unity3D协程"><a href="#Unity3D协程" class="headerlink" title="Unity3D协程"></a>Unity3D协程</h2><p>Ref: <a href="https://www.cnblogs.com/Roz-001/p/11205700.html" target="_blank" rel="noopener">https://www.cnblogs.com/Roz-001/p/11205700.html</a></p><p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615796287192.png" alt="Alt text"></p><p>以上代码，实质上是调用Test2Sceonds方法，返回一个Enumerator对象，然后传递给StartCoroutine方法。</p><p>StartCoroutine是在Native层实现的。从行为上来看，当StartCoroutine后，Unity会每一帧执行一次MoveNext。</p><p>如果yield return 返回的对象为WaitForSecond等，Unity会据此判断下一次调用MoveNext是什么时候。如以上代码，Unity会在2秒后，再次调用MoveNext。</p><h3 id="本质是什么"><a href="#本质是什么" class="headerlink" title="本质是什么"></a>本质是什么</h3><p>协程是一种异步执行代码的方式，是一种假的多线程。本质上，是 <strong>将一件任务，分到多个帧中去执行</strong> 。</p><p>多线程（并发）与迭代器、枚举器、容器是毫不相干的两个概念，Unity为什么就把这两个概念联系到一起了呢？为什么实现协程要用到枚举类型？这种实现方案，本质上是用了Enumerator的什么特性呢？这是笔者一直困惑的。</p><p>如果一个技术A，要用到技术B，那么A的需求，一定与B的特性是有共同点的，否则A不会用到B。那么我们从这个角度去思考上述问题。</p><ul><li><p>协程，本质是异步执行，把一个任务（一段代码），分多帧去执行。</p></li><li><p>.NET当中的Enumerator与yield return的机制，恰好本质上是把一段代码拆分为多个段落（部分），每次调用MoveNext，执行一段逻辑，获取一个返回值。</p></li></ul><p>那么，两个技术自然就关联到了一起——Unity对Enumerator的MoveNext进行调用，就实现了将一个任务分多次去执行的需求。每一帧调用一次MoveNext，就实现了每一帧执行一部分任务。而Native层还对yield return返回的类型进行了判断，根据返回类型的不同 ，控制下一次调用MoveNext的时机，例如，如果返回值是new WaitForSeconds(2)，那么Unity会在2秒后调用下一个MoveNext，并获取返回值。如果返回值是UnityWebRequest.SendWebRequest，那么Unity会在相应的请求执行完后，继续执行后面的部分。</p><h3 id="yield-return-的一些特殊含义"><a href="#yield-return-的一些特殊含义" class="headerlink" title="yield return 的一些特殊含义"></a>yield return 的一些特殊含义</h3><pre><code class="lang-csharp">//程序在下一帧中从当前位置继续执行yield return 0; //程序在下一帧中从当前位置继续执行yield return null; //程序等待N秒后从当前位置继续执行yield return new WaitForSeconds(N); //在所有的渲染以及GUI程序执行完成后从当前位置继续执行yield new WaitForEndOfFrame(); //所有脚本中的FixedUpdate()函数都被执行后从当前位置继续执行yield new WaitForFixedUpdate(); //等待一个网络请求完成后从当前位置继续执行yield return WWW; //等待一个xxx的协程执行完成后从当前位置继续执行yield return StartCoroutine(xxx); //如果使用yield break语句，将会导致协程的执行条件不被满足，不会从当前的位置继续执行程序，而是直接从当前位置跳出函数体，回到函数的根部yield break; yield return IEnumerator自己定义实现类，等待到自定义的时间或事件结束。</code></pre><h3 id="一些Demo"><a href="#一些Demo" class="headerlink" title="一些Demo"></a>一些Demo</h3><pre><code class="lang-csharp">//下面定义了一个协程函数，注意必须使用IEnumerator作为返还值才能成为协程函数。 IEnumerator Test() { for(int i = 0; i&lt;1000 ; ++i) { ans += i; yield return 0;//挂起，下一帧再来从这个位置继续执行。 } j+=2; yield return 0;//挂起，下一帧再来从这个位置继续执行。 ++j; yield return 0;//挂起，下一帧再来从这个位置继续执行。}</code></pre><p>Demo1:</p><pre><code class="lang-csharp">//3s后执行Debug.LogIEnumerator Test(){ for(float timer = 0.0f; timer &lt; 3.0f ; timer += Time.DeltaTime){ yield return 0;//挂起，下一帧再来从这个位置继续执行。} Debug.Log(&quot;启动协程3s后&quot;); }</code></pre><p>Demo2:</p><pre><code class="lang-csharp">IEnumerator TestWaitForSeconds(){ //3s后执行Debug.Log;yield return new WaitForSeconds(3.0f); Debug.Log(&quot;启动协程3s后&quot;); }</code></pre><h3 id="AssetBundle异步加载"><a href="#AssetBundle异步加载" class="headerlink" title="AssetBundle异步加载"></a>AssetBundle异步加载</h3><pre><code class="lang-csharp">/// &lt;summary&gt;/// 从文件进行异步加载/// &lt;/summary&gt;/// &lt;param name=&quot;abFullPath&quot;&gt;ab包的绝对路径&lt;/param&gt;/// &lt;param name=&quot;finishCallBack&quot;&gt;完成加载回调，返回加载的AssetBundle&lt;/param&gt;/// &lt;param name=&quot;updateCallBack&quot;&gt;加载过程中的更新回调，返回加载进度&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;IEnumerator LoadABFileAsync(string abFullPath,Action&lt;AssetBundle&gt; finishCallBack, Action&lt;float&gt; updateCallBack=null){ AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(abFullPath); while (!request.isDone) { if(updateCallBack != null) { updateCallBack(request.progress); } yield return null; } yield return request; if(finishCallBack!=null) finishCallBack(request.assetBundle); } private void Start(){ assetPath = Application.dataPath + &quot;/../MyAssetBundles/&quot;; StartCoroutine(LoadABFileAsync(assetPath + assetBundleName, OnFinish, OnUpdate)); } private void OnUpdate(float obj){ Debug.Log(obj); } private void OnFinish(AssetBundle obj){ Instantiate(obj.LoadAsset(loadPrefabName)); obj.Unload(false); }</code></pre><h3 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h3><pre><code class="lang-csharp">using UnityEngine; using UnityEngine.Networking; using System.Collections; public class TestWebRequest : MonoBehaviour { void Start() { StartCoroutine(GetText()); } IEnumerator GetText() { UnityWebRequest www = new UnityWebRequest(&quot;http://www.my-server.com&quot;); www.downloadHandler = new DownloadHandlerBuffer(); yield return www.SendWebRequest(); if (www.result != UnityWebRequest.Result.Success) { Debug.Log(www.error); } else { // Show results as textDebug.Log(www.downloadHandler.text); // Or retrieve results as binary databyte[] results = www.downloadHandler.data; } } }</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/yield" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/yield</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【资源】Asset Bundle(2020-10-25 022900)</title>
      <link href="2023/07/25/Unity3D-%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91Asset-Bundle-2020-10-25-022900/"/>
      <url>2023/07/25/Unity3D-%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91Asset-Bundle-2020-10-25-022900/</url>
      
        <content type="html"><![CDATA[<h1 id="【资源】Asset-Bundle-2020-10-25-02-29-00"><a href="#【资源】Asset-Bundle-2020-10-25-02-29-00" class="headerlink" title="【资源】Asset Bundle(2020-10-25 02:29:00)"></a>【资源】Asset Bundle(2020-10-25 02:29:00)</h1><h1 id="【资源】Asset-Bundle-2020-10-25-02-29-00-1"><a href="#【资源】Asset-Bundle-2020-10-25-02-29-00-1" class="headerlink" title="【资源】Asset Bundle(2020-10-25 02:29:00)"></a>【资源】Asset Bundle(2020-10-25 02:29:00)</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="资源加载的方式"><a href="#资源加载的方式" class="headerlink" title="资源加载的方式"></a>资源加载的方式</h3><p>Resources加载 - Resources.Load()来直接加载Resources文件夹下的资源</p><p>AssetBundle</p><p>Addressable</p><h4 id="Resources加载的缺点"><a href="#Resources加载的缺点" class="headerlink" title="Resources加载的缺点"></a>Resources加载的缺点</h4><ul><li><p>对内存管理造成一定的负担。</p></li><li><p>在打开应用时加载时间很长。</p></li><li><p>Resources文件夹下的所有资源统一合并到一个序列化文件中（可以看成统一打一个大包，巨型AB包有什么问题它就有什么问题），对资源优化有一定的限制。</p></li><li><p>不建议大量使用Resources。</p></li></ul><h3 id="AssetBundle是什么"><a href="#AssetBundle是什么" class="headerlink" title="AssetBundle是什么"></a>AssetBundle是什么</h3><h4 id="从资源的角度"><a href="#从资源的角度" class="headerlink" title="从资源的角度"></a>从资源的角度</h4><p>它是一个 <strong>存在于硬盘上的文件</strong> 。可以称之为 <strong>压缩包</strong> 。这个压缩包可以认为是一个文件夹，里面包含了多个文件。这些文件可以分为两类：serialized file 和 resource files。（序列化文件和源文件）</p><ul><li><p>serialized files：资源被打碎放在一个对象中，最后统一被写进一个单独的文件（只有一个）。相当于是一个头文件，里面记录了关于这个AB的相关信息，当我们调用 <strong>LoadFromFile</strong> 接口加载AB的时候实际上就是去加载的这一部分信息。这部分信息在Profiler里面的SerilizeField选项里。</p></li><li><p>resource files（Bundle Content ）：某些二进制资源（图片、声音）被单独保存，方便快速加载</p></li></ul><h4 id="从API的角度"><a href="#从API的角度" class="headerlink" title="从API的角度"></a>从API的角度</h4><p>它是一个AssetBundle对象，我们可以通过代码从一个特定的压缩包加载出来的对象。这个对象包含了所有我们当初添加到这个压缩包里面的内容，我们可以通过这个对象加载出来使用。</p><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ol><li><p>AssetBundle是一个压缩包包含模型、贴图、预制体、声音、甚至整个场景，可以在游戏运行的时候被加载；</p></li><li><p>AssetBundle自身保存着互相的依赖关系；</p></li><li><p>压缩包可以使用LZMA和LZ4压缩算法，减少包大小，更快的进行网络传输；</p></li><li><p>把一些可以下载内容放在AssetBundle里面，可以减少安装包的大小；</p></li></ol><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1616396262550.png)</p><h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><p>AB包数量较多，包内资源较少 - 加载一个AB包到内存的时间短，玩家不会有卡顿感，但每个资源实际上加载时间变长。热更新灵活，要更新下载的包体较小。IO次数过多，增大了硬件设备耗能和发热压力。</p><p>AB包数量较少，包内资源较多 - 加载一个AB包到内存的时间较长，玩家会有卡顿感，但之后包内的每个资源加载很快。热更新不灵活，要更新下载的包体较大。IO次数不多，硬件压力小。</p><h3 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h3><ol><li><p>把经常更新的资源放在一个单独的包里面，跟不经常更新的包分离</p></li><li><p>把需要同时加载的资源放在一个包里面</p></li><li><p>可以把其他包共享的资源放在一个单独的包里面</p></li><li><p>把一些需要同时加载的小资源打包成一个包</p></li><li><p>如果对于一个同一个资源有两个版本，可以考虑通过后缀来区分 v1 v2 v3 unity3dv1 unity3dv2</p></li></ol><h4 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h4><p>a. 一个UI界面或者所有UI界面一个包（这个界面里面的贴图和布局信息一个包）<br>b. 一个角色或者所有角色一个包（这个角色里面的模型和动画一个包）<br>c. 所有的场景所共享的部分一个包（包括贴图和模型）</p><h4 id="按照类型分组"><a href="#按照类型分组" class="headerlink" title="按照类型分组"></a>按照类型分组</h4><p>所有 <strong>声音</strong> 资源打成一个包，所有 <strong>shader</strong> 打成一个包，所有 <strong>模型</strong> 打成一个包，所有材质打成一个包</p><h4 id="按照使用分组"><a href="#按照使用分组" class="headerlink" title="按照使用分组"></a>按照使用分组</h4><p>把在某一时间内使用的所有资源打成一个包。可以按照关卡分，一个关卡所需要的所有资源包括角色、贴图、声音等打成一个包。也可以按照场景分，一个场景所需要的资源一个包</p><h3 id="依赖打包"><a href="#依赖打包" class="headerlink" title="依赖打包"></a>依赖打包</h3><p>(Mat + Cube1) (Mat + Cube2)<br>(Mat) (Cube1) (Cube2)<br>Unity会自动识别，共享的依赖如果已经单独打包，则不会重复打包</p><h3 id="关于压缩"><a href="#关于压缩" class="headerlink" title="关于压缩"></a>关于压缩</h3><ul><li><p>加载时间：当从本地存储或本地缓存加载时，未压缩的AssetBundles加载速度比压缩的AssetBundles快得多。</p></li><li><p>构建时间：在压缩文件时，LZMA和LZ 4非常慢，统一编辑器依次处理AssetBundles。拥有大量资产Bundles的项目将花费大量的时间压缩它们。</p></li><li><p>应用程序大小：如果AssetBundles是在应用程序中提供的，那么压缩它们将减少应用程序的总大小。或者，AssetBundles可以在安装后下载。</p></li><li><p>内存使用：在Unity 5.3之前，Unity的所有解压缩机制都要求在解压缩之前将整个压缩的AssetBundles加载到内存中。如果内存使用很重要，请使用未压缩或LZ 4压缩AssetBundles。</p></li></ul><h4 id="LZMA和LZ4"><a href="#LZMA和LZ4" class="headerlink" title="LZMA和LZ4"></a>LZMA和LZ4</h4><p>LZMA是流压缩方式（stream-based）。流压缩再处理整个数据块时使用同一个字典，它提供了最大可能的压缩率，但是只支持顺序读取。所以加载AB包时，需要将整个包解压之后才能加载包内资源，会造成卡顿和额外内存占用。</p><p>LZ4是块压缩方式（chunk-based）。块压缩的数据被分为大小相同的块，并被分别压缩。不需要完整解压就可以加载包内资源。如果需要实时解压随机读取，块压缩是比较好的选择。<br>使用LZ4压缩，可以获得可以跟不压缩想媲美的加载速度，而且比不压缩文件要小。</p><p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1616396217868.png)</p><h4 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h4><blockquote><p>BuildAssetBundles底层会对传入的BuildAssetBundleOptions值进行处理，根据二进制位数来判断使用哪种策略构建AB包。因此如果在构建AB包时想要使用多种策略，用&amp;连接即可。</p></blockquote><p>BuildAssetBundleOptions.None：使用LZMA算法压缩，压缩的包更小，但是加载时间更长。使用之前需要整体解压。一旦被解压，这个包会使用LZ4重新压缩。。这就是为什么第一次加载时间长，之后加载时间就没那么长了。在下载的时候可以使用LZMA算法，一旦它被下载了之后，它会使用LZ4算法保存到本地上。</p><p>BuildAssetBundleOptions.UncompressedAssetBundle：不压缩，包大，加载快</p><p>DisableWriteTypeTree - 8：不包含TypeTree信息。虽然可以使得AB包更小，但是对低版本不兼容。不建议使用。</p><p>DeterministicAssetBundle - 16：创建一个哈希来映射存储在AB包里的对象的id。</p><p>ForceRebuildAssetBundle - 32：强制重建AB包。</p><p>IgnoreTypeTreeChanges - 64：当做增量构建检测时，忽略type tree的变化。</p><p>AppendHashToAssetBundleName - 128：添加哈希到AB包名。</p><p>ChunkBasedCompression - 256：使用LZ4压缩，压缩率没有LZMA高，但是我们可以加载指定资源而不用解压全部。</p><p>StrictMode - 512：如果在构建时有任何错误，则不允许构建成功。</p><p>DryRunBuild - 1024：干构建。</p><p>DisableLoadAssetByFileName - 4069：禁止AB包通过文件名加载资源。</p><p>DisableLoadAssetByFileNameWithExtension - 8192：禁止AB包通过文件扩展名加载资源。</p><p>AssetBundleStripUnityVersion：构建时从压缩文件和序列化文件的header中移除Unity版本号。</p><h3 id="assetBundleVariant-及自动标记打包API"><a href="#assetBundleVariant-及自动标记打包API" class="headerlink" title="assetBundleVariant 及自动标记打包API"></a>assetBundleVariant 及自动标记打包API</h3><p><strong>different AssetBundle variants will have the same internal IDs</strong> 。因此，AssetBundle的后缀名不仅仅是名称那么简单。而加载使用时，就看作不同名称的AB即可。</p><blockquote><p>注意：assetBundleName中设置后缀名 “Cube.ab”，并不能启到AssetBundle Variant的作用。后缀名应该在AssetImporter.assetBundleVariant中设置。</p></blockquote><p>variant 的用处：</p><ul><li><p>好一点设备上可以加载高模，而差一点的设备中只能加载低模</p></li><li><p>做分包，不同版本包</p></li><li><p>做多语言包</p></li></ul><p>手动设置name &amp; variant name:</p><p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1621089585094.png)</p><p>代码自动设置：</p><pre><code class="lang-csharp"># region 自动做标记[MenuItem(&quot;AssetBundle/Set AssetBundle Lables&quot; ,false , 100)] public static void SetAssetBundleLables(){ //移除掉所有没有使用的标记AssetDatabase.RemoveUnusedAssetBundleNames(); string assetDirectory = &quot;Assets/Res&quot;; DirectoryInfo directoryInfo = new DirectoryInfo(assetDirectory); DirectoryInfo[] scenesDirectories = directoryInfo.GetDirectories(); foreach (var tempDir in scenesDirectories) { string sceneDirectory = assetDirectory + &quot;/&quot; \+ tempDir.Name; DirectoryInfo sceneDirectoryInfo = new DirectoryInfo(sceneDirectory); if (sceneDirectoryInfo == null) { Debug.Log(sceneDirectoryInfo + &quot;不存在&quot;); return; } else{ Dictionary&lt;string , string&gt; namePathDictionary = new Dictionary&lt;string, string&gt;(); int index = sceneDirectory.LastIndexOf(&quot;/&quot;); string sceneName = sceneDirectory.Substring(index + 1); OnSceneFileSystemInfo(sceneDirectoryInfo , sceneName , namePathDictionary); OnWriteConfig(sceneName , namePathDictionary); } } AssetDatabase.Refresh(); Debug.Log(&quot;设置标记成功...&quot;); } /// &lt;summary&gt;/// 记录配置文件/// &lt;/summary&gt;/// &lt;param name=&quot;sceneDirectory&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;namePathDictionary&quot;&gt;&lt;/param&gt;private static void OnWriteConfig(string sceneName , Dictionary&lt;string , string&gt; namePathDictionary){ string path = Application.dataPath + &quot;/AssetBundles/&quot; \+ sceneName ; if (!Directory.Exists(path)) Directory.CreateDirectory(path); Debug.Log(path); using (FileStream fs = new FileStream(path + &quot;/Record.txt&quot;, FileMode.OpenOrCreate , FileAccess.Write)) { using (StreamWriter sw = new StreamWriter(fs)) { sw.WriteLine(namePathDictionary.Count); foreach (KeyValuePair&lt;string , string&gt; kv in namePathDictionary) { Debug.Log(kv.Value); sw.WriteLine(kv.Key+&quot;/&quot;+kv.Value); } } } } private static void OnSceneFileSystemInfo(FileSystemInfo fileSystemInfo , string sceneNama , Dictionary&lt;string, string&gt; namePathDictionary){ if (!fileSystemInfo.Exists) { Debug.Log(fileSystemInfo + &quot;不存在&quot;); return; } DirectoryInfo directoryInfo = fileSystemInfo as DirectoryInfo; FileSystemInfo[] fileSystemInfos = directoryInfo.GetFileSystemInfos(); foreach (var systemInfo in fileSystemInfos) { FileInfo fileInfo = systemInfo as FileInfo; if (fileInfo == null) { OnSceneFileSystemInfo(systemInfo, sceneNama , namePathDictionary); } else{ SetLables(fileInfo, sceneNama , namePathDictionary); } } } /// &lt;summary&gt;/// 修改资源 assetbundle lables/// &lt;/summary&gt;private static void SetLables(FileInfo fileInfo , string sceneName , Dictionary&lt;string, string&gt; namePathDictionary){ if(fileInfo.Extension == &quot;.meta&quot;)return; string bundleName = GetBundleName(fileInfo , sceneName); int index = fileInfo.FullName.IndexOf(&quot;Assets&quot;); string assetPath = fileInfo.FullName.Substring(index); AssetImporter assetImporter = AssetImporter.GetAtPath(assetPath); assetImporter.assetBundleName = bundleName; if (fileInfo.Extension == &quot;.unity&quot;) assetImporter.assetBundleVariant = &quot;u3d&quot;; elseassetImporter.assetBundleVariant = &quot;assetbundle&quot;; string folderName; if (bundleName.Contains(&quot;/&quot;)) folderName = bundleName.Split(&#39;/&#39;)[1]; elsefolderName = bundleName; string bundlePath = assetImporter.assetBundleName + &quot;.&quot; \+ assetImporter.assetBundleVariant; if (!namePathDictionary.ContainsKey(folderName)) namePathDictionary.Add(folderName, bundlePath); } private static string GetBundleName(FileInfo fileInfo, string sceneName){ string path = fileInfo.FullName; int index = path.IndexOf(sceneName) + sceneName.Length; string bundlePath = path.Substring(index + 1); bundlePath = bundlePath.Replace(@&quot;\&quot;, &quot;/&quot;); if (bundlePath.Contains(&quot;/&quot;)) { string[] tmp = bundlePath.Split(&#39;/&#39;); return sceneName + &quot;/&quot; \+ tmp[0]; } return sceneName; } #endregion</code></pre><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载流程可归为两步：</p><ol><li><p>从目标路径读取并创建 AssetBundle 对象</p></li><li><p>从 AssetBundle 对象中创建 Asset</p></li></ol><h3 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h3><h4 id="LoadFromFile"><a href="#LoadFromFile" class="headerlink" title="LoadFromFile"></a>LoadFromFile</h4><p>从磁盘路径读取 AssetBundle 文件，如果文件内容是以 LZMA 格式压缩的，则会将内容解压进内存保存。未压缩(uncompressed) 和块压缩(chunk-compressed) 的部分将会通过 IO 从磁盘读取。</p><p>如果AB包是LZ4加载方式，它只会加载AB包的Header，之后需要什么资源再加载那部分的AB包chunk。极大的减少了内存占用。</p><blockquote><p>但在Editor环境下，API还是会把整个AssetBundle加载到内存中，不应影响实际运行的设备上的性能。</p></blockquote><pre><code class="lang-csharp">public class LoadFromFileExample : MonoBehaviour { function Start() { var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;)); if (myLoadedAssetBundle == null) { Debug.Log(&quot;Failed to load AssetBundle!&quot;); return; } var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;); Instantiate(prefab); } }</code></pre><h4 id="LoadFromMemory"><a href="#LoadFromMemory" class="headerlink" title="LoadFromMemory"></a>LoadFromMemory</h4><p>从托管代码的字节数组（C#中的byte[]）中加载AssetBundle。要提前用其它的方式将资源的二进制数组加入到内存中。然后该接口会将源数据从托管代码字节数组复制到新分配的、连续的本机内存块中。</p><p>如果AssetBundle使用了LZMA压缩，在复制过程中AssetBundle会被解压；如果使用了LZ4压缩或者没有压缩，AssetBundle会被逐字复制（be copied verbatim）。</p><p>当资源有加密需求时，可先把AB读取到内存当中，进行解密后再调用该AssetBundle.LoadFromMemory 进行加载。</p><p>此API消耗的最大内存量将至少是AssetBundle的两倍：本机内存中的一个副本，和LoadFromMemory(Async)从托管字节数组中复制的一个副本。</p><p>因此，从通过此API创建的AssetBundle加载的资产将在内存中一次在托管代码字节数组中，一次在AssetBundle的栈内存副本中，第三次在GPU或系统内存中，用于Asset本身。</p><p>适用于需要对原始数据进行解密的方式。</p><blockquote><p><strong>若把Start()函数声明成返回IEnumrator，编译器会自动将Start的调用处理成协程的模式</strong></p></blockquote><pre><code class="lang-csharp">using UnityEngine; using System.Collections; using System.IO; public class Example : MonoBehaviour{ IEnumerator LoadFromMemoryAsync(string path){ AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path)); yield return createRequest; AssetBundle bundle = createRequest.assetBundle; var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;); Instantiate(prefab); } }</code></pre><h4 id="LoadFromStream"><a href="#LoadFromStream" class="headerlink" title="LoadFromStream"></a>LoadFromStream</h4><p>AssetBundle.LoadFromStream可进行流式加载，不需要将AB全部读到内存中再解密、加载，而是可以通过每次像Buffer中读一部分，解密一部分的方式进行加载，不会多占用一份很大的内存。如果使用该接口，需要自定义一个继承FileStream类，然在Read和Write方法内对byte数组进行异或加密解密处理。</p><blockquote><p>与 LoadFromFile 类似， LZMA 格式压缩的会被解压进内存，未压缩(uncompressed) 和块压缩(chunk-compressed) 的部分将会直接通过 Stream 来读取。</p><p>在加载AssetBundle或捆绑包中的任何资产时，请勿释放Stream对象。它的寿命应该比AssetBundle长。这意味着在调用AssetBundle.Unload之后处理Stream对象。</p></blockquote><p><a href="https://www.xuanyusong.com/archives/4607" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4607</a></p><h3 id="WWW-LoadFromCacheOrDownload（Obsolete）"><a href="#WWW-LoadFromCacheOrDownload（Obsolete）" class="headerlink" title="WWW.LoadFromCacheOrDownload（Obsolete）"></a>WWW.LoadFromCacheOrDownload（Obsolete）</h3><p>Loading an AB from a remote location will automatically <strong>cache</strong> the AssetBundles. If the AssetBundle is compressed, a worker thread will spin up to decompress the bundle and write it to the cache. <strong>Once a bundle has been decompressed and cached, it will load exactly like AssetBundle.LoadFromFile .</strong></p><pre><code class="lang-csharp">using UnityEngine; using System.Collections; public class LoadFromCacheOrDownloadExample : MonoBehaviour{ IEnumerator Start (){ while (!Caching.ready) yield return null; var www = WWW.LoadFromCacheOrDownload(&quot;http://myserver.com/myassetBundle&quot;, 5); yield return www; if(!string.IsNullOrEmpty(www.error)) { Debug.Log(www.error); yield return; } var myLoadedAssetBundle = www.assetBundle; var asset = myLoadedAssetBundle.mainAsset; } }</code></pre><h3 id="UnityWebRequest-AssetBundleDownloadHandler"><a href="#UnityWebRequest-AssetBundleDownloadHandler" class="headerlink" title="UnityWebRequest - AssetBundleDownloadHandler"></a>UnityWebRequest - AssetBundleDownloadHandler</h3><p>它使用工作线程，将下载的数据流存储到一个固定大小的缓冲区中，然后根据下载处理程序的配置方式将缓冲数据放到临时存储或AssetBundle缓存中。</p><p>它使用工作线程，将下载的数据流存储到一个固定大小的缓冲区中，然后根据下载处理程序的配置方式将缓冲数据放到临时存储或AssetBundle缓存中。</p><p>所有这些操作都发生在非托管代码中，消除了增加堆内存的风险。此外，该下载处理程序并不会保留所有下载字节的栈内存副本，从而进一步减少了下载AssetBundle的内存开销。</p><p>如果将缓存信息提供给UnityWebRequest对象，一旦有请求的AssetBundle已经存在于Unity的缓存中，那么AssetBundle将立即可用，并且此API的行为将会与AssetBundle.LoadFromFile相同操作。</p><blockquote><p>从服务器下载</p><ol><li>NetBox可以在本地启动服务器，把当前目录作为服务器端的网站</li></ol></blockquote><pre><code class="lang-csharp">IEnumerator InstantiateObject(){ string uri = &quot;file:///&quot; \+ Application.dataPath + &quot;/AssetBundles/&quot; \+ assetBundleName; UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0); yield return request.Send(); AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request); GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;); Instantiate(cube); Instantiate(sprite); }</code></pre><h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><ol><li><p>一般来说，只要有可能，就应该使用AssetBundle.LoadFromFile。这个API在速度、磁盘使用和运行时内存使用方面是最有效的。</p></li><li><p>对于必须下载或热更新AssetBundles的项目，强烈建议使用UnityWebRequest。</p></li><li><p>当使用UnityWebRequest时，要确保下载程序代码在加载AssetBundle后正确地调用Dispose。另外，C#的using语句是确保UnityWebRequest被安全处理的最方便的方法。</p></li><li><p>对于需要独特的、特定的缓存或下载需求的大项目，可以考虑使用自定义的下载器。编写自定义下载程序是一项重要并且复杂的任务，任何自定义的下载程序都应该与AssetBundle.LoadFromFile保持兼容。</p></li><li><p>在多数情况下，最好在玩家进入应用程序的性能关键区域（如主游戏关卡或世界）之前加载尽可能多的所需对象。这在移动平台上尤为重要，因为在移动平台上，访问本地存储的速度很慢，并且在运行时加载和卸载对象会触发垃圾回收。</p></li></ol><h3 id="同步和异步的优缺点"><a href="#同步和异步的优缺点" class="headerlink" title="同步和异步的优缺点"></a>同步和异步的优缺点</h3><p>Ref: <a href="https://blog.csdn.net/qq_40093529/article/details/85290686" target="_blank" rel="noopener">https://blog.csdn.net/qq_40093529/article/details/85290686</a><br><strong>异步</strong><br>优点：速度快，与主线程无关，<br>缺点：调用比较麻烦，因为你不知道啥时候你的资源准备好了，最好的做法也是使用回调，这样回调就会很多，很乱个人感觉管理起来很不舒服。</p><p><strong>同步</strong><br>优点：管理起来方便，而且资源准备好了是可以及时返回的，<br>缺点：是没有异步快<br>综合上诉，最终我选择了 同步，因为我不希望代码不整洁，也不希望写太多的回调函数来通知调用者，资源准备妥当了。那么问题来了，如何解决同步的缺点呢。也就是卡主线程。之前一直以为corotine这玩意可以帮到我们。但是当我深入理解了coroutine以后发现他其实也是在主线程中的。最终我选择了使用c# 的多线程机制来解决这个问题。</p><h3 id="Manifests的加载"><a href="#Manifests的加载" class="headerlink" title="Manifests的加载"></a>Manifests的加载</h3><p>加载Manifests文件可以处理资源的依赖</p><pre><code class="lang-csharp">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath); AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;); string[] dependencies = manifest.GetAllDependencies(&quot;assetBundle&quot;); //Pass the name of the bundle you want the dependencies for.foreach(string dependency in dependencies) { AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency)); }</code></pre><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>卸载有两个方面</p><ol><li><p>减少内存使用</p></li><li><p>有可能导致丢失<br>所以什么时候去卸载资源是我们要关注的</p></li></ol><h3 id="AssetBundle-Unload-true"><a href="#AssetBundle-Unload-true" class="headerlink" title="AssetBundle.Unload(true)"></a>AssetBundle.Unload(true)</h3><p>不仅Object被销毁，而且Instance ID的GUID和Local ID引用变无效。<br>When unloadAllLoadedObjects is true, all objects that were loaded from this bundle will be destroyed as well. If there are GameObjects in your Scene referencing those assets, the references to them will become missing.</p><p>卸载所有资源，即使有资源被使用着<br>1. 在关卡切换、场景切换<br>2. 资源没被用的时候调用</p><h3 id="AssetBundle-Unload-false"><a href="#AssetBundle-Unload-false" class="headerlink" title="AssetBundle.Unload(false)"></a>AssetBundle.Unload(false)</h3><p>虽Object不被销毁，但Instance ID的GUID和Local ID引用变无效。场景中的物体会与该AB包分离链接。即该物体的instance ID引用的GUID和Local ID会断开引用，无法再通过该instance ID找到GUID和Local ID。<br>如果再次加载该AB包时，分离了链接的物体不会受该新加载的AB包管理。因此如果不注意的话可能会导致一些不可控的问题。Unity中有Resources.UnloadUnusedAssets()方法可以很好地解决这个问题。</p><p>When unloadAllLoadedObjects is false, compressed file data inside the bundle itself will be freed, but any instances of objects loaded from this bundle will remain intact.</p><p>If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways:</p><ol><li><p>先去除对不想要的Objects的引用（包括场景和代码当中），然后调用 Resources.UnloadUnusedAssets. </p></li><li><p>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.</p></li></ol><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>大多数项目应该使用AssetBundle.Unload(True)，并采用一种方法来确保对象不被复制。<br>两种常见的方法是：<br>（1）在应用程序的生命周期内定义一个合适的节点，并在此期间卸载不需要的AssetBundle，例如在关卡切换或加载屏幕期间。这是最简单和最常见的选择。<br>（2）维护单个对象的引用计数，并仅当所有组成对象都未使用时才卸载AssetBundles。这允许应用程序在不重复内存的情况下卸载和重新加载单个对象。</p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="AssetDatabase"><a href="#AssetDatabase" class="headerlink" title="AssetDatabase"></a>AssetDatabase</h3><pre><code class="lang-csharp">var names = AssetDatabase.GetAllAssetBundleNames(); foreach (var name in names) Debug.Log(&quot;AssetBundle: &quot; \+ name);</code></pre><ul><li><p>AssetDatabase.GetAllAssetBundleNames() </p></li><li><p>AssetDatabase.GetAssetPathsFromAssetBundle </p></li><li><p>AssetDatabase.RemoveAssetBundleName()</p></li><li><p>AssetDatabase.GetUnusedAssetBundleNames() </p></li><li><p>AssetDatabase.RemoveUnusedAssetBundleNames() </p></li><li><p>The callback AssetPostProcessor.OnPostprocessAssetbundleNameChanged is called if user changes the AssetBundle name of an asset.</p></li></ul><h3 id="Asset-PostProcessor"><a href="#Asset-PostProcessor" class="headerlink" title="Asset PostProcessor"></a>Asset PostProcessor</h3><pre><code class="lang-csharp">using UnityEngine; using UnityEditor; public class MyPostprocessor : AssetPostprocessor{ void OnPostprocessAssetbundleNameChanged(string path,string previous, string next){ Debug.Log(&quot;AB: &quot; \+ path + &quot; old: &quot; \+ previous + &quot; new: &quot; \+ next); } }</code></pre><h2 id="AB包内部结构"><a href="#AB包内部结构" class="headerlink" title="AB包内部结构"></a>AB包内部结构</h2><p>AssetBundleFileHeader：记录了版本号、压缩等主要描述信息。</p><p>AssetFileHeader：包含一个文件列表，记录了每个资源的name、offset、length等信息。</p><p>Asset1：</p><p>AssetHeader：记录了TypeTree大小、文件大小、format等信息。<br>TypeTree（可选，有不要TypeTree的构建方式）：记录了Asset对象的class ID。Unity可以用class ID来序列化和反序列化一个类。（每个class对应了一个ID，如0是Object类，1是GameObject类等。具体可在Unity官网上查询。）<br>ObjectPath：记录了path ID（资源唯一索引ID）等。<br>AssetRef：记录了AB包对外部资源对引用情况。<br>Asset2…</p><p>.manifest文件</p><pre><code class="lang-csharp">`ManifestFileVersion: 0 # 文件版本CRC: 2657307167 # CRC校验码Hashes: # 哈希AssetFileHash: # AB包中所有资源的哈希，可用于增量更新检测serializedVersion: 2 # Unity序列化版本Hash: 717e408ba50ee41b0960161fd2d5a827TypeTreeHash: # AB包中所有类型的哈希，可用于增量更新检测serializedVersion: 2 # Unity序列化版本Hash: 8d552bf2f5bdba1177c938cb98ca6f2fHashAppended: 0ClassTypes: # TypeTree\- Class: 1 # GameObjectScript: {instanceID: 0}\- Class: 21 # MaterialScript: {instanceID: 0}\- Class: 28 # Texture2DScript: {instanceID: 0}\- Class: 48 # ShaderScript: {instanceID: 0}\- Class: 114 # MonoBehaviourScript: {fileID: 1392445389, guid: f70555f144d8491a825f0804e09c671c, type: 3}\- Class: 114 # MonoBehaviourScript: {fileID: -765806418, guid: f70555f144d8491a825f0804e09c671c, type: 3}\- Class: 114 # MonoBehaviourScript: {fileID: -1200242548, guid: f70555f144d8491a825f0804e09c671c, type: 3}\- Class: 114 # MonoBehaviourScript: {fileID: -146154839, guid: f70555f144d8491a825f0804e09c671c, type: 3}\- Class: 114 # MonoBehaviourScript: {fileID: 708705254, guid: f70555f144d8491a825f0804e09c671c, type: 3}\- Class: 114 # MonoBehaviourScript: {fileID: 1297475563, guid: f70555f144d8491a825f0804e09c671c, type: 3}\- Class: 114 # MonoBehaviourScript: {fileID: 11500000, guid: 20e8969313b8e4614b498f042e99683a, type: 3}\- Class: 114 # MonoBehaviourScript: {fileID: 11500000, guid: c86dbe77db44a434bb15895563508b65, type: 3}\- Class: 114 # MonoBehaviourScript: {fileID: 11500000, guid: 1a7e2f4cb82d9b94a91270d550c880c0, type: 3}\- Class: 115 # MonoScriptScript: {instanceID: 0}\- Class: 128 # FontScript: {instanceID: 0}\- Class: 198 # ParticleSystemScript: {instanceID: 0}\- Class: 199 # ParticleSystemRendererScript: {instanceID: 0}\- Class: 213 # SpriteScript: {instanceID: 0}\- Class: 222 # CanvasRendererScript: {instanceID: 0}\- Class: 224 # RectTransformScript: {instanceID: 0}\- Class: 687078895 # SpriteAtlasScript: {instanceID: 0}Assets: # 包含资源- Assets/Bundle/.../a.prefab- Assets/Bundle/.../b.prefab- Assets/Bundle/.../c.spriteatlasDependencies: # AB包依赖- /Users/apple/.../AssetBundles/Android/q- /Users/apple/.../AssetBundles/Android/w- /Users/apple/.../AssetBundles/Android/e- /Users/apple/.../AssetBundles/Android/r- /Users/apple/.../AssetBundles/Android/t`</code></pre><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h3><p>加密思路：<br>1、在构建完AB包后，可以将AB包中的内容以byte[]形式读取。<br>2、之后选用任意加密方式对该byte[]加密。<br>3、加密完后重新写入AB包中。<br>4、AB包加密完成。</p><blockquote><p>这样对AB包加密之后，如果使用AssetBundle.LoadFromFile()来加载加密的AB包是会报错的，因为Unity以及无法识别加密过后的内容。</p></blockquote><p>解密思路：<br>1、先以byte[]形式读取AB包中的内容。<br>2、之后使用对应的解密算法对该byte[]进行解密。<br>3、解密过后的byte[]通过AssetBundle.LoadFromMemory()来进行加载。<br>4、AB包加载完成。</p><p>占用内存的峰值至少是他所处理的AssetBundle大小的两倍：一份由此API创建在本机内存中的副本和一份传递给此API的位于托管字节数组中的副本。通过此API从AssetBundle加载的Asset会在内存中被复制3次：在托管代码中的字节数组、本机内存中的副本以及在GPU或系统内存中的Asset本体。</p><h3 id="耗费小的思路-偏移量"><a href="#耗费小的思路-偏移量" class="headerlink" title="耗费小的思路-偏移量"></a>耗费小的思路-偏移量</h3><p>在构建完AB包之后，在AB包前插入N个随机byte。AssetBundle.LoadFromFile()的第三个参数是AB包内容的byte偏移量。也就是说从offset个byte开始读取AB包的内容。</p><blockquote><p>对于资源加密，我们大多数时候能做到的是防小白不防专家，不管你是采用简单的或者复杂的，在反编译高手手里都有点苍白</p></blockquote><pre><code class="lang-csharp">public static AssetBundle LoadFromFile(string path, uint crc, ulong offset);</code></pre><p>具体实现可参考：<a href="https://zhuanlan.zhihu.com/p/75964237" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75964237</a></p><h3 id="LoadFromStream-1"><a href="#LoadFromStream-1" class="headerlink" title="LoadFromStream"></a>LoadFromStream</h3><p><a href="https://www.xuanyusong.com/archives/4607" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4607</a></p><h2 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h2><p>CRC MD5 SHA1<br>相同点：<br>CRC、MD5、SHA1都是通过对数据进行计算，来生成一个校验值，该校验值用来校验数据的完整性。<br>不同点：</p><ol><li><p>算法不同。CRC采用多项式除法，MD5和SHA1使用的是替换、轮转等方法；</p></li><li><p>校验值的长度不同。CRC校验位的长度跟其多项式有关系，一般为16位或32位；MD5是16个字节（128位）；SHA1是20个字节（160位）；</p></li><li><p>校验值的称呼不同。CRC一般叫做CRC值；MD5和SHA1一般叫做哈希值（Hash）或散列值；</p></li><li><p>安全性不同。这里的安全性是指检错的能力，即数据的错误能通过校验位检测出来。CRC的安全性跟多项式有很大关系，相对于MD5和SHA1要弱很多；MD5的安全性很高，不过大概在04年的时候被山东大学的王小云破解了；SHA1的安全性最高。</p></li><li><p>效率不同，CRC的计算效率很高；MD5和SHA1比较慢。</p></li><li><p>用途不同。CRC一般用作通信数据的校验；MD5和SHA1用于安全（Security）领域，比如文件校验、数字签名等。</p></li></ol><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="和项目一起安装"><a href="#和项目一起安装" class="headerlink" title="和项目一起安装"></a>和项目一起安装</h3><ul><li><p>减少项目构建时间并允许更简单的迭代开发。</p></li><li><p>发布可更新内容的初始修订版。</p></li></ul><h3 id="安装后再下载它们"><a href="#安装后再下载它们" class="headerlink" title="安装后再下载它们"></a>安装后再下载它们</h3><p>这就允许在安装后再更新游戏内容，而不必强迫用户重新下载整个应用程序。<br>将它们放在某个Web服务器上，并通过UnityWebRequest发布。Unity将自动在本地存储上缓存下载的AssetBundles。如果下载的AssetBundle是LZMA压缩的，那么AssetBundle将以未压缩或重新压缩的形式存储在缓存中，就像LZ 4一样（依赖Caching.compressionEnabled设置），以便将来更快地加载。如果下载的包是LZ 4压缩的，AssetBundles将被压缩存储。如果缓存被填满，Unity将从缓存中删除最近使用最少的AssetBundle。</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>Unity有一个内置的AssetBundle缓存系统，可以用来缓存通过UnityWebRequest API下载的AssetBundles，该API的重载会接受一个AssetBundle版本号作为参数。这个数字不是存储在AssetBundles里的，也不是由AssetBundles系统生成的。</p><p>缓存系统跟踪传递给UnityWebRequest的最后一个版本号。当使用版本号调用此API时，缓存系统通过比较版本号来检查是否存在缓存的AssetBundle。如果这些数字匹配，系统将加载缓存的AssetBundle。如果数字不匹配，或者没有缓存的AssetBundle，那么Unity将下载一个新的副本。此新副本将与新的版本号相关联。</p><p>缓存系统中的AssetBundle只通过它们的文件名来标识，而不是通过下载它们的完整URL。这意味着具有相同文件名的AssetBundle可以存储在多个不同的位置，例如CDN。只要文件名相同，缓存系统就会将它们识别为相同的AssetBundle。</p><h2 id="相关优化"><a href="#相关优化" class="headerlink" title="相关优化"></a>相关优化</h2><h3 id="冗余问题"><a href="#冗余问题" class="headerlink" title="冗余问题"></a>冗余问题</h3><p>在Unity5.0后，BuildAssetBundleOptions.CollectDependencies永久开启，即Unity会自动检测物体引用的资源并且一并打包，防止资源丢失遗漏的问题出现。有些情况下，如果没指定某公共资源的存放在哪个AB包中，这个公共资源就会被自动打进引用它的AB包中，所以出现多个不同的AB包中有重复的资源存在的现象。这就是资源冗余。</p><p>a. 把需要共享的资源打包到一起<br>b. 分割包，这些包不是在同一时间使用的<br>c. 把共享部分打包成一个单独的包</p><h3 id="图集重复问题"><a href="#图集重复问题" class="headerlink" title="图集重复问题"></a>图集重复问题</h3><p>在Unity当中，Sprite2D会被打包到一个图集当中（由Packing Tag决定）。如果不指定PackingTag，Sprite会打包到同一个图集当中。一个Sprite打包到AssetBundle中时，它所在的整个图集都会被打包进去。<br>解决方法：确保同一个图集当中的图片打包到同一个AssetBundle当中去。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul><li><p>Android贴图问题</p></li><li><p>iOS文件处理重复fixed in Unity 5.3.2p2.</p></li></ul><h2 id="UnityAssetBundleBrowserTool"><a href="#UnityAssetBundleBrowserTool" class="headerlink" title="UnityAssetBundleBrowserTool"></a>UnityAssetBundleBrowserTool</h2><h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><p>Build的时候，该文件夹下的所有东西会被原封不动地打包到我们的安装包当中。<br>一般放一些二进制文件、 AssetBundles。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://segmentfault.com/a/1190000038943912" target="_blank" rel="noopener">https://segmentfault.com/a/1190000038943912</a><br><a href="https://blog.uwa4d.com/archives/USparkle_Addressable3.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/USparkle_Addressable3.html</a></p><p><a href="https://learn.unity.com/tutorial/assets-resources-and-assetbundles" target="_blank" rel="noopener">https://learn.unity.com/tutorial/assets-resources-and-assetbundles</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【疑难问题处理】异常捕获与处理</title>
      <link href="2023/07/25/Unity3D-%E3%80%90%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E3%80%91%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86/"/>
      <url>2023/07/25/Unity3D-%E3%80%90%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E3%80%91%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Prin-PY/Unity-Excpetion-Crash" target="_blank" rel="noopener">https://github.com/Prin-PY/Unity-Excpetion-Crash</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内存】内存底层深入</title>
      <link href="2023/07/25/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91%E5%86%85%E5%AD%98%E5%BA%95%E5%B1%82%E6%B7%B1%E5%85%A5/"/>
      <url>2023/07/25/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91%E5%86%85%E5%AD%98%E5%BA%95%E5%B1%82%E6%B7%B1%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="物理内存的访问"><a href="#物理内存的访问" class="headerlink" title="物理内存的访问"></a>物理内存的访问</h3><p>CPU访问内存是一个慢速过程。<br>访问过程：先访问Cache，Cache包含L1，L2，L3，也就是一级缓存，二级缓存和三级缓存，若在这些缓存里全没找到我们要的数据，再去访问内存，接着会把找到的数据存放到Cache中，完成一次操作。</p><p>过多的Cache Miss就会导致大量的内存和Cache的IO交换，浪费大量时间。</p><blockquote><p>Unity ECS方案: 可以将存储在内存中的不连续数据，变为连续的数据，从而降低Cache Miss的概率。</p></blockquote><h3 id="台式设备和移动设备内存架构差异"><a href="#台式设备和移动设备内存架构差异" class="headerlink" title="台式设备和移动设备内存架构差异"></a>台式设备和移动设备内存架构差异</h3><ul><li><p>移动设备 <strong>没有独立显卡</strong> 。</p></li><li><p>移动设备 <strong>没有独立显存</strong> ，内存和显存是同一块内存。</p></li></ul><blockquote><p>所以有可能我们游戏占用的内存并不大，但是依旧爆内存了，其实是因为显存分配不出来了。这种情况，我们可以去查看一下Log，例如Android会有一个 OpenGL Error：Out Of Memory。</p></blockquote><ul><li>移动设备的CPU面积更小，因此会导致 <strong>缓存级数更少</strong> ，大小也更小，例如一般的台式机三级缓存可能有8-16M，而移动设备则只有2M左右。</li></ul><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>内存分页（IOS上大部分为16K/page）是内存管理的最小单位，当Unity需要申请内存的时候，都会以block的方式（若干个页）进行申请。如果某一页在若干次GC（IOS为8次）之后仍然为Empty的话，它就会被释放，实际的物理内存就会被还给物理内存。</p><h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/370467923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/370467923</a><br><a href="https://zhuanlan.zhihu.com/p/362941227" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/362941227</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动画】Animator &amp; ApplyRootMotion</title>
      <link href="2023/07/25/Unity3D-%E3%80%90%E5%8A%A8%E7%94%BB%E3%80%91Animator-ApplyRootMotion/"/>
      <url>2023/07/25/Unity3D-%E3%80%90%E5%8A%A8%E7%94%BB%E3%80%91Animator-ApplyRootMotion/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动画】Unity动画系统</title>
      <link href="2023/07/25/Unity3D-%E3%80%90%E5%8A%A8%E7%94%BB%E3%80%91Unity%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"/>
      <url>2023/07/25/Unity3D-%E3%80%90%E5%8A%A8%E7%94%BB%E3%80%91Unity%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Animation-System-Overview"><a href="#Animation-System-Overview" class="headerlink" title="Animation System Overview"></a>Animation System Overview</h2><h3 id="Animation-Type"><a href="#Animation-Type" class="headerlink" title="Animation Type"></a>Animation Type</h3><h4 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h4><p>The Root node allows Unity to establish consistency between Animation clips for a generic model.</p><h4 id="Humanoid"><a href="#Humanoid" class="headerlink" title="Humanoid"></a>Humanoid</h4><p>With rare exceptions, humanoid models have the same basic structure. This structure represents the major articulated parts of the body: the head and limbs. The first step to using Unity’s Humanoid animation features is to set up and configure an Avatar. Unity uses the Avatar to map the simplified humanoid bone structure to the actual bones present in the Model’s skeleton.</p><h4 id="Legacy-Animation-System"><a href="#Legacy-Animation-System" class="headerlink" title="Legacy Animation System"></a>Legacy Animation System</h4><p>Our legacy animation system is only included for backward compatibility with old projects, and it has a very limited feature set compared with our current animation system. The only reason you should use it is for legacy projects built using the old system.</p><h4 id="pros-and-cons"><a href="#pros-and-cons" class="headerlink" title="pros and cons"></a>pros and cons</h4><ul><li><p>Humanoid allows for retargeting animations on all humanoid type characters. Mecanim allows a better integration of humanoid avatars.</p></li><li><p>Generic allows for characters that aren’t humanoid and doesn’t match the humanoid mecanim structure.</p></li></ul><p>Humanoid requires you to have only 2 spine bones. Generic doesn’t have that restriction.</p><hr><p>The Humanoid system is used for animating human body types. This can mean humans, robots, upright animals, or whatever else you can think of that looks like a human. In any case, for this type of animation, it is best to create the animations in a separate modelling program, and then import them to Unity. If the model is correctly rigged, everything should import very smoothly.</p><p>The Generic system is very simple. It is used for any type of animation that is not humanoid. You can use it to open a door, fire a gun, etc.. For this type of animation, it is probably easier to use the animation editor that Unity provides to make your animations.</p><hr><p>Humanoid与Generic是不太可能完全相同的。Humanoid模式其本质是让通过Unity引擎自己的Avatar模板来驱动的，这个模板仅有30~35根骨骼（具体数字忘记了），而一般3D Max做出来的模型，其骨骼是很难与之一一对应，比如你上图中的手骨，其在3D Max中很可能是有动画的，而在Humanoid中主要还是映射过去计算的。这样就存在了部分骨骼之间的骨骼位置不一致，从而导致了Skinning后的结果也会不一致。</p><p>Humanoid模式使用的精髓还在于Retargeting，而这一点就基本上决定了不可能与原始动画完全一致，如果想要完全一致，Unity提供了另一种模式：Generic。<br><a href="https://answer.uwa4d.com/question/5a38b5775f86da7f0e37863d" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a38b5775f86da7f0e37863d</a></p><hr><blockquote><p>Legacy is outdated and probably going to be phased out. So there are no pros with it.</p></blockquote><h4 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h4><pre><code class="lang-csharp">Generic vs Humanoid，Generic的耗时约为Humanoid的60%。但是Humanoid在运行中内存占用、文件大小和加载效率都会比Generic要小。追求性能的话可转换为Generic，不常用的模型可将格式设置为Humanoid，这样两者兼顾。</code></pre><p>作者： <em>ArayA</em><br>链接：<a href="https://www.jianshu.com/p/6fc0332357e8" target="_blank" rel="noopener">https://www.jianshu.com/p/6fc0332357e8</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="关于-“Mecanim-动画系统”"><a href="#关于-“Mecanim-动画系统”" class="headerlink" title="关于 “Mecanim 动画系统”"></a>关于 “Mecanim 动画系统”</h3><p>Mecanim integrated humanoid animation retargeting, muscle control, and the state machine system.<br>Mecanim 并没有清楚的定义与边界。<br>“Mecanim” has now simply come to mean our main animation system.<br>Unity的Mecanim动画系统，是一套基于状态机的动画控制系统，是一个面向动画应用的动画系统。</p><blockquote><p>Mecanim operated only with humanoid characters, our legacy animation system was still required for animating non-humanoid characters and other keyframe-based animation of gameobjects within Unity.</p></blockquote><h2 id="角色模型动画Workflow"><a href="#角色模型动画Workflow" class="headerlink" title="角色模型动画Workflow"></a>角色模型动画Workflow</h2><p>1.通过建模软件创建角色模型网格（涉及建模软件的使用）<br>2.针对角色姿态，以及动画布置，创建角色骨骼<br>3.进行骨骼的蒙皮，将网格和角色网格绑定起来（顶点权重调整）<br>4.利用绑定好骨骼的角色制作动画，导出资源<br>5.Unity提取资源文件中的人物模型，提取动画切片（Clip）<br>6.通过Mecanim动画系统进行编辑，创建动画状态，动画的融合、过渡调整，设定过渡条件，结合脚本控制，将动画应用到游戏开发中</p><blockquote><p>需要我们在网格建立的时候考虑应用动画是对于网格的拉伸，扭曲，需要有好的拓扑结构<br> 在创建骨骼时，要符合15块骨骼为基准的骨骼结构<br> 对于蒙皮，可能要结合需要被应用的动画资源，或是对于目前已制作出的动画效果，对权重进行反复的调整<br> Unity无法解析physique蒙皮，因此我们必须使用Skin进行网格的蒙皮</p></blockquote><h2 id="ImportSettings操作"><a href="#ImportSettings操作" class="headerlink" title="ImportSettings操作"></a>ImportSettings操作</h2><p>ImportSettings影响的是对AnimationClip的导入，导入之后，曲线就只能手动编辑关键帧了，所以，影响到整体曲线形成方式的操作都在ImportSettings当中设置。</p><p>Loop Pose：Enable to make animation loop seamlessly. （使动画首尾姿态尽量无缝衔接，避免出现突变。实质上就是动画末尾到开头的过渡效果。）</p><p>Bake Into Pose：将角色对应属性的变换植入到身体（Pose）的运动中，让根节点对应属性的运动不发生改变。勾选Bake Into Pose，将消除根节点对应的运动属性，在切片播放时，角色对应的旋转/位移，将不会被植入到Unity中。</p><h3 id="ApplyRootMotion"><a href="#ApplyRootMotion" class="headerlink" title="ApplyRootMotion"></a>ApplyRootMotion</h3><p>动画的运动包括根节点的运行（RootMotion）和各个骨骼节点相对于根节点的运动。其根节点（Root）默认为Animator所在的物体。</p><p>动画导入后，如果不Bake，运动分为Root的运动和子节点骨骼的运动两部分。</p><ul><li><p>在播放动画时，不ApplyRootMotion，则不会进行根节点的运动，也就是只看到人物各个骨骼在相对于根节点做动作，而人物整体不运动。例如对于奔跑的动作，如果人物的位移与旋转是由根节点的位移与旋转实现的，播放时，人的手和脚在摆动，而位置不变。</p></li><li><p>播放动画时，勾选了ApplyRootMotion，则会将动画资源中Root的运动数据应用到根节点上，根节点会进行相应的位移和旋转。而RootMotion执行的是相对于初始位置的运动，因此奔跑的动作循环播放会导致人物一直前进。</p></li></ul><p>如果Bake，则会将RootMotion运动的信息烘焙到各个骨骼点上 ，导入的动画就没有Root节点运动的信息，无论是否ApplyRootMotion，角色的根节点的transform都不会改变，而骨骼节点执行的是相对于根节点的运动，并且是原先根节点运动(前进转身等)运动与骨骼节点运动（摆手臂等）的叠加。</p><p>总之RootMotion记录的是根节点相对于动画初始transform的运动。如果Bake，就将整体运动信息烘焙到骨骼上，根节点不动，动画循环播放，每次会从原位置开始运动。如果不Bake，不ApplyRootMotion，动画只有骨骼节点的运动， 没有整体的运动。如果ApplyRootMotion，就会将根节点的整体运动执行，每次开始播放动画，都相对于当前动画的位置运动。</p><h4 id="自定义RootMotionNode"><a href="#自定义RootMotionNode" class="headerlink" title="自定义RootMotionNode"></a>自定义RootMotionNode</h4><p>在ImportSettings中可以设置RootMotionNode：</p><p><img src="【动画】Unity动画系统/1615977607114.png" alt="Alt text"></p><p>如果设置了RootMotionNode，则会进行Bake，以所选节点为Root，将运动信息烘焙到子节点上，运行时，依然看到根节点transform是不变的，但是角色会前进一段后回到原位置。</p><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>如果不进行Bake，并且ApplyRootMotion的话，每一帧都需要更新根节点的位置，并在此基础上确定各个骨骼的位置，会有一定的开销。<br>如果ApplyRootMotion勾选，Unity每帧都会在ApplyOnAnimatorMove函数中调用ApplyBuiltinRootMotion。</p><p><img src="【动画】Unity动画系统/1615977339562.png" alt="Alt text"></p><p>如果不勾选，则不会调用：</p><p><img src="【动画】Unity动画系统/1615977392724.png" alt="Alt text"></p><h3 id="动画剪辑"><a href="#动画剪辑" class="headerlink" title="动画剪辑"></a>动画剪辑</h3><p>通过Clips下方的加号来新建AnimationClip，在下方可以更改AnimationClip的名字，在Length条上可以对动画进行裁剪。</p><p><img src="【动画】Unity动画系统/1615984365722.png" alt="Alt text"></p><p>剪辑时，下方将会显示出曲线图。通过红色/黄色/绿色，来标记剪切出的剪辑中，角色的某种姿态属性是否能够构成循环。（绿色可以，红色不可以，黄色取中间值）。<br>裁剪的结果是否能循环体现在Bake选项后的红色提示灯上，用于在Bake时参考：</p><p><img src="【动画】Unity动画系统/1615984621432.png" alt="Alt text"></p><p>由于Bake后Root是不动的，动画会循环播放，因此，绿色状态下才建议开发者进行Bake。如果是红色状态 ，Bake后动画的播放就会不连续。</p><h3 id="其它参数"><a href="#其它参数" class="headerlink" title="其它参数"></a>其它参数</h3><p>Cycle Offset：应是一个0到1之间的数值，否则无效，可以设定循环时起始播放位置的偏移</p><p>Base Upon：对应属性的改变要以什么为参照（通常保持默认即可）<br>—original 引用FBX文件中原先的位置，方位坐标，并以此为参照，通常对Y轴启用，对Rotation启用可能导致人物初始朝向不是Z轴正方向，对XZ平面启用可能导致人物不在原点位置<br>—Body Orientation 按身体的朝向变化为参照，通常对Rotation启用<br>—Center Of Mass 按身体重心位置为参照，选定时，身体重心位置会被至于原点，通常不对Y轴启用，而对XY平面启用<br>—feet 按脚底的Y轴高度为参照（Y轴高度的另一个参照）</p><p>Mirror：左右镜像翻转动画，可以节省动画师的工作量</p><h2 id="Animator组件的属性"><a href="#Animator组件的属性" class="headerlink" title="Animator组件的属性"></a>Animator组件的属性</h2><p>Controller：状态机的配置资源文件，整合Clip资源，创建状态机状态（State），设置动画 <strong>过渡</strong> 与 <strong>融合</strong> 。</p><p>Avatar：动画节点导引替身，与动画复用（尤其是人形动画复用）有关，通过配置和应用Avatar，可以实现不同FBX模型之间的动画复用</p><p>Update Mode：状态机播放动画的时间模式。</p><p><img src="【动画】Unity动画系统/1615987896583.png" alt="Alt text"></p><p>Normal：使用游戏Upadte的更新模式<br>Animate Physics：使用物理周期的更新模式（使用Unity中的物理系统实现位移，角色需要与场景中的物体进行物理交互）<br>Unscaled Time：不受TimeScale影响的更新模式（通常应用于GUI界面的动画）</p><p>Culling Mode：剔除模式</p><p>Always Animate：无论物体是否被摄像机可见，总是计算所有节点的运动，完整的进行动画播放<br>Cull Update Transforms：当物体不被摄像机可见时，仅计算根节点的位移植入，保证物体位置上的正确<br>Cull Completely：当物体不被摄像机可见时，完全终止动画的运行</p><h2 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h2><h3 id="Sub-State-Machine"><a href="#Sub-State-Machine" class="headerlink" title="Sub-State Machine"></a>Sub-State Machine</h3><p>创建一个子动画组。创建的指向动画组的过渡，当过渡触发时，就会来到该动画组的Entry，并进入该动画组的初始状态。</p><p>指向Exit的过渡 - 当触发时，就会返回上一层的Entry并进入上一层的初始状态。</p><p><img src="【动画】Unity动画系统/1615988240440.png" alt="Alt text"></p><h3 id="Blend-Tree"><a href="#Blend-Tree" class="headerlink" title="Blend Tree"></a>Blend Tree</h3><p>动画融合树</p><h3 id="动画过渡"><a href="#动画过渡" class="headerlink" title="动画过渡"></a>动画过渡</h3><p><strong>Has Exit Time</strong> ：勾选时上一个状态对于的动画片段必须被播放到末尾，才允许这个过渡被触发，不勾选可以在任意时刻进行过渡</p><p><strong>Eixt Time</strong> ：CurrentState所对应的动画片段，开始进行过渡融合的位置对起始位置的偏移（百分比）<br><strong>Transition Duration(s)</strong> ：过渡融合的区间长度（百分比或秒）<br><strong>Transition Offset</strong> ：过渡：NextState动画，进行过渡融合对应起始位置的偏移（百分比）</p><p><strong>Fixed Duration</strong> ：过渡区间的计算方式（决定Transition Duration的单位），不勾选按照对CurrentState动画的相对百分比长度计算，勾选按照恒定的秒时长计算</p><p><strong>Interruption Source</strong> ：打断来源，允许该过渡被来自CurrentState或NextState的其它过渡打断<br>被CurrentState打断则发生了“跳转”，NextState的指向被改变（例如受击打断了攻击）<br>被NextState打断则发生了“跃进”，动画迅速的完成了两个状态的过渡（例如从站立状态快速过渡到冲刺斩，奔跑状态被越过）</p><p><strong>合理的运用打断，实现快节奏的状态切换，是制作动作游戏的基础</strong></p><p>Ordered Interruption：针对CurrentState出发的过渡，是否只允许比当前过渡优先级高的过渡打断该过渡</p><h3 id="State配置"><a href="#State配置" class="headerlink" title="State配置"></a>State配置</h3><p>Motion：这个State所引用的动画片段</p><p>Speed：动画片段的播放速度（置为-1可倒放动画）</p><p>Multiplier：Speed的一个倍率因子，需要勾选Parameter，可选定一个浮点动画参数来动态控制这个因子</p><p>Normalized Time：片段播放位置，0到1之间浮点，需要一个被控制的浮点动画参数来作为输出映射，从而我们可以在脚本中获取这个片段的播放进度（Normallize Time * 片段帧长度，可以得到当前片段播放到第几帧）</p><p>Mirror：是否进行左右翻转，可以勾选要Parameter，可选定一个布尔动画参数来动态控制</p><p>Cycle Offset：偏移量（和之前Clip中的偏移相同），0到1之间的浮点值，可勾选Parameter选定一个浮点动画参数来动态控制</p><p>Foot IK：脚部的IK反向力学修正，针对人物上坡，上楼梯时的踏空而行进行修正</p><p>Write Default：初始化属性，如果一个Clip对于角色某个节点的某个属性完全不涉及，那么播放该Clip时，对于不涉及的属性值，是要置为初始状态，还是置为其它Clip末尾时对该值的修改结果。勾选则置为0帧初状态，不勾选则应用之前播放的Clip对其修改的结果</p><p>Write Default主要是针对人物骨骼之外的一些节点，例如武器，跟随物，这些节点只在部分互动动作之中被用到，那些没有使用该节点的动作执行时，是要让节点处于初始状态，还是上一次互动动作末尾时的状态</p><h2 id="Animator-Override-Controller"><a href="#Animator-Override-Controller" class="headerlink" title="Animator Override Controller"></a>Animator Override Controller</h2><p>Animator Override Controller 也是一种Controller状态机配置资源文件，它可以继承一种指定的Animator Controller，并在此基础上进行修改，从而在复用Controller的同时，做出针对性的修改。<br>Override Controller与AnimationController作用相同，只是可以替换AnimationClip的取值。</p><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>AnimationState面板上可以添加StateMachineBehaviour类Script，通过Override相关函数响应相关事件。</p><p><img src="【动画】Unity动画系统/1615987356620.png" alt="Alt text"></p><p><img src="【动画】Unity动画系统/1615987405918.png" alt="Alt text"></p><p>AnimationClip编辑时，可在关键帧添加AnimationEvent。</p><p><img src="【动画】Unity动画系统/1615987432960.png" alt="Alt text"></p><p>关键帧触发事件时，调用AnimationClip所在物体上的脚本中的同名函数。</p><p><img src="【动画】Unity动画系统/1615987484236.png" alt="Alt text"></p><h3 id="Mono—-gt-SMB的通信"><a href="#Mono—-gt-SMB的通信" class="headerlink" title="Mono—&gt;SMB的通信"></a>Mono—&gt;SMB的通信</h3><ol><li>拖动赋值 —— 序列化的方法</li></ol><p><img src="【动画】Unity动画系统/1615989784924.png" alt="Alt text"></p><ol><li>API</li></ol><pre><code class="lang-csharp">//Awake OR Startvar smb = animator.GetBehaviour&lt;StateMechine&gt;(); //这里会是从父动画组到子动画组以及其中包含的State，这个遍历顺序下，遇到的第一个StateMechinevar smbS = animator.GetBehaviours&lt;StateMechine&gt;(); //返回一个数组包含Controller中所有的StateMechine</code></pre><h3 id="SMB—-gt-Mono的通信"><a href="#SMB—-gt-Mono的通信" class="headerlink" title="SMB—&gt;Mono的通信"></a>SMB—&gt;Mono的通信</h3><ol><li><p>依然是序列化方法，同样需要用到两个Inspector窗口</p></li><li><p>在Mono中获取到该SMB，之后在Mono的Awake/Start对SMB中的Mono挂点进行赋值（逆向设置）</p></li></ol><h2 id="Avatar相关"><a href="#Avatar相关" class="headerlink" title="Avatar相关"></a>Avatar相关</h2><p>Avatar能够复用的条件是，生成源Avatar的FBX模型中的骨骼层级结构及名称与当前FBX相同</p><p><img src="【动画】Unity动画系统/1615989156276.png" alt="Alt text"></p><p>复用方式：Avatar的存在主要是为了解决人物动画的复用问题，不同来源的FBX中，对于骨骼节点的层级结构，以及命名可能不尽相同，因此Unity以Avatar作为一个中介，不同的FBX都对Avatar中的标准人物骨骼结构去创建映射关系。在Animator状态机进行动画控制时，依照人物模型创建的Avatar，将人物动画片段对标准人物骨骼中的节点控制，映射到当前的人物模型当中，从而就实现了对不同来源FBX中，人物动画的复用。</p><h2 id="一些API"><a href="#一些API" class="headerlink" title="一些API"></a>一些API</h2><pre><code class="lang-csharp">animator.GetFloat(blendHash); animator.SetFloat(blendHash, Input.GetAxis(&quot;Horizontal&quot;)); int layerID = animator.GetLayerIndex(&quot;Base Layer&quot;); animatorStateInfo = animator.GetCurrentAnimatorStateInfo(layerID); animatorStateInfo = animator.GetNextAnimatorStateInfo(layerID); transitionInfo = animator.GetAnimatorTransitionInfo(layerID); int idleHash = Animator.StringToHash(&quot;Idle&quot;); int layerID = animator.GetLayerIndex(&quot;Base Layer&quot;); animatorStateInfo = animator.GetCurrentAnimatorStateInfo(layerID); if (animatorStateInfo.shortNameHash == idleHash)//判定当前状态是否是Idle状态{ Debug.Log(&quot;OnState Idle&quot;); } int flyHash = Animator.StringToHash(&quot;Base Layer.FlyMechine.Fly&quot;); animatorStateInfo = animator.GetCurrentAnimatorStateInfo(0); if (animatorStateInfo.fullPathHash == flyHash) { Debug.Log(&quot;OnState Fly&quot;); } int tagHash = Animator.StringToHash(&quot;tagName&quot;); if(animatorStateInfo.tagHash==tagHash){ //do something}</code></pre><h2 id="动画系统性能"><a href="#动画系统性能" class="headerlink" title="动画系统性能"></a>动画系统性能</h2><p><strong>Mesh</strong> 面片数对Camera.Render的影响最大，而对其他Animator.Update、MeshSkinning.Update几乎没有影响。<br><strong>骨骼数量</strong> 增多时则主要影响Animator.Update，MeshSkinning.Update</p><p>当我们打开多线程渲染 <strong>Multithread Rendering</strong> 后，会开启Render Thread。然后主线程Camera.Render的耗时则会大幅下降，并且之前开销越大，则下降幅度越明显。</p><p>而打开 <strong>Optimize Game Objects</strong> 选项后，Animator.Update，MeshSkinning.Update的耗时则会大幅下降</p><p>当开启 <strong>Apply Root Motion</strong> 后，主线程中Animator.Update函数开销会增加很多，主要增加开销的函数是ApplyBuiltinRootMotion。有没有办法优化这块呢，答案是肯定的。只要勾选上Optimize Game Objects，这个函数的大部分计算就会放到子线程Worker Thread中去运算了。所以当你要用到Apply Root Motion时，记得一定要开启Optimize Game Objects。</p><p>推荐大家使用Optimal来进行动画压缩。</p><h3 id="多角色场景解决方案"><a href="#多角色场景解决方案" class="headerlink" title="多角色场景解决方案"></a>多角色场景解决方案</h3><h4 id="Bake-Mesh"><a href="#Bake-Mesh" class="headerlink" title="Bake Mesh"></a>Bake Mesh</h4><p>利用SkinnedMeshRender.BakeMesh来对场景中同种模型角色进行烘焙，将蒙皮网格SkinnedMesh转换成普通Mesh。根据所要播放的动画及播放时间可以在网格中获取对应的网格数据从而进行渲染。<br>使用Bake Mesh的优点是能大幅降低CPU的开销，但是同时也会增加运行时的内存占用，具体的内存占用跟Mesh的面片数和动画片段长度成正比，因此在使用此方案时要特别注意降低Mesh的面片数和动画片段。</p><h4 id="GPU-Skinning"><a href="#GPU-Skinning" class="headerlink" title="GPU Skinning"></a>GPU Skinning</h4><p>Skinning过程转移到GPU中</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.jianshu.com/p/6fc0332357e8" target="_blank" rel="noopener">https://www.jianshu.com/p/6fc0332357e8</a><br><a href="https://zhuanlan.zhihu.com/p/105029905" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105029905</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内存】Unity内存组成</title>
      <link href="2023/07/25/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91Unity%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90/"/>
      <url>2023/07/25/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91Unity%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><p>Ref: <a href="https://blog.csdn.net/greedylin/article/details/103711555" target="_blank" rel="noopener">https://blog.csdn.net/greedylin/article/details/103711555</a><br>物理内存</p><h3 id="1-1-Cache"><a href="#1-1-Cache" class="headerlink" title="1.1 Cache"></a>1.1 Cache</h3><p>CPU访问内存是一个慢速过程，因此会使用cache来加速访问，CPU如果在Cache中没有找到数据，称为一次Cache Missing，如果内存数据 指令是不连续的，会导致大量的Cache Missing</p><p>Unity的ECS和DOTS的目的之一就是提高内存的连续性，减少Cache Missing</p><blockquote><p>台式设备与移动设备的内存架构差异很大<br> CPU板上面积更小，缓存级数更少，大小也更小，例如一台台式机，L3的大小为8-16M,而移动的CPU,例如骁龙845，只有2M，Cache Missing的概率更大</p></blockquote><h3 id="1-2-显存"><a href="#1-2-显存" class="headerlink" title="1.2 显存"></a>1.2 显存</h3><p>移动设备没有独立显卡以及显存，有的时候，你的内存使用并不大，但还是会内存溢出，例如在Android上，可以看一下有没有OpenGL的out of memory的log，这意味这显存使用太大了</p><h3 id="1-3-虚拟内存"><a href="#1-3-虚拟内存" class="headerlink" title="1.3 虚拟内存"></a>1.3 虚拟内存</h3><ol><li><p>内存交换<br><strong>移动设备不支持内存交换</strong> （注：就是把部分物理内存中的数据保存在硬盘上）<br>谷歌的解释是移动设备和台式设备的IO <strong>速度</strong> 是不一样的，因此移动设备在做内存交换的时候会耗费大量的时间在IO上，并且移动设备的存储介质的 <strong>可擦写次数</strong> 和台式设备差距也很大</p></li><li><p>iOS可以进行内存压缩<br>把不活跃的内存压缩起来，放在特定的内存空间中，以节约物理内存，所以在iOS上可以看到有的时候实际使用的内存比物理内存大很多</p></li></ol><h3 id="1-4-内存寻址范围"><a href="#1-4-内存寻址范围" class="headerlink" title="1.4 内存寻址范围"></a>1.4 内存寻址范围</h3><p>32位CPU和64位CPU<br>严格来说，它们的寻址范围是无法确定谁高谁低的，CPU的位数指的是运算位数，不是MCU位数，只是目前大部分是对应的，即32位CPU对应32位的寻址范围，64位CPU对应64位的寻址范围</p><h3 id="1-5-栈内存"><a href="#1-5-栈内存" class="headerlink" title="1.5 栈内存"></a>1.5 栈内存</h3><p>主要存储小而短的数据。主要是一些值类型得数据，分配和回收很简单，快捷。</p><h3 id="1-6-堆内存"><a href="#1-6-堆内存" class="headerlink" title="1.6 堆内存"></a>1.6 堆内存</h3><p>主要存储大而时间长的数据，主要是引用类型数据。</p><h4 id="堆内存分配步骤："><a href="#堆内存分配步骤：" class="headerlink" title="堆内存分配步骤："></a>堆内存分配步骤：</h4><ol><li><p>检查堆中分配单元是否足够，如果充足则直接分配，如果不够则执行b步骤。</p></li><li><p>检测到堆内存不足则出发gc释放内存（耗时），再次检查堆中分配单元是否足够，如果充足则直接分配，如果不够则执行c步骤。</p></li><li><p>扩大堆内存大小（非常耗时），再来分配内存。</p></li></ol><h4 id="堆内存回收方式有三种："><a href="#堆内存回收方式有三种：" class="headerlink" title="堆内存回收方式有三种："></a>堆内存回收方式有三种：</h4><ol><li><p>系统定期自动回收。</p></li><li><p>分配内存不足时触发内存回收。</p></li><li><p>我们自己手动触发回收（执行：System.GC.Collect()）。</p></li></ol><h3 id="其他术语"><a href="#其他术语" class="headerlink" title="其他术语"></a>其他术语</h3><p>OOM - Out Of Memory</p><h2 id="2-硬件设备"><a href="#2-硬件设备" class="headerlink" title="2 硬件设备"></a>2 硬件设备</h2><h3 id="2-1-显存"><a href="#2-1-显存" class="headerlink" title="2.1 显存"></a>2.1 显存</h3><p>显存，也被叫做帧缓存，它的作用是用来存储显卡芯片处理过或者即将提取的渲染数据。如同计算机的内存一样，显存是用来存储要处理的图形信息的部件。</p><p>PC上，显存是显卡上的一部分，是一块独立的存储设备。<br>移动设备上，内存与显存在硬件层面上是一体的，在软件层面上，将内存中的一部分划分出来作为显存。</p><h4 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h4><p>显卡是主板上一个BGA封装的chipset，类似于CPU（Central Processing Unit），业内叫GPU(Graphics Processing Unit），市场上主要有nVIDIA和AMD两个厂商。图形芯片相当于显卡的CPU，不过它的主要任务是处理显示信息，在处理信息的过程中，它会产生大量的临时数据（未处理的、正在处理的、已经处理完成的），这就需要一个专门的地方来存放这些临时数据，那就是显存了，它也可能是一个芯片，也可能只是芯片的一部分，这要看硬件的设计（独立显卡和集成显卡）。</p><p>显卡的工作原理是：在显卡开始工作(图形渲染建模)前，通常是把所需要的材质和纹理数据传送到显存里面。开始工作时候(进行建模渲染)，这些数据通过AGP总线进行传输，显示芯片将通过AGP总线提取存储在显存里面的数据，除了建模渲染数据外还有大量的顶点数据和工作指令流需要进行交换，这些数据通过RAMDAC转换为模拟信号输出到显示端，最终就是我们看见的图像。</p><h2 id="3-Unity内存"><a href="#3-Unity内存" class="headerlink" title="3 Unity内存"></a>3 Unity内存</h2><h3 id="3-1-U3D开发使用的三种内存"><a href="#3-1-U3D开发使用的三种内存" class="headerlink" title="3.1 U3D开发使用的三种内存"></a>3.1 U3D开发使用的三种内存</h3><p>Ref: <a href="https://gameinstitute.qq.com/community/detail/103695" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/103695</a><br>实际上，Unity3D游戏开发使用的内存一共有三种：程序代码、托管堆(Managed Heap)以及本机堆(Native Heap)。</p><p><img src="【内存】Unity内存组成/游戏运行内存.png" alt="Alt text"></p><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><p>包括了所有的Unity3D游戏开发 <strong>引擎</strong> ，使用的 <strong>库</strong> ，以及你所写的所有的 <strong>游戏代码</strong> 。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity3D游戏开发默认场景， <em>什么代码都不放</em> ，在 <em>iOS设备</em> 上占用内存应该在 <em>17MB</em> 左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。</p><blockquote><p>Editor和Runtime是完全不同的，不仅是内存大小不同，分配时机，方式都不同，例如一个asset，在Runtime下，不主动load，不会进内存，Editor下，只要打开Unity，就可能会加载进内存，这种策略是为了保证编辑时的流畅，这种策略也导致首次打开Unity项目耗时特别长，会转换资源，再load相关资源，在2019.3中有了新的策略，按需导入和加载</p></blockquote><h4 id="托管堆-Managed-Heap-Mono堆内存"><a href="#托管堆-Managed-Heap-Mono堆内存" class="headerlink" title="托管堆(Managed Heap)(Mono堆内存)"></a>托管堆(Managed Heap)(Mono堆内存)</h4><p>是被Mono使用的一部分内存。Mono是一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例(比如用new生成的列表，实例中的各种声明的变量等)。</p><p>“ <strong>托管</strong> ”的意思是Mono“应该” <strong>自动地改变堆的大小来适应你所需要的内存</strong> ，并且定时地使用垃圾回收(Garbage Collect)来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收，这就是内存泄露。</p><p>ManagedHeap的内存值是由所写的C#代码来引起并造成的, 与GameObject数量、资源量无关。</p><p>同时，Managedheap的大小完全是由Mono来决定的，用户所写的任何脚本均是由Mono来负责解析。 <strong>Mono的堆内存</strong> 是 <strong>只升不降</strong> 的，这是Mono的一个问题，Unity暂时也无法对其进行修改。因此，只能建议开发者在编写代码时尽可能地优化代码，避免不需要的堆内存分配。其原理如下：</p><blockquote><p>在Unity环境下， <strong>Mono堆内存的占用，是只会增加不会减少的</strong> 。具体来说，可以将Mono堆，理解为一个内存池，每次Mono内存的申请，都会在池内进行分配；释放的时候，也是归还给池，而不会归还给操作系统。如果某次分配，发现池内内存不够了，则会对池进行扩建——向操作系统申请更多的内存扩大池以满足该次的内存分配。需要注意的是，每次对池的扩建，都是一次较大的内存分配，每次扩建，都会将池扩大6-10M左右</p></blockquote><h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><p>Reserved Mono内存：Mono向操作系统申请的总内存<br>Used Total：Mono内存池的代码使用到的内存</p><blockquote><p>Reserve：预定，储备，拥有</p><p>如果是在Editor中运行时，那么该数值是会比较大，因为编辑器运行游戏时，底层会做很多额外的事情，比如更多的log输出等，从而占据较多的堆内存。而如果在真机运行时看到该数值时，那么80M是比较大的，这个需要你对你的代码来进行优化，避免一些不必要的堆内存分配。比如，不要总是new一个class、array、container等等。<br> 可以在CPU Profiler中的GC Alloc处查看游戏每帧的堆内存分配。<br> 建议时刻关注CPU Profiler中的GC Collect值，查看由哪些选项分配较大或不断分配GC Allocation。这个是造成Managed Heap不断增大的原因。</p></blockquote><h4 id="原生堆-Native-Heap"><a href="#原生堆-Native-Heap" class="headerlink" title="原生堆(Native Heap)"></a>原生堆(Native Heap)</h4><p>是Unity3D游戏开发引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity3D 使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。</p><p>听起来很美好也和托管堆一样，但是由于Unity3D有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用(贴图什么的你懂的)，也是Unity3D给人留下“吃内存”印象的罪魁祸首。</p><h3 id="3-2-Profiler中的内存划分"><a href="#3-2-Profiler中的内存划分" class="headerlink" title="3.2 Profiler中的内存划分"></a>3.2 Profiler中的内存划分</h3><h4 id="Simple模式"><a href="#Simple模式" class="headerlink" title="Simple模式"></a>Simple模式</h4><p>Total: Accumulated value from all areas below</p><p>Unity: The amount of memory allocations in native Unity code, tracked by the native memory manager system and allocated in memory pools according to their type, source and platform specific allocation patterns.</p><p>Mono: The total heap size and used heap size managed code uses. This memory is garbage collected.</p><p>GfxDriver: The estimated amount of memory the driver uses on Textures, render targets, Shaders, and Mesh data.</p><blockquote><p>用来显示的数据，如Mesh、Texture等，Unity加载出来就会直接放在显存当中，需要显示时，不需要在内存中来读取。加载时，（如果没有开启Read/Write），有短暂的时间在内存当中，有一个从内存向显存传输数据的过程。传输结束就会把内存当中的部分删除掉。<br> 如果Mesh等开启Read/Write，为了方便对其进行读写，内存当中的数据不会被清除掉，内存与显存中各有一份。</p></blockquote><p>Audio: The Audio system’s estimated memory usage</p><p>Video: The Video system’s estimated memory usage</p><p>Profiler: Total memory the Profiler uses</p><h4 id="Detailed模式"><a href="#Detailed模式" class="headerlink" title="Detailed模式"></a>Detailed模式</h4><p>Assets — 当前从 scenes, Resources 和 Asset Bundles加载的总资源。<br>Built-in Resources — Unity Editor 资源 或者 Unity default 资源,<br>Not Saved — 被标记为 DontSave的GameObjects<br>Scene Memory — GameObject和它附属的Components<br>Other — 其他不在上面几条分类中的。</p><p>Other 下的一些内容：</p><ul><li><p>Objects - 实际上这里值是由一些BUG导致的。这一项表示各种从Object继承的对象，包括纹理，Mesh等等。它们在某个时刻和实际上的对象断开了链接，可以忽略。</p></li><li><p>System.ExecutableAndDlls：这是Unity的猜测值。它尝试通过汇总文件大小来猜测已加载的二进制代码消耗的内存。</p></li></ul><h4 id="Used和Reserved"><a href="#Used和Reserved" class="headerlink" title="Used和Reserved"></a>Used和Reserved</h4><p>Used和Reserved均是物理内存<br>Reserved是unity向系统申请的总内存，Unity底层为了不经常向系统申请开辟内存，开启了较大一块内存作为缓存，即所谓的Reserved内存，而运行时，unity所使用的内存首先是向Reserved中来申请内存，当不使用时也是先向Reserved中释放内存，从而来保证游戏运行的流畅性。</p><blockquote><p>建议尽可能地控制Used Total的大小，Used Total越大，则Reserved Total越大，而当Used Total降下去后，Reserved Total也是会随之下降的（但并不一定与Used Total同步）。</p></blockquote><p>通过PSS来查看移动端的内存是相当不准确的。<br>而PSS中多出的内存大致分为两部分</p><ol><li><p>App在运行会调用底层的一些核心库，这些库都会占用一定的内存</p></li><li><p>第二部分则是移动系统决定的，即虽然游戏中已经将资源卸载掉，但在系统层面上，系统并不会及时将其清除，而是将其缓存住，这样做的处理是为了便于以后该资源的复用效率，同时，当系统的内存分配达到上限时，系统本身会调用内存清理机制来轮询这些缓存区域，进而释放内存。</p></li></ol><h4 id="GfxDriver"><a href="#GfxDriver" class="headerlink" title="GfxDriver"></a>GfxDriver</h4><p>GfxDriver可以理解为GPU显存开销，主要由Texture，Vertex buffer以及index buffer组成。所以尽可能地减少或释放Texture和mesh等资源，即可降低GfxDriver内存。</p><h3 id="3-3-★★★-Unity内存管理机制与GC"><a href="#3-3-★★★-Unity内存管理机制与GC" class="headerlink" title="3.3 ★★★ Unity内存管理机制与GC"></a>3.3 ★★★ Unity内存管理机制与GC</h3><h4 id="Destroy机制与Custom-Null-Check-of-Unity"><a href="#Destroy机制与Custom-Null-Check-of-Unity" class="headerlink" title="Destroy机制与Custom Null Check of Unity"></a>Destroy机制与Custom Null Check of Unity</h4><h5 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h5><p>Destroy了B对象所在的GameObject后，遍历打印B的引用都为Null，在Inspector面板上看是missing。而这时候进行GC，堆内存其实并未释放这些B对象。只有当A对象中的数组被清空后，再调用GC，才可释放这些对象所占内存。</p><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>Unity中对Null的检测做了特殊的处理，在Unity中MonoBehaviour对象除了存在于Managed Heap中作为“壳”(wrapper objects)，在Native内存中还会有一个相对应的“实体”，在调用Destroy时，真正被释放的正是这个“实体”。而在判断一个MonoBehaviour对象是否为Null时，Unity会首先检测“实体”是否已经被销毁，如果是则返回为true，但此时Managed Heap中的“壳”实际上依然是被引用的，从而就会出现对象的Null判断为true，但实际上还是被引用着，无法被GC释放的问题。<br>如果作为Unity.GameObject对象是null，而作为System.Object对象不是null，说明这个对象已经被Unity标记为销毁了，Unity.GameObject重载的==运算符让游戏逻辑认为它是空的。</p><blockquote><p>官方解释：<a href="http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/" target="_blank" rel="noopener">http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/</a><br> When you get a c# object of type “GameObject”[2], it contains almost nothing. this is because Unity is a C/C++ engine. All the actual information about this GameObject (its name, the list of components it has, its HideFlags, etc) lives in the c++ side. The only thing that the c# object has is a pointer to the native object. We call these c# objects “wrapper objects”. The lifetime of these c++ objects like GameObject and everything else that derives from UnityEngine.Object is explicitly managed. These objects get destroyed when you load a new scene. Or when you call Object.Destroy(myObject); on them. Lifetime of c# objects gets managed the c# way, with a garbage collector. This means that it’s possible to have a c# wrapper object that still exists, that wraps a c++ object that has already been destroyed. If you compare this object to null, our custom == operator will return “true” in this case, even though <strong>the actual c# variable is in reality not really null</strong>.<br> downsides: </p><ul><li><p>It is counterintuitive.</p></li><li><p>Comparing two UnityEngine.Objects to eachother or to null is slower than you’d expect.</p></li><li><p>The custom ==operator is not thread safe, so you cannot compare objects off the main thread. (this one we could fix).</p></li><li><p>It behaves inconsistently with the ?? operator, which also does a null check, but that one does a pure c# null check, and cannot be bypassed to call our custom null check.</p></li></ul></blockquote><h5 id="总结：Destroy机制"><a href="#总结：Destroy机制" class="headerlink" title="总结：Destroy机制"></a>总结：Destroy机制</h5><p>将Native对象Destroy掉（是否立刻释放Native层的内存不清楚），C#层的壳不做处理，访问C#层对象时，会进行判空——根据引用的C#层对象，访问相应的Native层对象，看是否被Destroy，如果Native对象是Destroyed，则返回null。此时的null是fake null，C#层的对象壳还在被引用，无法被GC。只有将C#层手动置空，或者所在的容器Clear掉，才能被GC。</p><h5 id="create-an-instance-of-a-MonoBehaviour-derived-class只能通过AddComponent"><a href="#create-an-instance-of-a-MonoBehaviour-derived-class只能通过AddComponent" class="headerlink" title="create an instance of a MonoBehaviour derived class只能通过AddComponent"></a>create an instance of a MonoBehaviour derived class只能通过AddComponent</h5><p>更详细的解释：<a href="http://answers.unity3d.com/questions/745685/nullreferenceexception-on-startcoroutine.html" target="_blank" rel="noopener">http://answers.unity3d.com/questions/745685/nullreferenceexception-on-startcoroutine.html</a><br>In C# / .NET / Mono instances actually can’t be destroyed since they live in a managed memory environment. Objects are destroyed when all references to the object are gone, no longer valid. After that the garbage collector eventually kicks in and removes the object.</p><p>However in Unity, since it’s core is written in C++, (native) objects can be destroyed on command (with Destroy to be more precise). The Destroy method actually only destroys the object on the c++ side. The managed representation of the object (your MonoBehaviour script) will still be there since the GC can only collect the object when there are no references anymore. That’s why Unity actually “fakes” that the reference is null when the object has lost it’s native counterpart.</p><p>If you use the “new” keyword to create an instance of a MonoBehaviour derived class the instance doesn’t have a native counterpart and will always pretend to be null. If you want to create an instance at runtime it has to be attached to a gameobject. This is done with AddComponent</p><h4 id="Native对象的种类及回收方式的理解"><a href="#Native对象的种类及回收方式的理解" class="headerlink" title="Native对象的种类及回收方式的理解"></a>Native对象的种类及回收方式的理解</h4><p>Native层的对象类型：</p><ol><li><p>Component类型，创建出来是一个component类的对象实例。这部分实例可以Destroy。Destroy掉Native对象就会销毁，C#层的壳不会销毁，由C#的GC进行管理</p></li><li><p>资源类型（Assets，Component会引用到，类似于Texture、Mesh等）。在Destroy某个GameObject时，component会被销毁，而component所引用的资源（Texture、Mesh等）不会立刻销毁。如果这部分资源没有被引用，那么调用UnloadUnusedAssets可以卸载掉，释放内存。或者使用UnloadAsset()进行强制卸载。</p></li></ol><p>至于说component类的资源在Destroy后是否能够立刻释放内存，不太清楚。这一点不好测试，也不需要关注，因为component对象本身在Native层占用的内存也很小。可能是立刻释放内存，也可能是将引用断掉，统一回收处理。</p><h4 id="关于Native层资源垃圾回收机制的思考"><a href="#关于Native层资源垃圾回收机制的思考" class="headerlink" title="关于Native层资源垃圾回收机制的思考"></a>关于Native层资源垃圾回收机制的思考</h4><p>由于在之前对加载资源时过程的内存进行监控时，发现当Native层内存过高时，加载资源时，内存会下降。猜想在Native层也存在类似于Mono层的GC机制，当内存到达一定数值时，会对未被引用的资源进行卸载。<br>之所以会crash，是因为GC在试图卸载未被引用的资源以后，还是空间不足，那么再强行加载资源，就会因为内存分配不出来而crash。（有大部分资源因为被引用而无法卸载）</p><h4 id="场景切换时的内存"><a href="#场景切换时的内存" class="headerlink" title="场景切换时的内存"></a>场景切换时的内存</h4><p>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.<br>Destroy掉前一个场景中的GameObject，如果GameObject上挂载的Monobehaviour没有被其他地方引用的话，调用GC.Collect()会回收掉他占用的内存。</p><p>虽然GameObject被Destroy掉了， 如果Monobehaviour被其他在场景切换时无法销毁的对象所引用，那么其Mono层的对象是无法被回收的。比如：MonoBehaviour类中的某个函数注册了SceneManager类的sceneLoaded事件，那么这个对象就被SceneManager静态地引用了，该对象就无法销毁，Mono层地内存就无法释放。</p><h2 id="4-Unity的垃圾回收相关接口"><a href="#4-Unity的垃圾回收相关接口" class="headerlink" title="4 Unity的垃圾回收相关接口"></a>4 Unity的垃圾回收相关接口</h2><h2 id="5-Unity内存管理的一些经验"><a href="#5-Unity内存管理的一些经验" class="headerlink" title="5 Unity内存管理的一些经验"></a>5 Unity内存管理的一些经验</h2><h3 id="5-1-管理方式"><a href="#5-1-管理方式" class="headerlink" title="5.1 管理方式"></a>5.1 管理方式</h3><ul><li><p>引擎管理内存</p></li><li><p>用户管理内存, 即profiler中C#分配的托管内存</p></li></ul><h4 id="一次完整的GC流程："><a href="#一次完整的GC流程：" class="headerlink" title="一次完整的GC流程："></a>一次完整的GC流程：</h4><ol><li><p>音频等其他由逻辑触发的资源释放；</p></li><li><p>C#的GC：GC.Collect()；</p></li><li><p>释放无用资源：Resources.UnloadUnusedAssets()；</p></li><li><p>Lua的GC。</p></li></ol><h3 id="5-2-Unity监测不到的内存"><a href="#5-2-Unity监测不到的内存" class="headerlink" title="5.2 Unity监测不到的内存"></a>5.2 Unity监测不到的内存</h3><ul><li><p>用户分配的native内存</p></li><li><p>例如自己写的一个C++插件分配的内存</p></li><li><p>lua分配的内存</p></li></ul><h3 id="5-3-优化建议"><a href="#5-3-优化建议" class="headerlink" title="5.3 优化建议"></a>5.3 优化建议</h3><p>Mono内存和native内存是PSS内存主要的组成部分，mono内存更多的起到内存调用的功能，因此常常成为了开发人员优化内存的起点；</p><p>而native内存中包含了大量对象的资源，也是内存优化中的重要部分。</p><h4 id="以NGUI或者说UGUI为例如何去做优化"><a href="#以NGUI或者说UGUI为例如何去做优化" class="headerlink" title="以NGUI或者说UGUI为例如何去做优化"></a>以NGUI或者说UGUI为例如何去做优化</h4><p>通常一个Panel会产生1个或多个Draw Call，以一个Panel为单位，Draw Call 的数量通常由当前 Panel 中使用的Atlas、Font的数量所决定。<br>要降低UI渲染时的 Draw Call数量则需要对 Atlas 的制作进行合理的规划，即在保证使用较少的 Atlas 的同时，还需要保证 Atlas之间不会存在交叉遮挡。<br>要注意UI Texture的使用，每个UITexture自身会占用一个Draw Call，同时如果其Depth值穿插在了其他来自相同Atlas的UISprite中，还会导致Draw Call的打断，造成不必要的额外Draw Call。<br>另外还可以借助Panel Tool和Draw Call Tool来对UI部分的Draw Call进行分析，前者可以显示每个UIPanel包含了多少个Draw Call，而后者可以显示每个Draw Call由哪些UIWidget组成。</p><h3 id="5-4-几个方面的内存管理及涉及到的要点"><a href="#5-4-几个方面的内存管理及涉及到的要点" class="headerlink" title="5.4 几个方面的内存管理及涉及到的要点"></a>5.4 几个方面的内存管理及涉及到的要点</h3><h4 id="Unity-Native-Memory"><a href="#Unity-Native-Memory" class="headerlink" title="Unity Native Memory"></a>Unity Native Memory</h4><p>Unity重载了C++所有内存分配的操作符</p><ul><li><p>Allocator与memory lable<br>memory lable是内存操作符需要的一个参数，就是在profiler中的各种lable，作用是将这块内存分配到哪一个类型的Allocator池中，每一个Allocator池单独做自己的跟踪</p></li><li><p>NewAsRoot<br>所有的Allocator的生成都是在执行NewAsRoot的操作符的前提下生成的，NewAsRoot会生成memory island作为一个root，在这个root下面会有很多子内存，例如一个shader，加载一个shader的时候，会生成该shader的root，每个shader会有很多的子数据，例如subshader pass等，会作为该root的子内存，在统计Runtime的内存时，只会统计root</p></li><li><p>会及时返还给系统</p></li></ul><h5 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h5><p>注意scene中GameObject的数量是否过多，数量过多会导致native内存显著增涨，在创建一个GameObject的时候，Unity会在C++中构建一个或者多个的Object来保存相关信息，因此，当发现Native内存过大时，优先检查Scene中的GameObject数量</p><h5 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h5><ol><li><p>DSP buffer<br>Unity中对应多档的设置，当需要播放声音时，会向CPU发送对应指令，如果指令发送太频繁，会导致CPU和IO压力 ,因此很多的音频插件，例如Unity中使用的，会使用DSP buffer，当这个buffer被填满之后，再发送指令，所以当这个buffer越大，CPU压力越小，内存占用越多，声音延迟也越大，因为每次都要等这个buffer被填满后才能播放，在一些Android设备上常常出现声音延迟过大，可以优先看看这个选项</p></li><li><p>Force to mono<br>很多的音频都是双声道的，但是左右声道完全一致，这就会导致内存和包体空间的浪费，在这种情况下，开启这个选项，会强制为单声道，减少内存和包体大小，对音质要求不高的项目可以使用（注：测试发现，只是把音频文件变为单声道，实际播放的时候，例如是双声道播放，还是双声道的，只是播放的是一样的）</p></li></ol><h5 id="code-size"><a href="#code-size" class="headerlink" title="code size"></a>code size</h5><p>很多人忽略的问题，代码本身也占内存（也会导致cache missing），其中一个主要的问题是模板泛型的滥用，编译C++时，会把所有的泛型展开为静态类，如果一个类使用了四个泛型，编译出来的cpp文件可能高达25M，这对il2cpp的编译速度造成很大影响，因为一个单一的cpp文件，是无法并行编译的</p><h5 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h5><ol><li><p>TypeTree<br>用于不同版本构建的AssetBundle可以在不同版本的Unity上保持兼容，防止序列化出错，如果Build AssetBundle的Unity版本和运行时的版本一致，可以关闭这个功能，关闭之后有三个好处<br>a. 减少内存占用<br>b. 减小包体大小<br>c. build和运行时会变快，因为当需要序列化有TypeTree的AssetBundle时，会序列化两次，先序列化TypeTree信息，再序列化数据，反序列化也需要两次</p></li><li><p>LZ4&amp;Lzma<br>LZ4是一种trunk-base的压缩技术，速度几乎是Lzma的10倍，但是压缩的体积会高出30%，trunk-base的压缩方式，在解压时可以减少内存占用，因为不需要解压整个文件，解压每个trunk的时候，可以复用buffer（在中国增强版中会推出一个基于LZ4的AssetBundle加密功能）</p></li><li><p>Size&amp;Count<br>就是AssetBundle的颗粒度控制，尽量减少AssetBundle的数量，可以减少AssetBundle头文件的内存和包体大小占用，有的资源的头文件甚至比数据还大，官方建议一个AssetBundle的大小在1-2M之间，不过这个建议是考虑网络带宽的影响，实际使用可以根据自身的环境设置</p></li></ol><h5 id="Resources文件夹"><a href="#Resources文件夹" class="headerlink" title="Resources文件夹"></a>Resources文件夹</h5><p>能不用就不用，在打包的时候，Unity也会为所有的Resources下面的资源构建一个头文件，一棵红黑树(R-B Tree)，在游戏启动的时候就会加载进内存，并且不会卸载，因此也会拖慢启动速度，因为红黑树没有加载分析完，是不会进入游戏的，目前这种方式主要用于Debug，甚至一些公司在Debug也不会使用Resources，而使用AssetBundle了</p><h5 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h5><ol><li><p>upload buffer<br>和DSP buffer类似，就是填满多少Texture数据时，向GPU push一次</p></li><li><p>r/w<br>如果没有必要就不要开启，一个Texture正常的加载流程为<br>加载进内存 -&gt; 解析 -&gt; upload buffer -&gt; 从内存中delete<br>开启选项后，不会从内存delete，导致内存和显存中都存在一份（注：貌似iOS不会存在两份，而是使用一个虚拟指针，指向同一块数据，具体细节可以查证一下）</p></li><li><p>mip maps<br>例如UI这些就别开启了，也能减少内存占用</p></li></ol><h5 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h5><ol><li><p>r/w<br>和Texture r/w类似，能不开就不开</p></li><li><p>compression<br>需要注意的是，在某些版本中，开了还不如不开，需要自己测试一下</p></li></ol><h5 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h5><p>可以看看Unity官方的最佳实践（<a href="https://blog.csdn.net/greedylin/article/details/80645860" target="_blank" rel="noopener">https://blog.csdn.net/greedylin/article/details/80645860</a>）</p><h4 id="Unity-Managed-Memory"><a href="#Unity-Managed-Memory" class="headerlink" title="Unity Managed Memory"></a>Unity Managed Memory</h4><p>详见我的笔记：Unity游戏Mono内存管理与泄漏</p><h5 id="VM内存池"><a href="#VM内存池" class="headerlink" title="VM内存池"></a>VM内存池</h5><ol><li><p>VM会返还内存给OS吗？<br>会的，条件是同一个内存block，6次GC都没有访问到时，就会返还，所以概率很小，特别是mono，il2cpp几率还会高一点</p></li><li><p>当VM内存池高于某个阈值时，会根据一些条件，乘出一块内存</p></li><li><p>注意，有时候托管内存已经释放了，实际内存可能还会涨，因为内存碎片化的问题，导致一些内存块无法复用，建议操作内存时，先使用大内存，再使用小内存</p></li></ol><h5 id="GC机制考量"><a href="#GC机制考量" class="headerlink" title="GC机制考量"></a>GC机制考量</h5><ol><li><p>Throughput（回收能力）<br>一次回收，能够回收多少的内存</p></li><li><p>Pause times（暂停时长）<br>回收时，对主线程的影响有多大</p></li><li><p>Fragmentation（碎片化）<br>回收之后，回收的内存会对整体碎片化贡献多少</p></li><li><p>Mutator overhead（额外消耗）<br>回收行为本身的消耗</p></li><li><p>Scalability（可扩展性）<br>能否扩展到多线程</p></li><li><p>Portability（可移植性）<br>能否在不同平台使用</p></li></ol><h5 id="Boehm"><a href="#Boehm" class="headerlink" title="Boehm"></a>Boehm</h5><p>Unity当前使用的GC算法</p><ol><li><p>Non-generational（不分代式）<br>分代的特征是指：例如会将大块内存 小内存以及超小内存 长久内存（例如一块长时间未访问的内存会移入长久内存）会放在不同的内存区域管理，Unity未采用的一个考量是，不分代式的速度很快</p></li><li><p>Non-compaction（非压缩式）<br>压缩是指：当一块内存被回收时，会移动其他内存，使之紧密连接，Unity目前不会压缩，会把它空着，如果下次分配的内存小于空着的内存，就会再次使用</p></li><li><p>为什么选择这种听起来不合理的GC算法呢？<br>a. 历史原因（Unity和Mono的恩怨，导致一直使用老版本的Mono）<br>b. 目前Unity的重点转向了il2cpp，采用了Incremental GC（渐进式GC），解决主线程卡顿问题，原理是分帧进行，将一次卡顿峰值平摊到多帧里面，平摊卡顿时间<br>c. 未来考虑使用SGen算法或升级Boehm？<br>SGen是一种分代的GC算法，可以减少碎片化，调用执行快，或者考虑升级Boehm算法<br>d. 目前il2cpp上面是Unity自己写的Boehm算法，在策略上会更激进</p></li></ol><h5 id="Zombie-Memory（僵尸内存）"><a href="#Zombie-Memory（僵尸内存）" class="headerlink" title="Zombie Memory（僵尸内存）"></a>Zombie Memory（僵尸内存）</h5><ol><li><p>无用内存<br>代码设计不好，以为可以释放，但是没有释放的内存，所以大家要关注活跃度不高的内存</p></li><li><p>通过代码管理和性能工具来分析</p></li></ol><h5 id="实践注意点"><a href="#实践注意点" class="headerlink" title="实践注意点"></a>实践注意点</h5><ul><li><p>Don’t Null it,but Destroy it<br>不要置空就完事了，记得显式调用Destroy</p></li><li><p>Class VS Struct<br>可以关注Unity的DOTS和ECS</p></li><li><p>Closures and anonymous methods（闭包和匿名函数）</p></li><li><p>Coroutines（协程）<br>协程可以看作闭包和匿名函数的特例，在il2cpp中，每一个闭包和匿名函数，都会new一个对象出来，只是无法访问，里面的数据，即使是你认为用完就丢的局部变量，在你用完了之后，也不会立即释放，而是等到这个对象释放才释放，有的项目在游戏一开始就开启一个协程，一直到游戏结束，这样使用是错误的，会导致闭包中的数据一直占用内存，正确的做法是用到的时候生成一个协程，不用的时候就扔掉，协程的设计不是当作线程使用的</p></li><li><p>configurations（配置表）<br>如果配置较大，不要一下全部加载进内存，有两个解决方案：</p><ol><li><p>通过网络流量获得相关的配置信息</p></li><li><p>按需加载，例如进入一个关卡时，再加载这个关卡的配置</p></li></ol></li><li><p>Singleton（单例）<br>一定要慎用，在C++的年代，这就是万恶之源，不要什么都往这里面扔，会导致内存无法释放，注意单例的引用关系，当引用关系变得复杂时，很难确定哪些东西没有及时释放</p></li></ul><h2 id="6-内存相关工具"><a href="#6-内存相关工具" class="headerlink" title="6 内存相关工具"></a>6 内存相关工具</h2><h3 id="Unity-Profiler"><a href="#Unity-Profiler" class="headerlink" title="Unity Profiler"></a>Unity Profiler</h3><h4 id="Profiler-Detailed-中的一些参数"><a href="#Profiler-Detailed-中的一些参数" class="headerlink" title="Profiler Detailed 中的一些参数"></a>Profiler Detailed 中的一些参数</h4><h2 id="7-关于Unity的闪退与卡顿"><a href="#7-关于Unity的闪退与卡顿" class="headerlink" title="7 关于Unity的闪退与卡顿"></a>7 关于Unity的闪退与卡顿</h2><h3 id="Unity程序闪退与卡顿原因"><a href="#Unity程序闪退与卡顿原因" class="headerlink" title="Unity程序闪退与卡顿原因"></a>Unity程序闪退与卡顿原因</h3><p>1.闪退<br>原因1：程序吃内存。表现为内存泄露或加载资源时闪退等。<br>原因2：程序吃CPU。表现为​程序执行复杂运算时闪退等。<br>原因3：系统内存回收机制。它按照优先级回收内存。如果内存很紧张的时候会回收掉前 台进程，有可能就把我们的程序给杀掉。<br>原因4：兼容性问题。​程序对目标设备的软硬件环境的兼容情况也会造成闪退。</p><p>2.卡顿<br>原因1：某帧堆积的任务过多。建议采用多线程或把任务量平摊到多个帧执行。</p><p>原文地址：<a href="http://blog.sina.com.cn/s/blog_80cc3d870102vefy.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_80cc3d870102vefy.html</a></p><h3 id="Unity内存不足引起崩溃的几种原因"><a href="#Unity内存不足引起崩溃的几种原因" class="headerlink" title="Unity内存不足引起崩溃的几种原因"></a>Unity内存不足引起崩溃的几种原因</h3><p>At some points a game may crash with “out of memory” though it in theory it should fit in fine. When this happens compare your normal game memory footprint and the allocated memory size when the crash happens. If the numbers are not similar, then there is a memory spike. This might be due to:</p><p>在某些时刻，一个游戏可能由于“内存不足”而崩溃。尽管理论上它最后应当是合适的。当这个问题发生而引发崩溃时，对比你的正规的游戏内存轨迹和已分配内存大小。如果得到的数字不是类似的，那么这就发生了一个内存峰值。这可能是由于：</p><ul><li><p>Two big scenes being loaded at the same time - use an empty scene between two bigger ones to fix this.<br>两个大场景被同时加载——为了解决它，在两个更大的场景中间使用一个空的场景。</p></li><li><p>Additive scene loading - remove unused parts to maintain the memory size.<br>附加的场景加载——移除没有用到的部分来维护内存大小。</p></li><li><p>Huge asset bundles loaded to the memory<br>巨大的资源包被加载到内存</p></li><li><p>Loading via WWW or instantiating (a huge amount of) big objects like:<br>通过WWW加载或是实例化（大量的实例化）庞大的对象，例如：</p><ul><li><p>Textures without proper compression (a no go for mobiles).<br>没有合适压缩的贴图（对于移动设备是无效的）。</p></li><li><p>Textures having Get/Set pixels enabled. This requires an uncompressed copy of the texture in memory.<br>被启用了 获取/设置像素 的贴图。这需要在内存中创建一个贴图的未压缩的复制品。</p></li><li><p>Textures loaded from JPEG/PNGs at runtime are essentially uncompressed.<br>动态地从JPEG/PNGs加载的贴图没有基本上被压缩。</p></li><li><p>Big mp3 files marked as decompress on loading.<br>在加载时，巨大的mp3文件被标记为解压缩。</p></li></ul></li><li><p>Keeping unused assets in weird caches like static monobehavior fields, which are not cleared when changing scenes.<br>在怪异的缓存中（像静态monobehavior区域，当变换场景时它不会被清理）保留了未使用的资源。</p></li></ul><p>Ref:<br><a href="https://blog.csdn.net/y90o08u28/article/details/87202259" target="_blank" rel="noopener">https://blog.csdn.net/y90o08u28/article/details/87202259</a><br><a href="https://blog.csdn.net/jxw167/article/details/74555351" target="_blank" rel="noopener">https://blog.csdn.net/jxw167/article/details/74555351</a><br><a href="https://www.cnblogs.com/msxh/p/12987632.html" target="_blank" rel="noopener">https://www.cnblogs.com/msxh/p/12987632.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Editor Extension】IMGUI</title>
      <link href="2023/07/25/Unity3D-%E3%80%90Editor-Extension%E3%80%91IMGUI/"/>
      <url>2023/07/25/Unity3D-%E3%80%90Editor-Extension%E3%80%91IMGUI/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>An immediate mode graphic user interface (GUI), also known as IMGUI, is a graphical user interface design pattern which uses an immediate mode graphics library to create the GUI. via. Wikipedia</p><p>即时模式图形用户界面（IMGUI）代表了一种范例，其中用户界面的创建（对于客户端应用程序）和实现更简单（对于工具箱设计器）。</p><h3 id="传统用户界面系统缓存状态的缺点"><a href="#传统用户界面系统缓存状态的缺点" class="headerlink" title="传统用户界面系统缓存状态的缺点"></a>传统用户界面系统缓存状态的缺点</h3><p>传统用户界面系统设计和使用的复杂性是由此类系统保持了各种状态引起的。程序员通常被要求在应用程* 序和用户界面之间来回主动地复制状态，以便用户界面反映应用程序的状态，反之，为了使用户界面中发生的更改影响应用程序的状态。UI系统的状态是实际状态的一份COPY/CACHE。</p><p>从客户端应用的角度看，UI更像是一堆对象的集合（通常称为widget），这些对象分装了需要和应用交互的各种状态。这个同步过程是双向的，为了让用户了解到当前应用的状态，状态需要从应用端转移到UI端；为了让应用知道当前用户的操作，状态需要从UI端转移到应用端。 </p><p>此外，通知应用程序用户与接口交互的方式（这反过来表明需要重新同步状态）通常采用回调的形式。这需要应用程序为感兴趣的任何低级交互实现“事件处理程序”，通常是通过手动或通过各种代码生成技巧将某些工具箱基类子类化；在任何一种情况下，都会使客户机应用程序的生命周期更加复杂。</p><h3 id="IMGUI"><a href="#IMGUI" class="headerlink" title="IMGUI"></a>IMGUI</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>IMGUI通过要求应用程序实时显式传递可视化和交互所需的所有状态来消除这种状态同步。 用户界面只保留了为方便系统支持的每种小部件所需的功能所需的最小状态量。</p><p>Widget不再是对象，甚至可以说是不存在的。它们采用过程方法调用的形式，用户界面本身从有状态的对象集合变成了方法调用的实时序列。</p><p>这种实现方式的基础是实时应用程序循环的概念，也就是说，应用以实时的帧率处理逻辑和绘制（30 frames per second或者更高）。在游戏场景，这个是很常见的。</p><p>乍看起来，通过传递参数的方式实现看上去很冗余，但实际上并不是这样的。看上去会影响绘制性能。但是，对于现代的CPU和GPU而言，这个不是问题。</p><p>其优点在于简单和灵活。删除用户界面系统中的隐式状态缓存可以减少与缓存相关的bug的可能性，也完全消除了工具箱将小部件作为对象公开给客户机应用程序的需要。在逻辑上，小部件从对象变为方法调用。我们将看到，这从根本上改变了客户机应用程序处理用户界面实现的方式。</p><p>简单总结，IMGUI有以下优点：</p><ul><li><p>丝毫不需要分配内存，也即需要的内存为零！</p></li><li><p>速度很快。即使使用非常复杂的UI并且只有单线程的情况下，大多数（如果不是全部）ImGUI在60fps（帧）的速度下运行没有任何问题。</p></li><li><p>不需要对必须管理的对象进行创建和销毁操作。</p></li><li><p>没有状态，因为没有对象来存储状态。</p></li><li><p>基本不需要编制数据。</p></li><li><p>没有需要注册或响应的事件或回调。</p></li></ul><h4 id="IMGUI的缺点"><a href="#IMGUI的缺点" class="headerlink" title="IMGUI的缺点"></a>IMGUI的缺点</h4><h5 id="可能需要更多的CPU"><a href="#可能需要更多的CPU" class="headerlink" title="可能需要更多的CPU"></a>可能需要更多的CPU</h5><p>传统的GUI系统当元素有变化时，只需重新绘制局部元素。</p><p>ImGUI则相反，任何时候你想更改任何内容，整个图形用户界面就要重新绘制。即使是光标。以我们进入Excel示例，所有75个工具栏控件和300个单元格都将因为一个闪烁的光标而重新绘制。这是IMGUI的最坏情况。大量的CPU被浪费了。</p><h5 id="可访问性问题"><a href="#可访问性问题" class="headerlink" title="可访问性问题"></a>可访问性问题</h5><p>通常GUI不保留任何数据，所以它可能做不了保留模式GUI能够做的那些事情。</p><h5 id="动画的支持性"><a href="#动画的支持性" class="headerlink" title="动画的支持性"></a>动画的支持性</h5><p>大多数ImGUI都是无状态的，所以所有的动画都取决于应用程序。</p><h2 id="Unity-IMGUI"><a href="#Unity-IMGUI" class="headerlink" title="Unity IMGUI"></a>Unity IMGUI</h2><p>IMGUI is a code-driven GUI system. It is driven by calls to the OnGUI function on any script which implements it. </p><p>“Immediate Mode” refers to the way the IMGUI is created and drawn. To create IMGUI elements, you must write code that goes into a special function named OnGUI. The code to display the interface is executed every frame, and drawn to the screen. There are no persistent gameobjects<br>other than the object to which your OnGUI code is attached, or other types of objects in the hierarchy related to the visual elements that are drawn.</p><h3 id="Unity-GameObject-based-UI-system-vs-IMGUI"><a href="#Unity-GameObject-based-UI-system-vs-IMGUI" class="headerlink" title="Unity GameObject-based UI system vs IMGUI"></a>Unity GameObject-based UI system vs IMGUI</h3><p>GameObject-based UI system has far better tools to work with the visual design and layout of the UI.</p><p>适用情况：Unity’s main GameObject-based UI system is used for normal in-game user interfaces that players might use and interact with.</p><p>IMGUI allows you to create a wide variety of functional GUIs using code. Rather than creating GameObjects, manually positioning them, and then writing a script that handles its functionality, you can do everything at once with just a few lines of code. The code produces GUI controls that are drawn and handled with a single function call.</p><h3 id="Controls"><a href="#Controls" class="headerlink" title="Controls"></a>Controls</h3><p>The Control defines the content</p><h3 id="GUIStyle-amp-GUISkin"><a href="#GUIStyle-amp-GUISkin" class="headerlink" title="GUIStyle &amp; GUISkin"></a>GUIStyle &amp; GUISkin</h3><p>GUItyles define the appearance of a GUI Control. GUISkins are a collection of GUIStyles. </p><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><h4 id="Fixed-Layout-amp-Automatic-Layout"><a href="#Fixed-Layout-amp-Automatic-Layout" class="headerlink" title="Fixed Layout &amp; Automatic Layout"></a>Fixed Layout &amp; Automatic Layout</h4><ul><li><p>Fixed Layout makes sense to use when you have a pre-designed interface to work from. </p></li><li><p>Automatic Layout makes sense to use when you don’t know how many elements you need up front, or don’t want to worry about hand-positioning each Control.</p></li></ul><p>About Automatic Layout:</p><ul><li><p>GUILayout is used instead of GUI</p></li><li><p>No Rect() function is required for Automatic Layout Controls</p></li></ul><h4 id="GUILayoutOptions"><a href="#GUILayoutOptions" class="headerlink" title="GUILayoutOptions"></a>GUILayoutOptions</h4><p>You can use GUILayoutOptions to override some of the Automatic Layout parameters. You do this by providing the options as the final parameters of the GUILayout Control.</p><h3 id="GUI-vs-EditorGUI"><a href="#GUI-vs-EditorGUI" class="headerlink" title="GUI vs EditorGUI"></a>GUI vs EditorGUI</h3><p>The difference between GUI and EditorGUI is primarily just their use case. GUI is used to display GUI items in game. GUI was the original way of creating Unity UI before their new canvas APIs. EditorGUI is used to create custom editors for your scripts and other editor customization.</p><p>One exception to that rule is that certain GUI classes are used for both. For instance, GUISkin and GUIStyle are used by both and their current values are accessed using GUI.skin regardless if used in game or in editor.</p><h2 id="经验与思考"><a href="#经验与思考" class="headerlink" title="经验与思考"></a>经验与思考</h2><h3 id="关于OnGUI调用逻辑的探究"><a href="#关于OnGUI调用逻辑的探究" class="headerlink" title="关于OnGUI调用逻辑的探究"></a>关于OnGUI调用逻辑的探究</h3><p>Monobehaviour脚本的OnGUI在Play时确实是会每帧都调用，每帧都重新绘制内容。表现在使用如下脚本，Play时，字体会随着正弦函数不断连续变大变小。</p><pre><code class="lang-csharp">// C# exampleusing UnityEngine; using System.Collections; public class Fontsize : MonoBehaviour{ void OnGUI (){ //Set the GUIStyle style to be labelGUIStyle style = GUI.skin.GetStyle (&quot;label&quot;); //Set the style font size to increase and decrease over time//This specific example requires that the default font (Arial) is loaded and marked as dynamic. You cannot change the size of any font that is not marked as dynamic.style.fontSize = (int)(20.0f + 10.0f * Mathf.Sin (Time.time)); //the font does not smoothly change size, this is becauses there is not an infinite number of font sizes.GUI.Label (new Rect (10, 10, 200, 80), &quot;Hello World!&quot;); } }</code></pre><p>但是在EditorWindow下，如果OnGUI中没有写EditorWindow.Repaint()的话，OnGUI并不会每帧都调用，字体大小不会自动连续地按照正弦曲线变大变小。只有当触发一定的事件时（比如点击窗口，在某个按钮上hover等），EditorWindow才会重新绘制，调用OnGUI。</p><p>如果OnGUI中主动调用Repaint()，则OnGUI会每帧都调用，原理还不明确。</p><h3 id="EditorGUI的一个BUG"><a href="#EditorGUI的一个BUG" class="headerlink" title="EditorGUI的一个BUG"></a>EditorGUI的一个BUG</h3><p>EditorGUI有两个函数，BeginChangeCheck、EndChangeCheck()，用以检测特定范围内，UI元素的值是否发生改变。<br>当Begin与Begin发生嵌套时，会</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/Immediate_mode_GUI" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Immediate_mode_GUI</a></p><p><a href="https://www.tangledrealitystudios.com/development-tips/gui-vs-guilayout-vs-editorgui-vs-editorguilayout-and-when-to-use-them/" target="_blank" rel="noopener">https://www.tangledrealitystudios.com/development-tips/gui-vs-guilayout-vs-editorgui-vs-editorguilayout-and-when-to-use-them/</a></p><p><a href="https://www.cnblogs.com/grass-and-moon/p/13864696.html" target="_blank" rel="noopener">https://www.cnblogs.com/grass-and-moon/p/13864696.html</a><br><a href="https://blog.csdn.net/csdnnews/article/details/90746003" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/90746003</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内存】PSS内存组成</title>
      <link href="2023/07/25/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91PSS%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90/"/>
      <url>2023/07/25/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91PSS%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p><img src="【内存】PSS内存组成/1631087823435.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>”游戏程序员核心竞争力“问题总结</title>
      <link href="2023/07/25/Unity3D-%E2%80%9D%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B%E2%80%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>2023/07/25/Unity3D-%E2%80%9D%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B%E2%80%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="信息提取"><a href="#信息提取" class="headerlink" title="信息提取"></a>信息提取</h1><h2 id="道理"><a href="#道理" class="headerlink" title="道理"></a>道理</h2><p><strong>缓解焦虑的唯一办法，只有提高能力。</strong></p><h2 id="研究领域"><a href="#研究领域" class="headerlink" title="研究领域"></a>研究领域</h2><ol><li>客户端渲染</li><li>服务器架构</li><li>gameplay专家，游戏逻辑</li><li>技术管理/主程序</li><li>优化</li><li>引擎功能开发</li></ol><h1 id="内容搜集"><a href="#内容搜集" class="headerlink" title="内容搜集"></a>内容搜集</h1><h2 id="MaxwellGeng"><a href="#MaxwellGeng" class="headerlink" title="MaxwellGeng"></a>MaxwellGeng</h2><p>什么叫“数学比较差，做不了图形的东西”？ 我也软件工程在读，我数学底子也差（微分和积分一个BC一个C了解一下？），现在起码通了一遍PBR的材质和后处理特效了，也跟着GDC和Siggraph分享以及Github上众多前辈留下的脚印比着葫芦画瓢写了一套晃晃悠悠的渲染管线了，这不叫“图形学的东西”吗？CPP底子薄？谁CPP底子不薄啊？？生下来就会啊？！</p><h2 id="Jerish"><a href="#Jerish" class="headerlink" title="Jerish"></a>Jerish</h2><p>我有价值，起码当前的我是有竞争力的，我在UE4上（以及相关技术）的功底就是我当前的核心竞争力。我有一个特点，就是能钻研，你只要有源码我就能看，愿意主动看，而且还尽可能要求自己都看懂，看懂还能给人讲明白，能正确的修改其中的问题。</p><p><strong>竞争力就是你的必要性以及不可替代性。必要性是指你所在的技术位置很重要，很多游戏团队都需要。不可替代性是指花同样的成本（或稍微高一些）去找一个能替代你的人很困难。</strong></p><p>在完成自己的任务后就开始研究身边人的工作内容，看看他们做的东西难点在哪？我有没有办法解决？差距在哪里？同时，我在空闲时间就去看各大游戏公司的招聘条件，主程什么要求、高级程序员什么要求，我离这个要求有多远。实在一点的说，衡量你竞争力的标准就是你能不能找到工资更高的工作，所以你完全可以通过网络，技术qq群等去查找你需要的能力。  </p><p><img src="”游戏程序员核心竞争力“问题总结/Image.png" alt=""></p><p>专心搞技术，那么就 <strong>客户端渲染</strong> 、 <strong>服务器架构</strong> 选一个不停的深入研究<br>国内短期还不会需要 <strong>gameplay专家</strong><br>如果想走 <strong>技术管理</strong> ，那就不要在意客户端服务器gameplay，能学多少学多少，然后多跟项目，了解各方面的技术与项目管理细节。我在和主程沟通的时候，发现他什么都懂，可以流畅的与所有程序沟通不同的技术，定制目标，安排任务，还能提出建议给出参考资料。这就是 <strong>主程序</strong> 的竞争力。</p><h2 id="flashyiyi"><a href="#flashyiyi" class="headerlink" title="flashyiyi"></a>flashyiyi</h2><p>做架构的，做图形的，做战斗的，做UI的，做优化的，做工具的</p><p>程序员只靠技术，竞争力确实比较有限，但只要你能稍微跨点界，你的竞争力都会飞速上涨，跨美术或者策划都行， <strong>管理能力强</strong> ，也是优点。</p><p><strong>架构</strong> 就不用说了，基本都是老资格。重要程度也不用多说。</p><p>做 <strong>优化</strong> 的不是说只做优化，而是会做优化。你会做优化，你就有了自己的核心竞争力。说的明白点就是搞底层的。</p><p><strong>做工具的——引擎功能开发</strong> 要点是了解各个开发者的真实需求，而且架构能力要好，通用性要高，做出来的东西不至于没人愿意用（随便找个人来做这个的结果通常都是没人用）。我这个名字可能不太好，其实就是做引擎的。但现在没必要做引擎，所以就是做通用组件，搞编辑器啥的。<br>我举个具体的例子，一个数据编辑器的要点是什么？1.修改简单，具体做法就是通过元标签生成界面。2.热更，修改数据后在游戏内部就能生效。然而这种需求，基本上不要指望策划或者美术会给你提，他们只会缺什么要什么。这得靠你的悟性。当然实现上也不能说没有难度。</p><p><strong>图形</strong> 好像也不用提，因为稍微有点门槛。图形后面还可以转TA，必要性更高，即使是国内的低级项目也有需求（高级的图程，不做牛逼东西，确实不太用得上）。</p><p>做 <strong>战斗</strong> 的，基本就是写逻辑，oop能力要强，基本也不会没人要。而且做战斗的经常会直接参与战斗细节的调整，因为自己调比暴露参数快多了，细节参数需求也很难到位，尤其遇到纠缠在一起的复杂逻辑。能自己调战斗的程序员必然是有竞争力的，没有也有，毕竟逻辑足够复杂，而且招到合适的不比招个图程容易。如果有人觉得图程更难，说明他们游戏的逻辑部分太简单。逻辑这东西，难度是随着复杂度指数级上升的。</p><h2 id="顾煜"><a href="#顾煜" class="headerlink" title="顾煜"></a>顾煜</h2><p><strong>缓解焦虑的唯一办法，只有提高能力。</strong><br>不是只有做图形学才是做游戏开发的唯一出路，游戏开发领域值得学习的东西太多了。</p><p>先打好基础。游戏开发本质上还是软件开发，编程语言本身、设计模式、架构、软件工程知识等，都要深入学习。</p><p>再从Gameplay切入。寻路、人物行为、高层动画、网络同步方案、UI界面、各种脚本，高层gameplay一般比较直观，不存在太多的前置技术需求，每一个领域都是可以快速切入，在几个月里面深入熟悉。</p><p>然后考虑偏底层的模块。多线程、资源管理、内存管理、性能优化、工具链、渲染等等。这些领域需要一些前置的技术学习，但每一个领域也都不是学不会的，只是费时更久些。</p><p>最后方方面面知识都接触过了，融会贯通，培养技术的想象力，能结合各种技术，随时结合已有的技术，解决具体的问题。</p><h2 id="gougou槐宏文"><a href="#gougou槐宏文" class="headerlink" title="gougou槐宏文"></a>gougou槐宏文</h2><p>最稀缺的人才，就是高质量独立游戏制作者的模式，一个人可以包揽设计和实现，一个人可以完成迭代，从设计到打磨玩法全部做好（需要动画美术支持可能），这是最理想的gameplay最稀缺的人才。</p><p>做游戏是工程学，不是做研究。一个好的工作室的技术积累，大部分的时间不是研究高精尖的算法，而是 <strong>在优化自己的生产管线</strong> 。也就是说，如何 <strong>提高自己工作室某个类型开发过程的效率</strong> ，降低开发成本，优化迭代速度，靠着强大的产出工具链产出内容，完成优秀的产品。如果你仔细看看很多gdc关于pipeline的talk，看看虚幻引擎的工具集，等等，你会发现，这里面不只是技术的积累，更是在某一个游戏领域经验的积累。比如ue4的cinematic的工具集，没有做过很多大型3A游戏的cine的经验是没有办法优化的如此好的，这里面当然需要好的程序技术，但是也需要对这个行业，对游戏开发很懂的人才能做出来，这不是一个算法的问题。好的pipeline可以极大的节省成本，优化流程，是一个游戏工作室最核心的竞争力和技术积累之一。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows与MacOS在U3D项目中的使用</title>
      <link href="2023/07/25/Unity3D-Windows%E4%B8%8EMacOS%E5%9C%A8U3D%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2023/07/25/Unity3D-Windows%E4%B8%8EMacOS%E5%9C%A8U3D%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Windows的优劣</p><ol><li><p>优势</p><ol><li><p>和美术协作比较方便</p></li><li><p>显卡性能也有保障</p></li><li><p>设备性价比高</p></li><li></li></ol></li></ol><p>MacOS的优劣</p><ol><li><p>优势</p><ol><li><p>出包或者做平台关联 api。 有时候要导出 xcode 项目，需要在 xcode 里写代码。</p></li><li><p>好看逼格高系统舒服</p></li></ol></li><li><p>设备成本较高。同等价位设备性能较差</p></li></ol><p>主要使用windows 开发，mac 打包</p><p>参考讨论：<a href="https://www.v2ex.com/t/670347" target="_blank" rel="noopener">https://www.v2ex.com/t/670347</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YAML</title>
      <link href="2023/07/25/Unity3D-YAML/"/>
      <url>2023/07/25/Unity3D-YAML/</url>
      
        <content type="html"><![CDATA[<p>YAML TAG： <a href="https://stackoverflow.com/questions/15233335/i-dont-understand-what-a-yaml-tag-is" target="_blank" rel="noopener">https://stackoverflow.com/questions/15233335/i-dont-understand-what-a-yaml-tag-is</a></p><p>YAML 文档：<a href="https://yaml.org/spec/1.2.2/#rule-ns-tag-directive" target="_blank" rel="noopener">https://yaml.org/spec/1.2.2/#rule-ns-tag-directive</a></p><p>YAML 博客：<a href="https://www.jianshu.com/p/20c3cde0f189" target="_blank" rel="noopener">https://www.jianshu.com/p/20c3cde0f189</a></p><p>Unity YAML解析方案：<a href="https://stackoverflow.com/questions/21473076/pyyaml-and-unusual-tags" target="_blank" rel="noopener">https://stackoverflow.com/questions/21473076/pyyaml-and-unusual-tags</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity线上技术大会</title>
      <link href="2023/07/25/Unity3D-Unity%E7%BA%BF%E4%B8%8A%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A/"/>
      <url>2023/07/25/Unity3D-Unity%E7%BA%BF%E4%B8%8A%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<p><img src="Unity线上技术大会/1605524504449.png" alt="Alt text"></p><p><img src="Unity线上技术大会/1605526082081.png" alt="Alt text"></p><p><img src="Unity线上技术大会/1605526188199.png" alt="Alt text"></p><p>Unity</p><h3 id="ShaderProfiler"><a href="#ShaderProfiler" class="headerlink" title="ShaderProfiler"></a>ShaderProfiler</h3><p>capture<br>看到当前Active的shader<br>subshader<br>variant</p><h3 id="AssetBundle加密方案"><a href="#AssetBundle加密方案" class="headerlink" title="AssetBundle加密方案"></a>AssetBundle加密方案</h3><h3 id="instant-game"><a href="#instant-game" class="headerlink" title="instant game"></a>instant game</h3><p>安装包降低<br>资源打包成独立的AssetBundle，单个包大小不超过1MB<br>视线内的资源优先加载。</p><h3 id="Windup"><a href="#Windup" class="headerlink" title="Windup"></a>Windup</h3><p><img src="Unity线上技术大会/1605527989245.png" alt="Alt text"></p><p><img src="Unity线上技术大会/1605528077501.png" alt="Alt text"></p><p><img src="Unity线上技术大会/1605528097381.png" alt="Alt text"></p><p><img src="Unity线上技术大会/1605528110907.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity相关Culling知识</title>
      <link href="2023/07/25/Unity3D-Unity%E7%9B%B8%E5%85%B3Culling%E7%9F%A5%E8%AF%86/"/>
      <url>2023/07/25/Unity3D-Unity%E7%9B%B8%E5%85%B3Culling%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>Frustum Culling</p><p>剔除被其他物体遮挡的，摄像机不可见(但在视锥体内)的渲染物体。使用 Occlusion Culling 需要手动设置，并在 Occlusion Culling Window 中通过 Bake 计算剔除数据。</p><p><a href="https://docs.unity3d.com/Manual/OcclusionCulling.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/OcclusionCulling.html</a></p><p> <strong>Builtin管线</strong></p><p>视锥体剔除 - 视锥体剔除是引擎自己做的，在给GPU提交数据进行渲染前，会执行视锥体剔除，决定哪些可见哪些不可见。经过剔除之后，Renderer的isVisible值就表示相应物体的可见性，不过此时已经在这帧的Update之后了。在Update当中取IsVisible属性获取的实际上是上一帧的可见性。 至于视锥体剔除的实现方法我们不清楚，可能引擎底层会有一些优化，使用kd-tree进行空间划分等等。</p><p> <strong>SRP的Culling：</strong></p><ol><li><p>SRP的Culling可以自己写</p></li><li><p>URP的管线相对比较固定，可定制化程度低，Culling不太好自己写</p></li></ol><p>Occlusion Culling is different from Frustum Culling. Frustum Culling only disables the renderers for objects that are outside the camera’s viewing area but does not disable anything hidden from view by overdraw. Note that when you use Occlusion Culling you will still benefit from Frustum Culling.</p><p>Occlusion Culling </p><p>在移动端使用的比较少，属于用 CPU时间换一定的CPU时间和一定的GPU时间的操作。使用方法是：预先烘焙遮挡剔除信息（对于一定的区域，哪些物体被遮挡），在游戏运行时，经过视锥体剔除之后，对于视锥体内的物体，相机到了一定的位置，会去取预先烘焙的信息，来判断哪些物体被遮挡，对相应的物体进行剔除，进而节省被遮挡的物体提交渲染进行、在GPU端进行绘制的时间。</p><p>Camera.layerCullDistance</p><p>For performance reasons, you might want to cull small objects earlier. For example, small rocks and debris could be made invisible at much smaller distance than large buildings. To do that, put small objects into a separate layer and set up per-layer cull distances using Camera.layerCullDistances script function.</p><p><a href="https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html</a></p><p>CullingGroup API</p><p>CullingGroup offers a way to integrate your own systems into Unity’s culling and LOD pipeline.The CullingGroup will calculate visibility based on frustum culling and static occlusion culling only. It will not take dynamic objects into account as potential occluders.</p><p><a href="https://docs.unity3d.com/Manual/CullingGroupAPI.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/CullingGroupAPI.html</a></p><p>Unity的CullingGroup API是纯逻辑的东西，不影响渲染。其使用方法是：在逻辑代码中定义CullingGroup，Group中加入一些球体(位置与半径，是逻辑上的球体，实际是不可见的)，并加入要检测的相机，渲染时，Unity会判断这些球体是否可见，进而判断CullingGroup的可见性。在渲染之后，可以在代码中获取该Group的可见性，进而据此控制一些逻辑。如果不用代码去取CullingGroup的信息，那么它就是没有用的。</p><p>ref: <a href="https://blog.csdn.net/kenight/article/details/82760667" target="_blank" rel="noopener">https://blog.csdn.net/kenight/article/details/82760667</a></p><p>使用Unity提供的API自己实现视锥体剔除逻辑：</p><p>using System.Collections.Generic;</p><p>using UnityEditor;</p><p>using UnityEngine;</p><p>using System.Linq;</p><p>public class FrustumTest : MonoBehaviour</p><p>{</p><p>public Camera CulingCamera;</p><p>public Renderer[] CullingTestObjects;</p><p>private Plane[] planes;</p><p>void OnEnable()</p><p>{</p><p>planes = new Plane[6];</p><p>}</p><p>void Update()</p><p>{</p><p>GeometryUtility.CalculateFrustumPlanes(CulingCamera, planes);</p><p>for (var index = 0; index &lt; CullingTestObjects.Length; index++)</p><p>{</p><p>var bounds = CullingTestObjects[index].bounds;</p><p>var result = GeometryUtility.TestPlanesAABB(planes, bounds);</p><p>CullingTestObjects[index].enabled = result;</p><p>}</p><p>}</p><p>[MenuItem(“Test/Create”)]</p><p>static void Create()</p><p>{</p><p>var gos = new List<GameObject>();</p><p>var root = new GameObject(“Root”).transform;</p><p>for (var i = 0; i &lt; 10; i++)</p><p>{</p><p>for (var j = 0; j &lt; 10; j++)</p><p>{</p><p>for (var k = 0; k &lt; 10; k++)</p><p>{</p><p>var go = GameObject.CreatePrimitive(PrimitiveType.Cube);</p><p>go.transform.position = new Vector3(i, j, k) * 2;</p><p>go.transform.parent = root;</p><p>gos.Add(go);</p><p>}</p><p>}</p><p>}</p><p>var test = new GameObject(“FrustumTest”).AddComponent<FrustumTest>();</p><p>test.CulingCamera = Camera.main;</p><p>test.CullingTestObjects = gos.Select(item =&gt; item.GetComponent<Renderer>()).ToArray();</p><p>}</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity的架构</title>
      <link href="2023/07/25/Unity3D-Unity%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
      <url>2023/07/25/Unity3D-Unity%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><p>Unity当中渲染的部分是用C++执行的<br>Mono是Unity运行过程中的一部分，负责在特定的时间编译C#脚本，运行C#程序集。<br>所以，操作系统之上是基于C++的Unity程序，在Unity当中的一部分是Mono，Mono负责Unity当中与C#相关的部分。</p><p>整个Unity程序的运行是基于一帧一帧的刷新来进行的。<br>如果在一帧当中，调用了一个耗时比较长的函数，整个程序就会卡在这一帧，直到这个函数调用结束。<br>在编辑器模式下，通过MenuItem调用一个函数，就是在一帧里面进行函数调用，这个函数耗时比较长，这一帧就会等待这个函数调用完再刷新。</p><p>Unity当中有些程序是支持多线程的，比如烘培操作，烘培的时候，会在右下角开一个进度条，但是Game界面的程序还是会不断地一帧一帧刷新，不会阻塞，就是在多个线程下运行的结果。</p><p>在Mono之上是整个C#环境，Unity在运行时，C#环境就一直在内存当中运行的。</p><h2 id="关于异常"><a href="#关于异常" class="headerlink" title="关于异常"></a>关于异常</h2><p>在脚本运行的时候，抛出异常，会一层一层往上抛。<br>异常被try catch时，如果catch到，那么try当中的代码就会跳过。也就是说，被try的函数就会在异常出终止，进而从catch语句块之后的代码开始继续运行。</p><p>如果自己写的程序不catch这个异常，那么这个异常会最终被Unity catch到，那么，Unity调用的我写的整个函数，就会终止掉。而实际上，整个C#的程序是没有终止的，Unity的C#程序还在内存当中，与我自己catch到异常没有本质的区别。而且，出异常的函数所分配的资源，如果不写代码释放掉，就没有其他好办法来释放了。因为这部分资源是在Unity的C#环境中的，只有重启整个Unity，才能强制释放。</p><p>如果某个脚本索引了一个文件流，由于文件流没有被释放而造成文件被锁、无法重新打开，可以对这个脚本进行reimport，Why？</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity的渲染顺序</title>
      <link href="2023/07/25/Unity3D-Unity%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/"/>
      <url>2023/07/25/Unity3D-Unity%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="决定渲染顺序的因素"><a href="#决定渲染顺序的因素" class="headerlink" title="决定渲染顺序的因素"></a>决定渲染顺序的因素</h2><p><img src="Unity的渲染顺序/1617976734905.png" alt="Alt text"></p><h3 id="Camera-Depth"><a href="#Camera-Depth" class="headerlink" title="Camera Depth"></a>Camera Depth</h3><p>按照Camera的Depth值从低到高的顺序，逐个Camera进行渲染。</p><p><img src="Unity的渲染顺序/1617962792081.png" alt="Alt text"></p><p>每个Camera绘制的内容可以在CullingMask当中设置——设置绘制哪些Layers的物体</p><p><img src="Unity的渲染顺序/1617962839947.png" alt="Alt text"></p><p>物体的Layer可以在Inspector面板进行设置。</p><p><img src="Unity的渲染顺序/1617962903268.png" alt="Alt text"></p><h3 id="Opaque-Skybox-Transparent"><a href="#Opaque-Skybox-Transparent" class="headerlink" title="Opaque-Skybox-Transparent"></a>Opaque-Skybox-Transparent</h3><p>Queue&lt;=2500 - Opaque<br>Queue&gt;=2501 - Transparent</p><h3 id="Sorting-Layers-Order-in-Layer"><a href="#Sorting-Layers-Order-in-Layer" class="headerlink" title="Sorting Layers + Order in Layer"></a>Sorting Layers + Order in Layer</h3><p>可在Project Settings-&gt;Tags and Layers-&gt;SortingLayers中添加Layer。</p><p><img src="Unity的渲染顺序/1617975393846.png" alt="Alt text"></p><p>在ParticleSystem、Sprite等Unity动态生成网格的Component中设置Sorting Layer与Order in Layer，来决定物体绘制的顺序，绘制时按从小到大排序。</p><p><img src="Unity的渲染顺序/1617976086216.png" alt="Alt text"></p><p><img src="Unity的渲染顺序/1617976104615.png" alt="Alt text"></p><h3 id="RenderQueue"><a href="#RenderQueue" class="headerlink" title="RenderQueue"></a>RenderQueue</h3><p>RenderQueure是Material的一个属性。<br>按照渲染队列，从低到高绘制。</p><p>Background (1000) - rendered before any others. You’d typically use this for things that really need to be in the background.</p><p>Geometry (default) (2000) - this is used for most objects. Opaque geometry uses this queue.</p><p>AlphaTest (2450) - alpha tested geometry uses this queue. It’s a separate queue from Geometry one since it’s more efficient to render alpha-tested objects after all solid ones are drawn.</p><p>Transparent (3000) - this render queue is rendered after Geometry and AlphaTest, in back-to-front order. Anything alpha-blended (i.e. shaders that don’t write to depth buffer) should go here (glass, particle effects).</p><p>Overlay (4000) - this render queue is meant for overlay effects. Anything rendered last should go here (e.g. lens flares, UI).</p><h3 id="Sorting-Fudge"><a href="#Sorting-Fudge" class="headerlink" title="Sorting Fudge"></a>Sorting Fudge</h3><p>Particle System组件还有一个属性：Sorting Fudge，在其他值都相同时，这个值会影响绘制的先后顺序，值比较高的先绘制。</p><p><img src="Unity的渲染顺序/1617976537790.png" alt="Alt text"></p><h3 id="深度排序"><a href="#深度排序" class="headerlink" title="深度排序"></a>深度排序</h3><p>按照 <strong>包围盒</strong> 中心点的深度进行排序</p><ul><li><p>不透明物体 - 由近到远（从前向后）</p></li><li><p>透明物体 - 由远到近（从后向前）</p></li></ul><h2 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h2><h3 id="明确分层"><a href="#明确分层" class="headerlink" title="明确分层"></a>明确分层</h3><p>例如UI上的半透明（特效、面片）始终在3D场景之上，则一般分多个相机来绘制。<br>大片填充率的物件，例如地形，天空等，一般为提高深度命中，都会选择在延后批次绘制。<br>Draw character before the terrain.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/55762351" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55762351</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity渲染相关API</title>
      <link href="2023/07/25/Unity3D-Unity%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3API/"/>
      <url>2023/07/25/Unity3D-Unity%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3API/</url>
      
        <content type="html"><![CDATA[<p>从引擎提供的接口的层面去看渲染相关知识体系。</p><h2 id="CommandBuffer"><a href="#CommandBuffer" class="headerlink" title="CommandBuffer"></a>CommandBuffer</h2><p>List of graphics commands(rendering commands - “set render target, draw mesh, …”) to execute. </p><blockquote><p>Command Buffers - <strong>“list of things to do” buffers</strong></p></blockquote><p>Command buffers can be created and then executed many times if needed.<br>Typically they would be used to extend Unity’s rendering pipeline in some custom ways. For example, you could render some additional objects into deferred rendering g-buffer after all regular objects are done, or do custom processing of light shadow maps. </p><p>相关API：</p><ul><li><p>Camera.AddCommandBuffer</p></li><li><p>Light.AddCommandBuffer</p></li><li><p>Graphics.ExecuteCommandBuffer</p></li></ul><p>Some of its Public Methods：</p><ul><li><p>Blit - Add a “blit into a render texture” command.(Note that Blit changes the currently active render target. After Blit executes, dest becomes the active render target.)</p></li><li><p>DrawMesh - Add a “draw mesh” command.</p></li><li><p>DrawMeshInstanced</p></li><li><p>SetComputeBufferParam - Adds a command to set an input or output buffer parameter on a ComputeShader.</p></li><li><p>DrawRenderer - Add a “draw renderer” command.</p></li></ul><h3 id="low-level-amp-high-level-command-buffer"><a href="#low-level-amp-high-level-command-buffer" class="headerlink" title="low-level &amp; high-level command buffer"></a>low-level &amp; high-level command buffer</h3><p><strong>A command buffer in graphics</strong> is a low-level list of commands to execute. For example, 3D rendering APIs like Direct3D or OpenGL typically end up constructing a command buffer that is then executed by the GPU. Unity’s multi-threaded renderer also constructs a command buffer between a calling thread and the “worker thread” that submits commands to the rendering API.</p><p><strong>In Unity scripting API</strong> , the “commands” are somewhat higher level. Instead of containing things like “set internal GPU register X to value Y”, the commands are “Draw this mesh with that material” and so on.</p><p>For example, you could render some additional objects into deferred shading G-buffer after all regular objects are done. Or render some clouds immediately after skybox is drawn, but before anything else. Or render custom lights (volume lights, negative lights etc.) into deferred shading light buffer after all regular lights are done. And so on; we think there are a lot of interesting ways to use them.</p><h2 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a>Renderer</h2><p>A renderer is what makes an object appear on the screen. Use this class to access the renderer of any object, mesh or Particle System. Renderers can be disabled to make objects invisible, and the materials can be accessed and modified through them. </p><p>Some of its Properties:</p><ul><li><p>bounds </p></li><li><p>isVisible </p></li><li><p>lightmapIndex </p></li><li><p>sharedMaterial </p></li><li><p>sortingOrder </p></li><li><p>worldToLocalMatrix </p></li></ul><p>Public Methods:</p><ul><li><p>GetPropertyBlock </p></li><li><p>SetPropertyBlock </p></li></ul><p>Messages:</p><ul><li><p>OnBecameVisible </p></li><li><p>OnBecameInvisible </p></li></ul><h3 id="Mesh-Renderer"><a href="#Mesh-Renderer" class="headerlink" title="Mesh Renderer"></a>Mesh Renderer</h3><ul><li><p>Mesh Renderer</p></li><li><p>Materials</p></li><li><p>Lighting</p></li><li><p>Lightmapping</p></li></ul><h3 id="Line-Renderer"><a href="#Line-Renderer" class="headerlink" title="Line Renderer"></a>Line Renderer</h3><p>The Line Renderer component takes an array of two or more points in 3D space, and draws a straight line between each one. You can use a Line Renderer to draw anything from a simple straight line to a complex spiral.</p><h3 id="Trail-Renderer"><a href="#Trail-Renderer" class="headerlink" title="Trail Renderer"></a>Trail Renderer</h3><p>The Trail Renderer component renders a trail of polygons behind a moving GameObject. This can be used to give an emphasized feeling of motion to a moving object, or to highlight the path or position of moving objects. </p><h2 id="RenderBuffer"><a href="#RenderBuffer" class="headerlink" title="RenderBuffer"></a>RenderBuffer</h2><p>Color or depth buffer part of a RenderTexture.</p><p>RenderTexture = RenderBuffer combination.</p><p>A single RenderTexture object represents both color and depth buffers, but many complex rendering algorithms require using the same depth buffer with multiple color buffers or vice versa.</p><p>Related API</p><ul><li><p>RenderTexture.colorBuffer</p></li><li><p>RenderTexture.depthBuffer</p></li><li><p>Graphics.activeColorBuffer</p></li><li><p>Graphics.activeDepthBuffer</p></li><li><p>Graphics.SetRenderTarget.</p></li></ul><h2 id="RenderTexture"><a href="#RenderTexture" class="headerlink" title="RenderTexture"></a>RenderTexture</h2><p>Render textures are textures that can be rendered to.<br>They can be used to implement image based rendering effects, dynamic shadows, projectors, reflections or surveillance cameras.</p><p>RenderTexture是unity定义的一种特殊的Texture类型,它是连接着一个FrameBufferObject的存在于GPU端的Texture(Server-Side Texture)</p><p>One typical usage of render textures is setting them as the “target texture” property of a Camera (Camera.targetTexture), this will make a camera render into a texture instead of rendering to the screen.</p><p>Static Properties:</p><ul><li><p>antiAliasing </p></li><li><p>colorBuffer </p></li><li><p>depthBuffer</p></li><li><p>sRGB </p></li><li><p>useMipMap </p></li></ul><p>Public Methods:</p><ul><li><p>Create </p></li><li><p>GenerateMips </p></li><li><p>IsCreated </p></li><li><p>Release </p></li></ul><p>Static Methods:</p><ul><li><p>GetTemporary </p></li><li><p>ReleaseTemporary </p></li></ul><h3 id="RenderTexture-active"><a href="#RenderTexture-active" class="headerlink" title="RenderTexture.active"></a>RenderTexture.active</h3><p>Currently active render texture.<br>All rendering goes into the active RenderTexture. If the active RenderTexture is null everything is rendered in the main window.</p><p>Setting RenderTexture.active is the same as calling Graphics.SetRenderTarget. </p><pre><code class="lang-csharp">using UnityEngine; using System.Collections; // Get the contents of a RenderTexture into a Texture2Dpublic class ExampleClass : MonoBehaviour{ static public Texture2D GetRTPixels(RenderTexture rt){ // Remember currently active render textureRenderTexture currentActiveRT = RenderTexture.active; // Set the supplied RenderTexture as the active oneRenderTexture.active = rt; // Create a new Texture2D and read the RenderTexture image into itTexture2D tex = new Texture2D(rt.width, rt.height); tex.ReadPixels(new Rect(0, 0, tex.width, tex.height), 0, 0); // Restorie previously active render textureRenderTexture.active = currentActiveRT; return tex; } }</code></pre><h2 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h2><p>Raw interface to Unity’s drawing functions.<br>This is the high-level shortcut into the optimized mesh drawing functionality of Unity.</p><p>Static Properties</p><ul><li><p>activeColorBuffer - Currently active color buffer (Read Only).</p></li><li><p>activeColorGamut - Returns the currently active color gamut.</p></li><li><p>activeDepthBuffer - Currently active depth/stencil buffer (Read Only).</p></li></ul><p>Static Methods</p><ul><li><p>Blit(位块传送) - Copies source texture into destination render texture with a shader.</p></li><li><p>DrawMesh - Draw a mesh.</p></li><li><p>DrawMeshInstanced - Draw the same mesh multiple times using GPU instancing.</p></li><li><p>DrawMeshInstancedIndirect - Draw the same mesh multiple times using GPU instancing.</p></li><li><p>DrawMeshInstancedProcedural - Draw the same mesh multiple times using GPU instancing. This is similar to Graphics.DrawMeshInstancedIndirect, except when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.</p></li><li><p>DrawMeshNow - Draw a mesh immediately.</p></li><li><p>DrawTexture - Draw a texture in screen coordinates.</p></li><li><p>ExecuteCommandBuffer - Execute a command buffer.</p></li></ul><h3 id="Graphics-Blit"><a href="#Graphics-Blit" class="headerlink" title="Graphics.Blit"></a>Graphics.Blit</h3><p>Copies source texture into destination render texture with a shader.<br>Blit sets dest as the render target, sets source <strong>_MainTex</strong> property on the <strong>material</strong> , and draws a full-screen quad.</p><p>This is mostly used for implementing post-processing effects.</p><p>If you are using the Built-in Render Pipeline, when dest is null, Unity uses the screen backbuffer as the blit destination. However, if the main camera is set to render to a RenderTexture (that is, if Camera.main has a non-null targetTexture property), the blit uses the render target of the main camera as destination.<br>If you are using a Scriptable Render Pipeline (like HDRP or Universal RP), to blit to the screen backbuffer using Graphics.Blit, you have to call Graphics.Blit from inside a method that you register as the RenderPipelineManager.endFrameRendering callback.</p><p>Note that if you want to use a depth or stencil buffer that is part of the source (Render)texture, you have to manually write an equivalent of the Graphics.Blit function - i.e. Graphics.SetRenderTarget with destination color buffer and source depth buffer, setup orthographic projection (GL.LoadOrtho), setup material pass (Material.SetPass) and draw a quad (GL.Begin).</p><p>Graphics.Blit changes RenderTexture.active. Keep track of the previously active RenderTexture if you need to use it after calling Graphics.Blit.</p><h3 id="Graphics-SetRenderTarget"><a href="#Graphics-SetRenderTarget" class="headerlink" title="Graphics.SetRenderTarget"></a>Graphics.SetRenderTarget</h3><p>This function sets which RenderTexture or a RenderBuffer combination will be rendered into next.<br>Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually.</p><p>Calling SetRenderTarget with just a RenderTexture argument is the same as setting RenderTexture.active property.</p><h3 id="Graphics-DrawMeshInstanced"><a href="#Graphics-DrawMeshInstanced" class="headerlink" title="Graphics.DrawMeshInstanced"></a>Graphics.DrawMeshInstanced</h3><p>Draw the same mesh multiple times using GPU instancing.</p><blockquote><p>Similar to Graphics.DrawMesh, this function draws meshes for one frame without the overhead of creating unnecessary game objects.</p></blockquote><p>The transformation matrix of each instance of the mesh should be packed into the matrices array. You can specify the number of instances to draw, or by default it is the length of the matrices array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using SetFloatArray, SetVectorArray and SetMatrixArray.</p><p><img src="Unity渲染相关API/1607334545990.png" alt="Alt text"></p><p>Note: You can only draw a maximum of 1023 instances at once.</p><h3 id="Graphics-DrawMeshInstancedIndirect"><a href="#Graphics-DrawMeshInstancedIndirect" class="headerlink" title="Graphics.DrawMeshInstancedIndirect"></a>Graphics.DrawMeshInstancedIndirect</h3><p>Similar to Graphics.DrawMeshInstanced, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from bufferWithArgs.</p><h2 id="GL"><a href="#GL" class="headerlink" title="GL"></a>GL</h2><p>Low-level graphics library.<br>Note that in almost all cases using Graphics.DrawMesh or CommandBuffer is more efficient than using immediate mode drawing.</p><p>GL immediate drawing functions use whatever is the “current material” set up right now (see Material.SetPass). The material controls how the rendering is done (blending, textures, etc.), so unless you explicitly set it to something before using GL draw functions, the material can happen to be anything. Also, if you call any other drawing commands from inside GL drawing code, they can set material to something else, so make sure it’s under control as well.</p><p>GL drawing commands execute immediately. That means if you call them in Update(), they will be executed before the camera is rendered (and the camera will most likely clear the screen, making the GL drawing not visible).</p><p>The usual place to call GL drawing is most often in OnPostRender() from a script attached to a camera, or inside an image effect function (OnRenderImage).</p><h2 id="Matrix4x4"><a href="#Matrix4x4" class="headerlink" title="Matrix4x4"></a>Matrix4x4</h2><p>A standard 4x4 transformation matrix.<br>A transformation matrix can perform arbitrary linear 3D transformations (i.e. translation, rotation, scale, shear etc.) and perspective transformations using homogenous coordinates. </p><p>Matrices in Unity are column major. - 列优先存储（不同于GLSL的行优先）</p><h3 id="Matrix4x4-TRS"><a href="#Matrix4x4-TRS" class="headerlink" title="Matrix4x4.TRS"></a>Matrix4x4.TRS</h3><pre><code class="lang-csharp">public static Matrix4x4 TRS(Vector3 pos, Quaternion q, Vector3 s);</code></pre><p>Creates a translation, rotation and scaling matrix.</p><p>The returned matrix is such that it places objects at position pos, oriented in rotation q and scaled by s.</p><h2 id="Quaternion"><a href="#Quaternion" class="headerlink" title="Quaternion"></a>Quaternion</h2><h3 id="Quaternion-LookRotation"><a href="#Quaternion-LookRotation" class="headerlink" title="Quaternion.LookRotation"></a>Quaternion.LookRotation</h3><p>Creates a rotation with the specified forward and upwards directions.</p><p>Z axis will be aligned with forward, X axis aligned with cross product between forward and upwards, and Y axis aligned with cross product between Z and X.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Unity Documentation<br><a href="https://www.jianshu.com/p/fa73c0f6762d" target="_blank" rel="noopener">https://www.jianshu.com/p/fa73c0f6762d</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity场景管理和切换</title>
      <link href="2023/07/25/Unity3D-Unity%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%88%87%E6%8D%A2/"/>
      <url>2023/07/25/Unity3D-Unity%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="关于yield-return"><a href="#关于yield-return" class="headerlink" title="关于yield return"></a>关于yield return</h2><p>对于yield return，目前我还无法深入理解其底层实现原理，无法看懂他编译成的IL代码。但是目前可以理解他的使用方法与机制。<br>yield return会每次返回后记录返回的位置，待等待的时间到了之后，从返回的位置继续往下执行。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="SceneManager-LoadScene"><a href="#SceneManager-LoadScene" class="headerlink" title="SceneManager.LoadScene"></a>SceneManager.LoadScene</h3><p>When using SceneManager.LoadScene, the scene <strong>loads in the next frame</strong> , that is it does not load immediately. This <strong>semi-asynchronous</strong> behavior can cause frame stuttering and can be confusing because load does not complete immediately.</p><p>Because loading is set to complete in the next rendered frame, calling SceneManager.LoadScene forces all previous AsyncOperations to complete, even if AsyncOperation.allowSceneActivation is set to false.</p><blockquote><p>如果场景名称重复，路径不同：<br> The given sceneName can either be the Scene name only, without the .unity extension, or the path as shown in the BuildSettings window still without the .unity extension. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with the same name but different paths, you should use the full path.</p></blockquote><h4 id="切换时相关Mono内存问题"><a href="#切换时相关Mono内存问题" class="headerlink" title="切换时相关Mono内存问题"></a>切换时相关Mono内存问题</h4><p>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.<br>Destroy掉前一个场景中的GameObject，如果GameObject上挂载的Monobehaviour没有被其他地方引用的话，调用GC.Collect()会回收掉他占用的内存。</p><p>虽然GameObject被Destroy掉了， 如果Monobehaviour被其他在场景切换时无法销毁的对象所引用，那么其Mono层的对象是无法被回收的。比如：MonoBehaviour类中的某个函数注册了SceneManager类的sceneLoaded事件，那么这个对象就被SceneManager静态地引用了，该对象就无法销毁，Mono层的内存就无法释放。</p><h3 id="LoadSceneMode"><a href="#LoadSceneMode" class="headerlink" title="LoadSceneMode"></a>LoadSceneMode</h3><p>(TODO: 是否会自动卸载，有待验证)<br>使用Single模式，关闭已经加载的所有场景（不是卸载，卸载是另一个函数 —— UnloadSceneAsync()），只加载一个新场景，新场景被添加到SceneManager的目录中。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>SetActiveScene() 激活已加载的场景，如果场景未加载，返回false。</p><p>GetActiveScene() 获取已激活的场景。</p><p>CreateScene() 运行时创建一个新场景。</p><p>MergeScenes(SceneManagement.Scene sourceScene, SceneManagement.Scene destinationScene) 将源场景的内容合并到目标场景中，并删除源场景。 源场景根目录下的所有游戏对象都将移动到目标场景的根目录。需要注意的是，该函数具有破坏性 —— 合并完成后，源场景将被销毁。</p><p>MoveGameObjectToScene()<br>将GameObject从其当前场景移动到新场景。<br>只能将根游戏对象从一个场景移动到另一个场景。 这意味着要移动的GameObject不能是其场景中任何其他GameObject的子对象。 这仅适用于将GameObjects移动到已加载的场景（LoadSceneMode.Additive）。 如果要加载单个场景，请确保在要移动到新场景的GameObject上使用DontDestroyOnLoad，否则Unity会在加载新场景时删除它。</p><p>UnloadSceneAsync()<br>销毁与给定场景关联的所有GameObject，并从SceneManager中移除场景。给定的场景名称可以是完整的场景路径，“构建设置”窗口中显示的路径，也可以是场景名称。<br>注意：</p><ol><li><p>由于它是异步的，因此无法保证完成时间。</p></li><li><p>资产目前尚未卸载。 为了释放资产内存，可以调用 Resources.UnloadUnusedAssets() 。</p></li><li><p>如果没有要加载的场景，则无法使用 UnloadSceneAsync() 。 </p></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="进度条异步加载场景"><a href="#进度条异步加载场景" class="headerlink" title="进度条异步加载场景"></a>进度条异步加载场景</h3><p>AsyncOperation的progress（0-1）属性在allowSceneActivation 为false时，最大加载到0.9就会暂停，直到allowSceneActivation 为true时才会继续加载0.9-1.0的这10%。<br>直到progress = 1.0时 isDone = true。</p><blockquote><p>在Unity编辑器模式下是看不出来进度条正常变化的，只有导出项目后才能看到正常进度条</p></blockquote><pre><code class="lang-csharp">using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using UnityEngine.SceneManagement; public class LoadSceneProgressBar : MonoBehaviour{ private Slider _progress; void Awake(){ _progress = GetComponent&lt;Slider&gt;(); } //使用协程void Update(){ if(Input.GetKeyDown(KeyCode.Space)) StartCoroutine(LoadScene()); } IEnumerator LoadScene(){ //用Slider 展示的数值int disableProgress = 0; int toProgress = 0; //异步场景切换AsyncOperation op = SceneManager.LoadSceneAsync(&quot;MainScene_DayLight&quot;); //不允许有场景切换功能op.allowSceneActivation = false; //op.progress 只能获取到90%，最后10%获取不到，需要自己处理while (op.progress &lt; 0.9f) { //获取真实的加载进度toProgress = (int)(op.progress * 100); while (disableProgress &lt; toProgress) { ++disableProgress; _progress.value = disableProgress / 100.0f;//0.01开始yield return new WaitForEndOfFrame(); } } //因为op.progress 只能获取到90%，所以后面的值不是实际的场景加载值了，90~100之间的是假进度条。toProgress = 100; while (disableProgress &lt; toProgress) { ++disableProgress; _progress.value = disableProgress / 100.0f; yield return new WaitForEndOfFrame(); } op.allowSceneActivation = true; } }</code></pre><p>对于LoadSceneAsync，如果不使用yield return，也会在后台线程自动完成异步加载，只是无法一帧一帧获取当前的加载进度，无法实现加载完之后调用的逻辑。<br>通过while+yield return的方式，是为了保证每帧执行一次while中的语句块，从而监控加载过程，并在加载结束后触发相应的逻辑。</p><h3 id="从AssetBundle加载场景"><a href="#从AssetBundle加载场景" class="headerlink" title="从AssetBundle加载场景"></a>从AssetBundle加载场景</h3><pre><code class="lang-csharp">// Load an assetbundle which contains Scenes.// When the user clicks a button the first Scene in the assetbundle is// loaded and replaces the current Scene.using UnityEngine; using UnityEngine.SceneManagement; public class LoadScene : MonoBehaviour{ private AssetBundle myLoadedAssetBundle; private string[] scenePaths; // Use this for initializationvoid Start(){ myLoadedAssetBundle = AssetBundle.LoadFromFile(&quot;Assets/AssetBundles/scenes&quot;); scenePaths = myLoadedAssetBundle.GetAllScenePaths(); } void OnGUI(){ if (GUI.Button(new Rect(10, 10, 100, 30), &quot;Change Scene&quot;)) { Debug.Log(&quot;Scene2 loading: &quot; \+ scenePaths[0]); SceneManager.LoadScene(scenePaths[0], LoadSceneMode.Single); } } }</code></pre><h3 id="分组加载卸载场景"><a href="#分组加载卸载场景" class="headerlink" title="分组加载卸载场景"></a>分组加载卸载场景</h3><pre><code class="lang-csharp">/**************************************************************************Copyright:@maxdongAuthor: maxdongDate: 2017-07-04Description:加载关卡，可以分组加载和卸载。使用Unity版本为5.3.0.因为里面使用了场景管理的一个类，这个类在5.3.0以上版本才添加的。测试操作：使用空格键来切换场景，然后间隔5秒后才开始卸载。**************************************************************************/using UnityEngine; using System.Collections; using UnityEngine.SceneManagement; [System.Serializable] public class LevelOrder{ [Header(&quot;每组关卡名称&quot;)] public string[] LevelNames; } public class ChangLevelsHasMain : MonoBehaviour{ [Header(&quot;所有关卡列表&quot;)] public LevelOrder[] levelOrder; private static int index; private int totalLevels = 0; private int levelOrderLength; void Start (){ for (int i = 0; i &lt; levelOrder.Length; i++) { totalLevels += levelOrder[i].LevelNames.Length; } if (totalLevels != SceneManager.sceneCountInBuildSettings) { } levelOrderLength = levelOrder.Length; } // Update is called once per framevoid Update (){ if (Input.GetKeyDown(KeyCode.Space)) { bool isOk = LoadNextLevels(); if (isOk) { InvokeRepeating(&quot;UnloadLastLevel&quot;, 2.0f, 5); } } } bool LoadNextLevels(){ bool bResult = true; //index = index % levelOrderLength;if (index &lt; 0 || index &gt;= levelOrderLength) { bResult = false; return bResult; } int LoadTimes = levelOrder[index].LevelNames.Length; for (int i = 0; i &lt; LoadTimes; i++) { SceneManager.LoadSceneAsync(levelOrder[index].LevelNames[i], LoadSceneMode.Additive); } return bResult; } void UnloadLastLevel(){ if (index == 0) { index++; CancelInvoke(&quot;UnloadLastLevel&quot;); return; } // 上一組的關卡int TmpLast = (index - 1) &gt;= 0 ? (index - 1) : levelOrderLength - 1; int LoadTimes = levelOrder[index].LevelNames.Length; for (int i = 0; i &lt; LoadTimes; i++) { Scene Tmp = SceneManager.GetSceneByName(levelOrder[index].LevelNames[i]); if (!Tmp.isLoaded) { return; } } // 下一關卡全部加載完畢後，卸載之前關卡for (int i = 0; i &lt; levelOrder[TmpLast].LevelNames.Length; i++) { SceneManager.UnloadScene(levelOrder[TmpLast].LevelNames[i]); } index++; CancelInvoke(&quot;UnloadLastLevel&quot;); } }</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/Ha1f_Awake/article/details/93319307" target="_blank" rel="noopener">https://blog.csdn.net/Ha1f_Awake/article/details/93319307</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity大气散射</title>
      <link href="2023/07/25/Unity3D-Unity%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/"/>
      <url>2023/07/25/Unity3D-Unity%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="USky使用方法"><a href="#USky使用方法" class="headerlink" title="USky使用方法"></a>USky使用方法</h2><p>建立USky空物体</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity控制程序停止运行</title>
      <link href="2023/07/25/Unity3D-Unity%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C/"/>
      <url>2023/07/25/Unity3D-Unity%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="停止运行的Game"><a href="#停止运行的Game" class="headerlink" title="停止运行的Game"></a>停止运行的Game</h2><p>在编辑状态下，不点击停止播放键也一样能够控制程序停止运行</p><pre><code class="lang-csharp">#if UNITY_EDITORUnityEditor.EditorApplication.isPlaying = false; #elseApplication.Quit(); #endif</code></pre><h2 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h2>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中的路径获取</title>
      <link href="2023/07/25/Unity3D-Unity%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96/"/>
      <url>2023/07/25/Unity3D-Unity%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="AssetDatabase"><a href="#AssetDatabase" class="headerlink" title="AssetDatabase"></a>AssetDatabase</h2><h3 id="获取选中资源"><a href="#获取选中资源" class="headerlink" title="获取选中资源"></a>获取选中资源</h3><pre><code class="lang-csharp">[MenuItem(&quot;Tools/GetSelectPaths&quot;)] public static void Execute(){ string[] strs = Selection.assetGUIDs; var curPath = System.IO.Directory.GetCurrentDirectory();//获取当前根目录foreach (var item in strs) { string path = AssetDatabase.GUIDToAssetPath(item); Debug.Log(curPath+&quot;/&quot;+path); } }</code></pre><h3 id="Active-Deactive选中物体"><a href="#Active-Deactive选中物体" class="headerlink" title="Active/Deactive选中物体"></a>Active/Deactive选中物体</h3><pre><code class="lang-csharp">[MenuItem(&quot;Example/Toggle Active of Selected %i&quot;)] static void DoToggle(){ Object[] activeGOs = Selection.GetFiltered( typeof(GameObject), SelectionMode.Editable | SelectionMode.TopLevel); foreach (GameObject obj in activeGOs) { obj.SetActive(!obj.activeSelf); } }</code></pre><h3 id="遍历所有文件"><a href="#遍历所有文件" class="headerlink" title="遍历所有文件"></a>遍历所有文件</h3><pre><code class="lang-csharp">private readonly string configJsonPath = AssetDatabase.GetAllAssetPaths() .FirstOrDefault(p =&gt; p.EndsWith(&quot;uwascan_ruleconfig.json&quot;));</code></pre><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>获取路径：”………………../Assets”</p><pre><code class="lang-csharp">string path = Application.dataPath;</code></pre><h3 id="遍历所有文件夹-待学习"><a href="#遍历所有文件夹-待学习" class="headerlink" title="遍历所有文件夹 (待学习)"></a>遍历所有文件夹 (待学习)</h3><pre><code class="lang-csharp">//遍历所选文件夹，查找该文件夹以及子文件夹中 后缀为 .prefab的文件路径using UnityEngine; using System.Collections; using System.Collections.Generic; using UnityEditor; using System.IO; public class CameraMove : MonoBehaviour { // 在菜单来创建 选项 ， 点击该选项执行搜索代码[MenuItem(&quot;Tools/遍历项目所有文件夹&quot;)] static void CheckSceneSetting(){ List&lt;string&gt; dirs = new List&lt;string&gt;(); GetDirs(Application.dataPath, ref dirs); } //参数1 为要查找的总路径， 参数2 保存路径private static void GetDirs(string dirPath, ref List&lt;string&gt; dirs){ foreach (string path in Directory.GetFiles(dirPath)) { //获取所有文件夹中包含后缀为 .prefab 的路径if (System.IO.Path.GetExtension(path) == &quot;.prefab&quot;) { dirs.Add(path.Substring(path.IndexOf(&quot;Assets&quot;))); Debug.Log(path.Substring(path.IndexOf(&quot;Assets&quot;))); } } if (Directory.GetDirectories(dirPath).Length &gt; 0) //遍历所有文件夹{ foreach (string path in Directory.GetDirectories(dirPath)) { GetDirs(path, ref dirs); } } } }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中的Texture相关知识(To Update)</title>
      <link href="2023/07/25/Unity3D-Unity%E4%B8%AD%E7%9A%84Texture%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-To-Update/"/>
      <url>2023/07/25/Unity3D-Unity%E4%B8%AD%E7%9A%84Texture%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-To-Update/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>纹理</strong> - A texture is a 2D image (even 1D and 3D textures exist) used to add detail to an object.</p><p>使用 <strong>纹理映射（texture mapping）</strong> 技术，我们可以把一张图“黏”在模型表面，逐 <strong>纹素（texel）</strong> （纹素的名字是为了和像素进行区分）地控制模型的颜色。</p><ul><li>纹素 - The individual color values are called a texture element, or texel.</li></ul><h3 id="Texture的作用"><a href="#Texture的作用" class="headerlink" title="Texture的作用"></a>Texture的作用</h3><p>To add more detail to our objects we can use colors for each vertex to create some interesting images. However, to get a fair bit of realism we’d have to have many vertices so we could specify a lot of colors. This takes up a considerable amount of extra overhead, since each model needs a lot more vertices and for each vertex a color attribute as well.</p><p>若不使用Texture，而使用顶点的Color属性的话，为了真实性，需要更多的顶点，并且每个顶点都要增加额外的颜色信息。</p><h2 id="Texture-Coordinates"><a href="#Texture-Coordinates" class="headerlink" title="Texture Coordinates"></a>Texture Coordinates</h2><p>In order to map a texture to the triangle we need to tell each vertex of the triangle which part of the texture it corresponds to. Each vertex should thus have a texture coordinate associated with them that specifies what part of the texture image to sample from. Fragment interpolation then does the rest for the other fragments.</p><p><img src="Unity中的Texture相关知识\(To Update\" alt="Alt text"><br>_files/1613985653479.png)</p><p><strong>纹理映射坐标（texture-mapping coordinates） / UV坐标：</strong> 存储在每个顶点上，定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个二维变量(u，v)来表示，其中u是横向坐标，而v是纵向坐标。</p><p>Each texel has a unique address in the texture. The address can be thought of as a column and row number, which are labeled u and v. </p><p>Texture coordinates are in texture space. That is, they are relative to the location (0,0) in the texture. </p><blockquote><p>顶点UV坐标的范围通常都被归一化到[0，1]范围内。<br> 在OpenGL里，纹理空间的原点位于左下角，而在DirectX中，原点位于左上角。Unity使用的纹理空间是符合OpenGL的传统的</p></blockquote><h3 id="uv-uv2-uv3-uv4"><a href="#uv-uv2-uv3-uv4" class="headerlink" title="uv, uv2, uv3, uv4"></a>uv, uv2, uv3, uv4</h3><p><img src="Unity中的Texture相关知识\(To Update\" alt="Alt text"><br>_files/UV.png)<br>unity一共支持4套uv，在shader编程中，分别叫UV0, UV1, UV2, UV3，而在c＃编程中分别叫uv, uv2, uv3, uv4。<br>通常来说(使用c# API中的命名)，uv用于主纹理, uv2用于光照贴图(Lightmap)的采样, uv3用于实时动态光照, uv4可进行自定义。<br>uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。如果在建模软件中只做了一套uv，将模型导入unity的时候，在导入设置中勾选Generate Lightmap UVs, unity会自动为我们生成用于光照贴图的uv2。uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p><blockquote><p>3DMax和maya等软件都能对模型加多套uv<br> 注意模型在fbx里可以保留多套uv，但是obj里只能保留默认的第一套<br> 另外unity里现在貌似支持最多四套</p></blockquote><h3 id="清除不必要的UV通道"><a href="#清除不必要的UV通道" class="headerlink" title="清除不必要的UV通道"></a>清除不必要的UV通道</h3><p>某些时候，因为美术的一些意外操作，会引入多个我们不需要的UV通道。<br>由于unity的光照贴图会自动占用uv2通道，如果你的项目中又使用的是动态加载光照贴图的方式的话，最好不要在导入模型的时候把UV2设置为null，如果你这样做了有可能会导致光照贴图显示不出来的问题。<br>如果物体不需要烘培，你自己也不使用uv2，则可以删除该通道。</p><pre><code class="lang-csharp">//删除color和uvpublic class ClearModelUV:AssetPostprocessor{ void OnPostprocessModel(GameObject rImaportModel){ this.ClearMeshUVAndColorChannel(rImaportModel); } private void ClearMeshUVAndColorChannel(GameObject rImportModel){ List&lt;Vector2&gt; rNewUV = null; List&lt;Color32&gt; rNewColor = null; var rFilters= rImportModel.GetComponentsInChildren&lt;MeshFilter&gt;(); for (int filter_index = 0; filter_index &lt; rFilters.Length; filter_index++) { rFilters[filter_index].sharedMesh.SetColors(rNewColor); rFilters[filter_index].sharedMesh.SetUVs(1, rNewUV); rFilters[filter_index].sharedMesh.SetUVs(2, rNewUV); rFilters[filter_index].sharedMesh.SetUVs(3, rNewUV); } } }</code></pre><h2 id="Texture-Import-Settings"><a href="#Texture-Import-Settings" class="headerlink" title="Texture Import Settings"></a>Texture Import Settings</h2><h3 id="Texture-Type"><a href="#Texture-Type" class="headerlink" title="Texture Type"></a>Texture Type</h3><p>Default 默认的纹理类型，普通的图片<br>Normal map 法线贴图</p><blockquote><p>【关于法线贴图：就是看起来与3D效果无异的2D贴图】<br> 游戏场景中譬如雕刻这种3D细节，如果做3D模型的话，就会浪费显示芯片，使游戏性能下降，便会用法线贴图，既不影响玩家体验游戏又不影响游戏性能</p></blockquote><p>Editor GUI and Legacy GUI GUI编辑器用到的UI贴图<br>Sprite(2D and UI) 图片精灵，主要用于2D游戏中，把一张大的图分割成一张张小图，大的图叫图集atlas,<br>小的图叫精灵sprite,可以通过精灵名字来使用精灵.<br>Cursor 鼠标或者叫光标的贴图<br>Cubemap 立方体的纹理<br>Cookie 遮罩贴图 聚光灯贴图<br>Lightmap 光照或者叫烘焙贴图<br>Advanced 高级(可自定义一些贴图属性)</p><h3 id="Alpha-Source-α通道来源"><a href="#Alpha-Source-α通道来源" class="headerlink" title="Alpha Source (α通道来源)"></a>Alpha Source (α通道来源)</h3><ol><li><p>None：强制无α通道。</p></li><li><p>Input Texture Alpha：使用纹理自带的α通道。</p></li><li><p>From Gray Scale：使用纹理RGB通道的均值来生成α通道。</p></li></ol><h3 id="Alpha-Is-Transparent"><a href="#Alpha-Is-Transparent" class="headerlink" title="Alpha Is Transparent"></a>Alpha Is Transparent</h3><p>当alpha用于透明处理时，我们要勾上该选项，可以防止不透明边缘锯齿现象</p><p>性”alpha is transparency”，原理是在压缩之前对贴图进行颜色放大处理来搞定边缘锯齿问题，这个颜色放大处理等同于ps里的最小值滤镜操作，对图片边缘做强化处理。</p><p>一个坑：（<a href="http://blog.coolcoding.cn/?p=198" target="_blank" rel="noopener">http://blog.coolcoding.cn/?p=198</a>）<br>如果有一张PNG图片, 95%的地方是全透明的,而在全透明的地方,RGB值是有意义的;<br>如果设置了alphaIsTransparency属性,则全透明的地方,Unity会将RGB值全部丢失!!!<br>如果要使用此纹理的4个通道做数据存储时(比如地型的4通道混合)<br>千万不能勾选alphaIsTransparency属性<br>除非此PNG图片仅仅用于UI显示。</p><h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><p>Non Power of 2：NPOT的处理方式。<br>Read/Write Enabled：读写开关，非必要不开启，否则会增加一倍的 内存。<br>Generate Mip Maps：生成Mip Maps，会增加33%的内存。一般用 于模型纹理，UI、天空盒等纹理不需要开启。<br>Border Mip Maps：防止低阶的Mip Map的色彩值溢出边界，一般用 于光照Cookie。<br>Mip Map Filtering：过滤算法，Box和Kaiser。<br>Fadeout Mip Maps：根据层阶使Mip Map慢慢变灰，一般用于细节 贴图（DetailMaps）。</p><h3 id="Wrap-Mode"><a href="#Wrap-Mode" class="headerlink" title="Wrap Mode"></a>Wrap Mode</h3><p>Wrap mode determines how texture is sampled when texture coordinates are outside of the typical 0..1 range.<br>这由纹理的映射函数来决定。在OpenGL中，这类映射函数称为“Texture Wrapping Mode”；在D3D中，称为“Texture Addressing Mode”。</p><h4 id="Repeat-重复"><a href="#Repeat-重复" class="headerlink" title="Repeat 重复"></a>Repeat 重复</h4><p>Tiles the texture, creating a repeating pattern.<br>When UVs are outside of the 0…1 range, the integer part will be ignored, thus creating a repeating pattern.<br>在算法上，忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上。对于大多数复制纹理的使用，在纹理顶部的纹理单元应与底部的纹理单元相匹配，在纹理左侧的纹理单元也应与右侧的纹理单元相匹配。这样才能做到无缝连接。</p><h4 id="Clamp-拉伸"><a href="#Clamp-拉伸" class="headerlink" title="Clamp 拉伸"></a>Clamp 拉伸</h4><p>makes the texture edge pixels be stretched when outside of of 0..1 range.<br>This is useful for preventing wrapping artifacts when mapping an image onto an object and you don’t want the texture to tile. UV coordinates will be clamped to the range 0…1. When UVs are larger than 1 or smaller than 0, the last pixel at the border will be used.<br>将大于1.0的数值设置为1.0，将小于0.0的数值设置为0.0，即将超出[0.0,1.0]范围的数值截取到[0.0,1.0]范围内，这样会导致纹理边缘的重复。</p><h4 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h4><p>Tiles the texture, creating a repeating pattern by mirroring it at every integer boundary.</p><h4 id="Mirror-Once"><a href="#Mirror-Once" class="headerlink" title="Mirror Once"></a>Mirror Once</h4><p>Mirrors the texture once, then clamps to edge pixels.<br>This effectively mirrors the texture around zero UV coordinates, and repeats edge pixel values when outside of [-1..1] range.</p><blockquote><p>This mode is called “mirror and clamp to edge” in graphics APIs like Vulkan, Metal and OpenGL. This feature is not always supported when using OpenGL ES and Vulkan graphics APIs, specifically on ARM and Qualcomm GPUs platforms. Check SystemInfo.supportsTextureWrapMirrorOnce to figure out whether the system is capable..</p></blockquote><h4 id="Per-axis"><a href="#Per-axis" class="headerlink" title="Per-axis"></a>Per-axis</h4><p>Choose this to individually control how Unity wraps Textures at the U axis and V axis. </p><h3 id="Filter-Mode"><a href="#Filter-Mode" class="headerlink" title="Filter Mode"></a>Filter Mode</h3><p>控制纹理通过三维变换拉伸的计算(过滤)方式</p><p>Point：最近点采样，当纹理坐标没有刚好对应Texture上的一个采样点时，它会选择最近的一个采样点作为该坐标的采样值，</p><p>当纹理没有拉伸变形时，这样还不错，因为速度是最快的，但如果拉伸变形了，会出现马赛克现象。</p><p>Bilinear：双线性过滤，以像素对应的纹理坐标为中心，采样它周围4个texel（纹素）的像素，取平均值作为该坐标采样值。这是Unity默认的模式，过渡效果相对平滑，当然速度会比最近点采样有一定下降。会有模糊化现象。</p><p>Trilinear：三线性过滤，会对像素大小和纹素大小最接近的两层Mipmap level分别进行双线性过滤，再对结果进行线性插值。由于使用了两次双线性过滤，也就是计算2x4=8个像素的值，速度会更加下降，当然滤波效果更好。同上也会有模糊化现象。</p><h3 id="Aniso-Level"><a href="#Aniso-Level" class="headerlink" title="Aniso Level"></a>Aniso Level</h3><p>各向异性级别。当以一个过小的角度观察纹理时，此数值越高观察的纹理质量就越高，该参数对于提高地面等纹理的显示效果非常明显。</p><blockquote><p>Default 点了没效果不能重置所有设置，还是得手动选择.废弃的按钮</p></blockquote><h3 id="对不同平台的压缩设置"><a href="#对不同平台的压缩设置" class="headerlink" title="对不同平台的压缩设置"></a>对不同平台的压缩设置</h3><ul><li><p>Max Size：最大尺寸。</p></li><li><p>Compression：压缩质量。</p></li><li><p>Format：压缩格式。<br>格化式存储该纹理的类型，纹理的精度越高，占用的内存越大，得到的效果也越好</p></li><li><p>Compressed 默认压缩方式,PVRTC图片格式，压缩选项将会针对你的目标平台来选择最合适的压缩算法替换原来的我们给的图片格式(比如我们给的是PNG格式)。<br>16 bits 无压缩16位格式，比32位节省一半的空间和内存。<br>Truecolor 无压缩32位以上真彩色,适合对色彩要求较高的情况下使用，比较占空间和内存。</p></li><li><p>Compressor Quality：压缩质量</p></li><li><p>Use Crunch Compression：紧凑压缩</p></li></ul><blockquote><p>Crunched 这种类型将会根据显卡的GPU来选择合适的压缩格式进行压缩然后会选用一种CPU上就能处理的压缩格式再压缩一遍。如果在制作供人下载的资源包的时候这种类型非常的合适。这个类型的压缩需要很长时间，但在运行时解压是非常快的。</p></blockquote><h3 id="其他纹理类型设置"><a href="#其他纹理类型设置" class="headerlink" title="其他纹理类型设置"></a>其他纹理类型设置</h3><h3 id="Normal-Map"><a href="#Normal-Map" class="headerlink" title="Normal Map"></a>Normal Map</h3><p>与Default相比增加了一下设置：<br>Create from Grayscale：从灰度高度图（Heightmap）创建。<br>Bumpiness：崎岖度。<br>Filtering：滤波算法。</p><ol><li>Smooth：平滑，标准前向差分算法。 2. Sharp：尖锐，Sobel滤波器。</li></ol><h4 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h4><p>与Default相比增加了一下设置：<br>Sprite Mode：精灵模式。</p><ol><li><p>Single：单图。</p></li><li><p>Multiple：多图。</p></li><li><p>Polygon：多边形，在SpriteEditor里使用多边形裁剪精灵。<br>PackingTag：指定图集。<br>PixelsPer Unit：每单位像素数，在世界场景中，每单位距离有多少个 像素。</p></li></ol><p>Mesh Type：网格类型（Polygon模式无此属性）。</p><ol><li>FullRect：矩形。 2. Tight：紧凑的，根据Alpha通道生成Mesh。（2DObject）<br>ExtrudeEdge：拉伸边缘。</li></ol><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie类型的纹理设置<br>与Default相比增加了一下设置：<br>Light Type：光照类型。</p><ol><li><p>Spotlight：聚光灯，形状必须为2D。</p></li><li><p>Directional：平行光，形状必须为2D。</p></li><li><p>Point：点光源，形状必须为立方体。</p></li></ol><h2 id="Sprite及图集的使用"><a href="#Sprite及图集的使用" class="headerlink" title="Sprite及图集的使用"></a>Sprite及图集的使用</h2><blockquote><p>只有Sprite模式的图片才可以打包成图集</p></blockquote><p>旧版：<br>Sprite Mode 设置为 Muitiple 设置Packing Tag<br>Window-&gt;Sprite Packer –&gt;点击 Pack 即可</p><p>新版：<br>Project Setting -&gt; Editor -&gt; Sprite Packer -&gt; Mode = Always Enabled<br>新建 Sprite Atlas<br>选择打包图集的文件夹或者依次添加单独图片，点击Pack Preview后自动打包成一个图集</p><p>代码获取图集并动态选择Sprite：</p><pre><code class="lang-csharp">using UnityEditor; using UnityEngine; using UnityEngine.U2D; using UnityEngine.UI; public class SpriteAtlasExample : MonoBehaviour{ private void Awake(){ SpriteAtlas atlas = AssetDatabase.LoadAssetAtPath&lt;SpriteAtlas&gt;(&quot;Assets/TestAtlas.spriteatlas&quot;); Sprite sprite = atlas.GetSprite(&quot;Icon2&quot;); if (sprite != null) { GetComponent&lt;Image&gt;().sprite = sprite; } } }</code></pre><h2 id="压缩格式相关"><a href="#压缩格式相关" class="headerlink" title="压缩格式相关"></a>压缩格式相关</h2><h3 id="图像文件格式"><a href="#图像文件格式" class="headerlink" title="图像文件格式"></a>图像文件格式</h3><p>文件格式是图像为了存储信息而使用的对信息的特殊编码方式，它存储在磁盘中，或者内存中，但是并不能被GPU所识别，因为以向量计算见长的GPU对于这些 复杂的计算无能为力。这些文件格式当被游戏读入后，还是需要经过CPU转换成图形硬件支持的格式，再传送到GPU端进行使用。<br>常用的图片格式及特点如下：</p><ul><li><p>JPG 有损压缩 文件小 不支持透明</p></li><li><p>PNG 无损压缩 文件小 支持透明</p></li><li><p>TAG 无损压缩 文件大 支持透明</p></li><li><p>DDS 无损压缩 文件最小 支持透明</p></li></ul><p>不同格式的本质区别在于压缩算法不一样，结果图片大小，还原度也各不相同。</p><blockquote><p>TIFF（Tag Image File Format）文件是由Aldus和Microsoft公司为扫描仪和桌上出版系统研制开发的一种较为通用的图像文件格式。TIFF格式灵活易变，同时定义了四类不同的格式：TIFF－B适用于二值图像；TIFF－G适用黑白灰度图像；TIFF－P适用于带调色板的彩色图像；TIFF－R适用于RGB真彩图像。TIFF支持多种编码方法，其中包括RGB无损压缩、RLE压缩以及JPEG压缩等。</p><p>GIF（Graphics Interchange Format ）是CompuServe公司在1987年开发的图像文件格式。GIF文件的数据是经过压缩的，它采用了可变长度的压缩算法。GIF的图像深度从1 bit到8 bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。</p></blockquote><h3 id="3D-图形硬件支持的压缩格式"><a href="#3D-图形硬件支持的压缩格式" class="headerlink" title="3D 图形硬件支持的压缩格式"></a>3D 图形硬件支持的压缩格式</h3><p>JPG, PNG, PSD are not used <strong>during realtime rendering by 3D graphics hardware</strong> such as a graphics card or mobile device. 3D graphics hardware requires Textures to be compressed in specialized formats which are <strong>optimised for fast Texture sampling</strong> . The various different platforms and devices available each have their own different proprietary formats.</p><p>By default, the Unity Editor automatically converts Textures to the most appropriate format to match the build target you have selected. Only the converted Textures are included in your build; your source Asset<br>files are left in their original format, in your project’s Assets folder.</p><blockquote><p>如果发现GPU不支持当前压缩格式，Unity就会将纹理转换成RGB（A），首先是解压过程的消耗，其次是内存中会保存两个纹理。</p></blockquote><h4 id="简单纹理格式"><a href="#简单纹理格式" class="headerlink" title="简单纹理格式"></a>简单纹理格式</h4><p>RGBA8888 每个像素4字节，RGBA通道各占用8位<br>RGBA4444 每个像素2字节，RGBA通道各占用4位<br>RGB888 每个像素3字节，RGB通道各占用8位，无透明通道<br>RGB565 每个像素2字节，RGB通道各占用5/6/5位，无透明通道<br>RGBA5551 每个像素2字节，RGB通道各占用5位，透明通道1位，所以要么完全透明要么不透明</p><blockquote><p>所有设备对RGB 16BITS/ARGB 16BITS/RGB A16BITS/RGB 24BITS/ARGB 32BITS等支持都很好，只是这些格式算是非压缩格式，对内存消耗和渲染消耗非常不友好。</p></blockquote><h4 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h4><ul><li><p>DXT - 有损压缩方式</p></li><li><p>ETC - （Ericsson Texture Compression），在移动平台中广泛采用。它是一种为感知质量设计的有损算法，其依据是人眼对亮度改变的反应要高于色度改变。</p><ul><li><p>ETC1：安卓原生支持，在各种Android设备上非透明纹理都可以采用ETC1格式。ETC1不支持透明，对于透明纹理，在Android设备上，可以把RGB和Alpha拆到2张ETC1纹理上，游戏中再合成使用。</p></li><li><p>ETC2是ETC1的扩张，向后兼容ETC1，对RGB的压缩质量更好，并且支持透明通道。ETC2比ETC1压缩质量更高，而且支持透明，在Android设备上再也不需要打不同纹理格式的包了。不过需要OpenGL ES 3.0以上才可以，目前很多设备只支持OpenGL ES 2.0。</p></li></ul></li><li><p>PVRTC（PowerVR Texture Compression） - 压缩比高，也是有损压缩。iOS只支持PVRTC的压缩格式。</p></li></ul><p>关于压缩后的在储存上的大小，假设高清(ARGB32)大小为1，那么大概数据如下：</p><pre><code class="lang-csharp">RGB PVRTC 4BITS:0.25ARGB PVRTC 4BITS:0.25RGB PVRTC 2BITS:0.13ARGB PVRTC 2BITS:0.13RGBA ETC2 4BITS:0.25RGBA ETC2 8BITS:0.25RGB \+ 1-bit ALPHA ETC2 8BITS:0.2DXT1 :0.3DXT5 : 0.6ARGB 16BITS:0.33RGB 16BITS:0.5RGB 24BITS:0.85ARGB 32BITS:1</code></pre><p>内存中的大小，假设高清(ARGB32)大小为1，那么大概数据如下：</p><pre><code class="lang-csharp">RGB PVRTC 2BITS:0.0625ARGB PVRTC 2BITS:0.0625RGB PVRTC 4BITS:0.125ARGB PVRTC 4BITS:0.125RGBA ETC2 4BITS:0.125RGBA ETC2 8BITS:0.25RGB \+ 1-bit ALPHA ETC2 8BITS:0.125DXT1 : 0.125DXT5 : 0.25ARGB 16BITS:0.5RGB 16BITS:0.5RGB 24BITS:0.8ARGB 32BITS:1</code></pre><h4 id="格式选择"><a href="#格式选择" class="headerlink" title="格式选择"></a>格式选择</h4><p>一般方案：ETC1+Alpha/PVRTC4 和 RGB16/RGBA16 搭配使用。</p><hr><h5 id="高清无压缩"><a href="#高清无压缩" class="headerlink" title="高清无压缩"></a>高清无压缩</h5><p>RGBA32 （等同于原图了，效果最好，效率最差。）</p><hr><h5 id="中清晰中压缩"><a href="#中清晰中压缩" class="headerlink" title="中清晰中压缩"></a>中清晰中压缩</h5><ul><li><p>不透明贴图 ：RGB 16BITS</p></li><li><p>透明贴图：RGBA 16BITS + Dithering</p></li></ul><blockquote><p>RGBA16在遇到渐变的时候表现很差，可能需要做抖动（Dithering）处理。<br> 16位压缩会带来颜色损失，但如果本来美术就是按16BITS画的话，就不会损失，日本好些手游都是按16BITS来画的。这样的游戏一般少渐变艳度高比较容易看出来。</p></blockquote><hr><h5 id="低清晰高压缩"><a href="#低清晰高压缩" class="headerlink" title="低清晰高压缩"></a>低清晰高压缩</h5><p>ETC1+Alpha/PVRTC4（能直接被GPU使用，占用少，效率高。）</p><p>IOS下 </p><ul><li><p>普通不透明：RGB PVRTC 4BITS</p></li><li><p>普通透明：RGBA PVRTC 4BITS</p></li></ul><blockquote><p>PVRTC 要求方形的图集贴图<br> 非方形的贴图会被转成16位RGB(A)的压缩格式。</p></blockquote><p>Android下：</p><ul><li><p>普通不透明：RGB ETC 4BITS</p></li><li><p>普通透明：</p><ul><li><p>RGBA 16BIT</p></li><li><p>有针对性的选择DXT5/ATC8 BITS/ETC2 8BITS</p></li><li><p>如果有技术支持，可以采用RGB ETC 4BITS加一张ALPHA 8的贴图来实现透明效果。</p></li></ul></li></ul><p><strong>对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16</strong></p><blockquote><p>Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；<br> iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。<br> 另外，针对Android 上的带Alpha通道的图片，还有一种常见的做法，即把Alpha通道独立出来作为另一张纹理，从而将 RGB 部分和 Alpha 部分分别采用 ETC1来压缩，但渲染时就需要自定义的 Shader来处理。</p></blockquote><p>windows：<br>使用Compressed格式。会压缩为DXT5（带透明通道），DXT1 格式。</p><h4 id="关于POT-Power-Of-Two"><a href="#关于POT-Power-Of-Two" class="headerlink" title="关于POT(Power Of Two)"></a>关于POT(Power Of Two)</h4><p>Only textures with width/height being multiple of 4 can be compressed to ETC1 format.（ 只有宽/高的尺寸是4的倍数才能被压缩成ETC1格式。)<br>Only POT textures can be compressed to ETC1 format. ( 只有POT(Power of two,2的幂次方)的贴图才能被压缩成ETC1格式。)</p><p>如果纹理的原始尺寸不是2的幂次方的话，则可在Unity中可以通过导入设置来进行更正。</p><p><img src="Unity中的Texture相关知识\(To Update\" alt="Alt text"><br>_files/1604336979482.png)</p><ul><li><p>None不做处理</p></li><li><p>ToNearest（选择最接近的幂次方）</p></li><li><p>ToLarger（选择最大尺寸的幂次方）</p></li><li><p>ToSmaller（选择最小尺寸的幂次方）</p></li></ul><p>以一张513x1023尺寸的图片来举例：</p><ul><li><p>None：513x1023</p></li><li><p>ToNearest：512x1024</p></li><li><p>ToLarger：1024x1024</p></li><li><p>ToSmaller：512x512</p></li></ul><h2 id="实用的小工具"><a href="#实用的小工具" class="headerlink" title="实用的小工具"></a>实用的小工具</h2><h3 id="Texture转换成Texture2D"><a href="#Texture转换成Texture2D" class="headerlink" title="Texture转换成Texture2D"></a>Texture转换成Texture2D</h3><pre><code class="lang-csharp">/// &lt;summary&gt;/// Texture转换成Texture2D.../// &lt;/summary&gt;/// &lt;param name=&quot;texture&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;Texture2D TextureToTexture2D(Texture texture){ Texture2D texture2D = new Texture2D(texture.width, texture.height, TextureFormat.RGBA32, false); RenderTexture currentRT = RenderTexture.active; RenderTexture renderTexture = RenderTexture.GetTemporary(texture.width, texture.height, 32); Graphics.Blit(texture, renderTexture); RenderTexture.active = renderTexture; texture2D.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0); texture2D.Apply(); RenderTexture.active = currentRT; RenderTexture.ReleaseTemporary(renderTexture); return texture2D; }</code></pre><h3 id="Texture2D形式截图"><a href="#Texture2D形式截图" class="headerlink" title="Texture2D形式截图"></a>Texture2D形式截图</h3><pre><code class="lang-csharp">/// &lt;summary&gt;/// 截图.../// &lt;/summary&gt;/// &lt;param name=&quot;rect&quot;&gt;截图的区域&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;Texture2D CaptureScreenshot(Rect rect) { // 先创建一个的空纹理，大小可根据实现需要来设置Texture2D screenShot = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24,false); // 读取屏幕像素信息并存储为纹理数据，screenShot.ReadPixels(rect, 0, 0); screenShot.Apply(); // 然后将这些纹理数据，成一个png图片文件byte[] bytes = screenShot.EncodeToPNG(); string filename = Application.dataPath + &quot;/Screenshot.png&quot;; System.IO.File.WriteAllBytes(filename, bytes); Debug.Log(string.Format(&quot;截屏了一张图片: {0}&quot;, filename)); // 最后，我返回这个Texture2d对象，这样我们直接，所这个截图图示在游戏中，当然这个根据自己的需求的。return screenShot; }</code></pre><h3 id="Texture保存到本地"><a href="#Texture保存到本地" class="headerlink" title="Texture保存到本地"></a>Texture保存到本地</h3><pre><code class="lang-csharp">/// &lt;summary&gt;/// 将Texture转为本地PNG.../// &lt;/summary&gt;/// &lt;param name=&quot;filePath&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;teture&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static bool saveMainTextureToPng(string filePath, Texture teture){ if (teture.GetType() != typeof(Texture2D)) { return false; } Texture2D savedTexture = (Texture2D)teture; try{ Texture2D newTexture = new Texture2D(savedTexture.width, savedTexture.height, TextureFormat.RGBA32, false); newTexture.SetPixels(0, 0, savedTexture.width, savedTexture.height, savedTexture.GetPixels()); newTexture.Apply(); byte[] bytes = newTexture.EncodeToPNG(); if (bytes != null &amp;&amp; bytes.Length &gt; 0) { if (File.Exists(filePath)) { File.Delete(filePath); } System.IO.File.WriteAllBytes(filePath, bytes); } } catch (IOException ex) { return false; } return true; }</code></pre><h3 id="将图片转换为byte数组"><a href="#将图片转换为byte数组" class="headerlink" title="将图片转换为byte数组"></a>将图片转换为byte数组</h3><pre><code class="lang-csharp">/// &lt;summary&gt;/// 将图片转换为byte数组.../// &lt;/summary&gt;/// &lt;param name=&quot;filePath&quot;&gt;图片路径&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static byte[] ReadTexture(string filePath){ FileStream fileStream = new FileStream(filePath, FileMode.Open, System.IO.FileAccess.Read); fileStream.Seek(0, SeekOrigin.Begin); //创建byte数组 ... byte[] buffer = new byte[fileStream.Length]; fileStream.Read(buffer, 0, (int)fileStream.Length); fileStream.Close(); fileStream.Dispose(); fileStream = null; return buffer; }</code></pre><h2 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h2><p><a href="https://www.cnblogs.com/suogasus/p/5311264.html" target="_blank" rel="noopener">https://www.cnblogs.com/suogasus/p/5311264.html</a></p><p>Alpha通道是计算机图形学中的术语，指的是特别的通道，意思是“非彩色”通道，主要是用来保存选区和编辑选区</p><ul><li><p>Alpha 没有透明度的意思，不代表透明度。opacity 和 transparency 才和透明度有关，前者是不透明度，后者是透明度。比如 css 中的「opacity: 0.5」就是设定元素有 50% 的不透明度。</p></li><li><p>一个图像的每个像素都有 RGB 三个通道，后来 Alvy Ray Smith 提出每个像素再增加一个 Alpha 通道，取值为0到1，用来储存这个像素是否对图片有「贡献」，0代表透明、1代表不透明。也就是说，「Alpha 通道」储存一个值，其外在表现是「透明度」，Alpha 和透明度没啥关系。</p></li><li><p>为什么取名为 Alpha 通道，我觉得是因为这是除RGB以外「第一个通道」的意思，没有别的更深刻的含义。</p></li><li><p>Alpha 通道」是图片内在的一个属性，用 css 或者其他外部方法设定透明度，并没有改变图片的 Alpha 通道的值。</p></li></ul><p>真正让图片变透明的不是Alpha 实际是Alpha所代表的数值和其他数值做了一次运算<br>比如你有一张图片你想抠出图片中间的一部分 在PS里你会建立一个蒙板 然后在蒙板里把不需要的地方填充成黑色 需要的留成白色 这个时候实际上是是做了一次乘法<br>用黑色所代表的数值0去乘以你所填充的地方 那么这个地方就变透明了 </p><p>设Alpha值[0，255]区间映射为[0，1]区间相对应的值表示，即Alpha值为0—1之间的数值。则图形文件中各个像素点可表示为：<br>Graphx（Redx，Greenx，Bulex，Alphax）<br>屏幕上相应像素点的显示值就转换为：<br>Dispx（Redx<em>Alphax，Greenx</em>Alphax，Bluex*Alphax）</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>Alpha通道<br>颜色通道<br>复合通道<br>专色通道<br>矢量通道</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>《Unity Shader入门精要》 冯乐乐<br><a href="https://zhuanlan.zhihu.com/p/126752791" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126752791</a><br><a href="https://www.jianshu.com/p/bec1a7514b08" target="_blank" rel="noopener">https://www.jianshu.com/p/bec1a7514b08</a><br><a href="https://blog.csdn.net/ynnmnm/article/details/44983545" target="_blank" rel="noopener">https://blog.csdn.net/ynnmnm/article/details/44983545</a><br><a href="https://www.jianshu.com/p/832e242523a4" target="_blank" rel="noopener">https://www.jianshu.com/p/832e242523a4</a><br><a href="https://blog.csdn.net/skymanwu/article/details/295121" target="_blank" rel="noopener">https://blog.csdn.net/skymanwu/article/details/295121</a><br><a href="https://blog.csdn.net/qq_29266497/article/details/81515326" target="_blank" rel="noopener">https://blog.csdn.net/qq_29266497/article/details/81515326</a><br><a href="https://learnopengl.com/Getting-started/Textures" target="_blank" rel="noopener">https://learnopengl.com/Getting-started/Textures</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中Culling相关技术</title>
      <link href="2023/07/25/Unity3D-Unity%E4%B8%ADCulling%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
      <url>2023/07/25/Unity3D-Unity%E4%B8%ADCulling%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Frustum-Culling"><a href="#Frustum-Culling" class="headerlink" title="Frustum Culling"></a>Frustum Culling</h2><p>剔除被其他物体遮挡的，摄像机不可见(但在视锥体内)的渲染物体。使用 Occlusion Culling 需要手动设置，并在 Occlusion Culling Window 中通过 Bake 计算剔除数据。<br><a href="https://docs.unity3d.com/Manual/OcclusionCulling.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/OcclusionCulling.html</a></p><h3 id="Builtin管线"><a href="#Builtin管线" class="headerlink" title="Builtin管线"></a>Builtin管线</h3><p>视锥体剔除 - 视锥体剔除是引擎自己做的，在给GPU提交数据进行渲染前，会执行视锥体剔除，决定哪些可见哪些不可见。经过剔除之后，Renderer的isVisible值就表示相应物体的可见性，不过此时已经在这帧的Update之后了。在Update当中取IsVisible属性获取的实际上是上一帧的可见性。 至于视锥体剔除的实现方法我们不清楚，可能引擎底层会有一些优化，使用kd-tree进行空间划分等等。</p><h3 id="SRP的Culling"><a href="#SRP的Culling" class="headerlink" title="SRP的Culling"></a>SRP的Culling</h3><ol><li><p>SRP的Culling可以自己写</p></li><li><p>URP的管线相对比较固定，可定制化程度低，Culling不太好自己写</p></li></ol><p>Occlusion Culling is different from Frustum Culling. Frustum Culling only disables the renderers for objects that are outside the camera’s viewing area but does not disable anything hidden from view by overdraw. Note that when you use Occlusion Culling you will still benefit from Frustum Culling.</p><h2 id="Occlusion-Culling"><a href="#Occlusion-Culling" class="headerlink" title="Occlusion Culling"></a>Occlusion Culling</h2><p>在移动端使用的比较少，属于用 CPU时间换一定的CPU时间和一定的GPU时间的操作。使用方法是：预先烘焙遮挡剔除信息（对于一定的区域，哪些物体被遮挡），在游戏运行时，经过视锥体剔除之后，对于视锥体内的物体，相机到了一定的位置，会去取预先烘焙的信息，来判断哪些物体被遮挡，对相应的物体进行剔除，进而节省被遮挡的物体提交渲染进行、在GPU端进行绘制的时间。</p><h2 id="Camera-layerCullDistance"><a href="#Camera-layerCullDistance" class="headerlink" title="Camera.layerCullDistance"></a>Camera.layerCullDistance</h2><p>For performance reasons, you might want to cull small objects earlier. For example, small rocks and debris could be made invisible at much smaller distance than large buildings. To do that, put small objects into a separate layer and set up per-layer cull distances using Camera.layerCullDistances script function.<br><a href="https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html</a></p><h2 id="CullingGroup-API"><a href="#CullingGroup-API" class="headerlink" title="CullingGroup API"></a>CullingGroup API</h2><p>CullingGroup offers a way to integrate your own systems into Unity’s culling and LOD pipeline.The CullingGroup will calculate visibility based on frustum culling and static occlusion culling only. It will not take dynamic objects into account as potential occluders.<br><a href="https://docs.unity3d.com/Manual/CullingGroupAPI.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/CullingGroupAPI.html</a></p><p>Unity的CullingGroup API是纯逻辑的东西，不影响渲染。其使用方法是：在逻辑代码中定义CullingGroup，Group中加入一些球体(位置与半径，是逻辑上的球体，实际是不可见的)，并加入要检测的相机，渲染时，Unity会判断这些球体是否可见，进而判断CullingGroup的可见性。在渲染之后，可以在代码中获取该Group的可见性，进而据此控制一些逻辑。如果不用代码去取CullingGroup的信息，那么它就是没有用的。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://blog.csdn.net/kenight/article/details/82760667" target="_blank" rel="noopener">https://blog.csdn.net/kenight/article/details/82760667</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity&amp;C预处理指令</title>
      <link href="2023/07/25/Unity3D-Unity-C%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/"/>
      <url>2023/07/25/Unity3D-Unity-C%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-amp-C-预处理指令"><a href="#Unity-amp-C-预处理指令" class="headerlink" title="Unity&amp;C#预处理指令"></a>Unity&amp;C#预处理指令</h1><h1 id="Unity-amp-C-预处理指令-1"><a href="#Unity-amp-C-预处理指令-1" class="headerlink" title="Unity&amp;C#预处理指令"></a>Unity&amp;C#预处理指令</h1><h2 id="预处理指令（条件编译）"><a href="#预处理指令（条件编译）" class="headerlink" title="预处理指令（条件编译）"></a>预处理指令（条件编译）</h2><p>预处理器指令指导编译器在实际编译开始之前对信息进行预处理。<br>所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。<br>C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。在 C# 中，预处理器指令用于在条件编译中起作用。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。</p><pre><code class="lang-csharp">#define 它用于定义一系列成为符号的字符。通过使用符号作为传递给 #if 指令的表达式，表达式将返回 true。#undef 它用于取消定义符号。#if 它用于测试符号是否为真。#else 它用于创建复合条件指令，与 #if 一起使用。#elif 它用于创建复合条件指令。#endif 指定一个条件指令的结束。#line 它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。#error 它允许从代码的指定位置生成一个错误。#warning 它允许从代码的指定位置生成一级警告。#region 它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。#endregion 它标识着 #region 块的结束。</code></pre><h3 id="Conditional特性"><a href="#Conditional特性" class="headerlink" title="Conditional特性"></a>Conditional特性</h3><p>可以把输出日志的函数使用Conditional特性来标记上，只有在Unity编辑器中开启了指定的宏命令，这个输出日志的函数才能被编译，即可很方便地开关日志。<br><code>[Conditional(&quot;EnableLog&quot;)]</code><br>需要在Unity编辑器中添加上EnableLog宏命令，该方法才能被编译。</p><h2 id="Unity自带的一些宏定义"><a href="#Unity自带的一些宏定义" class="headerlink" title="Unity自带的一些宏定义"></a>Unity自带的一些宏定义</h2><p>UNITY_EDITOR Unity编辑器<br>UNITY_EDITOR_WIN Windows 操作系统.<br>UNITY_EDITOR_OSX macos操作系统<br>UNITY_STANDALONE_OSX 专门为macos（包括Universal, PPC，Intel architectures）平台的定义<br>UNITY_STANDALONE_WIN 专门为windows平台的定义<br>UNITY_STANDALONE_LINUX 专门为Linux平台的定义<br>UNITY_STANDALONE 独立平台 (Mac OS X, Windows or Linux).<br>UNITY_WII WII 游戏机平台<br>UNITY_IOS iOS系统平台<br>UNITY_IPHONE iPhone<br>UNITY_ANDROID android系统平台<br>UNITY_PS4 ps4平台<br>UNITY_SAMSUNGTV 三星TV平台<br>UNITY_XBOXONE Xbox One 平台<br>UNITY_TIZEN Tizen 平台<br>UNITY_TVOS Apple TV 平台<br>UNITY_WSA #define directive for Universal Windows Platform. Additionally, NETFX_CORE is defined when compiling C# files against .NET Core and using .NET scripting backend.<br>UNITY_WSA_10_0 #define directive for Universal Windows Platform. Additionally WINDOWS_UWP is defined when compiling C# files against .NET Core.<br>UNITY_WINRT UNITY_WSA.<br>UNITY_WINRT_10_0 UNITY_WSA_10_0<br>UNITY_WEBGL #define directive for WebGL.<br>UNITY_FACEBOOK faceBook平台(WebGL or Windows standalone).<br>UNITY_ADS 调用广告方法，版本 5.2 以后<br>UNITY_ANALYTICS 调用unity分析服务，版本5.2以后<br>UNITY_ASSERTIONS 控制指令的过程</p><p>UNITY_5 unity5版本, 包含所有的5.x.y版本<br>UNITY_5_0 Unity5.0版本,包含所有的5.0.x版本<br>UNITY_5_0_1 Unity5.0.1版本</p><h2 id="自定义宏定义"><a href="#自定义宏定义" class="headerlink" title="自定义宏定义"></a>自定义宏定义</h2><p>File - Build Settings - Player Settings - Other Settings<br>多个用分号隔开</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Addressasble</title>
      <link href="2023/07/25/Unity3D-Unity-Addressasble/"/>
      <url>2023/07/25/Unity3D-Unity-Addressasble/</url>
      
        <content type="html"><![CDATA[<ul><li>Unity Addressasble<ul><li>Heading</li></ul></li></ul><h2 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h2>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Crash 与 符号表</title>
      <link href="2023/07/25/Unity3D-Unity-Crash-%E4%B8%8E-%E7%AC%A6%E5%8F%B7%E8%A1%A8/"/>
      <url>2023/07/25/Unity3D-Unity-Crash-%E4%B8%8E-%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/wayland/articles/13092292.html" target="_blank" rel="noopener">https://www.cnblogs.com/wayland/articles/13092292.html</a></p><p><a href="https://blog.csdn.net/weixin_44084447/article/details/122929279" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44084447/article/details/122929279</a></p><p><a href="https://zhuanlan.zhihu.com/p/77984555" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77984555</a></p><p><a href="https://grrava.blogspot.com/2016/01/unity-crash-dumps-to-rescue.html" target="_blank" rel="noopener">https://grrava.blogspot.com/2016/01/unity-crash-dumps-to-rescue.html</a></p><p><a href="https://www.sebaslab.com/how-to-debug-unity-natively-using-mixed-c-and-c-stack/" target="_blank" rel="noopener">https://www.sebaslab.com/how-to-debug-unity-natively-using-mixed-c-and-c-stack/</a></p><p><a href="https://www.cnblogs.com/caiger-blog/p/16211519.html" target="_blank" rel="noopener">https://www.cnblogs.com/caiger-blog/p/16211519.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Native Programming（C与C++互相调用）</title>
      <link href="2023/07/25/Unity3D-Unity-Native-Programming%EF%BC%88C%E4%B8%8EC-%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%EF%BC%89/"/>
      <url>2023/07/25/Unity3D-Unity-Native-Programming%EF%BC%88C%E4%B8%8EC-%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-Native-Programming（C-与C-互相调用）"><a href="#Unity-Native-Programming（C-与C-互相调用）" class="headerlink" title="Unity Native Programming（C#与C++互相调用）"></a>Unity Native Programming（C#与C++互相调用）</h1><h1 id="Unity-Native-Programming（C-与C-互相调用）-1"><a href="#Unity-Native-Programming（C-与C-互相调用）-1" class="headerlink" title="Unity Native Programming（C#与C++互相调用）"></a>Unity Native Programming（C#与C++互相调用）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>主要是C/C++这种操作系统级别的语言作为桥接，几乎所有高级编程语言都支持C/C++扩展，交互。</p><p>c/c++可以编译成.so动态库（android平台下），.dll动态库（window平台和编辑器下），.a静态库（iOS平台下），.bundle包（Mac平台下和编辑器下）</p><blockquote><p>目前.Net平台中托管环境调用非托管环境有三种方法： <strong>P/Invoke</strong> , C++ Interop, COM Interop。C++ Interop是针对托管C++使用的方法（说实话C++/CLI感觉没啥前途），COM Interop则是针对Window软件开发而采用的方式。所以我们只剩下一种解决方案：也就是PInvoke来进行托管环境与非托管环境的互操作。</p></blockquote><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="库、动态库和静态库（-dll，-so，-lib，-a）"><a href="#库、动态库和静态库（-dll，-so，-lib，-a）" class="headerlink" title="库、动态库和静态库（.dll，.so，.lib，.a）"></a>库、动态库和静态库（.dll，.so，.lib，.a）</h3><p><strong>库</strong> - 库 是写好的现有的，成熟的，可以复用的代码。一般是软件作者为了发布方便、替换方便或二次开发目的，而发布的一组可以单独与应用程序进行compile time或runtime <strong>链接</strong> 的 <strong>二进制</strong> 可重定位 <strong>目标码文件</strong> 。</p><blockquote><p>本质上来说库是一种 <strong>可执行代码的二进制形式</strong> ， <strong>可以被操作系统载入内存执行</strong> 。可以在编译时由编译器直接链接到可执行程序中，也可以在运行时由操作系统的runtime enviroment根据需要动态加载到内存中。</p></blockquote><h4 id="链接种类"><a href="#链接种类" class="headerlink" title="链接种类"></a>链接种类</h4><p><strong>链接</strong> + 把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。</p><p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607254489703.png" alt="Alt text"></p><p><strong>静态链接库</strong> - 静态编译时由编译器到指定目录寻找并且进行链接，一旦链接完成，最终的可执行程序中就包含了该库文件中的所有有用信息，包括代码段、数据段等。</p><ul><li><p>使用静态库的时候，会将静态库的信息直接编译到可执行文件中</p></li><li><p>优点：当静态库被删除，对可执行文件没有影响</p></li><li><p>优点：直接被链接进可执行程序中之后，该可执行程序就不再依赖于运行环境的设置了（当然仍然会依赖于 CPU指令集和操作系统支持的可执行文件格式等硬性限制）</p></li><li><p>缺点:浪费内存空间。如果静态库被修改，可执行程序要重新编译</p></li></ul><p><strong>动态链接库</strong> - 在应用程序运行时，由操作系统根据应用程序的请求，动态到指定目录下寻找并装载入内存中，同时需要进行地址重定向。</p><ul><li><p>加载器在加载动态库时，操作系统会先检查动态库是否因为其它程序已经将这个动态库信息加载到了内存中。如果没有加载到内存中，操作系统会将动态库载入内存，并将它的引用计数设置为1;如果已经加载到内存，仅将动态库的引用计数加1。</p></li><li><p>优点：用户甚至可以在程序运行时随时替换该动态库，这就构成了动态插件系统的基础。</p></li></ul><blockquote><p>动态链接库的效率可能比静态链接库要差 - 程序总无法直接调用动态库中的函数符号，而只能通过调用操作系统的runtime enviroment接口来动态载入某个函数符号，同时获得该函数符号在内存中的地址，将其保存为函数指针进行调用，这就在函数调用时增加了一次间接寻址的过程。</p></blockquote><h4 id="不同平台的命名"><a href="#不同平台的命名" class="headerlink" title="不同平台的命名"></a>不同平台的命名</h4><hr><p>Android / Linux下：<br>静态库( static library ) : lib库名.a<br>动态库( shared library ) : lib库名.so(shared object)</p><hr><p>window：下<br>静态库:lib库名.lib<br>动态库:lib库名.dll(dynamic link library)</p><p><strong>Dynamic-link library (DLL)</strong> is <strong>Microsoft’s implementation</strong> of the <strong>shared library concept</strong> in the Microsoft Windows and OS/2 operating systems. These libraries usually have the file extension <strong>DLL</strong> , <strong>OCX</strong> (for libraries containing ActiveX controls), or <strong>DRV</strong> (for legacy system drivers). </p><blockquote><p>The file formats for DLLs are the same as for Windows EXE files – that is, Portable Executable (PE) for 32-bit and 64-bit Windows, and New Executable (NE) for 16-bit Windows. As with EXEs, DLLs can contain <strong>code</strong> , <strong>data</strong> , and <strong>resources</strong> , in any combination.</p></blockquote><p>相关链接：<a href="https://stackoverflow.com/questions/9688200/difference-between-shared-objects-so-static-libraries-a-and-dlls-so" target="_blank" rel="noopener">Difference between shared objects (.so), static libraries (.a), and DLL’s (.so)?</a></p><hr><blockquote><p>如何知道一个可执行程序依赖哪些库?<br> ldd命令可以查看一个可执行程序依赖的共享库</p></blockquote><pre><code class="lang-csharp"># ldd + 路径/可执行程序</code></pre><h3 id="ABI（Application-binary-interface）"><a href="#ABI（Application-binary-interface）" class="headerlink" title="ABI（Application binary interface）"></a>ABI（Application binary interface）</h3><p>In computer software, an application binary interface (ABI) is an interface between two <strong>binary program modules</strong>.</p><ul><li><p>a library or operating system facility</p></li><li><p>program that is being run by a user</p></li></ul><p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607772411910.png" alt="Alt text"></p><p><em>来源：WIKIPEDIA</em></p><p>An ABI defines how data structures or computational routines are accessed <strong>in machine code</strong> , which is a <strong>low-level</strong> , hardware-dependent format.<br>In contrast, an API defines this access in <strong>source code</strong> , which is a relatively <strong>high-level</strong> , hardware-independent, often human-readable format.<br>A common aspect of an ABI is <strong>the calling convention</strong> , which determines how data is provided as input to, or read as output from, computational routines.</p><h4 id="ABIs包含的一些细节"><a href="#ABIs包含的一些细节" class="headerlink" title="ABIs包含的一些细节"></a>ABIs包含的一些细节</h4><ul><li><p>a <strong>processor instruction set</strong> (with details like register file structure, stack organization, memory access types, …)</p></li><li><p>the sizes, layouts, and alignments of <strong>basic data types</strong> that the processor can directly access</p></li><li><p>the <strong>calling convention</strong> , which controls how the arguments of functions are passed, and return values retrieved. </p></li><li><p>in the case of a complete operating system ABI, <strong>the binary format of object files</strong> , <strong>program libraries</strong> , and so on.</p></li></ul><h4 id="Android-ABIs"><a href="#Android-ABIs" class="headerlink" title="Android ABIs"></a>Android ABIs</h4><p>Different Android devices use different <strong>CPUs</strong> , which in turn support different <strong>instruction sets</strong>. Each combination of CPU and instruction set has its own Application Binary Interface (ABI). </p><blockquote><p>查看安卓手机ABI:<br> adb shell cat /proc/cpuinfo<br> adb shell getprop ro.product.cpu.abi</p></blockquote><p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607774108632.png" alt="Alt text"></p><p>The default behavior of the build system is to include the binaries for each ABI in a single APK, also known as a <strong>fat APK</strong>.</p><p>At installation time, the package manager unpacks only the most appropriate machine code for the target device. ( <strong>Automatic extraction of native code at install time</strong> )</p><p>a fat APK may contain:</p><pre><code class="lang-csharp">/lib/armeabi/libfoo.so/lib/armeabi-v7a/libfoo.so/lib/arm64-v8a/libfoo.so/lib/x86/libfoo.so/lib/x86_64/libfoo.so</code></pre><h4 id="Generate-code-for-a-specific-ABI"><a href="#Generate-code-for-a-specific-ABI" class="headerlink" title="Generate code for a specific ABI"></a>Generate code for a specific ABI</h4><p>Gradle (whether used via Android Studio or from the command line) builds for all non-deprecated ABIs by default. </p><p>For example, to build for only 64-bit ABIs, set the following configuration in your build.gradle</p><pre><code class="lang-csharp">android {defaultConfig {ndk {abiFilters &#39;arm64-v8a&#39;, &#39;x86_64&#39;}}}</code></pre><h3 id="存储类型说明符-Storage-Class-Specifiers"><a href="#存储类型说明符-Storage-Class-Specifiers" class="headerlink" title="存储类型说明符(Storage Class Specifiers)"></a>存储类型说明符(Storage Class Specifiers)</h3><ul><li><p><strong>Storage class specifiers</strong> in C language tells the compiler <strong>where</strong> to store a variable, <strong>how</strong> to store the variable, <strong>what</strong> is the initial value of the variable and <strong>life time</strong> of the variable.</p></li><li><p>A storage class defines the <strong>scope (visibility)</strong> and <strong>life-time</strong> of <strong>variables</strong> and/or <strong>functions</strong> within a C++ Program. </p></li></ul><blockquote><p><strong>Declaration specifiers(声明说明符)</strong> (decl-specifier-seq) is a sequence of the following whitespace-separated specifiers, in any order.<br> (via. <a href="https://en.cppreference.com/w/cpp/language/declarations" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/declarations</a>)</p></blockquote><p>C provides the following storage-class specifiers:</p><ul><li><p>auto</p></li><li><p>register</p></li><li><p>static</p></li><li><p>extern</p></li><li><p>typedef</p></li><li><p>__declspec ( extended-decl-modifier-seq ) /<em> Microsoft-specific </em>/</p></li></ul><p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607186665209.png" alt="ABIs and supported instruction sets"></p><h4 id="EXTERN"><a href="#EXTERN" class="headerlink" title="EXTERN"></a>EXTERN</h4><p>The scope of this extern variable is throughout the main program. It is equivalent to global variable. <strong>Definition for extern variable might be anywhere in the C program</strong>.</p><pre><code class="lang-csharp">#include&lt;stdio.h&gt;int x = 10 ; int main( ){ extern int y; printf(&quot;The value of x is %d \n&quot;,x); printf(&quot;The value of y is %d&quot;,y); return 0; } int y=50;</code></pre><h4 id="REGISTER"><a href="#REGISTER" class="headerlink" title="REGISTER"></a>REGISTER</h4><ul><li><p>Register variables are also local variables, but stored in register memory. Whereas, auto variables are stored in main CPU memory.</p></li><li><p>Register variables will be accessed very faster than the normal variables since they are stored in register memory rather than main memory.</p></li><li><p>But, only limited variables can be used as register since register size is very low. (16 bits, 32 bits or 64 bits)</p></li></ul><h4 id="declspec"><a href="#declspec" class="headerlink" title="__declspec"></a>__declspec</h4><p>__declspec是Microsoft特定的属性，允许您指定存储类信息。但是，许多其他编译器供应商（例如GCC）现在支持此 <strong>语言扩展</strong> ，以与针对Microsoft编译器编写的已安装代码库兼容。</p><p>The <strong>extended attribute syntax</strong> for specifying <strong>storage-class information</strong> uses the __declspec keyword, which specifies that an instance of a given type is to be stored with a Microsoft-specific storage-class attribute listed below. </p><ul><li><p>thread</p></li><li><p>naked</p></li><li><p>dllimport</p></li><li><p>dllexport</p></li><li><p>(Others)</p></li></ul><div class="table-container"><table><thead><tr><th>语言概念</th><th>具体概念</th><th>代码  </th></tr></thead><tbody><tr><td>Keyword</td><td></td><td>__declspec  </td></tr><tr><td>decl-specifier（声明修饰符）</td><td></td><td>__declspec ( extended-decl-modifier-seq )  </td></tr><tr><td>extended-decl-modifier（声明修饰符的拓展）</td><td>Storage-Class Attributes（Specifier）</td><td>dllexport, dllimport等  </td></tr></tbody></table></div><blockquote><p>Microsoft将该__declspec符号发明为C ++语言的扩展。我相信GCC现在支持它，但这主要是出于与Microsoft编译器兼容的原因。而且我不了解“特定于MS”与“特定于编译器”有何不同。微软编写了一个C ++编译器，许多人使用它。它随Visual Studio一起提供。 via. <a href="https://qastack.cn/programming/8863193/what-does-declspecdllimport-really-mean" target="_blank" rel="noopener">QAStack</a></p></blockquote><p>可以指定的那些存储类属性中的两个是dllimport和dllexport。这些向编译器指示分别从DLL导入或导出函数或对象。</p><h5 id="dllexport-dllimport"><a href="#dllexport-dllimport" class="headerlink" title="dllexport, dllimport"></a>dllexport, dllimport</h5><p>You can use them to export and import functions, data, and objects to or from a DLL.</p><p>dllexport是把DLL中的相关代码（类，函数，数据）暴露出来为其他应用程 序使用。</p><p>These attributes explicitly define the DLL’s interface to its client, which can be the executable file or another DLL. Declaring functions as dllexport eliminates the need for a module-definition (.def) file, at least with respect to the specification of exported functions.</p><p>若要导出类中的所有公共数据成员和成员函数，关键字必须出现在类名的左边，如下所示：</p><pre><code class="lang-csharp">class __declspec(dllexport) CExampleExport : public CObject { ... class definition ... };</code></pre><p>dllexport of a function exposes the function with its decorated name. For C++ functions, this includes name mangling. For C functions or functions that are declared as extern “C”, this includes platform-specific decoration that’s based on the calling convention. For information on name decoration in C/C++ code, see Decorated Names. No name decoration is applied to exported C functions or C++ extern “C” functions using the __cdecl calling convention.</p><h5 id="特殊用法——提供者和使用者共用同一个头文件"><a href="#特殊用法——提供者和使用者共用同一个头文件" class="headerlink" title="特殊用法——提供者和使用者共用同一个头文件"></a>特殊用法——提供者和使用者共用同一个头文件</h5><pre><code class="lang-csharp">#ifndef DLL_H_ #define DLL_H_ #ifdef DLLProvider #define DLL_EXPORT_IMPORT __declspec(dllexport) #else#define DLL_EXPORT_IMPORT __declspec(dllimport) #endifDLL_EXPORT_IMPORT int add(int ,int); #endif</code></pre><h5 id="更详细的资料"><a href="#更详细的资料" class="headerlink" title="更详细的资料"></a>更详细的资料</h5><p>参见: <a href="https://www.cnblogs.com/yyxt/p/4241802.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyxt/p/4241802.html</a></p><h2 id="Unity中C-调用C-：PInvoke"><a href="#Unity中C-调用C-：PInvoke" class="headerlink" title="Unity中C#调用C++：PInvoke"></a>Unity中C#调用C++：PInvoke</h2><h3 id="Unity-Plugins"><a href="#Unity-Plugins" class="headerlink" title="Unity Plugins"></a>Unity Plugins</h3><p>In Unity, you normally use scripts to create functionality, but you can also include code created outside Unity in the form of a plug-in. There are two kinds of plug-ins you can use in Unity: Managed plug-ins and Native plug-ins.</p><h4 id="Managed-plug-ins"><a href="#Managed-plug-ins" class="headerlink" title="Managed plug-ins"></a>Managed plug-ins</h4><p>Managed plug-ins are managed .NET assemblies created with tools like Visual Studio. They contain only .NET code which means that they can’t access any features that are not supported by the .NET libraries.<br>However, managed code is accessible to the standard .NET tools that Unity uses to compile scripts. There is thus little difference in usage between managed plug-in code and Unity script code, except for the fact that the plug-ins are compiled outside Unity and so the source may not be available.</p><h4 id="Native-plug-ins"><a href="#Native-plug-ins" class="headerlink" title="Native plug-ins"></a>Native plug-ins</h4><p>Native plug-ins are are libraries of native code written in C, C++, Objective-C, etc. They are platform-specific.</p><p>They can access features like OS calls and third-party code libraries that would otherwise not be available to Unity.</p><h3 id="Unity-Assets-Plugins文件夹"><a href="#Unity-Assets-Plugins文件夹" class="headerlink" title="Unity Assets/Plugins文件夹"></a>Unity Assets/Plugins文件夹</h3><p>Plugins文件夹用来放native插件。它们会被自动包含进build中去。（注意这个文件夹只能是Assets文件夹的直接子目录。）</p><ol><li><p>Plugins/x86<br>如果为32bit或64bit平台创建游戏，那么这个文件夹下的native plugin文件会被自动的包含在游戏build中。如果这个文件夹不存在，则Unity会查找Plugins文件夹下的native pluglins。</p></li><li><p>Plugins/x86_64<br>如果为32bit或64bit平台创建游戏，那么这个文件夹下的native plugin文件会被自动的包含在游戏build中。如果这个文件夹不存在，则Unity会查找Plugins文件夹下的native pluglins。<br>如果要创建universal build，建议你同时使用这两个文件夹。然后将32bit和64bit的native plugins放进相应的文件夹中。</p></li><li><p>Plugins/Android<br>在这个文件夹里放入Java.jar文件。用于java语言的plugins。.so文件也会被包含进来。<br>See <a href="http://docs.unity3d.com/Documentation/Manual/PluginsForAndroid.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/PluginsForAndroid.html</a></p></li></ol><p>Android平台根据cpu架构不同放在对应文件夹下面，比如Anroid/libs/armeabi-v7a。</p><ol><li>Plugins/iOS<br>A limited, simple way to automatically add (as symbolic links) any .a, .m, .mm, .c, or .cpp files into the generated Xcode project. See<br>[<a href="http://docs.unity3d.com/Documentation/Manual/PluginsForIOS.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/PluginsForIOS.html</a><br>If you need more control how to automatically add files to the Xcode project, you should make use of the PostprocessBuildPlayer feature. Doing so does not require you to place such files in the Plugins/iOS folder. See[<a href="http://docs.unity3d.com/Documentation/Manual/BuildPlayerPipeline.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/BuildPlayerPipeline.html</a></li></ol><h3 id="PInvoke简单实践：Windows平台下调用Native代码"><a href="#PInvoke简单实践：Windows平台下调用Native代码" class="headerlink" title="PInvoke简单实践：Windows平台下调用Native代码"></a>PInvoke简单实践：Windows平台下调用Native代码</h3><h4 id="编写C-代码并导出"><a href="#编写C-代码并导出" class="headerlink" title="编写C++代码并导出"></a>编写C++代码并导出</h4><p>Write functions in a C-based language to access whatever features you need and compile them into a library. </p><ol><li><p>建立Win32工程</p></li><li><p>写代码</p></li></ol><p>TestLibAdd.h</p><pre><code class="lang-csharp">#ifndef __TESTLIBADD__#define __TESTLIBADD__extern &quot;C&quot; __declspec(dllexport) int __stdcall Add(int a, int b); #endif</code></pre><p>TestLibAdd.cpp</p><pre><code class="lang-csharp">#include &quot;TestLib-Add.h&quot;__declspec(dllexport) int __stdcall Add(int a, int b){ return a + b; }</code></pre><blockquote><p>__declspec(dllexport)代表需要导出的函数，需要放在函数定义的前面。<br> extern “C”表示以C语言方式进行导出<br> <strong>stdcall表示以标准方式调用。由于定义了extern “C”与</strong> stdcall，编译器会对函数名进行整理，在库中会独立对应一个标识符，C#也会根据相同的规则去寻找符合条件的函数以进行调用。<br> 在非托管dll导出的时候往往会用到不同的调用方式，所以相同的在C#中也可以通过调整DllImport中的CallingConvention进行指定以保证找到相应的函数。</p></blockquote><ol><li><p>右键点击工程，选择属性，选择生成动态库dll</p></li><li><p>选择平台类型</p></li></ol><p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607244642003.png" alt="Alt text"></p><ol><li>我们右键工程进行生成，分别生成x86与x64的版本。</li></ol><p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607244666427.png" alt="Alt text"></p><ol><li>分别将生成的.dll与.pdb放入到对应的文件夹中。x86放入x86文件夹，x64放入x86_64文件夹下。</li></ol><h4 id="在C-中编写接口"><a href="#在C-中编写接口" class="headerlink" title="在C#中编写接口"></a>在C#中编写接口</h4><p>Create a C# script which calls functions in the native library.</p><p>定义函数</p><ul><li><p>static - 非托管函数无需实例化就可直接调用</p></li><li><p>extern - 告诉编译器该函数在外部定义，不需要函数体</p></li><li><p>DllImport(“DLL名称”) - Unity会首先搜索Plugin，如果在Windows平台会去搜索系统目录，如果仍未找到就会抛出DllNotFound异常。</p></li></ul><blockquote><p>DllImport定义在命名空间<code>System.Runtime.InteropServices</code>中</p></blockquote><p>基本格式：</p><pre><code class="lang-csharp">using UnityEngine; using System.Runtime.InteropServices; class SomeScript : MonoBehaviour { #if UNITY_IPHONE// On iOS plugins are statically linked into// the executable, so we have to use __Internal as the// library name.[DllImport (&quot;__Internal&quot;)] #else// Other platforms load plugins dynamically, so pass the name// of the plugin&#39;s dynamic library.[DllImport (&quot;PluginName&quot;)] #endifprivate static extern float FooPluginFunction (); void Awake () { // Calls the FooPluginFunction inside the plugin// And prints 5 to the consoleprint (FooPluginFunction ()); } }</code></pre><p>笔者的案例：</p><pre><code class="lang-csharp">using System.Runtime.InteropServices; namespace TestNativeLib{ public class TestNativeLibInterface{ [DllImport(&quot;TestNativeLib&quot;)] public static extern int Add(int a, int b); } }</code></pre><blockquote><p>可能遇到的其他问题: 指定字符集、指定调用方式、指定调用入口。遇到时查阅相关资料即可</p></blockquote><p>在C#中调用就像普通调用C#函数一样。</p><pre><code class="lang-csharp">using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; namespace TestNativeLib{ public class AddUI : MonoBehaviour{ private Text text; private int cnt; void Start(){ text = GetComponent&lt;Text&gt;(); StartCoroutine(NumUIUpdate()); } IEnumerator NumUIUpdate(){ WaitForSeconds wfs = new WaitForSeconds(0.3f); while(true) { text.text = cnt.ToString(); cnt = TestNativeLibInterface.Add(cnt, 2); yield return wfs; } } } }</code></pre><h3 id="Native-C-plug-ins-for-Android"><a href="#Native-C-plug-ins-for-Android" class="headerlink" title="Native (C++) plug-ins for Android"></a>Native (C++) plug-ins for Android</h3><p>Unity supports native plug-ins for Android written in C/C++ and packaged in a <strong>shared library (.so)</strong> or a <strong>static library (.a)</strong>. </p><p>To build a C++ plug-in for Android, use the <strong>Android NDK</strong> and get yourself familiar with the steps required to build a shared library. </p><p>When using the <strong>IL2CPP</strong> scripting backend, you can use C/C++ source files as plug-ins and Unity compiles them along with IL2CPP generated files. This includes all <strong>C/C++ source files</strong> with extensions .c, .cc, .cpp and .h.</p><h4 id="how-the-Android-platform-manages-native-code-in-APKs-ABI-management"><a href="#how-the-Android-platform-manages-native-code-in-APKs-ABI-management" class="headerlink" title="how the Android platform manages native code in APKs(ABI management)"></a>how the Android platform manages native code in APKs(ABI management)</h4><h5 id="Native-code-in-app-packages"><a href="#Native-code-in-app-packages" class="headerlink" title="Native code in app packages"></a>Native code in app packages</h5><p>Both the Play Store and Package Manager expect to find NDK-generated libraries on filepaths inside the APK matching the following pattern:</p><pre><code class="lang-csharp">/lib/&lt;abi&gt;/lib&lt;name&gt;.so</code></pre><p>a fat APK may contain:a fat APK may contain:</p><pre><code class="lang-csharp">/lib/armeabi/libfoo.so/lib/armeabi-v7a/libfoo.so/lib/arm64-v8a/libfoo.so/lib/x86/libfoo.so/lib/x86_64/libfoo.so</code></pre><h5 id="Android-platform-ABI-support"><a href="#Android-platform-ABI-support" class="headerlink" title="Android platform ABI support"></a>Android platform ABI support</h5><p>You can force install an apk for a specific ABI. This is useful for testing. Use the following command:</p><pre><code class="lang-csharp">adb install --abi abi-identifier path_to_apk</code></pre><h5 id="Automatic-extraction-of-native-code-at-install-time"><a href="#Automatic-extraction-of-native-code-at-install-time" class="headerlink" title="Automatic extraction of native code at install time"></a>Automatic extraction of native code at install time</h5><p>When it finds the libraries that it’s looking for, the package manager copies them to <code>/lib/lib&lt;name&gt;</code>.so, under the application’s native library directory (<code>&lt;nativeLibraryDir&gt;/</code>). The following snippets retrieve the nativeLibraryDir:</p><pre><code class="lang-csharp">import android.content.pm.PackageInfo; import android.content.pm.ApplicationInfo; import android.content.pm.PackageManager; ... ApplicationInfo ainfo = this.getApplicationContext().getPackageManager().getApplicationInfo ( &quot;com.domain.app&quot;, PackageManager.GET_SHARED_LIBRARY_FILES ); Log.v( TAG, &quot;native library dir &quot; \+ ainfo.nativeLibraryDir );</code></pre><h4 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h4><ol><li><p>配置安卓开发环境 <a href="https://developer.android.com/" target="_blank" rel="noopener">https://developer.android.com/</a></p></li><li><p>Android Studio -&gt; Settings -&gt; Apperance &amp; Behaviour -&gt; System Settings -&gt;Android SDK -&gt; SDK Tools。安装CMake、NDK</p></li></ol><p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607349255030.png" alt="Alt text"></p><h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><p>how to use CMake with the NDK</p><ul><li><p>the Android Gradle Plugin’s <code>ExternalNativeBuild</code></p></li><li><p>invoking CMake directly</p></li></ul><h4 id="更多Android-Native代码开发教程"><a href="#更多Android-Native代码开发教程" class="headerlink" title="更多Android Native代码开发教程"></a>更多Android Native代码开发教程</h4><ol><li><p>官网 <a href="https://developer.android.com/studio/projects/add-native-code" target="_blank" rel="noopener">https://developer.android.com/studio/projects/add-native-code</a></p></li><li><p>国内博客 <a href="https://www.cnblogs.com/lsdb/p/9337285.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsdb/p/9337285.html</a></p></li><li></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/30746354" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30746354</a><br><a href="https://www.cnblogs.com/yyxt/p/4241802.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyxt/p/4241802.html</a><br><a href="https://fresh2refresh.com/c-programming/c-storage-class-specifiers/" target="_blank" rel="noopener">https://fresh2refresh.com/c-programming/c-storage-class-specifiers/</a><br><a href="https://docs.microsoft.com/en-us/cpp/cpp/declspec?view=msvc-160" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/cpp/declspec?view=msvc-160</a><br><a href="https://blog.csdn.net/junxuezheng/article/details/100557176" target="_blank" rel="noopener">https://blog.csdn.net/junxuezheng/article/details/100557176</a><br><a href="https://www.cnblogs.com/andyliu1988/p/3222892.html" target="_blank" rel="noopener">https://www.cnblogs.com/andyliu1988/p/3222892.html</a><br><a href="https://docs.unity3d.com/Manual/Plugins.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/Plugins.html</a><br><a href="https://docs.unity3d.com/Manual/AndroidNativePlugins.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/AndroidNativePlugins.html</a><br><a href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Application_binary_interface</a><br><a href="https://developer.android.com/ndk/guides/abis" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/abis</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UPM自定义资源包及相关规范</title>
      <link href="2023/07/25/Unity3D-UPM%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E5%8C%85%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A7%84%E8%8C%83/"/>
      <url>2023/07/25/Unity3D-UPM%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E5%8C%85%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>ByPrin@UWA</p><h2 id="UPM资源包介绍"><a href="#UPM资源包介绍" class="headerlink" title="UPM资源包介绍"></a>UPM资源包介绍</h2><p>作用：给Unity Package Manager制作自定义资源包，并上传至Github托管。使用PackageManager设定项目的依赖、解析资源包依赖、下载添加需要的资源包，将内容整合到项目中，以便在其他项目中使用，并与其他开发者共享。<br>常用于</p><ul><li><p>编辑器工具——文本编辑器、动画查看器或文本框架、Physics API、图形管线</p></li><li><p>内容库——纹理和动画资源集合</p></li></ul><blockquote><p><strong>Unity 2018.3 及之后版本, Unity Package Manager (UPM) 开始支持 Git</strong></p></blockquote><h3 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h3><p>UPM资源包是一个按特定标准排列的文件夹，是一个包含各种功能、资源的容器。必须遵循Unity的包格式标准才能正确运行（推荐的文件布局和版本号格式）。</p><pre><code class="lang-csharp">&lt;root&gt;├── package.json├── README.md├── CHANGELOG.md├── LICENSE.md├── Editor│ ├── Unity.[YourPackageName].Editor.asmdef│ └── EditorExample.cs├── Runtime│ ├── Unity.[YourPackageName].asmdef│ └── RuntimeExample.cs├── Tests│ ├── Editor│ │ ├── Unity.[YourPackageName].Editor.Tests.asmdef│ │ └── EditorExampleTest.cs│ └── Runtime│ ├── Unity.[YourPackageName].Tests.asmdef│ └── RuntimeExampleTest.cs└── Documentation~└── [YourPackageName].md</code></pre><blockquote><p>文件夹名称以~结尾不会显示在Editor的Project窗口</p></blockquote><h3 id="Package-manifest"><a href="#Package-manifest" class="headerlink" title="Package manifest"></a>Package manifest</h3><p>可以在Unity - Inspector面板填写</p><p>crucial information</p><ul><li><p>its registered name </p></li><li><p>version number<br>To User: </p></li><li><p>a user-friendly name that appears in the list view on the Package Manager window.</p></li><li><p>a brief description of the package</p></li><li><p>the earliest version of Unity the package is compatible with.</p></li></ul><h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>This name must conform to the Unity Package Manager naming convention, which uses reverse domain name notation.</p><ul><li><p>Start with <code>com.&lt;company-name&gt;.</code></p></li><li><p>Contain <strong>only lowercase letters</strong> , digits, hyphens (-), underscores (_), and periods (.)</p></li></ul><h4 id="Display-Name"><a href="#Display-Name" class="headerlink" title="Display Name"></a>Display Name</h4><p>是在Package Manager窗口显示给用户的名称，也是在Project窗口显示的包的Root文件夹的名称。</p><h4 id="版本号规范"><a href="#版本号规范" class="headerlink" title="版本号规范"></a>版本号规范</h4><p>Major.Minor.Patch</p><h4 id="the-lowest-Unity-version"><a href="#the-lowest-Unity-version" class="headerlink" title="the lowest Unity version"></a>the lowest Unity version</h4><p>If omitted, the package is considered compatible with all Unity versions.<br>A package that is not compatible with Unity will not appear in the Package Manager window.</p><h4 id="Package-manifest-example"><a href="#Package-manifest-example" class="headerlink" title="Package manifest example"></a>Package manifest example</h4><p>在包的根目录下创建文件<code>package.json</code>，只要格式符合规范，就能被UPM识别</p><pre><code class="lang-csharp">{&quot;name&quot;: &quot;com.unity.example&quot;,&quot;version&quot;: &quot;1.2.3&quot;,&quot;displayName&quot;: &quot;Package Example&quot;,&quot;description&quot;: &quot;This is an example package&quot;,&quot;unity&quot;: &quot;2019.1&quot;,&quot;unityRelease&quot;: &quot;0b5&quot;,&quot;dependencies&quot;: {&quot;com.unity.some-package&quot;: &quot;1.0.0&quot;,&quot;com.unity.other-package&quot;: &quot;2.0.0&quot;},&quot;keywords&quot;: [&quot;keyword1&quot;,&quot;keyword2&quot;,&quot;keyword3&quot;],&quot;author&quot;: {&quot;name&quot;: &quot;Unity&quot;,&quot;email&quot;: &quot;unity@example.com&quot;,&quot;url&quot;: &quot;https://www.unity3d.com&quot;}}</code></pre><h3 id="Assembly-definition"><a href="#Assembly-definition" class="headerlink" title="Assembly definition"></a>Assembly definition</h3><p>Assembly definition files are the Unity equivalent to a C# project in the .NET ecosystem. You must set explicit references in the assembly definition file to other assemblies (whether in the same package or in external packages).</p><p>命名规则：<br>Editor/MyCompany.MyFeature.Editor.asmdef<br>Runtime/MyCompany.MyFeature.Runtime.asmdef</p><p>CompanyName.FeatureName与package.json文件一致<br>文件的名称与文件中的”name”一致</p><blockquote><p>使用asmdef的优势</p><ul><li><p>更短的编译时间</p></li><li><p>发挥访问修饰符”internal”的作用</p></li><li><p>允许使用 unsafe code</p></li><li><p>.dll 文件可以指定特定的程序集引用。</p></li></ul></blockquote><p>一些注意事项：</p><ol><li>Editor 文件夹下的 AssemblyDefinition 中 Platform 只能选择 Editor，并且 Reference 必须添加上 Runtime 中的那个 AssemblyDefiniion</li></ol><h3 id="LICENSE相关（暂时忽略）"><a href="#LICENSE相关（暂时忽略）" class="headerlink" title="LICENSE相关（暂时忽略）"></a>LICENSE相关（暂时忽略）</h3><p>推荐添加Third Party Notices.md 和 LICENSE.md </p><ul><li>LICENSE.md：例如以MIT许可证为准的开源许可证MD文件</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-按照规范创建Package"><a href="#1-按照规范创建Package" class="headerlink" title="1. 按照规范创建Package"></a>1. 按照规范创建Package</h3><h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>压缩为zip文件<br>Unity Package Manager窗口通过Add Package from Disk添加</p><h4 id="Git代码库分发"><a href="#Git代码库分发" class="headerlink" title="Git代码库分发"></a>Git代码库分发</h4><p>添加到Git仓库中，包括meta文件</p><p>下载方式（使用者必须安装git）</p><ul><li>在PackageManager中通过Git URL直接下载</li></ul><pre><code class="lang-csharp">git tag 1.0.0 upm git push origin upm --tags</code></pre><h2 id="README文档"><a href="#README文档" class="headerlink" title="README文档"></a>README文档</h2><p>Developer package documentation. This is generally documentation to help developers who want to modify the package or push a new change on the package master source repository.</p><h2 id="Changelog规范"><a href="#Changelog规范" class="headerlink" title="Changelog规范"></a>Changelog规范</h2><p>You can update the CHANGELOG.md file every time you publish a new version. Every new feature or bug fix should have a trace in this file.</p><p><strong>Added</strong> for new features.<br><strong>Changed</strong> for changes in existing functionality.<br><strong>Deprecated</strong> for soon-to-be removed features.<br><strong>Removed</strong> for now removed features.<br><strong>Fixed</strong> for any bug fixes.<br><strong>Security</strong> in case of vulnerabilities.</p><blockquote><p>轻量级的使用Fixed和Features就足够了</p></blockquote><p>例如：</p><pre><code class="lang-csharp">## [3.0.3] - 2018-04-05 ### Changed \- API Examples are now published on [Github](https://github.com/Unity-Technologies/ProBuilder-API-Examples). ### Added \- Expose poly shape creation methods. Add API example. colors. \- New option to set edge and wireframe line width (not available on Metal). ### Fixed \- Fix scene info not updating with selection changes. \- Fix `Apply Material` only applying to parent gameobjects if children are also selected. \- Fix `pb_Object.SetSelectedFaces` setting duplicate vertex indices. ### Removed \- Remove update checking.</code></pre><blockquote><p>原则<br> Changelogs are for humans, not machines. </p><ul><li><p>There should be an entry for every single version.</p></li><li><p>The same types of changes should be grouped.</p></li><li><p>Versions and sections should be linkable.</p></li><li><p>The latest version comes first.</p></li><li><p>The release date of each version is displayed.</p></li><li><p>Mention whether you follow Semantic Versioning.</p></li></ul></blockquote><h2 id="Semantic-Versioning规范"><a href="#Semantic-Versioning规范" class="headerlink" title="Semantic Versioning规范"></a>Semantic Versioning规范</h2><p>MAJOR.MINOR.PATCH</p><ul><li><p>MAJOR introduces one or more breaking changes</p></li><li><p>MINOR introduces one or more <strong>backward-compatible API changes</strong></p></li><li><p>PATCH only introduces bug fixes with no API changes at all</p></li></ul><blockquote><p>When you begin to develop a package, start the version number at <strong>0.1.0.</strong> The MAJOR version number 0 is reserved for packages in their initial development phase. During initial development, package APIs change often, frequently in a breaking manner, so keep the MAJOR version number at 0 until you consider your package stable enough and ready for use in production.</p></blockquote><p>PS: 该规范主要在开发提供给用户的API时有重要作用。先不深究，大致按照此标准进行即可。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://docs.unity.cn/2019.4/Documentation/Manual/CustomPackages.html" target="_blank" rel="noopener">https://docs.unity.cn/2019.4/Documentation/Manual/CustomPackages.html</a><br><a href="https://keepachangelog.com/en/1.0.0/" target="_blank" rel="noopener">https://keepachangelog.com/en/1.0.0/</a><br><a href="https://semver.org/" target="_blank" rel="noopener">https://semver.org/</a><br><a href="https://www.jianshu.com/p/153841d65846" target="_blank" rel="noopener">https://www.jianshu.com/p/153841d65846</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI</title>
      <link href="2023/07/25/Unity3D-UGUI/"/>
      <url>2023/07/25/Unity3D-UGUI/</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas渲染"><a href="#Canvas渲染" class="headerlink" title="Canvas渲染"></a>Canvas渲染</h2><h3 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h3><p><img src="UGUI/1620891879051.png" alt="Alt text"></p><p>Pixel Perfect - 使UI元素像素对应，效果就是边缘清晰不模糊。</p><h3 id="RenderMode"><a href="#RenderMode" class="headerlink" title="RenderMode"></a>RenderMode</h3><h4 id="Screen-Space-Overlay"><a href="#Screen-Space-Overlay" class="headerlink" title="Screen Space-Overlay"></a>Screen Space-Overlay</h4><p>the Canvas is scaled to fit the screen and then rendered directly without reference to the scene or a camera</p><p>If the screen’s size or resolution are changed then the UI will automatically rescale to fit. </p><p>The UI will be drawn over any other graphics such as the camera view.<br>此模式只适合单纯的UI开发</p><h4 id="Screen-Space-Camera"><a href="#Screen-Space-Camera" class="headerlink" title="Screen Space - Camera"></a>Screen Space - Camera</h4><p>the Canvas is rendered as if it were drawn on a plane object some distance in front of a given camera. </p><p>The onscreen size of the UI does not vary with the distance since it is always rescaled to fit exactly within the camera frustum.</p><p>If the screen’s size or resolution or the camera frustum are changed then the UI will automatically rescale to fit.</p><p>可以用来实现在UI上显示3D模型的需求</p><p>参数：<br>Render Camera:渲染摄像机<br>Plane Distance:画布距离摄像机的距离<br>Sorting Layer<br>Order in Layer</p><h4 id="World-Space"><a href="#World-Space" class="headerlink" title="World Space"></a>World Space</h4><p>the plane need not face the camera and can be oriented however you like.</p><p>参数Event Camera - 用来指定接受事件的摄像机</p><h2 id="分辨率自适应-Canvas-Scaler"><a href="#分辨率自适应-Canvas-Scaler" class="headerlink" title="分辨率自适应 - Canvas Scaler"></a>分辨率自适应 - Canvas Scaler</h2><h3 id="关于Pixels-Per-Unity"><a href="#关于Pixels-Per-Unity" class="headerlink" title="关于Pixels Per Unity"></a>关于Pixels Per Unity</h3><p>Sprite中的设置：</p><p><img src="UGUI/1620895502265.png" alt="Alt text"></p><p>对于256x256的图片，这个值设置成100，意味着这个图的大小是 2.56x2.56 Units。</p><p>Canvas中的设置：</p><p><img src="UGUI/1620895706110.png" alt="Alt text"></p><p>指的是元素的1Unit对应UI屏幕上的多少像素。<br>2.56x2.56 Units的图片，对应屏幕上的256x256的像素。</p><p>For sprites that have the same Pixels Per Unit as the Reference Pixels Per Unit in the Canvas, the pixel density will be one to one.</p><h3 id="自适应方法"><a href="#自适应方法" class="headerlink" title="自适应方法"></a>自适应方法</h3><p>Reference Resolution - 开发时的分辨率。以后缩放就参考它。</p><p><img src="UGUI/1620896163082.png" alt="Alt text"></p><p>适应屏幕分辨率，本质是选择一个合适的缩放Canvas的方式。屏幕的宽高比会变化，Canvas的宽高比要与屏幕永远一致。Unity提供了几种方式 ，用来对Canvas进行缩放，来保证Canvas的宽高比与实际屏幕一致。</p><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>Match - Determines if the scaling is using the width or height as reference, or a mix in between.<br>处于中间某处时，对上述两者的影响进行权重加成 。所以一般我们都把其放在0.5的位置（0.618）</p><p>缩放时，UI元素之间的相对位置的比例是不变的。<br>Canvas进行 <strong>等比缩放</strong> 。</p><p>如图，Reference Resolution为800x600。</p><p><img src="UGUI/1620897020559.png" alt="Alt text"></p><p>Match Width - 匹配Width，保持Canvas的Width与Reference一致，缩放Heigth来保证比例与屏幕一致。比例一致后，Scale指的是当前的Canvas最终画到手机上时，应该进行的缩放。</p><p>当Resolution为1600x800时，Width不变，缩放Canvas的Height来保持比例与屏幕一致。因此，Canvas变为800x300。Scale为2，表示 屏幕 = Canvas x 2 ，Canvas放大两倍后画到屏幕上。</p><p><img src="UGUI/1620897086485.png" alt="Alt text"></p><p><img src="UGUI/1620898602324.png" alt="Alt text"></p><p>一般是Match Height，保持Canvas的高度不变，背景图的宽度画的长一点，用来适配不用的屏幕。UI元素的锚点设置为四个角即可。</p><p><img src="UGUI/1620900142626.png" alt="Alt text"></p><h4 id="Expand-amp-Shrink"><a href="#Expand-amp-Shrink" class="headerlink" title="Expand &amp; Shrink"></a>Expand &amp; Shrink</h4><p>Expand - Expand the canvas area either horizontally or vertically, so the size of the canvas will never be smaller than the reference.<br>Shrink - Crop the canvas area either horizontally or vertically, so the size of the canvas will never be larger than the reference.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#104;&#x74;&#x74;&#x70;&#x73;&#x3a;&#x2f;&#x2f;&#x64;&#x6f;&#99;&#115;&#46;&#x75;&#x6e;&#x69;&#x74;&#121;&#x33;&#x64;&#x2e;&#x63;&#x6f;&#x6d;&#x2f;&#80;&#x61;&#x63;&#107;&#x61;&#x67;&#x65;&#115;&#x2f;&#x63;&#111;&#109;&#46;&#117;&#110;&#x69;&#116;&#121;&#46;&#x75;&#103;&#117;&#x69;&#64;&#x31;&#x2e;&#48;&#x2f;&#x6d;&#x61;&#110;&#117;&#97;&#x6c;&#47;&#99;&#108;&#97;&#x73;&#x73;&#45;&#67;&#97;&#110;&#118;&#x61;&#x73;&#x2e;&#104;&#x74;&#x6d;&#x6c;">&#104;&#x74;&#x74;&#x70;&#x73;&#x3a;&#x2f;&#x2f;&#x64;&#x6f;&#99;&#115;&#46;&#x75;&#x6e;&#x69;&#x74;&#121;&#x33;&#x64;&#x2e;&#x63;&#x6f;&#x6d;&#x2f;&#80;&#x61;&#x63;&#107;&#x61;&#x67;&#x65;&#115;&#x2f;&#x63;&#111;&#109;&#46;&#117;&#110;&#x69;&#116;&#121;&#46;&#x75;&#103;&#117;&#x69;&#64;&#x31;&#x2e;&#48;&#x2f;&#x6d;&#x61;&#110;&#117;&#97;&#x6c;&#47;&#99;&#108;&#97;&#x73;&#x73;&#45;&#67;&#97;&#110;&#118;&#x61;&#x73;&#x2e;&#104;&#x74;&#x6d;&#x6c;</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U3D工具链积累</title>
      <link href="2023/07/25/Unity3D-U3D%E5%B7%A5%E5%85%B7%E9%93%BE%E7%A7%AF%E7%B4%AF/"/>
      <url>2023/07/25/Unity3D-U3D%E5%B7%A5%E5%85%B7%E9%93%BE%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U3D资源优化（零碎）知识点汇总</title>
      <link href="2023/07/25/Unity3D-U3D%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%EF%BC%88%E9%9B%B6%E7%A2%8E%EF%BC%89%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>2023/07/25/Unity3D-U3D%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%EF%BC%88%E9%9B%B6%E7%A2%8E%EF%BC%89%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h2><h3 id="ImportSettings"><a href="#ImportSettings" class="headerlink" title="ImportSettings"></a>ImportSettings</h3><p>Force To Mono：将多声道音频混合为单声道，一般手机使用单声道足够满足需求<br>Load In Background：When this option is enabled, the loading of the clip will happen at a delayed time on a separate thread, without blocking the main thread. 分线程加载， 不阻塞主线程<br>Ambisonic：是否环绕声</p><p>Load Type：加载方式</p><p><strong>Decompress On Load</strong> ：在音频 <strong>加载后马上解压缩</strong> 。对 <strong>较小的压缩声音</strong> 使用此选项可以避免动态解压缩的性能开销，不过在加载时解压缩Vorbis编码的声音将使用大约十倍于内存的内存（对于ADPCM编码约为3.5倍），因此请勿对大文件使用此选项。<br><strong>Compressed In Memory</strong> ：将声音压缩在内存中并在 <strong>播放时解压缩</strong> 。 此选项具有轻微的性能开销（特别是对于Ogg / Vorbis压缩文件），因此仅将其 <strong>用于加载时解压缩将使用大量内存的较大的文件</strong> 。 解压缩发生在 <strong>混音器线程</strong> 上，可以在探查器窗口的音频窗格中的”DSP CPU(Digital Signal Processor)”部分进行监视。<br><strong>Streaming</strong> ： <strong>动态解码</strong> 声音。 此方法使用 <strong>最少量的内存来缓冲从磁盘中逐步读取并在运行中解码的压缩数据</strong> 。 解压缩发生在单独的流线程上，可以在Profiler窗口的音频窗格的”Streaming CPU”部分中监视其CPU使用情况。 即使没有加载任何音频数据，Streaming的剪辑也有大约200KB的消耗。</p><p>Preload Audio Data：预加载</p><p>Compression Format<br>PCM：此选项以 <strong>更大的文件</strong> 大小为代价提供 <strong>更高的质量</strong> ，并且最适 <strong>合非常短的声音</strong> 效果。<br>ADPCM：这种格式对于 <strong>包含大量噪音</strong> 且 <strong>需要大量播放</strong> 的声音非常有用，例如脚步声，撞击声，武器。 <strong>压缩比</strong> 是PCM的 <strong>3.5倍</strong> ，而且 <strong>CPU使用率</strong> 远 <strong>低</strong> 于MP3 / Vorbis格式，这使其成为上述类别声音的首选。<br>Vorbis/MP3：压缩为较小的文件，但与PCM音频相比 <strong>质量稍低</strong> 。 <strong>压缩量</strong> 可通过”质量”滑块进行 <strong>配置</strong> 。 此格式最适合 <strong>中等长度</strong> 的音效和音乐。</p><p>Sample Rate Setting： 采样率设置<br>Preserve Sample Rate: 保留采样率<br>Optimize Sample Rate：此设置根据分析的最高频率内容自动优化采样率。<br>Override Sample Rate：此设置允许手动覆盖采样率，因此可以有效地避免采样内容丢失。</p><blockquote><p>要关注:<br> OriginalSize:磁盘大小<br> ImportedSize:内存大小<br> Ratio:ImportedSize占OriginalSize比例</p></blockquote><h3 id="设置建议"><a href="#设置建议" class="headerlink" title="设置建议"></a>设置建议</h3><ol><li><p>建议都勾选ForceToMono：将多声道音频混合为单声道</p></li><li><p>在iOS上请使用MP3格式，在Android上使用Vorbis</p></li><li><p>场景等长音效使用Streaming + Vorbis/MP3</p></li><li><p>技能等短音效使用DecompressOnLoad + ADPCM</p></li><li><p>采样率选择手动控制到22050左右</p></li><li><p>短音频可选格式aifff或wav，长音频可选格式mp3或ogg</p></li></ol><h3 id="导入后处理脚本"><a href="#导入后处理脚本" class="headerlink" title="导入后处理脚本"></a>导入后处理脚本</h3><pre><code class="lang-csharp">using System; using UnityEngine; using System.Collections; using UnityEditor; public class MyAudioProcessor : AssetPostprocessor{ public void OnPreprocessAudio(){ if (!assetPath.StartsWith(&quot;Assets/MyAudio&quot;)) return; AudioImporter audioImporter = (AudioImporter)assetImporter; audioImporter.forceToMono = true; //Android设置AudioImporterSampleSettings androidSettings = new AudioImporterSampleSettings(); androidSettings.loadType = AudioClipLoadType.DecompressOnLoad; //长音效用Streaming，短的用DecompressOnLoadandroidSettings.compressionFormat = AudioCompressionFormat.Vorbis; //Android用VorbisandroidSettings.quality = 100; androidSettings.sampleRateSetting = AudioSampleRateSetting.OverrideSampleRate; //采样率控制到22050左右androidSettings.sampleRateOverride = 22050; audioImporter.SetOverrideSampleSettings(&quot;Android&quot;, androidSettings); //iOS设置AudioImporterSampleSettings iOSSettings = new AudioImporterSampleSettings(); iOSSettings.loadType = AudioClipLoadType.DecompressOnLoad; //长音效用Streaming，短的用DecompressOnLoadiOSSettings.compressionFormat = AudioCompressionFormat.MP3; //iOS用MP3iOSSettings.quality = 100; iOSSettings.sampleRateSetting = AudioSampleRateSetting.OverrideSampleRate; //采样率控制到22050左右iOSSettings.sampleRateOverride = 22050; audioImporter.SetOverrideSampleSettings(&quot;iOS&quot;, iOSSettings); } }</code></pre><blockquote><p>Ref:<br> <a href="https://blog.csdn.net/LeoHiJack/article/details/95228708" target="_blank" rel="noopener">https://blog.csdn.net/LeoHiJack/article/details/95228708</a><br> <a href="https://blog.csdn.net/u013244147/article/details/104548393" target="_blank" rel="noopener">https://blog.csdn.net/u013244147/article/details/104548393</a><br> <a href="https://zhuanlan.zhihu.com/p/27438828" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27438828</a></p></blockquote><h2 id="Cull-Transparent-Mesh"><a href="#Cull-Transparent-Mesh" class="headerlink" title="Cull Transparent Mesh"></a>Cull Transparent Mesh</h2><p>Unity2018.2加入的新功能：Image对应的CanvasRenderer组件上可以勾选Cull Transparent Mesh</p><blockquote><p>官方描述：Indicates whether geometry emitted by this renderer can be ignored when the vertex color alpha is close to zero for every vertex of the mesh.</p></blockquote><p>若Image的Color属性的Alpha值接近于0，则该Image是看不见的，如果对其进行渲染，则会造成不必要的渲染性能开销。<br>如果在Image对应的CanvasRenderer开启Cull Transparent Mesh，则Unity进行渲染时会对该Image的Color的Alpha值进行检测，若该值接近于0，就忽略该Image，不进行绘制，节约性能。</p><p><img src="U3D资源优化（零碎）知识点汇总/2.png" alt="Alt text"></p><p><img src="U3D资源优化（零碎）知识点汇总/1.png" alt="Alt text"></p><p>如上图，第二张图Image组件的Alpha值为0，由FrameDebugger可见，Unity没有对该Image进行绘制。</p><p>更具体的，可见讨论：<br>I assume this culling test has a cost, which is why it’s not enabled by default/done automatically.</p><p>实现上：<br>this checkbox toggles a shader feature to cull pixels in the fragment shader with very low alpha value.</p><p>Docs would seem to indicate this uses the vertex colour alpha at the vertex stage:</p><p><a href="https://docs.unity3d.com/ScriptReference/CanvasRenderer-cullTransparentMesh.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/CanvasRenderer-cullTransparentMesh.html</a></p><p>But e.g:</p><p><a href="https://github.com/TwoTailsGames/Un...er/DefaultResourcesExtra/UI/UI-Default.shader" target="_blank" rel="noopener">https://github.com/TwoTailsGames/Un…er/DefaultResourcesExtra/UI/UI-Default.shader</a></p><blockquote><p>Ref:<br> <a href="https://twitter.com/dmitriy_focus/status/1166706421389496321?lang=en" target="_blank" rel="noopener">https://twitter.com/dmitriy_focus/status/1166706421389496321?lang=en</a><br> <a href="https://docs.unity3d.com/ScriptReference/CanvasRenderer-cullTransparentMesh.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/CanvasRenderer-cullTransparentMesh.html</a><br> <a href="https://forum.unity.com/threads/practical-effect-of-cull-transparent-mesh.746711/" target="_blank" rel="noopener">https://forum.unity.com/threads/practical-effect-of-cull-transparent-mesh.746711/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skinned Mesh Renderer</title>
      <link href="2023/07/25/Unity3D-Skinned-Mesh-Renderer/"/>
      <url>2023/07/25/Unity3D-Skinned-Mesh-Renderer/</url>
      
        <content type="html"><![CDATA[<h2 id="Motion-Vector"><a href="#Motion-Vector" class="headerlink" title="Motion Vector"></a>Motion Vector</h2><p><img src="assets/Skinned%20Mesh%20Renderer/1606707414304.png" alt="Alt text"></p><p>Motion vectors provide you with a texture with two channels that calculate the positional difference objects render in camera space between this frame and the previous frame.</p><blockquote><p>In video compression, a motion vector is the key element in the motion estimation process. It is used to represent a macroblock in a picture based on the position of this macroblock (or a similar one) in another picture, called the reference picture. — Wikipedia<br> In video editing motion vectors are used to compress video by storing the changes to an image from one frame to the next. — <a href="https://www.webopedia.com/TERM/M/motion_vector.html" target="_blank" rel="noopener">webopedia</a></p></blockquote><h3 id="算法的关键点"><a href="#算法的关键点" class="headerlink" title="算法的关键点"></a>算法的关键点</h3><p>In fact all of these terms refer to the process of finding corresponding points between two images or video frames. The points that correspond to each other in two views (images or frames) of a real scene or object are “usually” the same point in that scene or on that object. Before we do motion estimation, we must define our measurement of correspondence, i.e., the matching metric, which is a measurement of how similar two image points are. There is no right or wrong here; the choice of matching metric is usually related to what the final estimated motion is used for as well as the optimisation strategy in the estimation process.</p><h3 id="Unity中的Mesh-Renderer-Motion-Vectors"><a href="#Unity中的Mesh-Renderer-Motion-Vectors" class="headerlink" title="Unity中的Mesh Renderer Motion Vectors"></a>Unity中的Mesh Renderer Motion Vectors</h3><p><strong>Motion vectors</strong> track the per-pixel object velocity from one frame to the next in screen space. 描述当前像素下的片元，在相邻两帧之间，屏幕空间位置的差。</p><p>实现原理与兼容性 - When set, the camera renders another pass (after opaque but before Image Effects): First, a full screen pass is rendered to reconstruct screen-space motion from the camera movement, then, any moving objects have a custom <strong>pass</strong> to render their object-specific motion. The <strong>buffer</strong> uses the RenderTextureFormat.RGHalf format, so this feature only works on platforms where this format is supported.</p><p><strong>Velocity Buffer</strong> - 是一个全屏尺寸的 RenderTexture，motion vector 组成的Buffer。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>Use this velocity to reconstruct previous positions.</p></li><li><p>Using this information you can apply specific Image Effects such as <strong>motion blur</strong> or <strong>temporal anti-aliasing</strong>.</p></li></ul><h4 id="skinned-motion-vectors"><a href="#skinned-motion-vectors" class="headerlink" title="skinned motion vectors"></a>skinned motion vectors</h4><p>There is a cost to skinned motion vectors, though; they require twice as much memory per skinned mesh because the graphics memory on the GPU becomes double buffered (one buffer for the current frame and one buffer for the previous frame). The buffers track motion between frames; the velocity is the current frame’s position minus the last frame’s position.</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>使用Motion Vector实现相关的后处理特效:<br>相机上的脚本: </p><pre><code class="lang-csharp">using UnityEngine; [ExecuteInEditMode] [RequireComponent(typeof(Camera))] public class DatamoshEffect : MonoBehaviour { public Material DMmat; //datamosh materialvoid Start () { this.GetComponent().depthTextureMode=DepthTextureMode.MotionVectors; //generate the motion vector texture @ &#39;_CameraMotionVectorsTexture&#39;} private void OnRenderImage(RenderTexture src, RenderTexture dest){ Graphics.Blit(src,dest,DMmat); } } ``` ```csharp sampler2D _MainTex; sampler2D _CameraMotionVectorsTexture; fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); float4 mot = tex2D(_CameraMotionVectorsTexture,i.uv); col+=mot;//add motion vector values to the current colorsreturn col; } ``` ```csharp fixed4 frag (v2f i) : SV_Target { float4 mot = tex2D(_CameraMotionVectorsTexture,i.uv); //add motion vectors directly to UV position for sampling colorfixed4 col = tex2D(_MainTex, i.uv+mot.rg); return col; }</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://gitee.com/xianglinlove/Avatar" target="_blank" rel="noopener">https://gitee.com/xianglinlove/Avatar</a><br><a href="https://zhuanlan.zhihu.com/p/41763382" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41763382</a><br><a href="https://github.com/xieliujian/UnityDemo_Avatar" target="_blank" rel="noopener">https://github.com/xieliujian/UnityDemo_Avatar</a><br><a href="https://blog.uwa4d.com/archives/avartar.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/avartar.html</a><br><a href="https://github.com/zouchunyi/UnityAvater" target="_blank" rel="noopener">https://github.com/zouchunyi/UnityAvater</a></p><h2 id="优秀的相关资料"><a href="#优秀的相关资料" class="headerlink" title="优秀的相关资料"></a>优秀的相关资料</h2><p>在 Unity SRP 实现 Temporal Anti-aliasing: <a href="https://zhuanlan.zhihu.com/p/138866533" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138866533</a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/Motion_vector" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Motion_vector</a><br><a href="https://ompuco.wordpress.com/2018/03/29/creating-your-own-datamosh-effect/" target="_blank" rel="noopener">https://ompuco.wordpress.com/2018/03/29/creating-your-own-datamosh-effect/</a><br><a href="https://www.webopedia.com/TERM/M/motion_vector.html" target="_blank" rel="noopener">https://www.webopedia.com/TERM/M/motion_vector.html</a><br><a href="https://zhuanlan.zhihu.com/p/138866533" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138866533</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader变体相关知识与优化</title>
      <link href="2023/07/25/Unity3D-Shader%E5%8F%98%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>2023/07/25/Unity3D-Shader%E5%8F%98%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>标签：</strong>|  <em>优化</em>  </p><p>By Prin@UWA on 2020/8/17</p><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h2><h3 id="1-1-Shader相关一些概念"><a href="#1-1-Shader相关一些概念" class="headerlink" title="1.1 Shader相关一些概念"></a>1.1 Shader相关一些概念</h3><ul><li><p>着色器资源（Shader asset）: The full file source code with properties（属性）, sub-shader（子着色器）, passes（通道）, and HLSL（HLSL代码）.</p></li><li><p>着色器片段（Shader snippet）: The HLSL input code with dependencies for a single shader stage.(这个概念定义的不清楚)</p></li><li><p>着色器阶段（Shader stage）: A specific stage in the GPU rendering pipeline, typically a vertex shader stage and a fragment shader stage.</p></li><li><p>着色器关键字（Shader keyword）: A preprocessor identifier for compile-time branches across shaders.</p></li><li><p>着色器关键字集（Shader keyword set）: A specific set of shader keywords identifying a particular code path.</p></li><li><p>着色器变体（Shader variant）: The platform-specific shader code generated by the Unity shader compiler, for a single shader stage for a specific graphics tier, pass, shader keyword set, etc.</p></li><li><p>超着色器（Uber shader）: A shader source that can produce many shader variants.</p></li></ul><h4 id="Shader-snippet"><a href="#Shader-snippet" class="headerlink" title="Shader snippet"></a>Shader snippet</h4><p>对于snippet的概念，Unity官方的定义有点ambiguous。对此本文做了细致的研究。</p><h5 id="在Unity-Documentation中"><a href="#在Unity-Documentation中" class="headerlink" title="在Unity Documentation中"></a>在Unity Documentation中</h5><blockquote><p>Shader code is written by embedding “Cg/HLSL snippets” in the shader text. Snippets are compiled into low-level shader assembly by the Unity editor, and the final shader that is included in your game’s data files only contains this low-level assembly or bytecode, that is platform specific. </p><p>HLSL program snippets are written between CGPROGRAM and ENDCG keywords, or alternatively between HLSLPROGRAM and ENDHLSL.</p><p>Each snippet must contain at least a vertex program and a fragment program, so #pragma vertex and #pragma fragment directives are required.（<a href="https://docs.unity3d.com/Manual/SL-ShaderPrograms.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/SL-ShaderPrograms.html</a>）</p></blockquote><p>Shader Snippet就是CGPROGRAM/HLSLPROGRAM 和 ENDCG/ENDHLSL之间的程序片段<br>一个Snippet包含vertex shader和fragment shader 两个阶段（stage）</p><h5 id="在Shader-Build-Pipeline中"><a href="#在Shader-Build-Pipeline中" class="headerlink" title="在Shader Build Pipeline中"></a>在Shader Build Pipeline中</h5><p>在Shader编译管线中，一个Snippet对应的是一个单独的Stage。一个pass中，CGPROGRAM和ENDCG之间的部分包含两个snippets，分别是vertex snippet和fragment snippet。<br>对于包含两个stages（snippets）的pass，若关键字组合数为n，则一个snippet生成n个变体，一个pass生成2n个变体。</p><p>查看相关API的源码可以验证此结论:</p><p><img src="Shader变体相关知识与优化/ShaderSnippetData.png" alt="ShaderSnippetData"></p><p><img src="Shader变体相关知识与优化/ShaderType.png" alt="ShaderType"></p><p>Snippet类包含ShaderType属性，确定一个snippet是哪个stage的shader（Vertex、Fragment等）</p><h4 id="Shader-Variant"><a href="#Shader-Variant" class="headerlink" title="Shader Variant"></a>Shader Variant</h4><p>开发人员在写shader时，往往会在shader片段(Snippet)中定义一些关键字(Keyword)，并在代码中根据关键字开启与否控制物体的渲染过程，这样同一份shader源码可以具备多种不同的功能。最终编译的时候，引擎会根据不同的关键字组合生成多份shader程序(Program)。其中每一种组合对应的程序就是这个shader的一个变体(Variant)。</p><p>根据关键字产生shader变体的主要意义有：</p><ul><li>GPU不擅长处理分支语句（if-else），通过变体可避免分支语句导致的性能下降</li></ul><blockquote><p>GPU使用了不同于CPU的技术来实现分支语句。最坏的情况下，运行一个分支语句的时间相当于运行了所有分支语句的时间。如果在Shader中使用了大量的流程控制语句，那么这个Shader的性能可能会成倍下降。 ——《Unity Shader入门精要》</p></blockquote><ul><li>游戏运行时可在代码中选择shader变体，动态改变着色器功能</li></ul><p>Unity在打包时会把所有multi_compile产生的shader变体都打进包中</p><blockquote><p>对所有的宏的值的组合情况都生成一份Shader的变体，这样在使用的时候直接匹配，避免在Shader代码中使用if-else判断语句。if-else在GPU的并行处理中会表现出低效的性能，因为它会把所有的if走一遍(根据条件决定是否真的运行)，再把所有的else走一遍。</p></blockquote><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre><code class="lang-csharp">Shader &quot;MyShaderName&quot;{ Properties { // material properties here} SubShader // subshader for graphics hardware A{ Pass { // pass commands ...} // more passes if needed} // more subshaders if neededFallBack &quot;VertexLit&quot; // optional fallback} ``` ```csharp Pass { // ... the usual pass state setup ...CGPROGRAM // compilation directives for this snippet, e.g.:#pragma vertex vert#pragma fragment frag// the Cg/HLSL code itselfENDCG // ... the rest of pass setup ...} ``` ```csharp Shader &quot;Tutorial/Display Normals&quot; { SubShader { Pass { CGPROGRAM #pragma vertex vert#pragma fragment frag#include &quot;UnityCG.cginc&quot;struct v2f { float4 pos : SV_POSITION; fixed3 color : COLOR0; }; v2f vert (appdata_base v){ v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.color = v.normal * 0.5 \+ 0.5; return o; } fixed4 frag (v2f i) : SV_Target{ return fixed4 (i.color, 1); } ENDCG } } }</code></pre><h3 id="1-2-compile-directives（编译指令）及变体的生成规则"><a href="#1-2-compile-directives（编译指令）及变体的生成规则" class="headerlink" title="1.2 compile directives（编译指令）及变体的生成规则"></a>1.2 compile directives（编译指令）及变体的生成规则</h3><p>At the start of the snippet, compilation directives can be given as #pragma statements. </p><p>shader_feature更适用于材质的关键字，而multi_compile更适用于代码设置的全局关键字</p><h4 id="multi-compile"><a href="#multi-compile" class="headerlink" title="multi_compile"></a>multi_compile</h4><p>multi_compile会默认生成所有的变体，因此应当谨慎适用multi_compile，否则将会导致变体数量激增。</p><pre><code class="lang-csharp">#pragma multi_compile TEST_A TEST_B TEST_C #pragma multi_compile TEST_D TEST_E</code></pre><p><img src="Shader变体相关知识与优化/QQ截图20200806171125.png" alt="Alt text"></p><pre><code class="lang-csharp">#pragma multi_compile __ TEST_ON</code></pre><p>This directive produces two shader variants: one with nothing defined (__), and one with TEST_ON defined.<br>节省一个变量个数的占用（Unity中关键字有个数限制）<br>如： </p><h4 id="shader-feature"><a href="#shader-feature" class="headerlink" title="shader_feature"></a>shader_feature</h4><pre><code class="lang-csharp">#pragma shader_feature KW1 KW2 ``` ```csharp #pragma shader_feature KW_X #pragma shader_feature __ KW_X</code></pre><p>shader_feature is very similar to multi_compile. The only difference is that Unity does not include unused variants of shader_feature shaders in the final build.<br>只生成对应的Material上关键字对应的变体。</p><ol><li><p>预编译语句会默认生成开启第一个关键字的变体</p></li><li><p>shader<em>feature 预编译语句行至少有两个关键字。如果只定义了一个关键字SF_A，则会默认生成一个下划线关键字” </em>“，默认SF<em>A不开启，生成一份开启关键字”</em> “的变体。如果SF<em>A开启，则会生成分别开启”</em>”和”SF_A”的两份变体</p></li><li><p>shader_feature 预编译语句行，如果定义了两个关键字”SF_C”和”SF_D”，则不生成下划线关键字。默认第一个关键字 “SF_C” 开启，生成一份变体。如果某个材质开启了”SF_D”，但没有材质开启”SF_C”，依然认为两个关键字都被使用到，生成两份变体。</p></li><li><p>如果同一个Material开启了同一个shader_feature行的两个关键字”SF_C”和”SF_D”，则认为开启无效，只按照默认情况生成一份变体（SF_C开启的变体）.</p></li></ol><p>我们来看以下案例：<br>Material-M使用原先使用的Shader为Shader-A，其上包含Shader-A中定义的关键字KW1、KW2，如果Material-M的Shader换成了Shader-B，且场景中没有其他Material使用Shader-A，那么，虽然Material-M上还记录了Shader-A中的关键字KW1和KW2，但是并不会对Shader-A生成的变体造成影响，Shader-A不会生成两份变体。<br>即：Unity只会按照Shader实际对应的材质的关键字生成变体，没有使用Shader-A的材质Material-M上的关键字不会影响Shader-A的变体的生成。</p><h4 id="Unity内置变体"><a href="#Unity内置变体" class="headerlink" title="Unity内置变体"></a>Unity内置变体</h4><p>multi_compile_fwdbase<br>multi_compile_fwdadd<br>multi_compile_fwdadd_fullshadows<br>multi_compile_fog </p><p>Most of the built-in shortcuts produce many shader variants. if you know the project doesn’t need them, you can use #pragma skip_variants to skip compiling some of them.</p><pre><code class="lang-csharp">#pragma multi_compile_fwdadd #pragma skip_variants POINT POINT_COOKIE</code></pre><h4 id="local-keyword-vs-global-keyword"><a href="#local-keyword-vs-global-keyword" class="headerlink" title="local keyword vs global keyword"></a>local keyword vs global keyword</h4><p>The main disadvantage of shader_feature and multi_compile is that all keywords defined in them contribute towards Unity’s global keyword count limit (256 global keywords, plus 64 local keywords). </p><p>The total number of local and global keywords per shader affects performance: in an ideal set-up, use more local keywords and fewer global keywords, to reduce the total keyword count per shader.</p><p>local keyword有助于提高项目的性能，同时也可以减少每个shader中keyword数量。</p><p>留坑: 这里笔者还存在两点疑惑</p><ol><li><p>local keyword 和 global keyword的区别在哪里</p></li><li><p>If a Material has a local keyword enabled, and its shader changes to one that is no longer declared, Unity creates a new global keyword. 这句话实际是什么意思，它描述的问题笔者没有复现。</p></li></ol><h3 id="1-3-Material-ShaderKeywords启用禁用宏"><a href="#1-3-Material-ShaderKeywords启用禁用宏" class="headerlink" title="1.3 Material ShaderKeywords启用禁用宏"></a>1.3 Material ShaderKeywords启用禁用宏</h3><p>Material所包含的Shader Keywords表示启用shader中对应的宏，Unity会调用当前宏组合所对应的变体来为Material进行渲染。</p><p>在Editor下，可以通过将material的inspector调成Debug模式来查看当前material定义的Keywords，也可在此模式下直接定义Keywords，用空格分隔Keyword。<br>在程序中，可用Material.EnableKeyword()、Material.DisableKeyword()、Shader.EnableKeyword()、Shader.DisableKeyword()来启用/禁用相应的宏。</p><h3 id="1-4-变体数量"><a href="#1-4-变体数量" class="headerlink" title="1.4 变体数量"></a>1.4 变体数量</h3><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><p><img src="Shader变体相关知识与优化/image7.png" alt="Alt text"></p><blockquote><p>For each supported graphics API in the project, we need a dedicated set of shader variants. (每个支持的graphics API都需要一套专用的变体集。)Shader data size are directly proportional to the number of supported graphics APIs.</p></blockquote><h4 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h4><p>在Shader的inspector面板中可以看到Shader的Compiled Code选项，点开后可以看到Shader Variants数量</p><h3 id="1-6-Shader-build-pipeline"><a href="#1-6-Shader-build-pipeline" class="headerlink" title="1.6 Shader build pipeline"></a>1.6 Shader build pipeline</h3><p>The shader compilation pipeline in Unity is a black box where each shader in the project is parsed to extract shader snippets before collecting the variant preprocessing instructions, such as multi_compile and shader_feature. This produces a list of compilation parameters, one per shader variant.</p><p><img src="Shader变体相关知识与优化/ShaderBuildPipeline.png" alt="Shader Build Pipeline"></p><h4 id="Build时，哪些变体会被编译打包？"><a href="#Build时，哪些变体会被编译打包？" class="headerlink" title="Build时，哪些变体会被编译打包？"></a>Build时，哪些变体会被编译打包？</h4><ol><li><p>Scenes In Build里面的场景引用到的Shader</p></li><li><p>Project Settings -&gt; Graphics -&gt; Always Include Shaders中的shader</p></li><li><p>任意位置的名为Resources的文件夹下的shaders</p></li><li><p>以上被编译的Shader脚本当中的fallback用到的shaders</p></li></ol><h4 id="自动Shader变体去除"><a href="#自动Shader变体去除" class="headerlink" title="自动Shader变体去除"></a>自动Shader变体去除</h4><p>Unity executes an <strong>automatic shader variant</strong> stripping pass based on two heuristics(启发式方法). </p><ul><li>Project Settings</li></ul><blockquote><p>例如：如果虚拟现实支持（Virtual Reality Supported）被禁用，则VR着色器变体会被系统地移除掉。</p></blockquote><ul><li>configuration of Shader Stripping section of the Graphics Settings</li></ul><p>下面这个着色器变体列表，里面的已启用关键字都被自动移除：</p><blockquote><p>Lightmap modes: LIGHTMAP_ON, DIRLIGHTMAP_COMBINED, DYNAMICLIGHTMAP_ON, LIGHTMAP_SHADOW_MIXING, SHADOWS_SHADOWMASK<br> Fog modes: FOG_LINEAR, FOG_EXP, FOG_EXP2<br> Instancing Variants: INSTANCING_ON</p></blockquote><p>当虚拟现实支持被禁用时，带有下列内置关键字的着色器变体都会被移除：</p><blockquote><p>STEREO_INSTANCING_ON, STEREO_MULTIVIEW_ON, STEREO_CUBEMAP_RENDER_ON, UNITY_SINGLE_PASS_STEREO</p></blockquote><p>当自动移除过程完成后，着色器构建管线会使用剩余编译参数集来安排并行着色器变体编译顺序，并根据平台所拥有的CPU核心线程尽可能多地启动多个同时编译过程。</p><h4 id="奇怪的现象——多生成一份Vertex-Shader"><a href="#奇怪的现象——多生成一份Vertex-Shader" class="headerlink" title="奇怪的现象——多生成一份Vertex Shader"></a>奇怪的现象——多生成一份Vertex Shader</h4><p>在Build时，使用OnProcessShader对编译过程生成的变体进行输出，会发现每个Shader都会对Vertex Shader多生成一次 ，如下图，TestShader1只有一份变体。</p><p><img src="Shader变体相关知识与优化/QQ截图20201014203947.png" alt="Alt text"></p><p>观察编译过程，发现在Building Resources folder时先生成一份Vertex Shader，然后在编译结束后，会生成完整的Shader变体。那么整个编译过程是怎样的呢？为什么会预先生成一份vertex shader？笔者想对Build过程进行探索如下。<br>Building Player显示的编译过程如下：</p><ol><li><p>Build Player</p></li><li><p>Buiding scene 0: SampleScene</p></li><li><p>Material1 - Custom/TestShader2 - Pass 0: Stripping Vertex programs</p></li><li><p>Building Resources folder</p></li><li><p>Packaging assets - globalgamemanagers.assets</p></li><li><p>Standard - FORWARD: Stripping Vertex programs</p></li><li><p>Skybox/Procedural - Pass 0: Stripping Vertex programs</p></li><li><p>Legacy Shaders/Diffuse - FORWARD: Stripping Fragment programs</p></li><li><p>Hidding/Internal-DefferedShading - Pass 0: 1 of 26 vp</p></li><li><p>Hidden/Internal-ODSWorldTexture - Pass 0: Stripping Vertex programs</p></li><li><p>Postprocessing Player</p></li><li><p>Copying files to final destination</p></li><li><p>Done</p></li></ol><p>就目前得信息来看，可能在Shader变体的预处理阶段会首先生成一份Vertex Shader。</p><h3 id="1-7-Shader的build及加载过程"><a href="#1-7-Shader的build及加载过程" class="headerlink" title="1.7 Shader的build及加载过程"></a>1.7 Shader的build及加载过程</h3><h4 id="Editor中"><a href="#Editor中" class="headerlink" title="Editor中"></a>Editor中</h4><ul><li><p>At import time, only do minimal processing of the shader (surface shader generation etc.).</p></li><li><p>Actually compile the shader variants only when needed.</p></li><li><p>Instead of typical work of compiling 100–10000 internal shaders at import time, this usually ends up compiling just a handful.</p></li></ul><blockquote><p>Individual shader variant compilation results are cached in the project, under Library/ShaderCache folder. </p></blockquote><h4 id="Build时"><a href="#Build时" class="headerlink" title="Build时"></a>Build时</h4><p>每个shader生成哪些变体会决定好，shader生成对应的变体之后，打进包中。<br>All the “not yet compiled” shader variants are compiled, so that they are in the game data even if the editor did not happen to use them.</p><h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>场景加载时，加载到的object对应的Shader都会加载进内存当中，加载之后就会进行解析(Shader.Parse)<br>实际进行渲染时，会将Shader写入GPU显存中(Shader.CreateGPUProgram)。</p><p>根据回答：<a href="https://answer.uwa4d.com/question/5ce5467ad1d3d045c846d769" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5ce5467ad1d3d045c846d769</a><br>Shader进行Parse的时候，会将一部分Shader写入GPU当中，此时生成的GPU程序片段不全，在渲染实际的物体时，一定会将用到的Shader编译结果写入GPU显存。</p><p>如果提前进行warmup，就可以提前将GPUProgram写入显存。</p><ul><li><p>在Unity 4.x中，调用Shader.WarmupAllShaders()，可以自动编译该场景中用到的所有shader。该方法在Unity5中已经废弃</p></li><li><p>没有使用5.x新的shader(Standard和StandardSpecular)，自定义shader也没有使用大量关键字等还是可以使用Shader::WarmupAllShaders</p></li><li><p>调用ShaderVariantCollection.WarmUp()函数手动进行预热，编译shader并写入显存</p></li><li><p>在ProjectSettings-&gt;Graphics中，设置PreloadedShaders，这样可以在加载场景时一并编译需要预加载的shader（是否会warmup不清楚）</p></li></ul><blockquote><p>ShaderLab在相关shader加入内存时就已经产生，但如果没有被渲染的话不会触发CreateGPUProgram操作，如果提前在ShaderVariantCollection中收集了相关变体并执行了warmup（预热）的话，第一次渲染时就不会再CreateGPUProgram，对卡顿会有一定好处。因此第一次加载shader先warmup一下，虽然等待的时间长但是仅此一次，当你退出游戏下次再进入也不会再执行warmup，可以有效避免渲染卡顿</p></blockquote><h2 id="2-面对的问题"><a href="#2-面对的问题" class="headerlink" title="2 面对的问题"></a>2 面对的问题</h2><p>Shaders are small programs that execute on the GPU, and loading them can take some time.<br>大量的Shader变体会造成以下两点问题：</p><ul><li><p>Build时， <strong>时间长，数据包体大</strong><br>Large numbers of these shader variants increase game build time, and game data size.</p></li><li><p>Rumtime时， <strong>占用内存高，加载耗时长（卡顿）</strong><br>Loading large numbers of shader variants at runtime is slow and takes up memory.</p></li></ul><p>我们希望 <strong>在保证渲染效果正确的情况下，尽可能地控制项目重shader变体数量，避免产生冗余资源</strong></p><h3 id="2-1-变体数与内存、显存的关系"><a href="#2-1-变体数与内存、显存的关系" class="headerlink" title="2.1 变体数与内存、显存的关系"></a>2.1 变体数与内存、显存的关系</h3><p><img src="Shader变体相关知识与优化/QQ截图20200807185651.png" alt="Alt text"></p><p>变体数和ShaderLab的内存占用基本成正比，而和GFX无关。说明没有参与渲染的Shader变体是不会经历CreateGPUProgram统计到GFX内存中的。</p><blockquote><p>一般来说shader片段中multi_compile类关键字每增加一个，或者启用的shader_feature类关键字增加一个，该Shader的变体数量就会x2，是以指数函数的方式增长的。</p></blockquote><h3 id="2-2-Shader变体的打包方式"><a href="#2-2-Shader变体的打包方式" class="headerlink" title="2.2 Shader变体的打包方式"></a>2.2 Shader变体的打包方式</h3><p>Shader与Material打在一个包中，变体根据material中的keywords自动生成</p><ul><li><p>多个不同的material包中可能存在相同的shader变体，造成资源冗余</p></li><li><p>若程序运行时动态改变material的keyword，使用shader_feature定义的宏，其 变体可能并没有被生成</p></li></ul><p>Shader单独打包，使用multi_compile定义的全部宏全部变体都被生成，不会发生需要的变体未生成的情况。</p><ul><li>生成的变体数量庞大，严重浪费资源</li></ul><p>Shader单独打包，shader_feature（需要使用ShaderVariantCollection生成变体）与multi_compile（还是生成所有变体）结合使用能够有效控制shader_feature变体数量。</p><ul><li>容易遗漏需要生成的变体，特别是需要动态替换的变体</li></ul><h3 id="2-3-Unity-Material关键字的坑"><a href="#2-3-Unity-Material关键字的坑" class="headerlink" title="2.3 Unity Material关键字的坑"></a>2.3 Unity Material关键字的坑</h3><p>实际打进包中的Shader变体数量和在Editor下预览的还是不一样的，实际打进包中的变体数量要多于Editor下预览的，并且发现了有很多隐藏的关键字，这些关键字其实根本没有显式的引用，但是却在打包的时候出现了，并且增加了Shader变体数量。</p><p>Unity关键字有个坑：<br>材质球里会记录之前使用的关键字，打个比方 ：Shader A 需要开启关键字 _AKW ，Shader B需要开启关键字 _BKW ，材质球 M 起初使用了Shader A ，开启了关键字_AKW，由于某个原因这个材质球不想使用Shader A 了，切换到Shader B，开启了_BKW，那么这个材质球就会包含_AKW 、_BKW 这两个关键字。</p><p>不过如果Shader B中如果没有定义_KWA，则残留的关键字_KWA不会对变体数造成影响。旧的关键字的残留对项目的影响在实际研发中进一步考证。</p><h2 id="3-工具与方案"><a href="#3-工具与方案" class="headerlink" title="3 工具与方案"></a>3 工具与方案</h2><h3 id="3-1-Shader变体数量统计小工具"><a href="#3-1-Shader变体数量统计小工具" class="headerlink" title="3.1 Shader变体数量统计小工具"></a>3.1 Shader变体数量统计小工具</h3><pre><code class="lang-csharp">using UnityEditor; using UnityEngine; using System.Reflection; using System.IO; using System.Text; public class ShaderVariantCntGetter{ [MenuItem(&quot;Tools/GetShaderVariant&quot;)] public static void GetAllShaderVariantCount(){ System.Type t = typeof(Editor).Assembly.GetType(&quot;UnityEditor.ShaderUtil&quot;); MethodInfo method = t.GetMethod(&quot;GetVariantCount&quot;, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); var shaderList = AssetDatabase.FindAssets(&quot;t:Shader&quot;); var output = System.Environment.GetFolderPath(System.Environment.SpecialFolder.DesktopDirectory); string pathF = string.Format(&quot;{0}/ShaderVariantCount.csv&quot;, output); FileStream fs = new FileStream(pathF, FileMode.Create, FileAccess.Write); StreamWriter sw = new StreamWriter(fs, Encoding.UTF8); EditorUtility.DisplayProgressBar(&quot;Shader统计文件&quot;, &quot;正在写入统计文件中...&quot;, 0f); int ix = 0; sw.WriteLine(&quot;ShaderFile, VariantCount&quot;); foreach (var i in shaderList) { EditorUtility.DisplayProgressBar(&quot;Shader统计文件&quot;, &quot;正在写入统计文件中...&quot;, ix / shaderList.Length); var path = AssetDatabase.GUIDToAssetPath(i); Shader s = AssetDatabase.LoadAssetAtPath(path, typeof(Shader)) as Shader; var variantCount = method.Invoke(null, new System.Object[] { s, true }); sw.WriteLine(path + &quot;,&quot; \+ variantCount.ToString()); ++ix; } EditorUtility.ClearProgressBar(); sw.Close(); fs.Close(); } }</code></pre><h3 id="3-2-Shader-Control"><a href="#3-2-Shader-Control" class="headerlink" title="3.2 Shader Control"></a>3.2 Shader Control</h3><p>查看Shader的变体数量，冗余关键字、查看哪些材质引用了这个Shader的哪些关键字</p><p>ShaderControl的Clear All Material功能，批量清除了材质球中残留的关键字。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>Assets -&gt; Browse Shaders</p><p>查看：<br>In ‘Build View’ click “Quick Build’ and make a normal build. </p><blockquote><p>Notice the build completes very fast because this is a special build in which Shader Control only collects data about the shaders.</p></blockquote><p>剔除：<br>see a list of shaders compiled in your build. You can toggle the “Include” checkbox to include or not that shader or keyword in future builds.</p><p>We want to remove some keywords from the source code of the shader so we reduce the total keywords used in our project:</p><ol><li><p>Select ‘Project View’.</p></li><li><p>Click “Scan Project”. Shader Control will quickly scan your project for shaders using keywords and will show them.</p></li><li><p>show used keywords.</p></li><li><p>Disable any keywords and click “Save”. Colors will change depending on which keywords are enabled in the shader.</p></li></ol><p>The Build View gives you full control on which shaders or keywords are compiled (making the compilation faster and reducing the build size).<br>The Project View gives you full control on keywords in shaders that are in your project by modifying them automatically (reducing count of keywords in your project).</p><p>Clean All Materials<br>will scan all materials and prune any disabled keywords. This option is provided to ensure no materials are referncing a disabled shader keyword.<br>批量清除了材质球中残留的关键字。</p><h3 id="3-3-ShaderVariantCollection"><a href="#3-3-ShaderVariantCollection" class="headerlink" title="3.3 ShaderVariantCollection"></a>3.3 ShaderVariantCollection</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><p>ShaderVariantCollection records which shader variants are actually used in each shader.</p></blockquote><h5 id="1-编译时，强制打包要使用的变体"><a href="#1-编译时，强制打包要使用的变体" class="headerlink" title="(1) 编译时，强制打包要使用的变体"></a>(1) 编译时，强制打包要使用的变体</h5><p>有些Shader变体在运行时可能由C#脚本调用到，而在build时无法预知该变体是否会被访问，那么使用SVC可以对这部分变体进行强制打包。</p><h5 id="2-运行时warmup"><a href="#2-运行时warmup" class="headerlink" title="(2) 运行时warmup"></a>(2) 运行时warmup</h5><p>This is used for shader preloading (“warmup”), so that a game can make sure “actually required” shader variants are loaded at startup (or level load time), to avoid shader compilation related hiccups later on in the game.<br>取代Shader.WarmupAllShaders()接口，提前warmup防止运行时打嗝（hiccup, 卡顿），又避免Warmup所有的Shader造成时间与内存的浪费。</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>有了变体集之后，打包shader时，依然对shader进行了长时间的编译。由此推断，SVC无法减少Build时打包的变体数量，需要我们自行过滤排除。<br>在使用ShaderVariantCollection收集变体打包时，只对shader_feature定义的宏有意义，multi_compile的变体不用收集也会被全部打进包体。</p><h3 id="3-4-从Shader代码上入手：Improving-shader-code-design"><a href="#3-4-从Shader代码上入手：Improving-shader-code-design" class="headerlink" title="3.4 从Shader代码上入手：Improving shader code design"></a>3.4 从Shader代码上入手：Improving shader code design</h3><ol><li><p>First, we should make sure that every keyword is actually useful. If we can guarantee these keywords are never used, then we should remove them. 去除从未使用的关键字</p></li><li><p>Second, we should combine keywords that effectively produce a single code path. 去除无效的关键字组合</p></li></ol><pre><code class="lang-csharp">#pragma multi_compile COLOR_ORANGE COLOR_VIOLET COLOR_GREEN COLOR_GRAY // color keywords #pragma multi_compile OP_ADD OP_MUL OP_SUB // operator keywords ``` ```csharp #pragma multi_compile ADD_COLOR_ORANGE MUL_COLOR_VIOLET MUL_COLOR_GREEN #if defined(ADD_COLOR_ORANGE) #define COLOR_ORANGE #define OP_ADD #elif defined(MUL_COLOR_VIOLET) #define COLOR_VIOLET #define OP_MUL #elif defined(MUL_COLOR_GREEN) #define COLOR_GREEN #define OP_MUL #endif</code></pre><h3 id="3-4-scriptable-shader-variants-stripping-本文简写做SVS"><a href="#3-4-scriptable-shader-variants-stripping-本文简写做SVS" class="headerlink" title="3.4 scriptable shader variants stripping(本文简写做SVS)"></a>3.4 scriptable shader variants stripping(本文简写做SVS)</h3><blockquote><p>原Shader编译管线的缺陷——受编译时间的限制<br> Unity can’t automatically select only the necessary shader variants at build time because those shader variants depend on runtime C# execution. </p></blockquote><p>SVS: Massively reduce Player build time and data size by allowing developers to control which Shader variants are handled by the Unity Shader compiler and included in the Player data.</p><p>发布版本：2018.2 beta</p><p>功能：</p><ul><li><p>strip all the shader variants with invalid code paths, </p></li><li><p>strip shader variants for unused features </p></li><li><p>create shader build configurations such as “debug” and “release” without affecting iteration time or maintenance complexity.</p></li></ul><p>In Unity 2018.2 beta, the shader pipeline architecture introduces a new <strong>stage</strong> right <strong>before the shader variant compilation scheduling</strong> , allowing users to <strong>control the shader variant compilation</strong>. This new stage is exposed via C# callbacks to user code, and <strong>each callback is executed per shader snippet</strong>.</p><p><strong>OnProcessShader</strong> is called right <strong>before the scheduling of the shader variant compilation</strong>.</p><p>Each combination of <strong>a Shader</strong> , <strong>a ShaderSnippetData</strong> and <strong>ShaderCompilerData</strong> instances is an identifier for <strong>a single shader variant</strong> that the shader compiler will produce. To strip that shader variant, we only need to remove it from the ShaderCompilerData list.<br>Every single shader variant that the shader compiler should generate will appear in this callback. </p><h4 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h4><ol><li><p>systematically strip invalid shader variants of a render pipeline due to the various combinations of shader keywords.<br>HDRP和URP分别实现了自己的Shader variants stripping功能。</p></li><li><p>Another use case is a script to strip all the rendering features of a render pipeline that are not used for a specific project.</p></li></ol><h4 id="Tips-on-writing-SVS-code"><a href="#Tips-on-writing-SVS-code" class="headerlink" title="Tips on writing SVS code"></a>Tips on writing SVS code</h4><p>回调序列：callbackOrder 决定了IPreprocessShaders类中Shader处理函数OnProcessShader的调用顺序(in order of increasing callbackOrder)。因此，可以在Project中写多个类继承IPreprocessShaders，在编译时，编辑器会按照callbackOrder增加的顺序，逐个调用OnProcessShader函数。</p><p><strong>separate the scripting per purpose</strong><br>Script 1: Systematically strips all the shader variants with invalid code paths.<br>Script 2: Strips all the debug shader variants.<br>Script 3: Strips all the shader variants in the code base that are not necessary for the current project.<br>Script 4: Logs the remaining shader variants and strips them all for fast iteration time on the stripping scripts.(这个没有看懂)</p><h4 id="Process-for-writing-a-SVS-script"><a href="#Process-for-writing-a-SVS-script" class="headerlink" title="Process for writing a SVS script"></a>Process for writing a SVS script</h4><ol><li><p>In the Project view, filter for all shaders.</p></li><li><p>Select a shader and, in the Inspector, click Show to open the list of keywords / variants of that shader. There will be a list of keywords that are always included in the build.</p></li><li><p>Make sure that you know which specific graphics features the project uses.</p></li><li><p>Check whether the keywords are used in all shader stages. Only one variant is necessary for stages that don’t use these keywords.</p></li><li><p>Strip shader variants in the script.</p></li><li><p>Verify the visuals in the build.</p></li><li><p>Repeat steps 2–6 for each shader.</p></li></ol><h4 id="应用示例（两个较成熟的stripping实现）"><a href="#应用示例（两个较成熟的stripping实现）" class="headerlink" title="应用示例（两个较成熟的stripping实现）"></a>应用示例（两个较成熟的stripping实现）</h4><p><a href="https://github.com/lujian101/ShaderVariantCollector" target="_blank" rel="noopener">https://github.com/lujian101/ShaderVariantCollector</a><br><a href="https://github.com/SixWays/UnityShaderStripper" target="_blank" rel="noopener">https://github.com/SixWays/UnityShaderStripper</a></p><h2 id="4-Others"><a href="#4-Others" class="headerlink" title="4 Others"></a>4 Others</h2><h3 id="4-1-Standard-Shader造成变体数过多的原因"><a href="#4-1-Standard-Shader造成变体数过多的原因" class="headerlink" title="4.1 Standard Shader造成变体数过多的原因"></a>4.1 Standard Shader造成变体数过多的原因</h3><p>由于Standard的变体太多了，所以当引用了Standard的时候，往往会存在多个Standard变体，占用大量的内存。</p><h4 id="模型导入导致"><a href="#模型导入导致" class="headerlink" title="模型导入导致"></a>模型导入导致</h4><p>模型导入的时候，“Import Materials”是默认勾选的。所以当模型导入时，Unity会在同目录创建“Materials”目录，并创建相应的材质，而这个材质默认是使用 <strong>Standard</strong> 。<br>解决方法: 把“Import Materials”去掉，并把没有使用的默认材质删除。</p><p>问题补充：<br>没有勾选“Import Materials”的模型文件，在实例化Prefab时，ShaderLab会存在一份“Standard”的shader内存，而这个shader的引用是指向一个“Default-Material”文件（可是这文件并不存在）。<br>但是，在模型和Prefab在相同的AssetBundle中，或者使用Resources加载时，却不会有“Standard”和“Default-Material”的出现。</p><p>解决方案：在需要模型与Prefab分开打包时，勾选“Import Materials”，直接使用和修改默认生成的材质。</p><h4 id="默认模型（Cube、Sphere）创建导致的"><a href="#默认模型（Cube、Sphere）创建导致的" class="headerlink" title="默认模型（Cube、Sphere）创建导致的"></a>默认模型（Cube、Sphere）创建导致的</h4><p>早期场景搭建时，为了方便定位和可视化，曾经使用Cube等系统默认的Mesh作为锚点，然后在启动游戏时禁用掉。<br>由于这些Cube不启用，性能消耗很轻微。所以就没有理会了。<br>可是，就因为是系统默认的Mesh，所以创建时，赋予的材质就是默认的材质“Default-Material”，而这个材质使用的着色器就恰恰是“Standard”。</p><p>解决的方案：删掉这些mesh或者是替换材质。</p><h3 id="4-2-其他ShaderLab内存优化方案（未研究）"><a href="#4-2-其他ShaderLab内存优化方案（未研究）" class="headerlink" title="4.2 其他ShaderLab内存优化方案（未研究）"></a>4.2 其他ShaderLab内存优化方案（未研究）</h3><p><a href="https://zhuanlan.zhihu.com/p/39337699" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39337699</a></p><h2 id="5-其他注意事项"><a href="#5-其他注意事项" class="headerlink" title="5 其他注意事项"></a>5 其他注意事项</h2><ol><li><p>内存中ShaderLab的大小和变体成正比关系。从减少内存方面应该尽量减少变体数量，可以使用 #pragma skip_variants。</p></li><li><p>在使用ShaderVariantCollection收集变体打包时，只对shader_feature定义的宏有意义，multi_compile的变体不用收集也会被全部打进包体。</p></li><li><p>2018.2新功能OnProcessShader可以移除无用的shader变体。比#pragma skip_variants更合理。</p></li><li><p>项目前期介入美术效果制作流程，规范shader宏定义使用，防止TA为了美术效果过度使用宏定义的情况，以过往项目经验来看，到后期进行此项工作导致的资源浪费非常之大。</p></li><li><p>ShaderLab在相关shader加入内存时就已经产生，但如果没有被渲染的话不会触发CreateGPUProgram操作，如果提前在ShaderVariantCollection中收集了相关变体并执行了warmup的话，第一次渲染时就不会再CreateGPUProgram，对卡顿会有一定好处。</p></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/27336202" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27336202</a><br><a href="https://www.cnblogs.com/msxh/p/12987632.html" target="_blank" rel="noopener">https://www.cnblogs.com/msxh/p/12987632.html</a><br><a href="https://zhuanlan.zhihu.com/p/68888831" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68888831</a><br><a href="https://www.jianshu.com/p/5a2388c9963a" target="_blank" rel="noopener">https://www.jianshu.com/p/5a2388c9963a</a><br><a href="https://blogs.unity3d.com/cn/2018/05/14/stripping-scriptable-shader-variants/" target="_blank" rel="noopener">https://blogs.unity3d.com/cn/2018/05/14/stripping-scriptable-shader-variants/</a><br><a href="https://docs.unity3d.com/Manual/SL-ShaderPrograms.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/SL-ShaderPrograms.html</a><br><a href="https://docs.unity3d.com/Manual/ShaderTut2.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/ShaderTut2.html</a><br><a href="https://github.com/lujian101/ShaderVariantCollector" target="_blank" rel="noopener">https://github.com/lujian101/ShaderVariantCollector</a><br><a href="http://imgtec.eetrend.com/d6-imgtec/blog/2018-06/16669.html" target="_blank" rel="noopener">http://imgtec.eetrend.com/d6-imgtec/blog/2018-06/16669.html</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/68888831" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68888831</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Settings与优化相关知识点</title>
      <link href="2023/07/25/Unity3D-Project-Settings%E4%B8%8E%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2023/07/25/Unity3D-Project-Settings%E4%B8%8E%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Managed-code-stripping"><a href="#Managed-code-stripping" class="headerlink" title="Managed code stripping"></a>Managed code stripping</h2><p>unused code from a build -&gt;</p><ul><li><p>decrease the final build size</p></li><li><p>while using the IL2CPP - decrease build time because less code needs to be converted to C++ and compiled.</p></li></ul><p><strong>statically analyzing</strong> the code in a Project to detect classes, members of classes, and even portions of functions that can never be reached during execution. </p><blockquote><p>When your code (or code in a plugin) looks up classes or members dynamically using reflection, the code stripping tool cannot always detect that the Project is using those classes or members, and might remove them. To declare that a Project is using such code, use link.xml files or Preserve attributes.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ScriptableObject</title>
      <link href="2023/07/25/Unity3D-ScriptableObject/"/>
      <url>2023/07/25/Unity3D-ScriptableObject/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文档：<a href="https://docs.unity3d.com/ScriptReference/ScriptableObject.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/ScriptableObject.html</a><br> <a href="https://docs.unity3d.com/Manual/class-ScriptableObject.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/class-ScriptableObject.html</a></p></blockquote><p>ScriptableObject类直接继承自Object类；它和MonoBehaviour是并列的，都继承自Object（但MonoBehaviour并不是直接继承自Object）</p><p>是一个 <strong>数据容器</strong> ，可以用来存储大量的数据，它是可序列化的。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>存储数据：在游戏运行时创建脚本化对象实例，然后可以将数据保存到本地（如果不保存，它会在游戏结束后销毁）；</p></li><li><p>减少内存：将数据存储在ScriptableObject对象中，在代码中可以进行引用，来减少工程以及游戏运行时因拷贝值所造成的内存占用；</p></li></ol><blockquote><p><strong>ScriptableObject与预制体</strong> ：当你有一个预制体，它附加了一些mono脚本，包含了一些数据，每次我们实例化预制体的时候它都会拷贝assets下原预制体的值生成一份自己的拷贝，然后我们可以修改场景内预制体的值而并不影响assets下预制体的值，这是prefab的特性，对于我们从一个prefab模板生成属性不同的游戏对象是很有用的，但是如果prefab里的脚本数据是不需要修改的，它就会造成很大的资源浪费，尤其在数据很多的时候；为了避免这种问题，我们可以在不需要修改prefab里的脚本数据时，考虑使用ScriptableObject来存储这些重复的数据，然后其它所有预制体都可以使用引用的方式来访问这份数据，这就意味着不管场景中实例了多少预制体，在内存中就只需要有一份数据；它所带给我们的启示就是， <strong>当预制体中的脚本里有大量重复数据时，我们要想着将数据抽离，单独保存在本地</strong></p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><strong>Unity编辑器外不可操作</strong> ：仅在编辑器中才可以保存修改的数据（因为ScriptableObject对象虽然声明在UnityEngine中，但是它的Scriptable是通过UnityEditor命名空间下的类例如Editor类等来实现的），所以在部署构建的时候不可以用于存储游戏运行时更改的数据，但是可以使用之前存储好的数据。也就是ScriptableObject生成的数据资源文件 <strong>在Editor外具有只读属性</strong> ，如果你需要在游戏中修改数据并存储下来，就不推荐使用ScriptableObject了；</li></ol><blockquote><p>就像我们不可以在游戏运行时修改一个shader资源的代码、不可以修改一个纹理资源的像素内容一样，而在Unity Editor里可以修改ScriptableObject是因为Unity的编辑器对它格式的支持</p></blockquote><ol><li><p>继承自UnityEngine.Object，不必附着在对象上也无需/不能赋给Gameobject或Prefab</p></li><li><p>可以被serialize，可以在资源面板创建一个对应的.asset文件，把数据存储在资源文件中，通过属性面板可修改数值。该文件表示一个ScriptableObject的对象实例的序列化文件，退出之后也不会丢失。</p></li><li><p>本身是个类，可以引用，在项目之间共享</p></li><li><p>回调少 ：OnEnable 、OnDisable、OnDestroy</p></li><li><p>persistent：当它被绑定到.asset文件或者AssetBundle等资源文件中的时候（它可以通过Resources.UnloadUnusedAssets来被unload出内存。可以通过脚本引用或其他需要的时候被再次load到内存）<br>非persistent：通过CreateInstance&lt;&gt;来创建的时候（它可以通过GC被直接destroy掉（如果没有任何引用的话）。如果不想被GC的话，可以使用HideFlags.HideAndDontSave）</p></li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>unity内置的一种储存容器</p></li><li><p>PlayMode储存数据更改（再也不怕更改数据没保存了）<br>3</p></li></ol><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><pre><code class="lang-csharp">//在游戏运行时创建一个Scriptable类型的实例，不使用时被GC回收；//静态方法，使用了ScriptableObject类约束的泛型参数Tpublic static T CreateInstance&lt;T&gt;() where T : ScriptableObject; //实例化一个对象，返回一个实例；类似于GameObject的Instantiate()，其它函数也和GameObject类似public static T Instantiate(T original);</code></pre><p>???<br>ScriptableObject内部实现上也继承自MonoBehavior，它只有四个消息函数，Awake()、OnDestroy()、OnEnable()、OnDisable()；</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h3><p>需要指定创建的目录和资源名称，如果资源已经存在，则不会创建新资源；</p><pre><code class="lang-csharp">public class MakeScriptableObject { [MenuItem(&quot;Assets/Create/My Scriptable Object&quot;)] public static void CreateMyAsset(){ MyScriptableObjectClass asset = ScriptableObject.CreateInstance&lt;MyScriptableObjectClass&gt;(); AssetDatabase.CreateAsset(asset, &quot;Assets/NewScripableObject.asset&quot;); AssetDatabase.SaveAssets(); EditorUtility.FocusProjectWindow(); Selection.activeObject = asset; } }</code></pre><h3 id="CreateAssetMenu"><a href="#CreateAssetMenu" class="headerlink" title="CreateAssetMenu"></a>CreateAssetMenu</h3><p>可以在Assets下任意目录创建资源，而且可以创建多个资源；</p><pre><code class="lang-csharp">[CreateAssetMenu(fileName = &quot;data&quot;, menuName = &quot;ScriptableObjects/SpawnManagerScriptableObject&quot;, order = 1)] public class SpawnManagerScriptableObject : ScriptableObject { public string prefabName; public int numberOfPrefabsToCreate; public Vector3[] spawnPoints; }</code></pre><p>在Assets下创建一个可编程对象资源，设置好所需数据；如果需要在其它脚本中获取该数据，是需要声明一个该类型变量，然后为其赋值或加载该数据资源；然后，就像使用用一个类中的公有变量一样使用即可；</p><pre><code class="lang-csharp">public SpawnManagerScriptableObject spawnManagerValues; //spawnManagerValues.prefabName</code></pre><h3 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a>动态创建</h3><pre><code class="lang-csharp">ScriptableObject.CreateInstance&lt;MyScriptableObject &gt;();</code></pre><h3 id="CreateAssets-amp-FindAssets-amp-ScriptableObject"><a href="#CreateAssets-amp-FindAssets-amp-ScriptableObject" class="headerlink" title="CreateAssets &amp; FindAssets &amp; ScriptableObject"></a>CreateAssets &amp; FindAssets &amp; ScriptableObject</h3><ol><li><p>对于ScriptableObject，使用CreateInstance来创建Asset实例对象<br><code>testI = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj));</code></p></li><li><p>对于其他资源类型，使用new来创建对象</p></li><li><p>然后调用 <code>AssetDatabase.CreateAsset</code>函数，将实例对象作为资源存储在Assets路径当中。</p></li><li><p>最后使用<code>AssetDatabase.FindAssets</code>获取相应资源的GUID</p></li><li><p>由 <code>AssetDatabase.GUIDToAssetPath</code> 获取相应资源的路径。</p></li></ol><pre><code class="lang-csharp">// This script file has two CS classes. The first is a simple Unity ScriptableObject script.// The class it defines is used by the Example class below.// (This is a single Unity script file. You could split this file into a ScriptObj.cs and an// Example.cs file which is more structured.)using UnityEngine; using UnityEditor; public class ScriptObj : ScriptableObject{ public void Awake(){ Debug.Log(&quot;ScriptObj created&quot;); } } // Use ScriptObj to show how AssetDabase.FindAssets can be usedpublic class Example{ static ScriptObj testI; static ScriptObj testJ; static ScriptObj testK; [MenuItem(&quot;Examples/FindAssets Example two&quot;)] static void ExampleScript(){ CreateAssets(); NamesExample(); LabelsExample(); TypesExample(); } static void CreateAssets(){ testI = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); AssetDatabase.CreateAsset(testI, &quot;Assets/AssetFolder/testI.asset&quot;); testJ = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); AssetDatabase.CreateAsset(testJ, &quot;Assets/AssetFolder/testJ.asset&quot;); // create an asset in a sub-folder and with a name which contains a spacetestK = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); AssetDatabase.CreateAsset(testK, &quot;Assets/AssetFolder/SpecialFolder/testK example.asset&quot;); // an asset with a material will be used laterMaterial material = new Material(Shader.Find(&quot;Standard&quot;)); AssetDatabase.CreateAsset(material, &quot;Assets/AssetFolder/SpecialFolder/MyMaterial.mat&quot;); } static void NamesExample(){ Debug.Log(&quot; FINDING ASSETS BY NAME &quot;); string[] results; results = AssetDatabase.FindAssets(&quot;testI&quot;); foreach (string guid in results) { Debug.Log(&quot;testI: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } results = AssetDatabase.FindAssets(&quot;testJ&quot;); foreach (string guid in results) { Debug.Log(&quot;testJ: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } results = AssetDatabase.FindAssets(&quot;testK example&quot;); foreach (string guid in results) { Debug.Log(&quot;testK example: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } Debug.Log(&quot;*** More complex asset search ***&quot;); // find all assets that contain test (which is all assets)results = AssetDatabase.FindAssets(&quot;test&quot;); foreach (string guid in results) { Debug.Log(&quot;name:test - &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } } static void LabelsExample(){ Debug.Log(&quot; FINDING ASSETS BY LABELS &quot;); string[] setLabels; setLabels = new string[] {&quot;wrapper&quot;}; AssetDatabase.SetLabels(testI, setLabels); setLabels = new string[] {&quot;bottle&quot;, &quot;banana&quot;, &quot;carrot&quot;}; AssetDatabase.SetLabels(testJ, setLabels); setLabels = new string[] {&quot;swappable&quot;, &quot;helmet&quot;}; AssetDatabase.SetLabels(testK, setLabels); // label searching:// testI has wrapper, testK has swappable, so both have &#39;app&#39;// testJ has bottle, so have a label searched as &#39;bot&#39;string[] getGuids = AssetDatabase.FindAssets(&quot;l:app l:bot&quot;); foreach (string guid in getGuids) { Debug.Log(&quot;label lookup: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } } static void TypesExample(){ Debug.Log(&quot; FINDING ASSETS BY TYPE &quot;); string[] guids; // search for a ScriptObject called ScriptObjguids = AssetDatabase.FindAssets(&quot;t:ScriptObj&quot;); foreach (string guid in guids) { Debug.Log(&quot;ScriptObj: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } guids = AssetDatabase.FindAssets(&quot;t:ScriptObj l:helmet&quot;); foreach (string guid in guids) { Debug.Log(&quot;ScriptObj+bottle: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); } } }</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>ScriptableObject的生命周期和其他资源都是类似的：</p><p>当它是被绑定到.asset文件或者AssetBundle等资源文件中的时候，它就是persistent的，这意味着<br>它可以通过Resources.UnloadUnusedAssets来被unload出内存<br>可以通过脚本引用或其他需要的时候被再次load到内存<br>如果是通过CreateInstance&lt;&gt;来创建的，它就是非persistent的，这意味着<br>它可以通过GC被直接destroy掉（如果没有任何引用的话）<br>如果不想被GC的话，可以使用HideFlags.HideAndDontSave</p><h2 id="其他高级应用Demo"><a href="#其他高级应用Demo" class="headerlink" title="其他高级应用Demo"></a>其他高级应用Demo</h2><p><a href="https://blog.csdn.net/candycat1992/article/details/52181814" target="_blank" rel="noopener">https://blog.csdn.net/candycat1992/article/details/52181814</a></p><h3 id="保存信息"><a href="#保存信息" class="headerlink" title="保存信息"></a>保存信息</h3><p>step1.创建你用于共享数据的类（例如EnemyData）</p><pre><code class="lang-csharp">using UnityEngine; public class EnemyData: ScriptableObject{ public string name; public Color thisColor; public Vector3[] spawnPoints; }</code></pre><p>step2.新建一个脚本扩展Editor,使编辑器能够创建自定义的ScriptableObject对象</p><pre><code class="lang-csharp">using UnityEngine; using UnityEditor; //新建一个Editor文件夹，放在里面public class MakeEnemyData{ [MenuItem(&quot;Assets/Editor/Scriptable Object&quot;)] //定义了如何新建的路径public static void CreateMyAsset(){ //将EnemyData创建为assetEnemyData asset = ScriptableObject.CreateInstance&lt;EnemyData&gt;(); //设置新创建的NewScripableObject文件的初始路径AssetDatabase.CreateAsset(asset, &quot;Assets/NewScripableObject.asset&quot;); AssetDatabase.SaveAssets(); EditorUtility.FocusProjectWindow(); Selection.activeObject = asset; } }</code></pre><p>step3. 在需要引用的脚本中引用</p><pre><code class="lang-csharp">using UnityEngine; public class EnemyAI : MonoBehaviour { public EnemyData data; //data配置的数据就可以被所有相同种类的怪物共享，节省内存}</code></pre><h3 id="用作配置文件"><a href="#用作配置文件" class="headerlink" title="用作配置文件"></a>用作配置文件</h3><pre><code class="lang-csharp">[CreateAssetMenu] public class GameSettings : ScriptableObject{ [Serializable] public class PlayerInfo{ public string Name; public Color Color; ... } public List&lt;PlayerInfo&gt; players; private static GameSettings _instance; public static GameSettings Instance { get{ if (!_instance) _instance = Resources.FindObjectsOfTypeAll&lt;GameSettings&gt;().FirstOrDefault(); #if UNITY_EDITORif (!_instance) InitializeFromDefault(UnityEditor.AssetDatabase.LoadAssetAtPath&lt;GameSettings&gt;(&quot;Assets/Test game settings.asset&quot;)); #endifreturn _instance; } } public int NumberOfRounds; public static void LoadFromJSON(string path){ if (!_instance) DestroyImmediate(_instance); _instance = ScriptableObject.CreateInstance&lt;GameSettings&gt;(); JsonUtility.FromJsonOverwrite(System.IO.File.ReadAllText(path), _instance); _instance.hideFlags = HideFlags.HideAndDontSave; } public void SaveToJSON(string path){ Debug.LogFormat(&quot;Saving game settings to {0}&quot;, path); System.IO.File.WriteAllText(path, JsonUtility.ToJson(this, true)); } public static void InitializeFromDefault(GameSettings settings){ if (_instance) DestroyImmediate(_instance); _instance = Instantiate(settings); _instance.hideFlags = HideFlags.HideAndDontSave; } #if UNITY_EDITOR[UnityEditor.MenuItem(&quot;Window/Game Settings&quot;)] public static void ShowGameSettings(){ UnityEditor.Selection.activeObject = Instance; } #endif... } ``` ```csharp public class MainMenuController : MonoBehaviour{ public GameSettings GameSettingsTemplate; ... public string SavedSettingsPath { get { return System.IO.Path.Combine(Application.persistentDataPath, &quot;tanks-settings.json&quot;); } } void Start () { if (System.IO.File.Exists(SavedSettingsPath)) GameSettings.LoadFromJSON(SavedSettingsPath); elseGameSettings.InitializeFromDefault(GameSettingsTemplate); foreach(var info in GetComponentsInChildren&lt;PlayerInfoController&gt;()) info.Refresh(); NumberOfRoundsSlider.value = GameSettings.Instance.NumberOfRounds; } public void Play(){ GameSettings.Instance.SaveToJSON(SavedSettingsPath); GameState.CreateFromSettings(GameSettings.Instance); SceneManager.LoadScene(1, LoadSceneMode.Single); } ... }</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="https://blog.csdn.net/qq_36383623/article/details/99649941" target="_blank" rel="noopener">https://blog.csdn.net/qq_36383623/article/details/99649941</a><br><a href="https://blog.csdn.net/candycat1992/article/details/52181814" target="_blank" rel="noopener">https://blog.csdn.net/candycat1992/article/details/52181814</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overdraw</title>
      <link href="2023/07/25/Unity3D-Overdraw/"/>
      <url>2023/07/25/Unity3D-Overdraw/</url>
      
        <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>overdraw表示一个像素的重新绘制次数，在像素处理中，overdraw是最常见的性能瓶颈之一。<br>Scene视图的RenderMode-&gt;Overdraw。越亮的区域表示overdraw的程度越高，也就越消耗GPU。</p><blockquote><p>当然这里的视图只是提供了查看物体遮挡的层数关系，并不是真正的最终屏幕绘制的overdraw。也就是说，可以理解为它显示的是如果没有使用任何深度检验时的overdraw。这种视图是通过把所有对象都渲染成一个透明的轮廓，通过查看透明颜色的累计程度，来判断物体的遮挡。</p></blockquote><h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><ul><li><p>控制绘制顺序:PC上资源无限，一般都是从后往前绘制，但在移动上，尽量从前往后绘制.在Unity中，那些Shader中被设置为“Geometry”队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。尽量减小过度绘制区域:实在需要多层绘制的地方，要尽量减小各部分过度绘制区域，使重合区域小，绘制的像素点也就少一点</p></li><li><p>注意性能与效果的取舍:UGUI的许多控件有很好的通用性和展示效果，但是可能会耗更多性能</p></li><li><p>过大的不必要绘制尽量代码实现:例如点击屏幕空白区域返回功能，加透明image会增加很多</p></li><li><p>UI设计上尽可能简单减少重叠</p></li></ul><h3 id="针对性优化"><a href="#针对性优化" class="headerlink" title="针对性优化"></a>针对性优化</h3><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><p>Outline实现方式是将Text的四个顶点传过去复制四份，设置四份偏移量实现效果，将偏移量设置很大之后，可以看到一个Text周围有四个相同的Text<br>解决方案:<br>1.不使用或者使用Shadow(Shadow通过为图像或者文字的Mesh添加顶点实现阴影效果，Outline继承Shadow，在对象四个角上各添加一个Shadow)<br>2.使用Textmesh Pro(Unity5.5)需要制作相应的字体文件，对于动态生成的文字效果不好，固定字体很好<br>(<a href="https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&amp;utm_medium=referral</a>)<br>3.修改Mesh的UV坐标，提取文字原始UV坐标，扩大文字绘图区域，对文字纹理周围像素点采样，新旧颜色融合<br>(<a href="http://gad.qq.com/article/detail/29266" target="_blank" rel="noopener">http://gad.qq.com/article/detail/29266</a>)</p><h4 id="适配IphoneX"><a href="#适配IphoneX" class="headerlink" title="适配IphoneX"></a>适配IphoneX</h4><p>适配的需要加了层背景，不是iPhoneX失活就可以</p><h4 id="背景人物mesh"><a href="#背景人物mesh" class="headerlink" title="背景人物mesh"></a>背景人物mesh</h4><p>裁剪小一点更好</p><h4 id="Mask组件"><a href="#Mask组件" class="headerlink" title="Mask组件"></a>Mask组件</h4><p>Unity的Mask组件会增加一层Overdraw，还会多增加4个DrawCall<br>解决:<br>1.使用RectMask2D代替，缺点是只能用于矩形<br>2.对于多边形，用MeshMask，红色为UnityMask，蓝色是MeshMask，UnityMask消耗15个DrawCall，Overdraw2次，MeshMask消耗1个DrawCall，1层OverDraw(<a href="https://www.cnblogs.com/leoin2012/p/6822859.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoin2012/p/6822859.html</a>)</p><h4 id="Image的slide属性"><a href="#Image的slide属性" class="headerlink" title="Image的slide属性"></a>Image的slide属性</h4><p>对于slide九宫格图片，可以看情况取消fill center属性，那样中心区域会不渲染，中心区域也就镂空，重合面积也会小</p><p>1)重合多的地方尽可能不重合<br>2)无用的Image<br>少量的panel或者单纯的空父物体身上加着image，虽然没有给图片，但是还是会渲染<br>3)移动的波浪图片过大过多(修改高度，宽度)<br>4)特效粒子效果优化(<a href="http://www.u3dnotes.com/archives/807" target="_blank" rel="noopener">http://www.u3dnotes.com/archives/807</a>)<br>粒子效果薄弱的可以使用序列帧动画实现</p><p>部分小细节：<br>1.slide九宫格图片，取消fill center，中心镂空<br>2.mask尽量不用，可以用rect mask2D 代替<br>3.不用UI/Effect，包括Shadow，Outline，Position As UV1<br>4.不用Image的Tiled类型<br>5.不用Pixel Perfect<br>6.动静分离，动态的在父物体上加个Canvas<br>7.尽量active，不要destroy，也不要设置Alpha=0这样还是会渲染<br>8.不用BestFit(代价高，Unity会为该元素用到的所有字号生成图元保存在Altlas中，增加额外生成时间，还会使得字体对应的atlas变大)<br>9.特效粒子</p><p>Ref：<br><a href="https://www.jianshu.com/p/7167c516bd75" target="_blank" rel="noopener">https://www.jianshu.com/p/7167c516bd75</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Profiler使用技巧</title>
      <link href="2023/07/25/Unity3D-Profiler%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>2023/07/25/Unity3D-Profiler%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><code>csharp using UnityEngine; using System.Collections; using UnityEngine.Profiling;public class ExampleClass : MonoBehaviour { void Start() { Profiler.logFile = &quot;mylog&quot;; //Also supports passing &quot;myLog.raw&quot; Profiler.enableBinaryLog = true; Profiler.enabled = true; // Optional, if more memory is needed for the buffer Profiler.maxUsedMemory = 256 * 1024 * 1024; // ... // Optional, to close the file when done Profiler.enabled = false; Profiler.logFile = &quot;&quot;; // To start writing to a new log file Profiler.logFile = &quot;myOtherLog&quot;; Profiler.enabled = true; // ... } }</code> </p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NavMesh</title>
      <link href="2023/07/25/Unity3D-NavMesh/"/>
      <url>2023/07/25/Unity3D-NavMesh/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识-寻路算法"><a href="#基础知识-寻路算法" class="headerlink" title="基础知识 - 寻路算法"></a>基础知识 - 寻路算法</h2><h3 id="其他寻路算法"><a href="#其他寻路算法" class="headerlink" title="其他寻路算法"></a>其他寻路算法</h3><p>广度优先（Breadth First）算法 - 从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。</p><p>Dijkstra算法 - 加了移动代价的广度优先算法。计算每一个节点距离起点的总移动代价。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。</p><blockquote><p>如果图形为网格图，并且每个节点之间的移动代价是相等的，那么Dijkstra算法将和广度优先算法变得一样。</p></blockquote><p>最佳优先（Best First）算法 - 预先计算出每个节点到终点的距离。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级。从起点开始寻路，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。</p><ul><li><p>优点：这样做可以大大加快路径的搜索速度</p></li><li><p>缺点：如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径</p></li></ul><h3 id="A-Star算法"><a href="#A-Star算法" class="headerlink" title="A Star算法"></a>A Star算法</h3><p><img src="NavMesh/__SVG__3d425a215e8eeb2a056f553633aaae4a" alt=""><br> =<br><img src="NavMesh/__SVG__f010a0fda7cdcc04209d9381ef5fca27" alt=""><br> +<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2" alt=""></p><p><img src="NavMesh/__SVG__3d425a215e8eeb2a056f553633aaae4a_1" alt=""><br> - 节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。   </p><p><img src="NavMesh/__SVG__f010a0fda7cdcc04209d9381ef5fca27_1" alt=""><br> - 节点n距离起点的代价。   </p><p><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_1" alt=""><br> - 节点n距离终点的预计代价，这也就是A<em>算法的 <em>*启发函数</em></em> 。</p><pre><code class="lang-csharp">* 初始化open_set和close_set； * 将起点加入open_set中，并设置优先级为0（优先级最高）； * 如果open_set不为空，则从open_set中选取优先级最高的节点n： * 如果节点n为终点，则： * 从终点开始逐步追踪parent节点，一直达到起点； * 返回找到的结果路径，算法结束； * 如果节点n不是终点，则： * 将节点n从open_set中删除，并加入close_set中； * 遍历节点n所有的邻近节点： * 如果邻近节点m在close_set中，则： * 跳过，选取下一个邻近节点 * 如果邻近节点m也不在open_set中，则： * 设置节点m的parent为节点n * 计算节点m的优先级 * 将节点m加入open_set中</code></pre><ul><li><p>在极端情况下，当启发函数<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_2" alt=""><br>始终为0，则将由<br><img src="NavMesh/__SVG__f010a0fda7cdcc04209d9381ef5fca27_2" alt=""><br>决定节点的优先级，此时算法就退化成了Dijkstra算法。</p></li><li><p>如果<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_3" alt=""><br>始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_4" alt=""><br>的值越小，算法将遍历越多的节点，也就导致算法越慢。</p></li><li><p>如果<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_5" alt=""><br>完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</p></li><li><p>如果<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_6" alt=""><br>的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。<br>在另外一个极端情况下，如果<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_7" alt=""><br>相较于<br><img src="NavMesh/__SVG__f010a0fda7cdcc04209d9381ef5fca27_3" alt=""><br>大很多，则此时只有<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_8" alt=""><br>产生效果，这也就变成了最佳优先搜索。</p></li></ul><p><strong>通过调节启发函数我们可以控制算法的速度和精确度</strong><br><strong>在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可</strong></p><h4 id="启发函数h-n"><a href="#启发函数h-n" class="headerlink" title="启发函数h(n)"></a>启发函数h(n)</h4><p>曼哈顿距离 - 只允许朝上下左右四个方向移动</p><p><img src="NavMesh/1620751740246.png" alt="Alt text"></p><p>对角距离 - 允许斜着朝邻近的节点移动</p><p><img src="NavMesh/1620751750347.png" alt="Alt text"></p><p>欧几里得距离 - 两个节点之间的直线距离</p><h2 id="Unity-NavMesh"><a href="#Unity-NavMesh" class="headerlink" title="Unity NavMesh"></a>Unity NavMesh</h2><p>The navigation system allows you to create characters that can intelligently move around the game world, using navigation meshes that are created automatically from your Scene geometry. </p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p><strong>NavMesh</strong> (short for Navigation Mesh) - a data structure which describes the walkable surfaces of the game world and allows to find path from one walkable location to another in the game world. The data structure is built, or baked, automatically from your level geometry.</p><p>The walkable area is built automatically from the geometry in the scene by testing the locations where the agent can stand. Then the locations are connected to a surface laying on top of the scene geometry. This surface is called the navigation mesh (NavMesh for short).</p><p>The NavMesh stores this surface as <strong>convex polygons</strong>. Convex polygons are a useful representation, since we know that <strong>there are no obstructions between any two points inside a polygon</strong>. In addition to the polygon boundaries, <strong>we store information about which polygons are neighbours to each other</strong>. This allows us to reason about the whole walkable area.</p><h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><p><strong>NavMesh Agent component</strong> help you to create characters which avoid each other while moving towards their goal. Agents reason about the game world using the NavMesh and they know how to avoid each other as well as moving obstacles.</p><p><strong>Off-Mesh Link component</strong> allows you to incorporate navigation shortcuts which cannot be represented using a walkable surface. For example, jumping over a ditch or a fence, or opening a door before walking through it, can be all described as Off-mesh links.<br><strong>NavMesh Obstacle component</strong> allows you to describe moving obstacles the agents should avoid while navigating the world. </p><p><img src="NavMesh/1620748376654.png" alt="Alt text"></p><h3 id="two-problems"><a href="#two-problems" class="headerlink" title="two problems"></a>two problems</h3><ul><li><p>how to reason about the level to find the destination - global and static, in that it takes into account the whole scene.</p></li><li><p>how to move there - local and dynamic, it only considers the direction to move and how to prevent collisions with other moving agents.</p></li></ul><h2 id="寻路分解"><a href="#寻路分解" class="headerlink" title="寻路分解"></a>寻路分解</h2><h4 id="Finding-Paths"><a href="#Finding-Paths" class="headerlink" title="Finding Paths"></a>Finding Paths</h4><p><img src="NavMesh/1620752340467.png" alt="Alt text"></p><p>The sequence of polygons which describe the path from the start to the destination polygon is called a <strong>corridor</strong>. The agent will reach the destination by always steering towards the next visible corner of the corridor. </p><h4 id="Following-the-Path"><a href="#Following-the-Path" class="headerlink" title="Following the Path"></a>Following the Path</h4><p><img src="NavMesh/1620752593292.png" alt="Alt text"></p><p>When dealing with multiple agents moving at the same time, they will need to deviate from the original path when avoiding each other. Trying to correct such deviations using a path consisting of line segments soon becomes very difficult and error prone.</p><p>Since the agent movement in each frame is quite small, we can use the connectivity of the polygons to fix up the corridor in case we need to take a little detour. Then we quickly find the next visible corner to steer towards.</p><h4 id="Avoiding-Obstacles"><a href="#Avoiding-Obstacles" class="headerlink" title="Avoiding Obstacles"></a>Avoiding Obstacles</h4><p><img src="NavMesh/1620752915537.png" alt="Alt text"></p><p>The steering logic takes the position of the next corner and based on that figures out a desired <strong>direction</strong> and <strong>speed</strong> (or velocity) needed to reach the destination. Using the desired velocity to move the agent can lead to collision with other agents.</p><p>Obstacle avoidance chooses a new velocity which balances between <strong>moving in the desired direction</strong> and <strong>preventing future collisions</strong> with other agents and edges of the navigation mesh. Unity is using <strong>reciprocal velocity obstacles (RVO)</strong> to predict and prevent collisions.</p><h4 id="Moving-the-Agent"><a href="#Moving-the-Agent" class="headerlink" title="Moving the Agent"></a>Moving the Agent</h4><p>At this stage you can feed the velocity from the simulated agent to the animation system to move the character using <strong>root motion</strong> , or let the <strong>navigation system take care of that</strong>.</p><h4 id="Global-and-Local"><a href="#Global-and-Local" class="headerlink" title="Global and Local"></a>Global and Local</h4><p><img src="NavMesh/1620753233885.png" alt="Alt text"></p><h4 id="Two-Cases-for-Obstacles"><a href="#Two-Cases-for-Obstacles" class="headerlink" title="Two Cases for Obstacles"></a>Two Cases for Obstacles</h4><h5 id="local-obstacle-avoidance"><a href="#local-obstacle-avoidance" class="headerlink" title="local obstacle avoidance"></a>local obstacle avoidance</h5><p>When an obstacle is moving, it is best handled using local obstacles avoidance. This way the agent can predictively avoid the obstacle. </p><h5 id="global-pathfinding"><a href="#global-pathfinding" class="headerlink" title="global pathfinding"></a>global pathfinding</h5><p>静态：When the obstacle becomes stationary, and can be considered to block the path of all agents, the obstacles should affect the global navigation, that is, the navigation mesh.</p><p>动态改变：Changing the NavMesh is called carving. The process detects which parts of the obstacle touches the NavMesh and carves holes into the NavMesh. </p><h4 id="Off-mesh-Links"><a href="#Off-mesh-Links" class="headerlink" title="Off-mesh Links"></a>Off-mesh Links</h4><p><img src="NavMesh/1620753809200.png" alt="Alt text"></p><p>This link can be later accessed when following the path, and the special action can be executed.</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="Building-a-NavMesh"><a href="#Building-a-NavMesh" class="headerlink" title="Building a NavMesh"></a>Building a NavMesh</h3><p>NavMesh Baking - collects the Render Meshes and Terrains of all Game Objects which are marked as Navigation Static, and then processes them to create a navigation mesh that approximates the walkable surfaces of the level.</p><p><strong>Window &gt; AI &gt; Navigation</strong></p><ol><li><p>Select </p></li><li><p>Check Navigation Static</p></li><li><p>Adjust<br>Agent Radius<br>Agent Height<br>Max Slope<br>Step Height </p></li><li><p>Click bake </p></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://developer.aliyun.com/article/685477" target="_blank" rel="noopener">https://developer.aliyun.com/article/685477</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Material</title>
      <link href="2023/07/25/Unity3D-Material/"/>
      <url>2023/07/25/Unity3D-Material/</url>
      
        <content type="html"><![CDATA[<p>材质是一个数据集，主要功能就是给渲染器提供数据和光照算法。贴图就是其中数据的一部分，根据用途不同，贴图也会被分成不同的类型，比方说 Diffuse Map，Specular Map，Normal Map 和 Gloss Map 等等。另外一个重要部分就是光照模型 Shader ，用以实现不同的渲染效果。</p><p>将输入的贴图或者颜色，加上对应的Shader，以及对Shader的特定的参数设置，将这些打包在一起就是一个材质了。之后，我们便可以将材质赋予合适的renderer（渲染器）来进行渲染。</p><h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3><p>所谓 <strong>着色器(Shader)</strong> 实际上就是一小段程序，它负责将输入的网格(Mesh)以指定的方式和输入的贴图或者颜色等组合作用，然后输出，绘图单元可以依据这个输出来将图像绘制到屏幕上。着色器是一种可以精确控制材质球的工具，通过贴图和着色器的配合开发人员可以创造出非常逼真的模型</p><h3 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h3><p>Ref: <a href="https://blog.csdn.net/yuyingwin/article/details/80534970" target="_blank" rel="noopener">https://blog.csdn.net/yuyingwin/article/details/80534970</a></p><p>FX: Lighting and glass effects.( 灯光、玻璃)<br>GUI and UI: For user interface graphics.(用于用户界面图形)<br>Mobile: Simplified high-performance shader for mobile devices.(针对移动设备的简化的高性能着色器)<br>Nature: For trees and terrain.(适用于树木和地形)<br>Particles: Particle system effects.(粒子系统特效)<br>Skybox: For rendering background environments behind all geometry(用于渲染所有几何背后的背景环境)<br>Sprites: For use with the 2D sprite system(用于2D精灵系统)<br>Toon: Cartoon-style rendering.(卡通 风格 渲染)<br>Unlit: For rendering that entirely bypasses all light &amp; shadowing(渲染完全绕过所有光影)<br>Legacy: The large collection of older shaders which were superseded by the Standard Shader(被标准着色器取代的大型着色器集合)</p><h3 id="Standard-Shader"><a href="#Standard-Shader" class="headerlink" title="Standard Shader"></a>Standard Shader</h3><h4 id="Rendering-Mode"><a href="#Rendering-Mode" class="headerlink" title="Rendering Mode"></a>Rendering Mode</h4><p>Opaque(不透明的)：是默认设置，适用于没有透明区域的普通固体物体<br>Cutout：允许您创建在不透明区域和透明区域之间具有坚硬边缘的透明效果。在这种模式下，没有半透明区域，纹理是100％不透明或不可见的。当使用透明度来创建材质的形状（例如树叶或带孔洞和布块的布料）时，此功能非常有用<br>Transparent：适用于渲染逼真的透明材料，如透明塑料或玻璃。在这种模式下，材质本身会采用透明度值（基于纹理的alpha通道和色调的alpha），但反射和照明高光将以完全清晰的方式保持可见状态，就像真正的透明材质一样<br>Fade：允许透明度值完全淡出对象，包括任何高光反射或可能有的反射。如果您想要将对象淡入或淡出，则此模式非常有用。它不适合渲染逼真的透明材料，如透明塑料或玻璃，因为反射和高光也会消失</p><h4 id="Albedo基础贴图"><a href="#Albedo基础贴图" class="headerlink" title="Albedo基础贴图"></a>Albedo基础贴图</h4><p>需要一个“纹理”或是多个这个跟你所需要的Shder有关。</p><h4 id="Metallic金属"><a href="#Metallic金属" class="headerlink" title="Metallic金属"></a>Metallic金属</h4><p>Metallic 指出材料是否是金属材质。在金属材料的情况下，Albedo 颜色控制镜面反射的颜色，而大部分光纤将反射未镜面反射。非金属材料将具有与入射光线相同的颜色的镜面反射，并在表面时几乎不会反射。</p><p>纹理(Texture) Metallic 分配参数时，Metallic和smoothness 滑块将消失， 材质的金属级别由纹理的红色通道中的值控制(通道一般由 黑、白、灰构成，偏白反射越高)，材质的smoothness级别由纹理的Alpha通道控制.(这以为这 绿色 和 蓝色 通道 被忽略)</p><ul><li><p>Specular/Metallic Alpha：曲面每个点的平滑度都是单个值，因此数据只需要图像纹理的单个通道。因此。平滑度数据被假定存储在用于Metallic或specular纹理贴图的相同图像纹理的Alpha通道中</p></li><li><p>Albedo Alpha: 减少纹理的总数，也可以使用不同分辨率的纹理进行Smoothness和Specular/Metallic</p></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>HeightMap：高度映射图；灰度图。白色区域代表纹理的高区域，黑色代表低区域。白色的部分纹理偏移大。<br>OcclussionMap: 遮挡贴图. 提供模型的哪些区域接收 高或低 间接光照的信息。OcclussionMap 是灰度图像. 白色表示应该接受完全间接照明的区域，而黑色表示没有间接照明。<br>Emission：发光，控制从表面发射的光的颜色和强度。如果分配给了纹理贴图，则 纹理的全色值将用于发射颜色和亮度。Emission数字之字段仍然存在，可以将其用作乘数来提高或降低材料的整体发光水平。 该处纹理 贴图 必须 背景色是黑色，前景色是非黑色(充满 R,G,B)的才会叠加到Aledo的图片上。None：对象将显示为发射型，但附近物体的照明不受影响 。RealTime：来自此材质的发射光将被添加到场景的实时全局照明计算中，因此附近物体（甚至移动物体）的照明将受到发射光线的影响。 baked：来自这种材料的发射光将被烘焙成场景的静态光照贴图，因此其他附近的静态物体将显示为被该材料点亮，但动态物体不会受到影响。<br>DetailMaps：在Aledo纹理贴图上增添细节贴图；DetailMask：给DetailMaps 添加遮罩，限制细节的显示位置 。 </p><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><ul><li><p>Specular镜面反射：使用镜面特性模拟外观</p></li><li><p>Smoothness 光滑度：设置物体表面的光滑程度</p></li><li><p>Normal Map法线贴图：描述物体表面的凹凸程度</p></li><li><p>Emission自发光：控制物体表面自发光的颜色和贴图</p><ul><li><p>None不影响环境</p></li><li><p>Realtime实时动态改变</p></li></ul></li><li><p>Tiling平铺：沿着不同的轴，纹理平铺个数</p></li><li><p>Office偏移：滑动纹理</p></li></ul><h4 id="Standard-Specular-setup"><a href="#Standard-Specular-setup" class="headerlink" title="Standard(Specular setup)"></a>Standard(Specular setup)</h4><p>为经典方法选择此着色器。镜面反射颜色用于控制材料中镜面单摄的颜色和强度。例如：这使得有可能具有漫反射不同的颜色的镜面反射。<br>将纹理(Texture)分配给Specular参数时，Specular参数和Smoothness滑块均消失。相反，材质的镜面反射水平由纹理本身的红色，绿色和蓝色通道中的值控制，而光滑度材质的等级由相同纹理的Alpha通道控制。这里，镜面反射和平滑度由颜色和平滑度滑块定义。</p><p>tiling缩放：表示贴图在UV坐标的缩放倍数</p><h3 id="加载Material"><a href="#加载Material" class="headerlink" title="加载Material"></a>加载Material</h3><pre><code class="lang-csharp">Material mat = Resources.Load&lt;Material&gt;(&quot;shader path&quot;); ``` ```csharp Material mat = new Material(Shader.Find(&quot;shadername&quot;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mesh in U3D(ToUpdate)</title>
      <link href="2023/07/25/Unity3D-Mesh-in-U3D-ToUpdate/"/>
      <url>2023/07/25/Unity3D-Mesh-in-U3D-ToUpdate/</url>
      
        <content type="html"><![CDATA[<p>Unity3D中的 <strong>Mesh(网格)</strong> 事实上就是我们所说的 <strong>三角网格</strong> 。<br>三角网格就是由一系列三角形组成的多边形网格，主要用于模拟复杂物体的表面。</p><h2 id="数据结构——索引三角网格"><a href="#数据结构——索引三角网格" class="headerlink" title="数据结构——索引三角网格"></a>数据结构——索引三角网格</h2><p>用c++语言模拟Unity3D中Mesh数据的存储结构。</p><pre><code class="lang-csharp">//顶点表//-----------------------------------struct Vertex{ //由于存储三角形顶点级信息Vector3 p; ....... //其他信息 纹理映射坐标 法向量 光照信息 }; //三角形表//-----------------------------------struct Triangle{ //保存三角形级信息int vertex[3]; //三个顶点在顶点列表的索引}; //存放三角网格的结构 维护两个表 定点表和三角形表struct TriangleMesh{ int vertexCount; //顶点数Vertex *vertexList; //顶点存放链表int *uv; int triangleCount; //三角形数量Triangle *triangleCount; //存放三角形的链表........ };</code></pre><h3 id="vertices"><a href="#vertices" class="headerlink" title="vertices"></a>vertices</h3><pre><code class="lang-csharp">Vector3[] vertices; //所有的顶点。</code></pre><p>每个三角形面三个顶点，面与面之间不一定共用顶点。<br>法向量相同的两个面可以公用顶点，法向量不同的两个面，在同一个位置会分别有两个顶点数据，坐标相同，法向量不同。</p><p>每个顶点包含一个3D位置，一般也会包括 <strong>纹理映射坐标(UV坐标)</strong> ，表面 <strong>法向量</strong> ， <strong>光照值</strong> 等附加信息</p><h4 id="为何有冗余顶点"><a href="#为何有冗余顶点" class="headerlink" title="为何有冗余顶点"></a>为何有冗余顶点</h4><p>正方体6个面，每个面由2个三角形组成，所以共需要36个三角形顶点索引。但是正方体只有8个顶点，为什么需要24个顶点坐标数据呢？</p><p>答案是：Unity3D的Mesh.triangles是 <strong>三角形索引数组</strong> ，不仅依靠这个索引值 <strong>索引三角形顶点坐标</strong> ，而且 <strong>索引纹理坐标</strong> ， <strong>索引法线向量</strong> 。即正方体的 <strong>每个顶点都参与了3个平面，而这3个平面的法线向量是不同的</strong> ，该顶点在渲染这3个平面的时候需要索引到不同的法线向量。而由于顶点坐标和法线向量是由同一个索引值triangles[Index]取得的，例如，根据triangles[0],triangles[14],triangles[17]在vertices中索引到的顶点都为（0.5，－0.5，0.5），但是在normals中索引到的法向量值各不相同。这就决定了在正方体中一个顶点，需要有 <strong>3份存储</strong> 。（如果你需要创建其它模型，需要根据实际情况决定顶点坐标的冗余度。实质上顶点坐标的冗余正是方便了法线坐标、纹理坐标的存取。）</p><h3 id="triangles"><a href="#triangles" class="headerlink" title="triangles"></a>triangles</h3><pre><code class="lang-csharp">int[] triangles // a list of triangles that contains indices into the vertex array</code></pre><p>三角形的哪一面可见是由顶点序号的方向来确定的。如果顶点顺序是顺时针方向的话那么三角形是正面可见。</p><pre><code class="lang-csharp">mesh.vertices = new Vector3[] {new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 0)}; mesh.uv = new Vector2[] {new Vector2(0, 0), new Vector2(0, 1), new Vector2(1, 1)}; mesh.triangles = new int[] {0, 1, 2};</code></pre><h4 id="GetBaseVertex"><a href="#GetBaseVertex" class="headerlink" title="GetBaseVertex"></a>GetBaseVertex</h4><p>The base vertex can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers.</p><p>Unity Mesh的indexFormat[ format of the mesh index buffer data ]默认是uint16，存储的数值最大为65536，也就是说，索引数组(Index buffer)中的索引值最大为65536，顶点数组的大小如果超过65536，就超出了index的表示范围。因此，Unity的解决方法是</p><ol><li><p>对于这种情况，Submesh设置一个BaseVertex，其索引值为对这个值的偏移值。</p></li><li><p>设置indexFormat为32bit的intzhi</p></li></ol><h3 id="normals"><a href="#normals" class="headerlink" title="normals"></a>normals</h3><p>每个顶点对应一个法线，即顶点所在平面的法线</p><ul><li><p>法线是垂直于面的向量。我们通常使用单位长度的法向量，并向量指向面的外部，而不是内部。</p></li><li><p>法线可以用于确定光线与顶点的夹角。这个细节的使用取决于Shader。</p></li></ul><blockquote><p>作为三角面它永远是平的，因此它不应该需要被提供一个单独的法线信息。然而，我们需要造假。在现实中，顶点是不存在法线的，三角面才有。通过附加自定义顶点法线和三角面插着，我们可以奖状我们有一个平滑的曲面代替一堆平的三角面。这个错觉是令人信服的，只要你不去注意网格锋利的轮廓（锯齿）。</p></blockquote><p>法线用于规定每个顶点，所以我们必须填充另一个向量数组。另一种选择，我们可以依据网格的三角面来计算出法线。</p><h3 id="Tangent"><a href="#Tangent" class="headerlink" title="Tangent"></a>Tangent</h3><blockquote><p>tangent: 切线，切面，正切</p></blockquote><p>法线贴图在切线空间中定义。<br>所以切线是一个三维向量，但是在Unity中它是使用四维向量定义的。第四个值通常是1或者-1，用于控制第三切线空间唯独方向-朝前或朝后,这有助于展示法线贴图，通常用于左右对称的3D模型，像人一样。Untiy的shader执行此计算要求我们使用-1。</p><h4 id="法线贴图-Normal-Map"><a href="#法线贴图-Normal-Map" class="headerlink" title="法线贴图(Normal Map)"></a>法线贴图(Normal Map)</h4><p>使用颜色值记录了法相向量</p><h3 id="UV坐标-纹理坐标"><a href="#UV坐标-纹理坐标" class="headerlink" title="UV坐标(纹理坐标)"></a>UV坐标(纹理坐标)</h3><p>UV mapping is the 3D modeling process of projecting a 2D image to a 3D model’s surface for <strong>texture mapping</strong>. </p><blockquote><p>The letters “U” and “V” denote the axes of the 2D texture because “X”, “Y”, and “Z” are already used to denote the axes of the 3D object in model space, while “W” (in addition to XYZ) is used in calculating quaternion rotations, a common operation in computer graphics.</p></blockquote><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>U3D中的 <strong>纹理贴图的原理</strong> 应该是你的模型坐标进过顶点变化到投影坐标系，然后在接下来的片段着色的时候通过传递过来的UV值用<code>tex2D(_texName, UV)</code>来获取颜色值，然后渲染到屏幕上。</p><p>UV坐标通常在(0,0)到(1,1)之间，它覆盖了整个纹理。超出范围的坐标将造成 <strong>clamped</strong> 或者 <strong>Tiling</strong> 平铺的效果，这去取决于纹理设置。</p><h4 id="uv、uv2、uv3、uv4"><a href="#uv、uv2、uv3、uv4" class="headerlink" title="uv、uv2、uv3、uv4"></a>uv、uv2、uv3、uv4</h4><p>如果在模型导入时就存在 uv2，uv3，uv4，那么这是因为在建模软件中添加了这些顶点属性。<br>uv2通常被用于Lightmap，uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。<br>一般来说uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p><h3 id="colors属性"><a href="#colors属性" class="headerlink" title="colors属性"></a>colors属性</h3><p>在一些建模软件中导出的网格模型(Mesh)可能会带有colors属性，描述每个顶点的颜色。有些Shader可以使用这个属性进行运算与着色。然而很多时候colors属性是用不到的， <strong>如Unity标准着色器就不使用这个属性</strong> 。</p><blockquote><p>Most shaders choose to ignore vertex color, with exception of sprites shader.<br> 大多数着色器选择忽略顶点颜色，但精灵着色器除外<br> <a href="https://stackoverflow.com/questions/34460587/unity-changing-only-certain-part-of-3d-models-color" target="_blank" rel="noopener">https://stackoverflow.com/questions/34460587/unity-changing-only-certain-part-of-3d-models-color</a></p></blockquote><p>colors属性与tangents属性一样，如果网格顶点拥有该属性，同样会对内存、物理体积和加载性能造成影响。</p><p>默认情况下，在3d建模软件中并不会导出Color属性。以3ds max为例，Color通常是通过modifier添加的，因此只需要在导出前将其删除即可。<br>去除方法：<a href="https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf</a></p><blockquote><p>注意：切忌将不同属性的网格模型拼合在一起。举个例子 ，100个网格模型进行Static Batching，如果99个模型只有Position和UV两种属性，而剩下1个模型函数有Position、UV、Normal、Tangent和Color五种属性。那么引擎在进行拼合时，会将前99个模型的顶点属性补齐，然后再进行拼合。这样无形中会增加大量的内存占用，从而造成不必要的内存浪费。</p></blockquote><h3 id="无用属性的去除方法"><a href="#无用属性的去除方法" class="headerlink" title="无用属性的去除方法"></a>无用属性的去除方法</h3><p>1.如果有3dmax的源文件，可以直接在3dmax里操作，在那个channelinfo—清掉那个vc<br>2.如果只有fbx，或者这类文件太多，可以直接下载一个fbx的sdk，拿里面的例子改一下，生成一个exe。然后在unity里直接调用就行了。<br>其实从外包回来的fbx，一般都有问题，要么顶点色，要么会出现uv3、uv4。我这里附上工具和c++、及在unity调用的代码，你可以试一下。如果运行不了，缺dll，你就到网上找一下，多半可以用。 clear_fbx_clr_uv_tool.rar<br>注意这个工具会清掉顶点色和uv3、uv4！！<br>3.印象中在unity里也可以直接清顶点色，好像是meshfiter那里把colors直接置空，再重新保存回去。</p><h2 id="Unity-Mesh-API"><a href="#Unity-Mesh-API" class="headerlink" title="Unity Mesh API"></a>Unity Mesh API</h2><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>(1) vertices 网格顶点数组;<br>(2) normals 网格的法线数组;<br>(3) tangents 网格的切线数组;<br>(4) uv 网格的基础纹理坐标;<br>(5) uv2 网格设定的第二个纹理坐标;<br>(6) bounds 网格的包围盒;<br>(7) Colors 网格的顶点颜色数组;<br>(8) triangles 包含所有三角形的顶点索引数组;<br>(9) vectexCount 网格中的顶点数量(只读的);<br>(10) subMeshCount 子网格的数量，每个材质都有一个独立的网格列表;<br>(11) bonesWeights: 每个顶点的骨骼权重;<br>(12) bindposes: 绑定姿势，每个索引绑定的姿势使用具有相同的索引骨骼;</p><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>(1) Clear 清空所有的顶点数据和所有的三角形索引;<br>(2) RecalculateBounds 重新计算网格的包围盒;<br>(3) RecalculateNormals 重新计算网格的法线;<br>(4) Optimze 显示优化的网格;<br>(5) GetTriangles 返回网格的三角形列表;<br>(6) SetTriangles 为网格设定三角形列表;<br>(7) CominMeshes组合多个网格到同一个网格;</p><h2 id="Model-Import-Settings"><a href="#Model-Import-Settings" class="headerlink" title="Model Import Settings"></a>Model Import Settings</h2><h3 id="Mesh-Compression（通常禁用，优化渲染和发布文件大小时启用）"><a href="#Mesh-Compression（通常禁用，优化渲染和发布文件大小时启用）" class="headerlink" title="Mesh Compression（通常禁用，优化渲染和发布文件大小时启用）"></a>Mesh Compression（通常禁用，优化渲染和发布文件大小时启用）</h3><p>启用网格压缩，unity会按照一定的级别来压缩网格数据，压缩级别越高，网格的精度越低，这对于渲染优化和发布时游戏文件大小的降低很有用，但可能会导致失真。官方的想法是，尽可能的压缩网格，只要模型看起来不至于太奇怪。</p><h3 id="Optimize-Mesh"><a href="#Optimize-Mesh" class="headerlink" title="Optimize Mesh"></a>Optimize Mesh</h3><p>优化网格，如果开启，网格的定点和三角形会按照U3D既定的一套规则重新排序用以提高GPU性能。<br>The Optimize Meshes option in a mesh’s import settings will reorganize the vertex data for quicker readability, and sometimes regenerate the low-level rendering style (down to the level of points versus tris versus strips) to optimize the rendering speed of the mesh.</p><p>该优化方法也可以在代码中调用：</p><pre><code class="lang-csharp">Mesh mesh = gameObject.GetComponent&lt;MeshFilter&gt;().mesh; mesh.Optimize();</code></pre><p>This function causes the geometry and vertices of the mesh to be reordered internally in an attempt to improve vertex cache utilisation on the graphics hardware and thus rendering performance.<br>This operation can take a few seconds or more for complex meshes and should only be used where <strong>the ordering of the geometry and vertices is not significant</strong> as both will change.<br>理论上如果模型对顶点和面片顺序没有要求的话，不会导致显示问题。</p><h2 id="相关组件-Components"><a href="#相关组件-Components" class="headerlink" title="相关组件(Components)"></a>相关组件(Components)</h2><h3 id="MeshFiler组件"><a href="#MeshFiler组件" class="headerlink" title="MeshFiler组件"></a>MeshFiler组件</h3><p>MeshFilter 这个组件记录了你想要展示的网格数据</p><h3 id="MeshRender组件"><a href="#MeshRender组件" class="headerlink" title="MeshRender组件"></a>MeshRender组件</h3><p>MeshRenderer 使用这个组件告诉网格如何渲染，比如使用哪个材质球，是否接受阴影和其他设置。</p><h2 id="Mesh-SubMesh与Material"><a href="#Mesh-SubMesh与Material" class="headerlink" title="Mesh, SubMesh与Material"></a>Mesh, SubMesh与Material</h2><p>在Unity3D中一个Mesh里可以有多个SubMesh，引擎在渲染的时候，每个SubMesh都需要对应一个Material材质球来匹配做渲染。当Mesh有多个SubMesh时，Unity会默认Mesh有相应数量的Materials，Mesh与Material按照相应的顺序一一对应。</p><p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1618210128127.png)</p><p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1618210138491.png)</p><p>如果mesh没有submesh的话，多个材质球就是会渲染多遍，使用的对象就是当前的这个mesh。</p><h3 id="拆分SubMesh的意义"><a href="#拆分SubMesh的意义" class="headerlink" title="拆分SubMesh的意义"></a>拆分SubMesh的意义</h3><ol><li><p>3D模型制作人员在制作模型的时候，希望一个模型中一部分Mesh用一种材质球来表现效果，另一部分Mesh则用另一种材质球来表现效果，这时就需要将模型拆分开来。因为一个Mesh只能对应一个材质球做渲染，一个材质球只能表现一种效果，当他们需要表现两种完全不同的效果时就需要拆分。</p></li><li><p>模型中的某部分的贴图，在众多模型中共同使用的频率比较高，为了不重复制作以及减少重复劳动，那么就会让原本可以整体的模型单独拆分出来一部分公共材质的部分让它们都使用同一个材质球。</p></li><li><p>在制作动画时，由于动画过于复杂导致如果使用同一个模型去表现的话，骨骼数量就会成倍增加。为了能更好的表现动画，也为了能更节省骨骼的使用量，拆分出一部分模型让他们单独成为模型动画的一部分。</p></li></ol><p>拥有多个SubMesh一样可以有动画，另外它还能针对不同部分的Mesh选择有个性化的材质球来表现效果，从功能上来看比单个Mesh要灵活的多。</p><h3 id="多个SubMesh的缺点"><a href="#多个SubMesh的缺点" class="headerlink" title="多个SubMesh的缺点"></a>多个SubMesh的缺点</h3><ul><li><p>由于每个SubMesh都多出了材质球，导致SubMesh越多，增加的Drawcall也越多。</p></li><li><p>Mesh中存在多个SubMesh，在动作和拆分材质球渲染上确实有很好的优势，但无法与其他Mesh合并，导致优化的一个重要环节被阻断。</p></li></ul><h3 id="CombineMesh-in-Unity"><a href="#CombineMesh-in-Unity" class="headerlink" title="CombineMesh in Unity"></a>CombineMesh in Unity</h3><pre><code class="lang-csharp">void CombineMesh(){ MeshFilter[] mfs = GetComponentsInChildren&lt;MeshFilter&gt;(); CombineInstance[] combine = new CombineInstance[mfs.Length]; Mesh newMesh = new Mesh(); for(int i= 0; i&lt;mfs.Length; i++) { combine[i].mesh = mfs[i].sharedMesh; combine[i].transform = mfs[i].transform.localToWorldMatrix; combine[i].subMeshIndex = i;//标识Material的索引位置，可以为0，1，2等} newMesh.CombineMeshes(combine); AssetDatabase.CreateAsset(newMesh, &quot;Assets/TestTRS/NewMesh.mesh&quot;); }</code></pre><h2 id="Mesh的渲染"><a href="#Mesh的渲染" class="headerlink" title="Mesh的渲染"></a>Mesh的渲染</h2><h3 id="Mesh的坐标与bounds"><a href="#Mesh的坐标与bounds" class="headerlink" title="Mesh的坐标与bounds"></a>Mesh的坐标与bounds</h3><ul><li><p>每个Mesh都有Bounds属性，表示Mesh的包围盒。</p></li><li><p>Unity一个节点在Scene界面的坐标原点，取的是能包含所有子物体的bounds的bounds的中心。也就是对所有子物体的bounds进行Encapsulate后，求得一个大Bounds，取其中心。</p></li><li><p>修改Mesh的vertices坐标后，Unity并不会重新计算bounds。将修改后的Mesh创建出来，Unity会采用修改前的bounds来计算坐标原点的位置。</p></li></ul><p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1616555830226.png)<br><strong>因此，修改了Mesh的vertices属性后，需要调用RecalculateBounds才能保证包围盒的正确性。</strong></p><p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1616555982837.png)</p><h4 id="Mesh顶点整体偏移问题及Matrix4x4修正"><a href="#Mesh顶点整体偏移问题及Matrix4x4修正" class="headerlink" title="Mesh顶点整体偏移问题及Matrix4x4修正"></a>Mesh顶点整体偏移问题及Matrix4x4修正</h4><p>如图，世界空间的坐标原点是Cube所在的位置，而将左边的物体A的Position设置为(0, 0, 0)，看起来却回不到世界坐标原点的位置。</p><p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1616556303175.png)</p><p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1616556368115.png)<br>实质上，该GameObject的坐标值确实是世界坐标的原点，而由于Mesh的所有顶点都相对局部坐标原点有一个偏移，因此，Mesh显示的位置不在坐标原点，并且Scene界面的显示的模型坐标系采取的是Mesh的bounds的中心。</p><p>修正方法：修改Mesh的vertices，将顶点位置改变，是顶点的bounds的中心回到(0, 0, 0)。</p><p>求得当前的bounds的中心center，该center是相对坐标原点有一定的偏移的，使用<code>Matrix4x4.Translate(-center)</code>，即可将所有顶点都进行平移，抵消之前的偏移。</p><p>注意：Translate之后，需要重新计算bounds。</p><pre><code class="lang-csharp">void ModifyMesh(){ Mesh mesh = GetComponent&lt;MeshFilter&gt;().sharedMesh; mesh.RecalculateBounds(); Vector3 center = mesh.bounds.center; var m = Matrix4x4.Translate(-center); Vector3[] oldVertices = mesh.vertices; Vector3[] newVertices = new Vector3[oldVertices.Length]; for(int i=0; i&lt;oldVertices.Length; i++) { newVertices[i] = m.MultiplyPoint(oldVertices[i]); } mesh.vertices = newVertices; mesh.RecalculateBounds(); GetComponent&lt;MeshFilter&gt;().sharedMesh = mesh; AssetDatabase.CreateAsset(mesh, &quot;Assets/MeshModified.mesh&quot;); }</code></pre><h2 id="Mesh编程"><a href="#Mesh编程" class="headerlink" title="Mesh编程"></a>Mesh编程</h2><h3 id="画面片"><a href="#画面片" class="headerlink" title="画面片"></a>画面片</h3><pre><code class="lang-csharp">using UnityEngine; using UnityEditor; using System.Collections; public class GenMesh{ [MenuItem(&quot;MeshEditor/GenMesh&quot;)] static public void GenMeshM(){ Mesh m1 = CreateRect(); AssetDatabase.CreateAsset(m1, &quot;Assets/models/m1.asset&quot;); } public static Mesh CreateRect(){ Mesh mesh = new Mesh(); int particleNum = 10; //顶点坐标Vector3[] verts = new Vector3[4 * particleNum]; //uv坐标Vector2[] uvs = new Vector2[4 * particleNum]; //三角形索引int[] tris = new int[2 * 3 * particleNum]; Vector3 position; for (int i = 0; i &lt; particleNum; i++) { int i4 = i * 4; int i6 = i * 6; position.x = 5 * i; position.y = 5 * i; position.z = 0; //顶点坐标verts[i4 + 0] = position; verts[i4 + 1] = position + new Vector3(2, 0, 0); verts[i4 + 2] = position + new Vector3(2, 2, 0); verts[i4 + 3] = position + new Vector3(0, 2, 0); //四个顶点在UV坐标系中的位置uvs[i4 + 0] = new Vector2(0.0f, 0.0f); uvs[i4 + 1] = new Vector2(1.0f, 0.0f); uvs[i4 + 2] = new Vector2(1.0f, 1.0f); uvs[i4 + 3] = new Vector2(0.0f, 1.0f); //顺时针绘制三角形0 1 2 / 0 2 3tris[i6 + 0] = i4 + 0; tris[i6 + 1] = i4 + 1; tris[i6 + 2] = i4 + 2; tris[i6 + 3] = i4 + 0; tris[i6 + 4] = i4 + 2; tris[i6 + 5] = i4 + 3; } mesh.vertices = verts; mesh.triangles = tris; mesh.uv = uvs; mesh.RecalculateBounds(); return mesh; } }</code></pre><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><pre><code class="lang-csharp">#region 画圆/// &lt;summary&gt;/// 画圆/// &lt;/summary&gt;/// &lt;param name=&quot;radius&quot;&gt;圆的半径&lt;/param&gt;/// &lt;param name=&quot;segments&quot;&gt;圆的分割数&lt;/param&gt;/// &lt;param name=&quot;centerCircle&quot;&gt;圆心得位置&lt;/param&gt;void DrawCircle(float radius, int segments, Vector3 centerCircle){ gameObject.AddComponent&lt;MeshFilter&gt;(); gameObject.AddComponent&lt;MeshRenderer&gt;(); gameObject.GetComponent&lt;MeshRenderer&gt;().material = mat; //顶点Vector3[] vertices = new Vector3[segments + 1]; vertices[0] = centerCircle; float deltaAngle = Mathf.Deg2Rad * 360f / segments; float currentAngle = 0; for (int i = 1; i &lt; vertices.Length; i++) { float cosA = Mathf.Cos(currentAngle); float sinA = Mathf.Sin(currentAngle); vertices[i] = new Vector3(cosA * radius + centerCircle.x, sinA * radius + centerCircle.y, 0); currentAngle += deltaAngle; } //三角形int[] triangles = new int[segments * 3]; for (int i = 0, j = 1; i &lt; segments * 3 \- 3; i += 3, j++) { triangles[i] = 0; triangles[i + 1] = j + 1; triangles[i + 2] = j; } triangles[segments * 3 \- 3] = 0; triangles[segments * 3 \- 2] = 1; triangles[segments * 3 \- 1] = segments; Vector2[] uvs = new Vector2[vertices.Length]; for (int i = 0; i &lt; vertices.Length; i++) { uvs[i] = new Vector2(vertices[i].x / radius / 2 \+ 0.5f, vertices[i].y / radius / 2 \+ 0.5f); } Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh; mesh.Clear(); mesh.vertices = vertices; mesh.triangles = triangles; mesh.uv = uvs; } #endregion</code></pre><h3 id="画圆环"><a href="#画圆环" class="headerlink" title="画圆环"></a>画圆环</h3><pre><code class="lang-csharp">#region 画圆/// &lt;summary&gt;/// 画圆/// &lt;/summary&gt;/// &lt;param name=&quot;radius&quot;&gt;圆的半径&lt;/param&gt;/// &lt;param name=&quot;segments&quot;&gt;圆的分割数&lt;/param&gt;/// &lt;param name=&quot;centerCircle&quot;&gt;圆心得位置&lt;/param&gt;void DrawCircle(float radius, int segments, Vector3 centerCircle){ gameObject.AddComponent&lt;MeshFilter&gt;(); gameObject.AddComponent&lt;MeshRenderer&gt;(); gameObject.GetComponent&lt;MeshRenderer&gt;().material = mat; //顶点Vector3[] vertices = new Vector3[segments + 1]; vertices[0] = centerCircle; float deltaAngle = Mathf.Deg2Rad * 360f / segments; float currentAngle = 0; for (int i = 1; i &lt; vertices.Length; i++) { float cosA = Mathf.Cos(currentAngle); float sinA = Mathf.Sin(currentAngle); vertices[i] = new Vector3(cosA * radius + centerCircle.x, sinA * radius + centerCircle.y, 0); currentAngle += deltaAngle; } //三角形int[] triangles = new int[segments * 3]; for (int i = 0, j = 1; i &lt; segments * 3 \- 3; i += 3, j++) { triangles[i] = 0; triangles[i + 1] = j + 1; triangles[i + 2] = j; } triangles[segments * 3 \- 3] = 0; triangles[segments * 3 \- 2] = 1; triangles[segments * 3 \- 1] = segments; Vector2[] uvs = new Vector2[vertices.Length]; for (int i = 0; i &lt; vertices.Length; i++) { uvs[i] = new Vector2(vertices[i].x / radius / 2 \+ 0.5f, vertices[i].y / radius / 2 \+ 0.5f); } Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh; mesh.Clear(); mesh.vertices = vertices; mesh.triangles = triangles; mesh.uv = uvs; } #endregion</code></pre><h3 id="Mesh顶点编辑器"><a href="#Mesh顶点编辑器" class="headerlink" title="Mesh顶点编辑器"></a>Mesh顶点编辑器</h3><p>摘自：<a href="https://gameinstitute.qq.com/community/detail/129174" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/129174</a><br>思路：获取mesh上的所有顶点，然后在每个顶点位置创建一个控制点，控制点可以是任意你喜欢的物体，通过判断控制点的位置信息来修改mesh的顶点位置。<br>把每个顶点的坐标转为字符串，使用该坐标的字符串作为 <strong>key</strong> 来把 <strong>控制点</strong> 与 <strong>顶点数据</strong> 联系起来。</p><hr><p>控制点：</p><pre><code class="lang-csharp">using System.Collections; using System.Collections.Generic; using UnityEngine; public class MeshEditorPoint : MonoBehaviour ｛ //顶点id，（顶点初始位置转字符串）[HideInInspector] public string pointid; //记录坐标点上一次移动的位置，用于判断控制点是否移动[HideInInspector] private Vector3 lastPosition; public delegate void MoveDelegate(string pid,Vector3 pos); //控制点移动时的回调public MoveDelegate onMove = null; // Use this for initializationvoid Start () ｛lastPosition = transform.position; ｝ // Update is called once per framevoid Update () ｛if(transform.position != lastPosition)｛if(onMove != null) onMove(pointid, transform.localPosition); lastPosition = transform.position; ｝ ｝ ｝</code></pre><hr><p>顶点编辑器</p><pre><code class="lang-csharp">using System.Collections; using System.Collections.Generic; using UnityEngine; using System.Text; using System; public class ModelMeshEditor : MonoBehaviour ｛ //控制点的大小public float pointScale = 1.0f; private float lastPointScale = 1.0f; Mesh mesh; //顶点列表List&lt;Vector3&gt; positionList = new List&lt;Vector3&gt;(); //顶点控制物体列表List&lt;GameObject&gt; positionObjList = new List&lt;GameObject&gt;(); /// &lt;summary&gt;/// key:顶点字符串/// value:顶点在列表中的位置/// &lt;/summary&gt;Dictionary&lt;string, List&lt;int&gt;&gt; pointmap = new Dictionary&lt;string, List&lt;int&gt;&gt;(); // Use this for initializationvoid Start () ｛lastPointScale = pointScale; mesh = GetComponent&lt;MeshFilter&gt;().sharedMesh; CreateEditorPoint(); ｝ //创建控制点public void CreateEditorPoint()｛positionList = new List&lt;Vector3&gt;(mesh.vertices); for (int i = 0; i &lt; mesh.vertices.Length; i++) ｛ string vstr = Vector2String(mesh.vertices[i]); if(!pointmap.ContainsKey(vstr))｛ pointmap.Add(vstr,new List&lt;int&gt;()); ｝ pointmap[vstr].Add(i); ｝ foreach (string key in pointmap.Keys) ｛ GameObject editorpoint = (GameObject)Resources.Load(&quot;Prefabs/MeshEditor/MeshEditorPoint&quot;); editorpoint = Instantiate(editorpoint); editorpoint.transform.parent = transform; editorpoint.transform.localPosition = String2Vector(key); editorpoint.transform.localScale = new Vector3(1f, 1f, 1f); MeshEditorPoint editorPoint = editorpoint.GetComponent&lt;MeshEditorPoint&gt;(); editorPoint.onMove = PointMove; editorPoint.pointid = key; positionObjList.Add(editorpoint); ｝ ｝ //顶点物体被移动时调用此方法public void PointMove(string pointid,Vector3 position)｛if(!pointmap.ContainsKey(pointid))｛return; ｝ List&lt;int&gt; _list = pointmap[pointid]; for (int i = 0; i &lt; _list.Count; i ++)｛ positionList[_list[i]] = position; ｝ mesh.vertices = positionList.ToArray(); mesh.RecalculateNormals(); ｝ // Update is called once per framevoid Update () ｛//检测控制点尺寸是否改变if (Math.Abs(lastPointScale - pointScale) &gt; 0.1f)｛lastPointScale = pointScale; for (int i = 0; i &lt; positionObjList.Count; i ++)｛ positionObjList[i].transform.localScale = new Vector3(pointScale, pointScale, pointScale); ｝ ｝ ｝ string Vector2String(Vector3 v)｛StringBuilder str = new StringBuilder(); str.Append(v.x).Append(&quot;,&quot;).Append(v.y).Append(&quot;,&quot;).Append(v.z); return str.ToString(); ｝ Vector3 String2Vector(string vstr)｛try｛string[] strings = vstr.Split(&#39;,&#39;); return new Vector3(float.Parse(strings[0]), float.Parse(strings[1]), float.Parse(strings[2])); ｝catch(Exception e)｛ Debug.LogError(e.ToString()); return Vector3.zero; ｝ ｝ ｝</code></pre><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="3D建模软件"><a href="#3D建模软件" class="headerlink" title="3D建模软件"></a>3D建模软件</h3><p>1:Autodesk 3D Studio Max 支持mac os windows;<br>2: Autodesk 3D Maya 支持windows<br>3: Cinema4D 支持mac os windows<br>4: Blender 开源跨平台的全能三维制作软件, 支持mac os windows, linux;<br>5: Cheetah3D: 支持mac os<br>6: Unity与建模软件的单位比例:</p><div class="table-container"><table><thead><tr><th>软件</th><th>内部米</th><th>导入unity后的尺寸/m</th><th>与Unity单位的比例关系  </th></tr></thead><tbody><tr><td>3Dmax</td><td>1</td><td>0.01</td><td>100:1  </td></tr><tr><td>Maya</td><td>1</td><td>0.01</td><td>1:100  </td></tr><tr><td>Cinema 4D</td><td>1</td><td>0.01</td><td>1:100  </td></tr><tr><td>Light Wave</td><td>1</td><td>0.01</td><td>100:1  </td></tr></tbody></table></div><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://www.cnblogs.com/zhanghaipeng-Unity3D/p/4714973.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhanghaipeng-Unity3D/p/4714973.html</a><br><a href="https://blog.csdn.net/qq_29579137/article/details/77369734" target="_blank" rel="noopener">https://blog.csdn.net/qq_29579137/article/details/77369734</a><br><a href="https://www.bbsmax.com/A/QV5ZQvObJy/" target="_blank" rel="noopener">https://www.bbsmax.com/A/QV5ZQvObJy/</a><br><a href="https://blog.csdn.net/nanggong/article/details/54728823" target="_blank" rel="noopener">https://blog.csdn.net/nanggong/article/details/54728823</a><br><a href="https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf</a></p><p><a href="http://www.luzexi.com/2018/08/03/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB2" target="_blank" rel="noopener">http://www.luzexi.com/2018/08/03/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB2</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LUA相关</title>
      <link href="2023/07/25/Unity3D-LUA%E7%9B%B8%E5%85%B3/"/>
      <url>2023/07/25/Unity3D-LUA%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li><p><a href="https://github.com/mpeterv/luacheck" target="_blank" rel="noopener">https://github.com/mpeterv/luacheck</a></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map及其与Material、Texture的关系</title>
      <link href="2023/07/25/Unity3D-Map%E5%8F%8A%E5%85%B6%E4%B8%8EMaterial%E3%80%81Texture%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>2023/07/25/Unity3D-Map%E5%8F%8A%E5%85%B6%E4%B8%8EMaterial%E3%80%81Texture%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>贴图的英语 Map 其实包含了另一层含义就是“映射”。<br> 贴图指的是映射关系，其功能就是把纹理通过 UV 坐标映射到3D 物体表面。贴图包含了除了纹理以外其他很多信息，比方说 UV 坐标、贴图输入输出控制等等。</p></blockquote><p>UV坐标：水平方向是U，竖直方向是V。因为图片（纹理）是一个二维的平面，所以只需要UV坐标便可以确定图片的位置。（当然也有三维贴图，要用到UVW坐标，暂时还接触不到。）</p><h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>材质 Material包含贴图 Map，贴图包含纹理 Texture。<br>材质(Material)：物体的质地，物体看起来是什么做的<br>贴图(Map)<br>纹理(Texture)：普通的材质图片<br>贴图 + 着色器(Shader) = 材质球</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://gameinstitute.qq.com/community/detail/115074" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/115074</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU Skinning</title>
      <link href="2023/07/25/Unity3D-GPU-Skinning/"/>
      <url>2023/07/25/Unity3D-GPU-Skinning/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="蒙皮-Skinning"><a href="#蒙皮-Skinning" class="headerlink" title="蒙皮(Skinning)"></a>蒙皮(Skinning)</h3><p>将模型的网格皮肤(skin mesh)绑定给骨骼的过程</p><h3 id="刚体蒙皮"><a href="#刚体蒙皮" class="headerlink" title="刚体蒙皮"></a>刚体蒙皮</h3><h3 id="顶点混合"><a href="#顶点混合" class="headerlink" title="顶点混合"></a>顶点混合</h3>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graphics - Tier Settings &amp; Quality Level</title>
      <link href="2023/07/25/Unity3D-Graphics-Tier-Settings-Quality-Level/"/>
      <url>2023/07/25/Unity3D-Graphics-Tier-Settings-Quality-Level/</url>
      
        <content type="html"><![CDATA[<blockquote><p>优化中经常提到，根据机型配置的高低，进行不同的设置，使用不同性能的资源，那么这个究竟如何实现的，Unity使用什么样的机制支持这件事？</p></blockquote><h2 id="Graphics-Tier-Settings"><a href="#Graphics-Tier-Settings" class="headerlink" title="Graphics Tier Settings"></a>Graphics Tier Settings</h2><p>通过图形API或者设备的版本确定一些 <strong>全局的Graphics设置</strong> 以及所加载的 <strong>Shader脚本内容</strong> 。从而达到目的: </p><ul><li><p>兼容不同版本的图形API、显示设备</p></li><li><p>根据设备的性能调整项目质量的高低，在性能上适应不同的设备。</p></li></ul><blockquote><p>Use the Graphics settings (main menu: Edit &gt; Project Settings, then select the Graphics category) to apply global settings for Graphics.</p></blockquote><p>These settings allow you to make platform-specific adjustments to rendering and shader compilation, by tweaking built-in defines. </p><h3 id="常用设置项及其含义"><a href="#常用设置项及其含义" class="headerlink" title="常用设置项及其含义"></a>常用设置项及其含义</h3><h3 id="How-is-this-selection-done"><a href="#How-is-this-selection-done" class="headerlink" title="How is this selection done?"></a>How is this selection done?</h3><p>默认：Unity根据设备的版本或图形API自动选择。</p><h4 id="Tier-1"><a href="#Tier-1" class="headerlink" title="Tier 1"></a>Tier 1</h4><p>Android - all devices that have support for OpenGL ES 2 only</p><p>iOS - all devices before iPhone 5S (not including 5S, but including 5C), iPods up to and including 5th generation, iPads up to 4th generation, iPad mini first generation</p><p>Desktops: DirectX 9, HoloLens</p><h4 id="Tier-2"><a href="#Tier-2" class="headerlink" title="Tier 2"></a>Tier 2</h4><p>Android - all devices with OpenGL ES 3 support</p><p>iOS - all devices starting from iPhone 5S, iPad Air, iPad mini 2nd generation, iPod 6th generation<br>AppleTV</p><p>Web</p><p>Vulkan on Android is Tier 2.</p><h4 id="Tier-3"><a href="#Tier-3" class="headerlink" title="Tier 3"></a>Tier 3</h4><p>Desktops: OpenGL, Metal, DirectX 11+ , Vulkan </p><p>for desktops is in Tier 3</p><h3 id="Scripting-API"><a href="#Scripting-API" class="headerlink" title="Scripting API"></a>Scripting API</h3><p>自定义：使用脚本在Runtime强行设置。</p><pre><code class="lang-csharp">Graphics.activeTier : Rendering.GraphicsTier</code></pre><p>Initially this value is auto-detected from the hardware in use.<br><strong>Changing this value affects any subsequently loaded shaders. (So you have to do that before any shaders are loaded.)</strong><br>TierN corresponds to shader define UNITY_HARDWARE_TIERN</p><p>Runtime根据机型自定义Tier</p><pre><code class="lang-csharp">deviceID = SystemInfo.deviceModel; if(deviceID == &quot;iPhone10,3 &quot; || deviceID == &quot;iPhone10,6&quot;){ // This is an iPhoneX//now change the graphics tier to tier 3Graphics.activeTier = GraphicsTier.Tier3 }</code></pre><p><strong>set it once when you app starts.</strong></p><h2 id="Quality-Level"><a href="#Quality-Level" class="headerlink" title="Quality Level"></a>Quality Level</h2><p>设置方法：menu: Edit &gt; Project Settings, then select the Quality category</p><p>Set the level of graphical quality it attempts to render.<br>Generally speaking, quality comes at the expense of framerate and so it may be best not to aim for the highest quality on mobile devices or older hardware since it tends to have a detrimental effect on gameplay. </p><p>有Unity默认的Levels，也可以自己添加Levels，自己命名。</p><h3 id="Scripting-API-1"><a href="#Scripting-API-1" class="headerlink" title="Scripting API"></a>Scripting API</h3><p>Runtime设置Level</p><pre><code class="lang-csharp">using UnityEngine; public class Example : MonoBehaviour{ void OnGUI(){ string[] names = QualitySettings.names; GUILayout.BeginVertical(); for (int i = 0; i &lt; names.Length; i++) { if (GUILayout.Button(names[i])) { QualitySettings.SetQualityLevel(i, true); } } GUILayout.EndVertical(); } }</code></pre><blockquote><p>Note that: changing the quality level can be an expensive operation if the new level has different anti-aliasing setting. It’s fine to change the level when applying in-game quality options, but if you want to dynamically adjustquality level at runtime, pass false to applyExpensiveChanges so that expensive changes are not always applied.<br> When building a player quality levels that are not used for that platform are stripped. You should not expect a given quality setting to be at a given index. It’s best to query the available quality settings and use the returned index.</p></blockquote><h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p>Graphics Tier Settings一般是在真机上运行时自动选择，由于涉及到Grapics API的兼容性，开发者或用户一般不自己改Tier。</p><p>Quality Level比较常用，开发者可以根据场景或设备的性能设置Level。或者以UI的形式把设置Level的接口开放给用户，让用户根据自己的情况选择游戏质量。</p><p>判断设备高低端的方法：<br>不同的游戏厂商有不同的方法。</p><ul><li><p>粗糙一点的可能根据CPU的频率判断。</p></li><li><p>SystemInfo的API可以获取CPU等型号，根据型号判断等等。</p></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://forum.unity.com/threads/tiers-in-graphicsettings.485408/" target="_blank" rel="noopener">https://forum.unity.com/threads/tiers-in-graphicsettings.485408/</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU和CPU的区别</title>
      <link href="2023/07/25/Unity3D-GPU%E5%92%8CCPU%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2023/07/25/Unity3D-GPU%E5%92%8CCPU%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>GPU比较适合大量可并行的简单任务。比如场景渲染，光照处理等等。<br>GPU也支持一些其他的运算，比如通过GLSL，HLSL和Cg支持并行运算等等。<br>GPU同时也对游戏中的一些物理效果提供支持，比如PhysX。<br><strong>GPU负责显示特效</strong></p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU用于一些数值运算，比如伤害，随机数等等。同时你的敌人AI也是CPU运算出来的。<br>越是大型的单机游戏，游戏资源量越大，资源的实时加载以及处理也是大多由CPU来完成的。<br><strong>CPU负责游戏逻辑</strong></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image &amp; Raw Image</title>
      <link href="2023/07/25/Unity3D-Image-Raw-Image/"/>
      <url>2023/07/25/Unity3D-Image-Raw-Image/</url>
      
        <content type="html"><![CDATA[<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>而Image提供了四种ImageType：Simple（普通）、Sliced（切割）、Tiled（平铺）、Filled（填充），而且它还是布局元素（ILayoutElement），可以被各种布局组（ILayoutGroup）所包含，将它和其他布局元素进行布局。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Source Image：只支持Sprite类型的图片<br>Color：给图片混合上颜色<br>Material：材质(一些特殊情况需要使用材质)<br>Raycast Target：是否接收射线检测<br>Image Type：图片类型(普通，九宫切图，平铺，填充)<br>Preserve Aspect：是否保持宽高比<br>Set Native Size：设置元素为原本的像素大小</p><h4 id="Image-Type"><a href="#Image-Type" class="headerlink" title="Image Type"></a>Image Type</h4><h5 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h5><p>随意拉伸，会变形，可以勾选上PreserveAspect按原宽高比进行拉伸</p><h5 id="Sliced"><a href="#Sliced" class="headerlink" title="Sliced"></a>Sliced</h5><p>按照Sprite Editor中的九宫格进行拉伸处理</p><p><img src="assets/Image%20&amp;%20Raw%20Image/20200103131209912.png" alt="Alt text"></p><p>1，3，7，9区域不会进行拉伸，2和8区域会横向拉伸，4和6区域会纵向拉伸，5区域横纵都会拉伸</p><h5 id="Tilled"><a href="#Tilled" class="headerlink" title="Tilled"></a>Tilled</h5><p>图片本身大小会保持不变，像铺地面砖那样填充满整个Image控件</p><p><img src="assets/Image%20&amp;%20Raw%20Image/20200103132414236.png" alt="Alt text"></p><h5 id="Filled"><a href="#Filled" class="headerlink" title="Filled"></a>Filled</h5><p>图片以不同的方式呈现出来，例如技能冷却，血条，进度条</p><h2 id="Raw-Image"><a href="#Raw-Image" class="headerlink" title="Raw Image"></a>Raw Image</h2><blockquote><p>the Image control requires its Texture to be a Sprite<br> the Raw Image can accept any Texture.</p></blockquote><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>raw: 生的，未加工的<br>支持任何一种贴图模式，包括Render Texture和Movie Texture<br>只为我们提供了修改UV的方法，除此之外都是继承自MaskableGraphic的方法</p><blockquote><p>DefaultTexture类型会将贴图宽和高转换为2的n次幂<br> Sprite类型不会对宽和高进行自动拉伸，可以在Inspector—Advanced—Non—Power of 2选择是否进行转换</p></blockquote><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>Color<br>Material<br>Raycast Target<br>UV Rect：设置UV缩放和偏移(x和y属性用于控制UV左右、上下偏移，W和H属性用于控制UV的重复次数)</p><blockquote><p>可以在Import Settings中的Wrap Model设置循环的模式，Repeat模式可以用于2D游戏的背景图循环</p></blockquote><p>Set Native Size：设置元素为原本的像素大小</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/ecidevilin/article/details/52556724" target="_blank" rel="noopener">https://blog.csdn.net/ecidevilin/article/details/52556724</a><br><a href="http://&quot;https://blog.csdn.net/LLLLL&lt;strong" target="_blank" rel="noopener">/article/details/103807887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param”&gt;https://blog.csdn.net/LLLLL/article/details/103807887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DrawCall</title>
      <link href="2023/07/25/Unity3D-DrawCall/"/>
      <url>2023/07/25/Unity3D-DrawCall/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Draw Call就是CPU调用图形编程接口，比如DirectX或OpenGL，来命令GPU进行渲染的操作。<br>（DirectX中的DrawIndexedPrimitive命令，OpenGL中的glDrawElement命令）</p><p>命令缓冲区(Command Buffer)<br>CPU向其中添加命令，而由GPU从中读取命令<br>添加和读取的过程相互独立<br>命令有很多种类，而Draw Call是其中的一种<br>改变渲染状态（Shader，Texture）</p><h1 id="影响帧率"><a href="#影响帧率" class="headerlink" title="影响帧率"></a>影响帧率</h1><p>每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据，状态，命令等。在这一阶段，CPU需要完成很多工作，例如检查渲染状态等。<br>GPU的渲染能力很强，渲染速度往往快于CPU提交命令的速度。<br>如果Draw Call的数量太多，CPU就会把大量时间花费在提交Draw Call命令上，造成CPU的过载。</p><h2 id="如何减少Draw-Call"><a href="#如何减少Draw-Call" class="headerlink" title="如何减少Draw Call"></a>如何减少Draw Call</h2><h3 id="批处理-Batching"><a href="#批处理-Batching" class="headerlink" title="批处理(Batching)"></a>批处理(Batching)</h3><p>把很多小的Draw Call合并成一个大的Draw Call。</p><blockquote><p>在CPU和RAM中合并网格，而 <strong>合并网格</strong> 本身是需要计算，消耗CPU时间，而且 <strong>创建新网格</strong> 也会占用内存。因此批处理的频次不宜太高，不然造成的消耗可能得不偿失</p></blockquote><p>Unity内置了Draw Call Batching技术：在一次DrawCall中批量处理多个物体。只要物体的变换和材质相同，GPU就可以按完全相同的方式进行处理，即可以把它们放在一个Draw Call中。</p><p>条件: 合并的网格会在一次渲染任务中进行绘制，他们的渲染数据，渲染状态和shader都是一样的，因此合并的条件至少是： <strong>同材质、同贴图、同shader</strong> 。最好网格顶点格式也一致。</p><p>Unity提供了Dynamic Batching和Static Batching两种方式。</p><h4 id="Dynamic-Batching"><a href="#Dynamic-Batching" class="headerlink" title="Dynamic Batching"></a>Dynamic Batching</h4><p>Dynamic Batching是完全自动进行的，不需要也无法进行任何干预。</p><p>动态批处理的约束：</p><ol><li><p>批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。</p></li><li><p>如果着色器使用顶点位置，法线和UV值三种属性，那么只能批处理300顶点以下的物体；如果着色器需要使用顶点位置，法线，UV0，UV1和切向量，那么只能批处理180顶点以下的物体。</p></li><li><p>不要使用缩放，分别拥有缩放大小（1,1,1）和（2,2,2）的两个物体将不会进行批处理。</p></li><li><p>统一缩放的物体不会和非统一缩放的物体进行批处理。</p></li><li><p>使用缩放尺度（1,1,1）和（1,2,1）的两个物体将不会进行批处理，但是使用缩放尺度（1,2,1）和（1,3,1）的两个物体将可以进行批处理。</p></li><li><p>使用不同材质的实例化物体将会导致批处理失败。</p></li><li><p>拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。</p></li><li><p>多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。</p></li><li><p>预设体的实例会自动地使用相同的网格模型和材质。 </p></li><li><p>网格合并的顶点数量有上限（Unity中好像是65535还是900？）</p></li><li><p>使用MultiplePass的shader也不会进行批处理</p></li><li><p>接受实时阴影的物体也不会进行批处理</p></li></ol><h4 id="Static-Batching"><a href="#Static-Batching" class="headerlink" title="Static Batching"></a>Static Batching</h4><p>Static Batching需要把静止的物体标记为Static，然后无论大小，都会组成Batch。<br>如何对动态加载的静态物体进行静态合批操作：</p><pre><code class="lang-csharp">GameObject go = (GameObject)Instantiate(...); go.isStatic = true;//将实例化的物体设置为静态go.transform.parent = root.transform; gosList.Add(go); gos = gosList.ToArray(); StaticBatchingUtility.Combine(gos, root);静态合并</code></pre><blockquote><p>可以通过CombineChildren脚本（StandardAssets/Scripts/UnityScripts/CombineChildren）手动把物体组合在一起，但这个脚本会影响可见性测试，因为组合在一起的物体始终会被看作一个物体，从而会增加GPU要处理的几何体数量，因此要小心使用。</p></blockquote><h5 id="坏处：VBO增大，通过内存来换取性能"><a href="#坏处：VBO增大，通过内存来换取性能" class="headerlink" title="坏处：VBO增大，通过内存来换取性能"></a>坏处：VBO增大，通过内存来换取性能</h5><p>如果在静态批处理前有一些物体共享了相同的网格（例如这里的两个箱子），那么每一个物体都会有一个该网格的复制品，即一个网格会变成多个网格被发送给GPU。<br>如果使用同一网格的对象很多，可能需要牺牲一定的渲染性能，避免使用静态批处理。例如，如果在一个使用了1000个重复树模型的森林中使用静态批处理，那么结果就会产生1000倍的内存，这会造成严重的内存影响。</p><h4 id="Batching对提升性能的启发"><a href="#Batching对提升性能的启发" class="headerlink" title="Batching对提升性能的启发"></a>Batching对提升性能的启发</h4><ol><li><p>避免使用大量小的网格，当确实需要时，考虑是否要合并。</p></li><li><p>首先是尽量减少场景中使用的材质数量，即尽量共享材质，对于仅纹理不同的材质可以把纹理组合到一张更大的纹理中。把纹理打包成图集，减少材质数量。</p></li><li><p>把不会移动的物体标记为Static。</p></li><li><p>合并本身有消耗，因此尽量在编辑器下进行合并</p></li></ol><h3 id="减少反光阴影等"><a href="#减少反光阴影等" class="headerlink" title="减少反光阴影等"></a>减少反光阴影等</h3><p>尽量少的使用反光，阴影之类的，因为那会使物体多次渲染。<br>同样的设置，如果将灯光的阴影效果打开，DrawCall会大幅增加，使用lightmap可以实现想要的阴影效果</p><h3 id="遮挡剔除"><a href="#遮挡剔除" class="headerlink" title="遮挡剔除"></a>遮挡剔除</h3><p>对于复杂的静态场景，还可以考虑自行设计遮挡剔除算法，减少可见的物体数量同时也可以减少Draw Call。</p><h3 id="NGUI的优化"><a href="#NGUI的优化" class="headerlink" title="NGUI的优化"></a>NGUI的优化</h3><p>NGUI主要是有三大模块组成：UIPanel，UIWidget，UIDrawcall组成。其中UIPanel是用来管理UIWidget控件和UIDrawCall，而UIWidget是所有组件的基类。</p><p>在NGUI框架中，会有一个静态的list用来存放所有的Panel，然后每个单独的Panel下会保存自己的UIWidget和UIDrawCall，在每次绘制的时候panel会遍历自己下面的所有层级下的子物体，直到查找结束，或者遇到新的panel会跳出当前分支，继续寻找其他分支，直到全部查找结束。所以说在实际运行中，每次都会为一个UIWidget绘制一个DrawCall，如果这时候连续的多个UIWidget使用的材质和纹理一致，就会公用一个DrawCall。<br>使用不同材质和纹理：</p><p><img src="DrawCall/1592212245575.png" alt="Alt text"></p><p>使用材质和纹理：</p><p><img src="DrawCall/1592212252241.png" alt="Alt text"></p><p>使用同一个图集，并且使用同样的材质在同一个panel下才会合并为一个Drawcall</p><blockquote><p>如果使用同一个图集、材质，但是中间夹杂了其他的渲染状态，也会导致重新调用一次DrawCall。</p><p>另外还需要注意一点就是在panel下如果动态的物体，就是为了实现某种效果，需要UI 进行位置移动，这种情况下，最好做成动态分离，因为只要panel下UI有移动，panle就会对清空之前的保存的UIWidget和UIDrawCall，重新进行渲染，这样就会造成性能浪费</p></blockquote><p>对UI进行界面排布就需要对图集和层级做好规划，进而减少DrawCall次数</p><h2 id="计算（值得以后研究，把这个公式运用到优化实践中）"><a href="#计算（值得以后研究，把这个公式运用到优化实践中）" class="headerlink" title="计算（值得以后研究，把这个公式运用到优化实践中）"></a>计算（值得以后研究，把这个公式运用到优化实践中）</h2><p>NVIDIA 在 GDC 曾提出，25K batchs/sec 会吃满 1GHz 的 CPU，100的使用率。所以他们推出了一条公式，来预估游戏中大概可以 Run 多少个 Batch：<br>举个例子：如果你的目标是游戏跑30FPS、使用2GHz的CPU、20%的工作量拨给Draw Call来使用，那你每帧可以有多少Draw Call呢？<br>333 Batchs/Frame = 25K <em> 2 </em> (0.2/30)</p><p>Ref：<br><a href="https://blog.csdn.net/yu1368072332/article/details/85676537" target="_blank" rel="noopener">https://blog.csdn.net/yu1368072332/article/details/85676537</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Destroy</title>
      <link href="2023/07/25/Unity3D-Destroy/"/>
      <url>2023/07/25/Unity3D-Destroy/</url>
      
        <content type="html"><![CDATA[<p>Ref: <a href="https://www.cnblogs.com/timeObjserver/p/7575035.html" target="_blank" rel="noopener">https://www.cnblogs.com/timeObjserver/p/7575035.html</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UNITY Destroy()和DestroyImadiate()都不会立即释放对象内存</p><p>DestroyImadiate是立即将物体从场景hierachy中移除，并标记为 “null”，注意 是带引号的null。这是UNITY内部的一个处理技巧。关于这个技巧有很争议。</p><p>Destroy要等到帧末才会将物体从场景层级中移除并标记为”null”。</p><p>不管如何，二者都只是UNITY引擎层面的标记与处理，但在.NET底层，对象的内存都没有释放，只有手动GC.Collect()或等待NET去GC时才会释放掉对象内存。<br>如果该对象在其他地方还有引用的话，GC也无法将对象的内存释放。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>（1）obj并不会立即销毁，而是需要等待下一个Update更新，所以还是可以被print出来；<br>（2）DestroyImmediate立即对对像进行销毁，print出来是null；<br>（3）Destroy销毁场景中的物体，但内存中还存在，当令它需要销毁时，只是给一个标识。而内存中它依然是存在的，只有当内存不够，或一段时间没有再次被引用时（或者更多合理的条件满足），机制才会将它销毁并释放内存；<br>（4）这样做的目的就是为了避免频繁对内存的读写操作。回收器会定时清理一次内存中引用计数为0的对象，很可能你的要销毁的对象在其他地方还有引用而你自己不清楚，直接销毁可能导致其他地方空引用错误；<br>（5）建议使用平常Destroy函数，而不是DestroyImmediate函数；</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试代码如下：点ADD按钮不断创建对象，点DEL按钮清除所有对象，通过观察进程内存数值来察看对象内存是否释放。</p><pre><code class="lang-csharp">using System.Collections; using System.Collections.Generic; using System.Diagnostics; using UnityEngine; using UnityEngine.UI; public class MyGo : MonoBehaviour{ byte[] data = new byte[83000]; } public class testad : MonoBehaviour { Transform objs; Text txt; Process proc; // Use this for initializationvoid Start () { var btnadd = transform.Find(&quot;btnAdd&quot;).GetComponent&lt;Button&gt;(); btnadd.onClick.AddListener(OnClckAdd); var btndel = transform.Find(&quot;btnDel&quot;).GetComponent&lt;Button&gt;(); btndel.onClick.AddListener(OnClckDel); objs = transform.Find(&quot;objs&quot;); txt = transform.Find(&quot;Text&quot;).GetComponent&lt;Text&gt;(); proc = Process.GetCurrentProcess(); } void OnClckAdd(){ for (int i = 0; i &lt; 20; ++i) { var go = new GameObject(); go.AddComponent&lt;MyGo&gt;(); go.transform.SetParent(objs); } } void OnClckDel(){ for (int i = objs.childCount - 1; i &gt;= 0; i--) { GameObject.DestroyImmediate(objs.GetChild(i).gameObject); } System.GC.Collect(); } // Update is called once per framefloat timer = 0; void Update () { if (timer &gt; 0.5f) { timer = 0; txt.text = ((int)(proc.WorkingSet64 / 1024)).ToString(); } timer += Time.deltaTime; } }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Draw Call与Batching(TODO)</title>
      <link href="2023/07/25/Unity3D-Draw-Call%E4%B8%8EBatching-TODO/"/>
      <url>2023/07/25/Unity3D-Draw-Call%E4%B8%8EBatching-TODO/</url>
      
        <content type="html"><![CDATA[<h2 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>To draw a GameObject on the screen, the engine has to issue a draw call to the graphics API (such as OpenGL or Direct3D).<br><strong>每次引擎准备数据并通知GPU的过程称为一次Draw Call</strong> 。<br><strong>The command that tells the GPU to render a certain set of vertices as triangles with a certain state (shaders, blend state and so on)</strong></p><h3 id="耗时原因"><a href="#耗时原因" class="headerlink" title="耗时原因"></a>耗时原因</h3><p>在没有进行拼合的情况下，引擎准备数据并通知GPU的过程是逐个物体进行的，对于每个物体，不只GPU的渲染，CPU重新 <strong>设置材质/Shader</strong> 也是一项非常耗时的操作。</p><p><strong>Draw Call耗时主要是CPU端的耗时——</strong><br>Unity3d官方 - Draw calls are often resource-intensive(资源密集型的，大量占用资源的), with the graphics API doing significant work for every draw call, causing <strong>performance overhead(开销)on the CPU side</strong>. This is mostly caused <strong>by the state changes done between the draw calls</strong> (such as switching to a different Material), which causes resource-intensive validation and translation steps in the graphics driver.</p><p>There are some real costs with making draw calls, it requires <strong>setting up a bunch of state</strong> ( <strong>which set of vertices to use, what shader to use and so on</strong> ), and state changes have a cost both on the hardware side (updating a bunch of registers) and on the driver side (validating and translating your calls that set state).</p><p>为何要减少DrawCall？<br><strong>The main reason to make fewer draw calls is that graphics hardware can transform and render triangles much faster than you can submit them.</strong> If you submit few triangles with each call, you will be completely bound by the CPU and the GPU will be mostly idle. The CPU won’t be able to feed the GPU fast enough.</p><p><strong>The main cost of draw calls only apply if each call submits too little data</strong> , since this will cause you to be CPU-bound, and stop you from utilizing the hardware fully.</p><blockquote><p>Making a single draw call with two triangles is cheap, but if you submit too little data with each call, you won’t have enough CPU time to submit as much geometry to the GPU as you could have.</p><p>(我还不太懂的)draw calls can also cause the command buffer to be flushed, but in my experience that usually happens when you call SwapBuffers, not when submitting geometry. Video drivers generally try to buffer as much as they can get away with (several frames sometimes!) to squeeze out as much parallelism from the GPU as possible.</p></blockquote><h3 id="方法与建议"><a href="#方法与建议" class="headerlink" title="方法与建议"></a>方法与建议</h3><p>目前，我们建议DrawCall的主体范围(5%~95%) 控制在[0,150]范围内。</p><p>方法：减少所渲染物体的材质种类，并通过Draw Call Batching 来减少其数量。</p><h3 id="Note：游戏性能并非Draw-Call越小越好。"><a href="#Note：游戏性能并非Draw-Call越小越好。" class="headerlink" title="Note：游戏性能并非Draw Call越小越好。"></a>Note：游戏性能并非Draw Call越小越好。</h3><p>决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的 <strong>总线带宽</strong> 。当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。</p><h2 id="Batch-Draw-Call-Setpass-Call"><a href="#Batch-Draw-Call-Setpass-Call" class="headerlink" title="Batch, Draw Call, Setpass Call"></a>Batch, Draw Call, Setpass Call</h2><p>DrawCall</p><p>DrawCall：CPU每次调用图像编程接口 glDrawElements（OpenGl中的图元渲染函数）或者 DrawIndexedPrimitive（DirectX中的顶点绘制方法）命令GPU渲染的操作称为一次Draw Call。Draw Call就是一次渲染命令的调用，它指向一个需要被渲染的图元（primitive）列表，不包含任何材质信息，glDrawElements 或者 DrawIndexedPrimitive 函数的作用是将CPU准备好的顶点数据渲染出来。</p><p>Batch</p><p>一个Batch：提交vbo，提交ibo，提交shader，设置好硬件渲染状态，设置好光源属性，CPU调用GPU渲染。</p><p>这其实就是渲染流程的运用阶段，最终输出一个渲染图元（点、线、面等），再传递给GPU进行几何阶段和光栅化阶段的渲染显示。一个Batch必然会触发一次或多次DrawCall，且包含了该对象的所有的网格和顶点数据以及材质信息。把数据加载到显存是指把渲染所需的数据从硬盘加载到内存（RAM），再将网格和纹理等加载到显卡（VRAM），这一步比较耗时。设置渲染状态就是设置场景中的网格的顶点（Vertex）/片元（Fragment）着色器，光源属性，材质等。Unity提供的动态合批（Dynamic Batching ）合并的就是这一过程，将渲染状态相同的对象合并成一个Batch，减少DrawCall。</p><blockquote><p>如果一个batch和另一个batch使用的不是同种材质或者同一个材质的不同pass，那么就要触发一次set pass call来重新设定渲染状态。例如，Unity要渲染20个物体，这20个物体使用同种材质（但不一定mesh等价），假设两次dynamic batch各自合批了10个物体，则对于这次渲染，set pass call为1（只需要渲染一个材质），batch为2（向GPU提交了两次VBO，IBO等数据）。</p></blockquote><p>SetPassCall</p><p>Shader脚本中一个Pass语义块就是一个完整的渲染流程，一个着色器可以包含多个Pass语义块，每当GPU运行一个Pass之前，就会产生一个SetPassCall，所以可以理解为一次完整的渲染流程次数。</p><p>由此可见，一个Batch包含一个或多个DrawCall，都是产生是在CPU阶段，而目前普遍渲染的瓶颈恰恰就是CPU，GPU的处理速度比CPU快多了，Draw Call太高，CPU会把大量时间花费在处理Draw Call调用上。如果Batch太大，CPU需要频繁的从硬盘加载数据，切换渲染状态，这个消耗要比DrawCall大，所以后面Unity才逐渐弱化了DrawCall的显示。</p><h3 id="主要看哪个指标"><a href="#主要看哪个指标" class="headerlink" title="主要看哪个指标"></a>主要看哪个指标</h3><p>SetPass Call与 Draw Call相比，SetPass Call的指标与性能相关性更大（比如Static Batching的开启不影响Draw Call数，而SetPass Call通常会明显下降）。但 SetPass Call在某些情况下也同样存在问题，比如往一个场景中添加任意个相邻且材质相同的大网格物体（使Dynamic Batching失效）时，SetPass Call并不会变化。因此在UWA中，我们所使用的是类似Profiler 中 Total Batches 这一项指标，通常该数值与 Frame Debugger 中的数值基本一致，因此可以通过该工具来查看每个Batch的内容，从而更有针对性地进行优化。</p><h2 id="Draw-call-batching"><a href="#Draw-call-batching" class="headerlink" title="Draw call batching"></a>Draw call batching</h2><blockquote><p>You can enable or disable Dynamic and Static batching through Unity’s Player settings under Other Settings.</p><p>Built-in Batching的优劣：<br> Built-in batching has several <strong>benefits</strong> compared to manually merging GameObjects together; most notably, GameObjects <strong>can still be culled individually</strong>.<br> However, it also has some <strong>downsides</strong> ; <strong>static</strong> batching incurs <strong>memory and storage overhead</strong> , and <strong>dynamic</strong> batching incurs some <strong>CPU overhead</strong>.</p></blockquote><h3 id="Dynamic-batching"><a href="#Dynamic-batching" class="headerlink" title="Dynamic batching"></a>Dynamic batching</h3><h4 id="Meshes"><a href="#Meshes" class="headerlink" title="Meshes"></a>Meshes</h4><p>条件:</p><ol><li><p>share the same Material(共享相同的材质 <strong>实例</strong> )</p></li><li><p>fulfill other criteria</p><ul><li><p>顶点数量：Batching dynamic GameObjects has certain overhead per vertex, so batching is applied only to Meshes containing no more than 900 vertex attributes, and no more than 300 vertices. 如果你的着色器使用顶点位置，法线和一个UV，那么你可以动态批处理多达300个顶点；而如果你的着色器使用顶点位置，法线，UV0，UV1和切线，那么只有180个顶点。</p></li><li><p>镜像信息：GameObjects are not batched if they contain mirroring on the transform. 例如A物体的大小是(1f, 1f, 1f)，而B物体的大小则是(-1f, -1f, -1f)，则无法做批处理。</p></li><li><p>Using different <strong>Material instances</strong> causes GameObjects not to batch together, even if they are essentially the same. The exception is shadow caster rendering.</p></li><li><p>GameObjects with lightmaps have additional renderer parameters: lightmap index and offset/scale into the lightmap. Generally, dynamic lightmapped GameObjects should point to exactly the same lightmap location to be batched.</p></li><li><p>Multi-pass Shaders break batching. 几乎所有的Unity着色器都支持多个灯光的正向渲染模式（Forward Rendering），这要求额外的渲染次数，所以绘制 “额外的每像素灯”时不会被批处理；Legacy Deferred（Light Pre-Pass）渲染路径不能被动态批处理，因为它必须绘制物体两次。</p></li></ul></li></ol><blockquote><p>If you need to access shared Material properties from the scripts, then it is important to note that <strong>modifying Renderer.material creates a copy of the Material</strong>. Instead, use Renderer.sharedMaterial to keep Materials shared.</p><p>Shadow casters can often be batched together while rendering, even if their Materials are different. Shadow casters in Unity can use dynamic batching even with different Materials, as long as the values in the Materials needed by the shadow pass are the same. For example, many crates could use Materials with different Textures on them, but for the shadow caster rendering the textures are not relevant, so in this case they can be batched together.</p><p>如果Draw Call的开销比合批要低, 那么合批就没有意义了. Dynamic batching works by transforming all GameObject vertices into world space on the CPU, so it is only an advantage if that work is smaller than doing a draw call. The resource requirements of a draw call depends on many factors, primarily the graphics API used. For example, on consoles or modern APIs like Apple Metal, the draw call overhead is generally much lower, and often dynamic batching cannot be an advantage at all.</p></blockquote><h4 id="Particle-Systems-Line-Renderers-Trail-Renderers"><a href="#Particle-Systems-Line-Renderers-Trail-Renderers" class="headerlink" title="Particle Systems, Line Renderers, Trail Renderers"></a>Particle Systems, Line Renderers, Trail Renderers</h4><p>ParticleSystem等属于 <strong>Components with geometry that Unity generates dynamically(带有动态生成的几何图形的组件)</strong></p><p>具体处理方式:</p><ul><li><p>For each compatible renderer type, Unity builds all batchable content into 1 large Vertex Buffer.</p></li><li><p>The renderer sets up the Material state for the batch.</p></li><li><p>Unity binds the Vertex Buffer to the Graphics Device.</p></li><li><p>For each Renderer in the batch, Unity updates the offset into the Vertex Buffer, and then submits a new draw call.</p></li></ul><p>When measuring the cost of the Graphics Device calls, the slowest part of rendering a Component is the set-up of the Material state. Submitting draw calls at different offsets into a shared Vertex Buffer is very fast by comparison.</p><h3 id="Static-batching"><a href="#Static-batching" class="headerlink" title="Static batching"></a>Static batching</h3><p><strong>本质上是用空间换时间,要在渲染耗时与内存占用之间做权衡.</strong></p><p>Static batching allows the engine to reduce draw calls for geometry of any size provided it <strong>shares the same material</strong> , and <strong>does not move</strong>.</p><ul><li><p>优点：more efficient than dynamic batching (it does not transform vertices on the CPU)</p></li><li><p>缺点：uses more memory.</p></li></ul><blockquote><p>Using static batching requires <strong>additional memory for storing the combined geometry</strong>. If several GameObjects shared the same geometry before static batching, then a copy of geometry is created for each GameObject, either in the Editor or at runtime. This might not always be a good idea; sometimes you have to sacrifice rendering performance by avoiding static batching for some GameObjects to keep a smaller memory footprint. For example, marking trees as static in a dense forest level can have serious memory impact.</p></blockquote><p>内部实现: Internally, static batching works by transforming the static GameObjects into world space and building one shared vertex and index buffer for them.</p><h3 id="实践技巧"><a href="#实践技巧" class="headerlink" title="实践技巧"></a>实践技巧</h3><h4 id="Dynamic-Batching的开启"><a href="#Dynamic-Batching的开启" class="headerlink" title="Dynamic Batching的开启"></a>Dynamic Batching的开启</h4><p>Built-in管线，在Project Settings -&gt; Player当中：</p><p><img src="Draw Call与Batching\(TODO\" alt="Alt text"><br>_files/1617977824829.png)</p><p>SRP，在RenderPipelineAsset的Inspector面板的Advanced下：</p><p><img src="Draw Call与Batching\(TODO\" alt="Alt text"><br>_files/1617977877330.png)</p><h4 id="使用图集合并Material"><a href="#使用图集合并Material" class="headerlink" title="使用图集合并Material"></a>使用图集合并Material</h4><p>If you have two identical Materials which differ only in Texture, you can combine those Textures into a single big Texture. This process is often called Texture atlasing (see the Wikipedia page on Texture atlases for more information). Once Textures are in the same atlas, you can use a single Material instead.</p><p>atlas (also called a sprite sheet or an image sprite) is an image containing multiple smaller images, usually packed together to reduce overall dimensions.<br><strong>Benefits</strong><br>In an application where many small textures are used frequently, it is often more efficient to store the textures in a texture atlas which is treated as a single unit by the graphics hardware. This reduces the overhead of a context switch by increasing memory locality.</p><h4 id="无法合批的常见原因及案例"><a href="#无法合批的常见原因及案例" class="headerlink" title="无法合批的常见原因及案例"></a>无法合批的常见原因及案例</h4><p>详情见：<br><a href="https://github.com/Unity-Technologies/BatchBreakingCause" target="_blank" rel="noopener">https://github.com/Unity-Technologies/BatchBreakingCause</a></p><h2 id="SRP-Batching"><a href="#SRP-Batching" class="headerlink" title="SRP Batching"></a>SRP Batching</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.uwa4d.com/archives/Simple_PA_Rendering.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Simple_PA_Rendering.html</a><br><a href="https://blog.uwa4d.com/archives/optimzation_cpu.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/optimzation_cpu.html</a><br><a href="https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive" target="_blank" rel="noopener">https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive</a><br><a href="https://docs.unity3d.com/Manual/DrawCallBatching.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br><a href="https://en.wikipedia.org/wiki/Texture_atlas" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Texture_atlas</a><br><a href="https://www.zhihu.com/question/60614886" target="_blank" rel="noopener">https://www.zhihu.com/question/60614886</a><br><a href="https://zhuanlan.zhihu.com/p/76562300" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76562300</a><br><a href="https://zhuanlan.zhihu.com/p/366779113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/366779113</a><br><a href="https://answer.uwa4d.com/question/58d29b8b5a5050b366a6b6ae" target="_blank" rel="noopener">https://answer.uwa4d.com/question/58d29b8b5a5050b366a6b6ae</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CubeMap &amp; Skybox</title>
      <link href="2023/07/25/Unity3D-CubeMap-Skybox/"/>
      <url>2023/07/25/Unity3D-CubeMap-Skybox/</url>
      
        <content type="html"><![CDATA[<h2 id="Cubemap"><a href="#Cubemap" class="headerlink" title="Cubemap"></a>Cubemap</h2><p>A Cubemap is a collection of <strong>six square textures</strong> that represent the reflections on an environment. The six squares form the faces of an imaginary cube that surrounds an object; each face represents the view along the directions of the world axes (up, down, left, right, forward and back).</p><p>可以使用方向向量对它们索引和采样</p><pre><code class="lang-csharp">samplerCUBE _CubeMap; fixed4 frag (v2f i) : SV_Target { fixed4 col = texCUBE(_CubeMap, normalize(i.vertexLocal.xyz)); return col; }</code></pre><h2 id="制作方法"><a href="#制作方法" class="headerlink" title="制作方法"></a>制作方法</h2><h3 id="Legacy-Cubemap-Assets"><a href="#Legacy-Cubemap-Assets" class="headerlink" title="Legacy Cubemap Assets"></a>Legacy Cubemap Assets</h3><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185104728.png" alt="Alt text"></p><h3 id="Cubemap-texture"><a href="#Cubemap-texture" class="headerlink" title="Cubemap texture"></a>Cubemap texture</h3><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185140709.png" alt="Alt text"></p><h3 id="PanoramaToCubemap"><a href="#PanoramaToCubemap" class="headerlink" title="PanoramaToCubemap"></a>PanoramaToCubemap</h3><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185709526.png" alt="Alt text"></p><h3 id="Shader实现"><a href="#Shader实现" class="headerlink" title="Shader实现"></a>Shader实现</h3><p>使用Texture2D格式，在Shader当中组织，而不使用Unity的Cubemap格式。</p><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185174675.png" alt="Alt text"></p><h2 id="Skybox的实现"><a href="#Skybox的实现" class="headerlink" title="Skybox的实现"></a>Skybox的实现</h2><h3 id="使用Cubemap"><a href="#使用Cubemap" class="headerlink" title="使用Cubemap"></a>使用Cubemap</h3><p>制作Cubemap资源 。Buitin Shader当中的Skybox/Cubemap可以对Cubemap采样</p><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185387170.png" alt="Alt text"></p><h3 id="在Shader中对6张图采样"><a href="#在Shader中对6张图采样" class="headerlink" title="在Shader中对6张图采样"></a>在Shader中对6张图采样</h3><p>Builtin Shader: Mobile-Skybox</p><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185458141.png" alt="Alt text"></p><h3 id="Panorama-全景画"><a href="#Panorama-全景画" class="headerlink" title="Panorama(全景画)"></a>Panorama(全景画)</h3><p>Builtin Shader: Skybox/Panoramic<br>可以直接Texture2D格式的对全景图进行采样。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://blog.csdn.net/v_xchen_v/article/details/79474193" target="_blank" rel="noopener">https://blog.csdn.net/v_xchen_v/article/details/79474193</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collider</title>
      <link href="2023/07/25/Unity3D-Collider/"/>
      <url>2023/07/25/Unity3D-Collider/</url>
      
        <content type="html"><![CDATA[<h1 id="MeshCollider"><a href="#MeshCollider" class="headerlink" title="MeshCollider"></a>MeshCollider</h1><p>网格碰撞体 (Mesh Collider) 采用网格资源 (Mesh Asset) 并基于该网格构建其碰撞体 (Collider)。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BatchMode</title>
      <link href="2023/07/25/Unity3D-BatchMode/"/>
      <url>2023/07/25/Unity3D-BatchMode/</url>
      
        <content type="html"><![CDATA[<h2 id="使用原理"><a href="#使用原理" class="headerlink" title="使用原理"></a>使用原理</h2><h3 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h3><p>DOS是Disk Operation System(磁盘操作系统）的简称，是个人计算机上的一类操作系统。它直接操纵管理硬盘的文件，一般都是黑底白色文字的界面。<br>DOS就是人与机器的一座桥梁，是罩在机器硬件外面的一层“外壳”，只需通过一些接近于自然语言的DOS命令，就可以轻松地完成绝大多数对机器的日常操作。<br>此外，DOS还能有效地管理各种软硬件资源，对它们进行合理的调度，所有的软件和硬件都在DOS的监控和管理之下，有条不紊地进行着自己的工作，但是在操作不慎情况下也会死机。<br><strong>MS-DOS</strong> 是MicroSoft-dos，它不是纯DOS，是基于Windows的DOS程序，在功能上类似于DOS，但是不一样。<br>最新的Windows操作系统中，MS-dos的核心依然存在，只是加上Windows当作系统的图形界面。<br>微软图形界面操作系统 Windows NT 问世以来，DOS是一个 <strong>后台程序</strong> 的形式出现的。名为 <strong>Windows命令提示符</strong> 。可以通过点击运行- <strong>CMD</strong> 进入。</p><h4 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h4><p>DOS命令行不许要去专门当做一门语言学习，你只需要根据自己的需求百度一下命令行的使用方式即可。</p><h3 id="Batch-bat文件"><a href="#Batch-bat文件" class="headerlink" title="Batch(.bat文件)"></a>Batch(.bat文件)</h3><p><strong>批处理(Batch)</strong> ，也称为 <strong>批处理脚本</strong> 。通常被认为是一种简化的脚本语言，也称作宏。它应用于DOS和Windows系统中。<br>它是由DOS或者Windows系统内嵌的命令解释器（通常是COMMAND. COM或者CMD.EXE）解释运行。类似于Unix中的Shell脚本。批处理文件具有.bat或者.cmd的扩展名，其最简单的例子，是逐行书写在命令行中会用到的各种命令。<br><strong>使用</strong> ：在“命令提示”下键入批处理文件的名称，或者双击该批处理文件，系统就会调用Cmd.exe运行该批处理程序。<br><strong>运行</strong> ：运行批处理程序时，首先扫描整个批处理程序，然后从第一行代码开始向下逐句执行所有的命令，直至程序结尾或遇见exit命令或出错意外退出。</p><blockquote><p>批处理程序虽然是在命令行环境中运行，但不仅仅能使用命令行软件，任何当前系统下可运行的程序都可以放在批处理文件中运行。</p></blockquote><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h5 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h5><p>语法: echo [{on|off}] [message]<br>Sample：@echo off / echo hello world</p><p>打开回显或关闭请求回显功能，或显示消息。如果没有任何参数，echo命令将显示当前回显设置。<br>在实际应用中我们会把这条命令和重定向符号（也称为管道符号，一般用&gt; &gt;&gt; ^）结合来实现输入一些命令到特定的文件中，例如：</p><pre><code class="lang-csharp">echo test&gt;test.txt # 会创建一个名为&quot;test&quot;的文本文件，并将&quot;test&quot;输入到文本文件中。</code></pre><p>在批处理文件的开头，通常有：<br>echo off<br>原因是”@”可以将本行的命令关闭回显，搭配”echo off”就可以不显示”echo off”的回显了。</p><h5 id="rem-命令"><a href="#rem-命令" class="headerlink" title="rem 命令"></a>rem 命令</h5><p>语法：Rem [注释内容]<br>Sample：Rem 你好。</p><p>注释命令，类似于在C语言中的/ <em>——–</em> /，它并不会被执行，只是起一个注释的作用，只有在编辑批处理时才会被看到，主要用于方便修改。<br>:: 也具有rem的功能<br>但::和rem还是有区别的，当关闭回显时，rem和::后的内容都不会显示。<br>但是当打开回显时，rem后的内容会显示出来，然而::后的内容仍然不会显示。</p><h5 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h5><p>暂停命令。运行 Pause 命令时，将显示下面的消息：<br>Press any key to continue…（或：请按任意键继续…)</p><h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><h5 id="start"><a href="#start" class="headerlink" title="start"></a>start</h5><h5 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h5><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><p>Bash(Bourne-Again SHell): Unix shell的一种，能运行于大多数类Unix系统的操作系统之上，包括Linux与Mac OS X v10.4都将它作为默认shell。<br>是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。Bash还能从文件中读取命令，这样的文件称为脚本。</p><h3 id="Unity-Editor拓展"><a href="#Unity-Editor拓展" class="headerlink" title="Unity Editor拓展"></a>Unity Editor拓展</h3><p>放在工程目录下Assets/Editor文件下的方法都是对Unity引擎编辑器的拓展，一般常见的插件都会编写一部分编辑器拓展代码来自定义插件的Inspector面板等其他操作。</p><h3 id="Editor方法触发方式"><a href="#Editor方法触发方式" class="headerlink" title="Editor方法触发方式"></a>Editor方法触发方式</h3><h4 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h4><h4 id="EditorWindow-gt-Button"><a href="#EditorWindow-gt-Button" class="headerlink" title="EditorWindow-&gt;Button"></a>EditorWindow-&gt;Button</h4><pre><code class="lang-csharp">using UnityEditor; using UnityEngine; public class MyClass : EditorWindow{ // 重写window面板private void OnGUI(){ if(GUILayout.Button(&quot;MyFunc1&quot;)) { MyFunc1(); } } // 打开窗口[MenuItem(&quot;My Tools/My Window&quot;)] private static void OpenMyWindow(){ GetWindow&lt;MyClass&gt; (true, &quot;My Window&quot;); } [MenuItem(&quot;My Tools/MyFunc1&quot;)] private static void MyFunc1(){ //..你的操作Debug.Log (&quot;你的操作&quot;); } }</code></pre><h4 id="利用批处理来调用"><a href="#利用批处理来调用" class="headerlink" title="利用批处理来调用"></a>利用批处理来调用</h4><p>更多Unity Command line arguments：<a href="https://docs.unity3d.com/Manual/CommandLineArguments.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/CommandLineArguments.html</a></p><blockquote><p>最新Unity支持直接用.bat脚本直接导出linux、MacOS、Window的应用，暂时不支持Android和IOS等其它终端的输出。</p></blockquote><pre><code class="lang-csharp">using UnityEditor; public class MyWindow : EditorWindow{ public static void MyFunc1(){ Debug.Log(&quot;MyFunc1 Operation&quot;); } } ``` ```csharp rem 发布工具@echo off echo 启动 Unity.exe 请稍后... start /min D:\Unity\Editor\Unity.exe -batchmode -projectPath D:\MyProject\BatchProject -executeMethod MyClass.MyFunc1 Pausetaskkill /f /im unity.exe</code></pre><h5 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h5><p>echo 为DOS编程中一种显示消息的方法</p><p>start DOS编程中用于启动应用程序的命令<br>-batchmode 是Unity提供的Command line arguments中较为常用的一种，它是后台运行Unity，不显示Unity界面，这对于把机械的工作交给策划？美术？是极其重要的。<br>在-batchmode下运行Unity。这应该始终与其他命令行参数一起使用，因为 <strong>它确保没有出现弹出窗口，并且不需要任何人为干预</strong> 。执行脚本代码期间发生异常时，资产服务器更新失败或其他失败的操作，Unity立即退出并返回代码1。<br>请注意，在批处理模式下，Unity将其日志输出的最小版本发送到控制台。但是，日志文件仍然包含完整的日志信息。在编辑器打开相同的项目时以批处理模式打开项目不受支持; Unity的一个实例只能一次运行。</p><p>-projectPath 指定项目的路径</p><p>-executeMethod(ClassName.MethodName) 调用Unity编辑器某个类型中的某个方法</p><p>一旦Unity启动，项目打开，并且执行了可选的Asset Server更新之后，执行静态方法。这可以用于执行持续集成，执行单元测试，构建或准备数据等任务。要从命令行进程返回错误，请抛出异常，导致Unity退出代码1，或者使用非零返回代码调用EditorApplication.Exit。要传递参数，将它们添加到命令行并使用函数检索它们System.Environment.GetCommandLineArgs。要使用-executeMethod，您需要将封闭的脚本放在编辑器文件夹中。要执行的方法必须定义为static。</p><p>Ref: <a href="https://blog.csdn.net/qq_29579137/article/details/76598929" target="_blank" rel="noopener">https://blog.csdn.net/qq_29579137/article/details/76598929</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Camera &amp; Screen</title>
      <link href="2023/07/25/Unity3D-Camera-Screen/"/>
      <url>2023/07/25/Unity3D-Camera-Screen/</url>
      
        <content type="html"><![CDATA[<h2 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h2><pre><code class="lang-csharp">Screen.autorotateToLandscapeLeft = true; //自动旋转屏幕为向左 Screen.autorotateToLandscapeRight = false; //自动旋转屏幕向右 Screen.autorotateToPortrait = true; //自动旋转为纵向 Screen.autorotateToPortraitUpsideDown = true; //自动旋转为纵向倒置 print(Screen.currentResolution); //当前屏幕分辨率 Screen.fullScreen = !Screen.fullScreen; //是否全屏 print(Screen.height); //屏幕分辨率的高度 Screen.lockCursor = !Screen.lockCursor; //是否锁定光标 Screen.showCursor = !Screen.showCursor; //是否显示光标 Screen.orientation = ScreenOrientation.Landscape; //屏幕取向 Resolution[] resolutions = Screen.resolutions; //显示器支持的所有全屏分辨率 foreach (Resolution res in resolutions) { print(res.width + &quot; &quot; \+ res.height); } //参数1宽， 参数 2高， 参数3是否全屏 Screen.SetResolution(resolutions[0].width, resolutions[0].height, true);</code></pre><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><h3 id="View-Frustum-视锥体-相关参数图解"><a href="#View-Frustum-视锥体-相关参数图解" class="headerlink" title="View Frustum(视锥体)相关参数图解"></a>View Frustum(视锥体)相关参数图解</h3><h4 id="透视相机-Perspective"><a href="#透视相机-Perspective" class="headerlink" title="透视相机(Perspective)"></a>透视相机(Perspective)</h4><p><img src="assets/Camera%20&amp;%20Screen/20180524230527942.jpg" alt="Alt text"></p><p><img src="assets/Camera%20&amp;%20Screen/20180524232513244.jpg" alt="Alt text"></p><p>nearClipPalneHeight(近截平面的高)=2<em>Near</em>tan(FOV/2)<br>farClipPlaneHeight(远截平面)=2<em>Far</em>tan(FOV/2)<br>Aspect(摄像机的纵横比)=nearClipPlaneWidth/nearClipPalneHeight=farClipPlaneWidth/farClipPlaneHeight</p><h4 id="正交相机-Orthographic"><a href="#正交相机-Orthographic" class="headerlink" title="正交相机(Orthographic)"></a>正交相机(Orthographic)</h4><p><img src="assets/Camera%20&amp;%20Screen/20180524230615918.jpg" alt="Alt text"></p><p><img src="assets/Camera%20&amp;%20Screen/20180524231957314.jpg" alt="Alt text"></p><p>nearClipPlaneHeight=2*Size<br>farClipPlaneHeight=nearClipPlaneHeight<br>Aspect=nearClipPlaneHeight/farClipPlaneWidth=nearClipPlaneHeight/nearClipPalneWidth</p><h3 id="属性（Inspector可见）"><a href="#属性（Inspector可见）" class="headerlink" title="属性（Inspector可见）"></a>属性（Inspector可见）</h3><h4 id="Clear-Flags"><a href="#Clear-Flags" class="headerlink" title="Clear Flags"></a>Clear Flags</h4><p>清除标识：确定了屏幕哪些部分将被清除，方便多个摄像机画不同的游戏元素</p><p>Skybox ：<br>天空盒：这是默认设置。屏幕上的任何空的部分将显示当前相机的天空盒。<br>如果当前的相机没有设置天空盒，它会默认在渲染设置（Render Settings ）选择天空盒<br>Solid Color ：<br>纯色，屏幕上的空白部分将显示当前摄像机的背景色<br>Depth Only ：<br>深度相机，只渲染采集到的画面<br>如果你想绘制一个玩家的枪，又不让它内部环境被裁剪，你会设置深度为0的相机绘制环境，<br>和另一个深度为1的相机单独绘制武器。武器相机的清除标志（Clear Flags ）应设置 为depth only。<br>Don’t Clear ：<br>不清除，此模式不清除颜色或深度缓存。每帧的渲染画面叠加在上一帧画面之上。</p><h4 id="Background-背景色"><a href="#Background-背景色" class="headerlink" title="Background:背景色"></a>Background:背景色</h4><h4 id="Culling-Mask"><a href="#Culling-Mask" class="headerlink" title="Culling Mask"></a>Culling Mask</h4><p>Culling Mask:包含或省略要由相机呈现的对象层。在检查器中将图层分配给您的对象。<br>Nothing:什么层都不剔除<br>Everything:什么层都剔除<br>Default:默认层剔除<br>TransparentFX:隐形层,系统不会渲染贴图和模型<br>Ignore Raycast:射线层剔除<br>Water:水层剔除<br>UI：UI层剔除</p><p>原理：<br>清除标记至少与渲染管线的两个步骤有关：深度测试和颜色混合。屏幕上每一个像素都至少有两个信息， <strong>颜色信息</strong> 和 <strong>深度信息</strong> ，当新的一帧的像素信息在屏幕呈现之前，先会将 <strong>上一帧的缓存信息清除</strong> 某些部分（或者不清除任何信息），然后和 <strong>剩下的信息做深度测试和颜色混合得到最终结果</strong> （还有其他步骤，这里只讨论着两个），把结果放在帧缓存区并显示在屏幕上。</p><p>深入理解见：<a href="https://blog.csdn.net/mingyi2106/article/details/81606959" target="_blank" rel="noopener">https://blog.csdn.net/mingyi2106/article/details/81606959</a></p><h4 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h4><p>切换相机的功能来模拟透视。</p><p>Perspective(透视): 相机将完整地呈现透视物体。拍摄角度为0-180°（最高）<br>透视模式下，有远小近大的效果。呈现3D效果<br><strong>Field of View</strong> : 设置为“透视”时，“相机”的视口大小。</p><p>Orthographic(正交): 相机将统一渲染对象，没有视角。注：正交模式下不支持延迟渲染。正向渲染总是被使用。<br>物体在视口的代销只与正交视口的大小有关，与摄像机到物体的距离无关，主要呈现2D效果。<br><strong>Size</strong> :设置为“正交”时，“相机”的视口大小。</p><p>orthographic :摄像机投影模式。若值为true,正交模式，反之投影模式。</p><h4 id="Clipping-Planes"><a href="#Clipping-Planes" class="headerlink" title="Clipping Planes"></a>Clipping Planes</h4><p>剪切平面，从相机到开始和停止渲染的距离。<br>Near ：相对于相机的最近点将出现绘图。<br>Far ：相对于相机的最远点将出现绘图。</p><h4 id="ViewportRect"><a href="#ViewportRect" class="headerlink" title="ViewportRect"></a>ViewportRect</h4><p>视口矩形 四个值指示屏幕上的相机视图将被绘制的位置。在视口坐标中测量（值为0-1）。</p><h4 id="Depth"><a href="#Depth" class="headerlink" title="Depth"></a>Depth</h4><p>相机的位置按照画图顺序。具有较大值的相机将被绘制在具有较小值的相机之上。</p><h4 id="Rendering-Path"><a href="#Rendering-Path" class="headerlink" title="Rendering Path"></a>Rendering Path</h4><p>渲染路径 ：定义什么绘制方法被用于相机的选项<br>Use Graphics Settings 使用玩家设置：在玩家设置（Player Settings.）相机使用哪个渲染路径。<br>Forward 用正向光照渲染：所有对象每材质渲染只渲染一次,快速渲染。基于着色器的渲染路径。支持逐像素计算光照（包括法线贴图和灯光Cookies）和来自一个平行光的实时阴影。<br>Deferred 延迟照明：所有物体将在无光照的环境渲染一次，然后在渲染队列尾部将物体的光照一起渲染出来。支持实时阴影，计算消耗大，对硬件要求高，不支持移动设备，仅专业版可用。<br>Legacy Vertex Lit :使用顶点光照。最低消耗的渲染路径，不支持实时阴影，适用于移动及老式设备。<br>Legacy Deferred : 旧的延迟光照 </p><h4 id="Target-Texture"><a href="#Target-Texture" class="headerlink" title="Target Texture"></a>Target Texture</h4><p>目标纹理:渲染纹理 （Render Texture）包含相机视图输出。这会使相机渲染在屏幕上的能力被禁止。可用于实现画中画或者画面特效。</p><h4 id="Occlusion-Culling（遮挡剔除）"><a href="#Occlusion-Culling（遮挡剔除）" class="headerlink" title="Occlusion Culling（遮挡剔除）"></a>Occlusion Culling（遮挡剔除）</h4><p>是否剔除物体背向摄像机的部分</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>Allow HDR:高动态光照渲染，启动相机高动态范围渲染功能。让场景更真实。</p></li><li><p>Allow MSAA: 这台相机应该使用MSAA渲染目标吗？如果当前质量设置MSAA级别支持，将只使用MSAA。</p></li><li><p>Allow Dynamic Resolution：动态分辨率缩放。<br>如果相机使用动态分辨率渲染，则为true，否则为false。即使此属性为true，动态分辨率也只能在当前图形设备支持的情况下使用。</p></li><li><p>Target Display:设置此摄像机的目标显示。<br>此设置使摄像机呈现在指定的显示中。显示器（例如监视器）支持的最大数目是8. </p></li></ul><h3 id="属性（Inspector不可见）"><a href="#属性（Inspector不可见）" class="headerlink" title="属性（Inspector不可见）"></a>属性（Inspector不可见）</h3><h4 id="aspect-：Camera视口的宽高比（可获取，可设置）"><a href="#aspect-：Camera视口的宽高比（可获取，可设置）" class="headerlink" title="aspect ：Camera视口的宽高比（可获取，可设置）"></a>aspect ：Camera视口的宽高比（可获取，可设置）</h4><p>获取或者设置Camera视口的宽高比例值。例如：camera.aspect =2.0f,则视口的宽度、高度 = 2.0f，当硬件显示器屏幕的宽度与高度比例不为2.0f时,视图的显示将会发生变形。aspect只处理摄像机camera可以看到的视图的宽高比例，而硬件显示屏的作用只是把摄像机camera看到的内容显示出来，当硬件显示屏的宽高比例与aspect的比例值不同时，视图将发生变形。</p><h4 id="pixelRect"><a href="#pixelRect" class="headerlink" title="pixelRect"></a>pixelRect</h4><p>设置Camera被渲染到屏幕中的坐标位置。以实际像素大小来设置显示视口的位置。如下图：A为原始平面大小，B为变换后的视口大小，则X0的值为视口右移的像素大小，Y0的值为视口上移的像素大小，w为Camera.pixelWidth,h的值为Camera.pixelHeight。这里要注意：Screen.width和Screen.height为模拟硬件屏幕的宽高值，不随Camera.pixelWidth和Camera.pixelHeight的改变而改变。</p><pre><code class="lang-csharp">public class PixelRect : MonoBehaviour{ int which_change = -1; float temp_x = 0.0f, temp_y = 0.0f; void Update(){ //Screen.width和Screen.height为模拟硬件屏幕的宽高值,//其返回值不随camera.pixelWidth和camera.pixelHeight的改变而改变Debug.Log(&quot;Screen.width:&quot; \+ Screen.width); Debug.Log(&quot;Screen.height:&quot; \+ Screen.height); Debug.Log(&quot;pixelWidth:&quot; \+ Camera.main.pixelWidth); Debug.Log(&quot;pixelHeight:&quot; \+ Camera.main.pixelHeight); //通过改变Camera的坐标位置而改变视口的区间if (which_change == 0) { if (Camera.main.pixelWidth &gt; 1.0f) { temp_x += Time.deltaTime * 20.0f; } //取消以下注释察看平移状况//if (Camera.main.pixelHeight &gt; 1.0f)//{// temp_y += Time.deltaTime * 20.0f;//}Camera.main.pixelRect = new Rect(temp_x, temp_y, Camera.main.pixelWidth, Camera.main.pixelHeight); } //通过改变Camera的视口宽度和高度来改变视口的区间else if (which_change == 1){ if (Camera.main.pixelWidth &gt; 1.0f) { temp_x = Camera.main.pixelWidth - Time.deltaTime * 20.0f; } //取消以下注释察看平移状况//if (camera.pixelHeight &gt; 1.0f)//{// temp_y = camera.pixelHeight - Time.deltaTime * 20.0f;//}Camera.main.pixelRect = new Rect(0, 0, temp_x, temp_y); } } void OnGUI(){ if (GUI.Button(new Rect(10.0f, 10.0f, 200.0f, 45.0f), &quot;视口改变方式1&quot;)) { Camera.main.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); which_change = 0; temp_x = 0.0f; temp_y = 0.0f; } if (GUI.Button(new Rect(10.0f, 60.0f, 200.0f, 45.0f), &quot;视口改变方式2&quot;)) { Camera.main.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); which_change = 1; temp_x = 0.0f; temp_y = Camera.main.pixelHeight; } if (GUI.Button(new Rect(10.0f, 110.0f, 200.0f, 45.0f), &quot;视口还原&quot;)) { Camera.main.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); which_change = -1; } } }</code></pre><h3 id="实用案例"><a href="#实用案例" class="headerlink" title="实用案例"></a>实用案例</h3><h4 id="cameraToWorldMatrix-变换矩阵"><a href="#cameraToWorldMatrix-变换矩阵" class="headerlink" title="cameraToWorldMatrix : 变换矩阵"></a>cameraToWorldMatrix : 变换矩阵</h4><pre><code class="lang-csharp">using UnityEngine; public class cameratoworldmatrix : MonoBehaviour { // Use this for initializationvoid Start () { Debug.Log(&quot;Camera旋转前位置&quot; \+ transform.position); Matrix4x4 m = Camera.main.cameraToWorldMatrix; // 向量的位置转换为世界坐标中的位置//v3 的值为沿着Camera局部坐标系的-z轴方向前移5个单位的位置在世界坐标系中的位置Vector3 v3 = m.MultiplyPoint(Vector3.forward * 5.0f); //v4 的值为沿着Camera世界坐标系的-z轴方向前移5个单位的位置在世界坐标系中的位置Vector3 v4 = m.MultiplyPoint(transform.forward * 5.0f); Debug.Log(&quot;旋转前，V3坐标值：&quot;+v3); Debug.Log(&quot;旋转前，V4坐标值：&quot;+v4); // 将摄像机沿着Y轴正向旋转90度（此时摄像机局部坐标系的z轴方向和世界坐标的X轴方向一致），transform.Rotate(Vector3.up * 90f); m = Camera.main.cameraToWorldMatrix; v3 = m.MultiplyPoint(Vector3.forward * 5.0f); v4 = m.MultiplyPoint(transform.forward * 5.0f); Debug.Log(&quot;旋转后， v3坐标值&quot;+v3); Debug.Log(&quot;旋转后， v4坐标值&quot;+v4); } }</code></pre><h4 id="CullingMask设置"><a href="#CullingMask设置" class="headerlink" title="CullingMask设置"></a>CullingMask设置</h4><p>CullingMask 按层渲染，此属性用于按层（GameObject.layer）有选择性地渲染场景中的物体。通过cullingMask可以使得当前摄像机有选择性地渲染场景中的部分物体，默认cullingMask =-1即渲染场景中的任何物体，cullingMask = 0时不渲染场景中的任何物体。若只渲染2,3,4，可以使用cullingMask = （1&lt;&lt;2）+ (1&lt;&lt;3)+(1&lt;&lt;4)来进行。</p><h4 id="eventMask属性（待研究）"><a href="#eventMask属性（待研究）" class="headerlink" title="eventMask属性（待研究）"></a>eventMask属性（待研究）</h4><p>按层响应事件，选择哪个层（layer）的物体可以响应鼠标事件</p><p>必须满足两个条件：</p><ol><li><p>物体在摄像机的视野范围内。</p></li><li><p>在2的layer次方的值与eventMask进行运算（&amp;）后结果仍为2的layer次方的值，如：defalult ,layer值为0，2的0次方=1，如果1与eventMask进行与运算后扔为1，则此物体响应鼠标事件。由于EventMask为奇数时，与1的与运算结果都为1，所以若物体层为defalut并且eventMask为奇数时物体会响应鼠标事件。</p></li></ol><p>如果想要多个不同层的物体响应鼠标事件，则需要把所有层的2的layer次方值相加，再与eventMask做与运算。例如，2个物体，layer值分贝为1,3，当event与9进行与运算后结果仍为9，则这两个物体都会响应鼠标事件。</p><p>此属性有一个特殊情况，但固体layer选择IgnoreRaycast(其为系统内置，值为2)时，无论EventMask值为多少，物体都无法响应鼠标事件。</p><pre><code class="lang-csharp">using UnityEngine; using System.Collections; public class EventMask_ts : MonoBehaviour{ bool is_rotate = false;//控制物体旋转public Camera c;//指向场景中摄像机//记录摄像机的eventMask值，可以在程序运行时在Inspector面板中修改其值的大小public int eventMask_now = -1; //记录当前物体的层int layer_now; int layerTemp;//记录2的layer次方的值int ad;//记录与运算（&amp;）的结果string str = null; void Update(){ //记录当前对象的层，可以在程序运行时在Inspector面板中选择不同的层layer_now = gameObject.layer; //求2的layer_now次方的值layerTemp= (int)Mathf.Pow(2.0f, layer_now); //与运算（&amp;）ad = eventMask_now &amp; layerTemp; c.eventMask = eventMask_now; //当is_rotate为true时旋转物体if (is_rotate) { transform.Rotate(Vector3.up * 15.0f * Time.deltaTime); } } //当鼠标左键按下时，物体开始旋转void OnMouseDown(){ is_rotate = true; } //当鼠标左键抬起时，物体结束旋转void OnMouseUp(){ is_rotate = false; } void OnGUI(){ GUI.Label(new Rect(10.0f, 10.0f, 300.0f, 45.0f), &quot;当前对象的layer值为：&quot; \+ layer_now + &quot; , 2的layer次方的值为&quot; \+ layerTemp); GUI.Label(new Rect(10.0f, 60.0f, 300.0f, 45.0f), &quot;当前摄像机eventMask的值为：&quot; \+ eventMask_now); GUI.Label(new Rect(10.0f, 110.0f, 500.0f, 45.0f), &quot;根据算法，当eventMask的值与&quot; \+ layerTemp+ &quot;进行与运算（&amp;）后， 若结果为&quot; \+ tp + &quot;，则物体相应OnMousexxx方法，否则不响应！&quot;); if (ad == tp) { str = &quot; ,所以物体会相应OnMouseDown方法！&quot;; } else{ str = &quot; ,所以物体不会相应OnMouseDown方法！&quot;; } GUI.Label(new Rect(10.0f, 160.0f, 500.0f, 45.0f), &quot;而当前eventMask与&quot; \+ layerTemp+ &quot;进行与运算（&amp;）的结果为&quot; \+ ad + str); } }</code></pre><h4 id="LayerCullDistances-层消隐的距离"><a href="#LayerCullDistances-层消隐的距离" class="headerlink" title="LayerCullDistances:层消隐的距离"></a>LayerCullDistances:层消隐的距离</h4><p>摄像机可以通过基于层（GameObject.layer）的方式来设置不同层物体的消隐距离，但这个距离必须小于或者等于摄像机的farClipPlane才有效。</p><h4 id="layerCullSpherical-基于球面距离剔除"><a href="#layerCullSpherical-基于球面距离剔除" class="headerlink" title="layerCullSpherical:基于球面距离剔除"></a>layerCullSpherical:基于球面距离剔除</h4><p>基于球面距离的剔除方式。属性默认为false，即不使用球面剔除，表示只要有一点没有超出物体所在层的远视口平面，物体就是可见的。当设置此属性为True时，只要物体的世界坐标点Position与摄像机的距离大于所在层的剔除距离，物体就不可见。</p><h4 id="Shader相关"><a href="#Shader相关" class="headerlink" title="Shader相关"></a>Shader相关</h4><ul><li><p>RenderWithShader:使用其他shader渲染<br>使用指定shader来代替当前物体的shader渲染一帧。当replacementTag为空时会替换视口中所有物体的shader</p></li><li><p>SetReplacementShader 使用指定的shader来替换物体当前的shader,被替换后每一帧都会替换shader来渲染物体,与上面的方法刚好不同。</p></li></ul><pre><code class="lang-csharp">public class RenderWithShader : MonoBehaviour{ bool is_use = false; void OnGUI(){ if (is_use) { //使用高光shader：Specular来渲染CameraCamera.main.RenderWithShader(Shader.Find(&quot;Specular&quot;), &quot;RenderType&quot;); } if (GUI.Button(new Rect(10.0f, 10.0f, 300.0f, 45.0f), &quot;使用RenderWithShader启用高光&quot;)) { //RenderWithShader每调用一次只渲染一帧，所以不可将其直接放到这儿//camera.RenderWithShader(Shader.Find(&quot;Specular&quot;), &quot;RenderType&quot;);is_use = true; } if (GUI.Button(new Rect(10.0f, 60.0f, 300.0f, 45.0f), &quot;使用SetReplacementShader启用高光&quot;)) { //SetReplacementShader方法用来替换已有shader，调用一次即可Camera.main.SetReplacementShader(Shader.Find(&quot;Specular&quot;), &quot;RenderType&quot;); is_use = false; } if (GUI.Button(new Rect(10.0f, 110.0f, 300.0f, 45.0f), &quot;关闭高光&quot;)) { Camera.main.ResetReplacementShader(); is_use = false; } } }</code></pre><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>见：<a href="https://www.jianshu.com/p/547ef7f4a313" target="_blank" rel="noopener">https://www.jianshu.com/p/547ef7f4a313</a></p><h2 id="编辑器模式下修改屏幕分辨率"><a href="#编辑器模式下修改屏幕分辨率" class="headerlink" title="编辑器模式下修改屏幕分辨率"></a>编辑器模式下修改屏幕分辨率</h2><pre><code class="lang-csharp">#if UNITY_EDITORusing System; using System.Reflection; using UnityEditor; using UnityEngine; public static class GameViewUtils{ static object gameViewSizesInstance; static MethodInfo getGroup; static GameViewUtils(){ // gameViewSizesInstance = ScriptableSingleton&lt;GameViewSizes&gt;.instance;var sizesType = typeof(Editor).Assembly.GetType(&quot;UnityEditor.GameViewSizes&quot;); var singleType = typeof(ScriptableSingleton&lt;&gt;).MakeGenericType(sizesType); var instanceProp = singleType.GetProperty(&quot;instance&quot;); getGroup = sizesType.GetMethod(&quot;GetGroup&quot;); gameViewSizesInstance = instanceProp.GetValue(null, null); } public enum GameViewSizeType { AspectRatio, FixedResolution } [MenuItem(&quot;Test/AddSize&quot;)] public static void AddTestSize(){ AddCustomSize(GameViewSizeType.AspectRatio, GameViewSizeGroupType.Standalone, 123, 456, &quot;Test size&quot;); } [MenuItem(&quot;Test/SizeTextQuery&quot;)] public static void SizeTextQueryTest(){ Debug.Log(SizeExists(GameViewSizeGroupType.Standalone, &quot;Test size&quot;)); } [MenuItem(&quot;Test/Query16:9Test&quot;)] public static void WidescreenQueryTest(){ Debug.Log(SizeExists(GameViewSizeGroupType.Standalone, &quot;16:9&quot;)); } [MenuItem(&quot;Test/Set16:9&quot;)] public static void SetWidescreenTest(){ SetSize(FindSize(GameViewSizeGroupType.Standalone, &quot;16:9&quot;)); } [MenuItem(&quot;Test/SetTestSize&quot;)] public static void SetTestSize(){ int idx = FindSize(GameViewSizeGroupType.Standalone, 123, 456); if (idx != -1) SetSize(idx); } public static void SetSize(int index){ var gvWndType = typeof(Editor).Assembly.GetType(&quot;UnityEditor.GameView&quot;); var selectedSizeIndexProp = gvWndType.GetProperty(&quot;selectedSizeIndex&quot;, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); var gvWnd = EditorWindow.GetWindow(gvWndType); selectedSizeIndexProp.SetValue(gvWnd, index, null); } [MenuItem(&quot;Test/SizeDimensionsQuery&quot;)] public static void SizeDimensionsQueryTest(){ Debug.Log(SizeExists(GameViewSizeGroupType.Standalone, 123, 456)); } public static void AddCustomSize(GameViewSizeType viewSizeType, GameViewSizeGroupType sizeGroupType, int width, int height, string text){ // GameViewSizes group = gameViewSizesInstance.GetGroup(sizeGroupTyge);// group.AddCustomSize(new GameViewSize(viewSizeType, width, height, text);var group = GetGroup(sizeGroupType); var addCustomSize = getGroup.ReturnType.GetMethod(&quot;AddCustomSize&quot;); // or group.GetType().var gvsType = typeof(Editor).Assembly.GetType(&quot;UnityEditor.GameViewSize&quot;); var ctor = gvsType.GetConstructor(new Type[] { typeof(int), typeof(int), typeof(int), typeof(string) }); var newSize = ctor.Invoke(new object[] { (int)viewSizeType, width, height, text }); addCustomSize.Invoke(group, new object[] { newSize }); } public static bool SizeExists(GameViewSizeGroupType sizeGroupType, string text){ return FindSize(sizeGroupType, text) != -1; } public static int FindSize(GameViewSizeGroupType sizeGroupType, string text){ // GameViewSizes group = gameViewSizesInstance.GetGroup(sizeGroupType);// string[] texts = group.GetDisplayTexts();// for loop...var group = GetGroup(sizeGroupType); var getDisplayTexts = group.GetType().GetMethod(&quot;GetDisplayTexts&quot;); var displayTexts = getDisplayTexts.Invoke(group, null) as string[]; for (int i = 0; i &lt; displayTexts.Length; i++) { string display = displayTexts[i]; // the text we get is &quot;Name (W:H)&quot; if the size has a name, or just &quot;W:H&quot; e.g. 16:9// so if we&#39;re querying a custom size text we substring to only get the name// You could see the outputs by just logging// Debug.Log(display);int pren = display.IndexOf(&#39;(&#39;); if (pren != -1) display = display.Substring(0, pren - 1); // -1 to remove the space that&#39;s before the prens. This is very implementation-depdenentif (display == text) return i; } return -1; } public static bool SizeExists(GameViewSizeGroupType sizeGroupType, int width, int height){ return FindSize(sizeGroupType, width, height) != -1; } public static int FindSize(GameViewSizeGroupType sizeGroupType, int width, int height){ // goal:// GameViewSizes group = gameViewSizesInstance.GetGroup(sizeGroupType);// int sizesCount = group.GetBuiltinCount() + group.GetCustomCount();// iterate through the sizes via group.GetGameViewSize(int index)var group = GetGroup(sizeGroupType); var groupType = group.GetType(); var getBuiltinCount = groupType.GetMethod(&quot;GetBuiltinCount&quot;); var getCustomCount = groupType.GetMethod(&quot;GetCustomCount&quot;); int sizesCount = (int)getBuiltinCount.Invoke(group, null) + (int)getCustomCount.Invoke(group, null); var getGameViewSize = groupType.GetMethod(&quot;GetGameViewSize&quot;); var gvsType = getGameViewSize.ReturnType; var widthProp = gvsType.GetProperty(&quot;width&quot;); var heightProp = gvsType.GetProperty(&quot;height&quot;); var indexValue = new object[1]; for (int i = 0; i &lt; sizesCount; i++) { indexValue[0] = i; var size = getGameViewSize.Invoke(group, indexValue); int sizeWidth = (int)widthProp.GetValue(size, null); int sizeHeight = (int)heightProp.GetValue(size, null); if (sizeWidth == width &amp;&amp; sizeHeight == height) return i; } return -1; } static object GetGroup(GameViewSizeGroupType type){ return getGroup.Invoke(gameViewSizesInstance, new object[] { (int)type }); } //[MenuItem(&quot;Test/LogCurrentGroupType&quot;)]//public static void LogCurrentGroupType()//{// Debug.Log(GetCurrentGroupType());//}public static GameViewSizeGroupType GetCurrentGroupType(){ var getCurrentGroupTypeProp = gameViewSizesInstance.GetType().GetProperty(&quot;currentGroupType&quot;); return (GameViewSizeGroupType)(int)getCurrentGroupTypeProp.GetValue(gameViewSizesInstance, null); } public static void switchOrientation(){ int width = Screen.height; int height = Screen.width; int index = FindSize(GetCurrentGroupType(), width, height); if (index == -1) { AddCustomSize(GameViewSizeType.FixedResolution, GetCurrentGroupType(), width, height, &quot;&quot;); index = FindSize(GetCurrentGroupType(), width, height); } if (index != -1) { SetSize(index); } else{ Debug.LogError(&quot;switchOrientation failed, can not find or add resoulution for &quot; \+ width.ToString() + &quot;*&quot; \+ height.ToString()); } } } #endif</code></pre><h2 id="屏幕比例与摄像机设置"><a href="#屏幕比例与摄像机设置" class="headerlink" title="屏幕比例与摄像机设置"></a>屏幕比例与摄像机设置</h2><h3 id="宽高比（aspect）"><a href="#宽高比（aspect）" class="headerlink" title="宽高比（aspect）"></a>宽高比（aspect）</h3><p>Screen.witdh和Screen.heigh表示模拟硬件设备的宽高值，不受camera等相关组件在软件层面的代码影响。<br>Unity在Screen界面可以设置Screen的比例和像素，但是没有提供相应的接口用代码设置屏幕比例，因为硬件的屏幕就是不可设置的。</p><p><strong>aspect</strong> ：获取和设置屏幕的 <strong>宽高比</strong> 。</p><p>Viewport Rect：视口框。指的是在Screen上，显示图像的方框。X、Y为偏移值，W、H为实际视口宽/高与Screen宽/高的比例值。</p><p>aspect默认和screen的宽高比保持一致，摄像机渲染的图像填满screen。<br>当Viewport Rect宽高比发生变化时，aspect与之保持一致。<br>即默认情况下，aspect是由屏幕的宽高比以及Viewport Rect一起决定的。</p><p>当在脚本中手动更改aspect的值时，aspect的值即为手动设置的值，相机的宽高比也就是人手动设置的。</p><p>此时，Viewport宽高比不变，相机会把自己的视口当中的图像渲染到Viewport当中，由于宽高比不一致会导致变形。</p><h3 id="可见区域形状"><a href="#可见区域形状" class="headerlink" title="可见区域形状"></a>可见区域形状</h3><h4 id="Perspective"><a href="#Perspective" class="headerlink" title="Perspective"></a>Perspective</h4><p>透视视图下，可见区域是一个四棱台。<br>Aspect决定了宽高比，即棱台上下底、截面的宽高比。<br>Field of View：相机视野角度，由FOV Axis确定的轴向上的角度值(degree)</p><blockquote><p>宽高比决定了，改变Field of View，视口截面的形状会成比例缩放。从角度的层面来看，棱台的侧棱与高之间的夹角随FoV的变大而变大，直观来看，就是视角的放大与缩小。<br> （调整Screen或Viewport或aspect，只能改变相机视口的宽度，不能改变高度，就是因为Field of View把高度值定死了）<br> Clipping Planes：剪裁面片，指的是可视区域棱台的上下底面 距离camera坐标点的位置（近截面和远截面）</p></blockquote><p>以上所有参数，共同决定了camera可见范围的形状以及它与屏幕渲染的图像的关系。</p><blockquote><p><strong>aspect值在代码中设置过一次，就会固定。如果没有设置过，就默认与Screen宽高比一致。</strong></p></blockquote><h4 id="Orthographic"><a href="#Orthographic" class="headerlink" title="Orthographic"></a>Orthographic</h4><p>较容易理解。size参数相当于Perspective模式下的FoV。</p><p>摄像机高度 = 摄像机orthographicSize <em> 2<br>摄像机实际宽度 = 摄像机高度 </em> 屏幕宽高比<br>摄像机实际宽度 = 摄像机orthographicSize <em> 2 </em> 屏幕宽高比</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/unity-carry/p/9512662.html" target="_blank" rel="noopener">https://www.cnblogs.com/unity-carry/p/9512662.html</a><br><a href="https://www.jianshu.com/p/547ef7f4a313" target="_blank" rel="noopener">https://www.jianshu.com/p/547ef7f4a313</a><br><a href="https://www.jianshu.com/p/95cb4621206e" target="_blank" rel="noopener">https://www.jianshu.com/p/95cb4621206e</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSharp调用Java&amp;与Android交互</title>
      <link href="2023/07/25/Unity3D-CSharp%E8%B0%83%E7%94%A8Java-%E4%B8%8EAndroid%E4%BA%A4%E4%BA%92/"/>
      <url>2023/07/25/Unity3D-CSharp%E8%B0%83%E7%94%A8Java-%E4%B8%8EAndroid%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h2 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h2><p><a href="https://www.jb51.net/article/134135.htm" target="_blank" rel="noopener">https://www.jb51.net/article/134135.htm</a><br><a href="https://blog.csdn.net/m0_38096376/article/details/69567409" target="_blank" rel="noopener">https://blog.csdn.net/m0_38096376/article/details/69567409</a><br><a href="https://www.jianshu.com/p/b5e3cfcdf081" target="_blank" rel="noopener">https://www.jianshu.com/p/b5e3cfcdf081</a><br><a href="https://www.cnblogs.com/wufeng0927/p/5178216.html" target="_blank" rel="noopener">https://www.cnblogs.com/wufeng0927/p/5178216.html</a></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><pre><code class="lang-csharp">using UnityEngine; public class NewBehaviourScript : MonoBehaviour{ float e = 0; private void OnGUI(){ GUILayout.Label(string.Format($&quot;&lt;size=80&gt;电池总容量{Power.capacity}毫安,电压{Power.voltage}伏&lt;/size&gt;&quot;)); GUILayout.Label(string.Format($&quot;&lt;size=80&gt;实时电流{e}毫安,实时功率{(int)(e * Power.voltage)},满电量能玩{((Power.capacity /e).ToString(&quot;f2&quot;))}小时&lt;/size&gt;&quot;)); } float t = 0f; private void Update(){ if(Time.time - t &gt; 1f) { t = Time.time; e = Power.electricity; } } } public class Power{ static public float electricity { get { #if UNITY_ANDROID//获取电流（微安），避免频繁获取，取一次大概2毫秒float electricity = (float)manager.Call&lt;int&gt;(&quot;getIntProperty&quot;, PARAM_BATTERY); //小于1W就认为它的单位是毫安，否则认为是微安return ToMA(electricity); #elsereturn -1f; #endif} } //获取电压 伏static public float voltage { get; private set; } //获取电池总容量 毫安static public int capacity { get; private set; } //获取实时电流参数static object[] PARAM_BATTERY = new object[] { 2 }; //BatteryManager.BATTERY_PROPERTY_CURRENT_NOW)static AndroidJavaObject manager; static Power(){ #if UNITY_ANDROIDAndroidJavaClass unityPlayer = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;); AndroidJavaObject currActivity = unityPlayer.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;); manager = currActivity.Call&lt;AndroidJavaObject&gt;(&quot;getSystemService&quot;, new object[] { &quot;batterymanager&quot; }); capacity = (int)(ToMA((float)manager.Call&lt;int&gt;(&quot;getIntProperty&quot;, new object[] { 1 })) / ((float)manager.Call&lt;int&gt;(&quot;getIntProperty&quot;, new object[] { 4 })/100f)); //BATTERY_PROPERTY_CHARGE_COUNTER 1 BATTERY_PROPERTY_CAPACITY 4AndroidJavaObject receive = currActivity.Call&lt;AndroidJavaObject&gt;(&quot;registerReceiver&quot;, new object[] { null,new AndroidJavaObject(&quot;android.content.IntentFilter&quot;, new object[] { &quot;android.intent.action.BATTERY_CHANGED&quot; }) }); if (receive != null) { voltage = (float)receive.Call&lt;int&gt;(&quot;getIntExtra&quot;, new object[] { &quot;voltage&quot;,0 })/1000f; //BatteryManager.EXTRA_VOLTAGE} #endif} static float ToMA(float maOrua){ return maOrua &lt; 10000 ? maOrua : maOrua / 1000f; } }</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.xuanyusong.com/archives/4753" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4753</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atlas(图集)</title>
      <link href="2023/07/25/Unity3D-Atlas-%E5%9B%BE%E9%9B%86/"/>
      <url>2023/07/25/Unity3D-Atlas-%E5%9B%BE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Sprite的本质"><a href="#Sprite的本质" class="headerlink" title="Sprite的本质"></a>Sprite的本质</h2><p>原本的数据是图片，图片导入后，Sprite类型的设置以及Sprite的分割都是在ImportSettings当中设置的。而ImportSettings的信息就存储在.meta文件当中。因此，Sprite的本质就是meta文件当中存储的图集名称、ID及在原图片上的偏移量等信息。</p><h2 id="图集（Atlas）的本质"><a href="#图集（Atlas）的本质" class="headerlink" title="图集（Atlas）的本质"></a>图集（Atlas）的本质</h2><p>将Sprite集合设置为图集后，图集资源存储的就是Sprite索引的集合，在打包时，会将图集合并为Texture2D类型的资源放入包中，然后再放入各个Sprite的名称、ID以及在图集上的偏移量。</p><h3 id="图集的作用"><a href="#图集的作用" class="headerlink" title="图集的作用"></a>图集的作用</h3><ul><li><p>节省内存 - OpenGL载入纹理图片时，所用内存会自动扩张到2的N次方。如果图片大小为64<em>65，那么就会按照64</em>128载入。</p></li><li><p>减小包体 - 合成的大图会比之前所有的散图所占用的物理存储更小</p></li><li><p>提升载入速度 - 将很多小图拼接成一张大图，载入内存时一次载入，提高了载入速度。</p></li><li><p>DrawCall合批</p></li></ul><h2 id="Unity中的图集功能"><a href="#Unity中的图集功能" class="headerlink" title="Unity中的图集功能"></a>Unity中的图集功能</h2><blockquote><p>只有Sprite模式的图片才可以打包成图集</p></blockquote><p>旧版：<br>Sprite Mode 设置为 Muitiple 设置Packing Tag<br>Window-&gt;Sprite Packer –&gt;点击 Pack 即可</p><p>新版：<br>Project Setting -&gt; Editor -&gt; Sprite Packer -&gt; Mode = Always Enabled<br>新建 Sprite Atlas<br>选择打包图集的文件夹或者依次添加单独图片，点击Pack Preview后自动打包成一个图集</p><p>代码获取图集并动态选择Sprite：</p><pre><code class="lang-csharp">using UnityEditor; using UnityEngine; using UnityEngine.U2D; using UnityEngine.UI; public class SpriteAtlasExample : MonoBehaviour{ private void Awake(){ SpriteAtlas atlas = AssetDatabase.LoadAssetAtPath&lt;SpriteAtlas&gt;(&quot;Assets/TestAtlas.spriteatlas&quot;); Sprite sprite = atlas.GetSprite(&quot;Icon2&quot;); if (sprite != null) { GetComponent&lt;Image&gt;().sprite = sprite; } } }</code></pre><h3 id="Late-Binding-technology"><a href="#Late-Binding-technology" class="headerlink" title="Late Binding technology"></a>Late Binding technology</h3><p>Include in Build - Unity includes the Sprite Atlases with the Project’s build and automatically loads them at the build’s run time. </p><p><img src="Atlas\(图集\" alt="Alt text"><br>_files/1618326776601.png)</p><h4 id="Preparing-Sprite-Atlases-for-distribution"><a href="#Preparing-Sprite-Atlases-for-distribution" class="headerlink" title="Preparing Sprite Atlases for distribution"></a>Preparing Sprite Atlases for distribution</h4><p>Disable ‘Include in Build’ - Unity does not include the disabled Sprite Atlas in the Project’s published build, and does not automatically load it at run time. </p><p>Methods：</p><ol><li><p>Place the Sprite Atlases into the build’s Resources folder.</p></li><li><p>Distribute them as downloadable AssetBundles.</p></li></ol><h4 id="Late-Binding"><a href="#Late-Binding" class="headerlink" title="Late Binding"></a>Late Binding</h4><p>the build does not automatically load a prepared Sprite Atlas at run time.</p><p>SpriteAtlasManager.atlasRequested - Trigger when any <strong>Sprite was bound to SpriteAtlas</strong> but <strong>couldn’t locate the atlas asset during runtime</strong>.</p><ul><li><p>如果图集勾选Include in Build，在打包时，图集本身就会被自动打入AB包当中，加载Prefab时，就会把图集加载进内存，也就不会触发atlasRequested </p></li><li><p>不勾选Include in Build，在打包时，图集不会自动进入prefab所在的AB包，也不会自动加载出来，触发atlasRequested事件后，在相应的回调函数当中加载图集，即可实现延迟绑定，图集加载出来之后即可显示。</p></li></ul><pre><code class="lang-csharp">using UnityEngine; using UnityEngine.U2D; public class AtlasLoader : MonoBehaviour{ void OnEnable(){ SpriteAtlasManager.atlasRequested += RequestAtlas; } void OnDisable(){ SpriteAtlasManager.atlasRequested -= RequestAtlas; } void RequestAtlas(string tag, System.Action&lt;SpriteAtlas&gt; callback){ var sa = Resources.Load&lt;SpriteAtlas&gt;(tag); callback(sa); } } ``` ```csharp void RequestAtlas(string tag, System.Action&lt;SpriteAtlas&gt; callback){ Debug.LogError(&quot;RequestAtlas:&quot; \+ tag); string abPath = Application.streamingAssetsPath + &quot;/&quot; \+ tag.ToLower(); AssetBundle ab = AssetBundle.LoadFromFile(abPath); SpriteAtlas sa = ab.LoadAsset&lt;SpriteAtlas&gt;(tag); callback(sa); }</code></pre><h2 id="Texture-Packer"><a href="#Texture-Packer" class="headerlink" title="Texture Packer"></a>Texture Packer</h2><h3 id="Texture-Packer的图集-vs-Unity-Atlas的区别"><a href="#Texture-Packer的图集-vs-Unity-Atlas的区别" class="headerlink" title="Texture Packer的图集 vs. Unity Atlas的区别"></a>Texture Packer的图集 vs. Unity Atlas的区别</h3><p>Unity打图集时会将设置的一个sprite集合打入一张Texture2D当中，不会生成png、jpg等编码的图片格式，而在打包成AssetBundle后会生成一个Texture2D类型的资源。将合并后的Texture2D类型的资源以及各个图集的名称、ID、偏移量存储到包中。</p><hr><p>Texture Packer的基本使用：</p><p>Texture Packer会将图集合并成图片，生成一张合并后的PNG，并生成 <code>.tpsheet</code>文件（图集表），存储各个Sprite的名称以及偏移量。</p><p>在Unity中安装TexturePacker Importer插件后，将合并后的图集以及<code>.tpsheet</code>表格导入Unity后，插件会自动读取该信息，并根据该信息处理合并后的图片的ImportSettings，拆分Sprite，在Unity中还原TexturePacker中的设置。</p><h3 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h3><pre><code class="lang-csharp">E:\04_DCC_Tools\CodeAndWeb\TexturePacker\bin\TexturePacker --data foo.tpsheet \--sheet foo.png ./ ChatSystemAtlas.tps \--no-trim --max-size 1024</code></pre><p>其他相关参数：</p><pre><code class="lang-csharp">–replace &lt;regexp&gt;=&lt;string&gt; # 使用&lt;string&gt;替换掉拼接图片的文件名中正则表达式匹配的字符串 –texturepath &lt;path&gt; # 图片与tpsheet文件不再同一个目录时使用,不会改变out.png的目录 –ignore-files &lt;regexp&gt;–width/–height &lt;int&gt;–allow-free-size # 允许输出图片不是2的幂,以最小尺寸输出 –trim/no-trim # 剪裁图片,即移除图片周围的透明像素,保留原始尺寸,默认开启 –crop # 与上面的一条类似,移除图片四周的透明像素,不保留原始尺寸,保存为一张更小的图片 \--opt RGB444 # 设置输出图片的像素格式 一般默认RGBA8888</code></pre><h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>见官网：<a href="https://www.codeandweb.com/texturepacker/unity" target="_blank" rel="noopener">https://www.codeandweb.com/texturepacker/unity</a></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>图集的详细介绍：<a href="https://www.cnblogs.com/msxh/p/14194756.html" target="_blank" rel="noopener">https://www.cnblogs.com/msxh/p/14194756.html</a><br><a href="http://blog.justbilt.com/2013/12/12/use_tp_on_command_line/" target="_blank" rel="noopener">http://blog.justbilt.com/2013/12/12/use_tp_on_command_line/</a><br><a href="https://zhuanlan.zhihu.com/p/89332754" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/89332754</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Audio</title>
      <link href="2023/07/25/Unity3D-Audio/"/>
      <url>2023/07/25/Unity3D-Audio/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Basic-Theory"><a href="#Basic-Theory" class="headerlink" title="Basic Theory"></a>Basic Theory</h3><p>To simulate the effects of position, Unity requires sounds to originate from Audio Sources<br>attached to objects. The sounds emitted are then picked up by an Audio Listener<br>attached to another object, most often the main camera. Unity can then simulate the effects of a source’s distance and position from the listener object and play them to the user accordingly. The relative speed of the source and listener objects can also be used to simulate the <strong>Doppler Effect(多普勒效应)</strong> for added realism.</p><h4 id="回声和混响"><a href="#回声和混响" class="headerlink" title="回声和混响"></a>回声和混响</h4><p>Unity can’t calculate echoes purely from scene geometry but you can simulate them by adding Audio Filters to objects. For example, you could apply the Echo filter to a sound that is supposed to be coming from inside a cave. In situations where objects can move in and out of a place with a strong echo, you can add a Reverb Zone to the scene. </p><h2 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h2><p>Unity supports <strong>mono</strong> , <strong>stereo</strong> and <strong>multichannel</strong> audio assets (up to eight channels).<br>Unity3D游戏引擎一共支持4个音乐格式的文件<br>.AIFF 适用于较短的音乐文件可用作游戏打斗音效<br>.WAV 适用于较短的音乐文件可用作游戏打斗音效<br>.MP3 适用于较长的音乐文件可用作游戏背景音乐<br>.OGG 适用于较长的音乐文件可用作游戏背景音乐</p><blockquote><p>Unity also supports tracker modules, which use short audio samples as “instruments” that are then arranged to play tunes. Tracker modules can be imported from .xm, .mod, .it, and .s3m files but are otherwise used in much the same way as ordinary audio clips.</p></blockquote><h2 id="Recording"><a href="#Recording" class="headerlink" title="Recording"></a>Recording</h2><p>Unity can access the computer’s microphones from a script and create Audio Clips by direct recording. The <strong>Microphone</strong> class provides a straightforward API to find available microphones, query their capabilities and start and end a recording session.</p><h1 id="Clip"><a href="#Clip" class="headerlink" title="Clip"></a>Clip</h1><h3 id="Load-Type"><a href="#Load-Type" class="headerlink" title="Load Type"></a>Load Type</h3><h4 id="Decompress-On-Load"><a href="#Decompress-On-Load" class="headerlink" title="Decompress On Load"></a>Decompress On Load</h4><p>Use this option for smaller compressed sounds to avoid the performance overhead of decompressing on the fly. Be aware that decompressing Vorbis-encoded sounds on load will use about <strong>ten times</strong> more memory than keeping them compressed (for ADPCM encoding it’s about 3.5 times), so don’t use this option for large files.</p><p>适用于 <strong>较小</strong> 的压缩声音，避免即时解压缩的性能开销。不要使用于大文件。</p><h4 id="Compressed-In-Memory"><a href="#Compressed-In-Memory" class="headerlink" title="Compressed In Memory"></a>Compressed In Memory</h4><p>Keep sounds compressed in memory and decompress while playing. This option has a slight <strong>performance overhead</strong> (especially for Ogg/Vorbis compressed files) so only use it for bigger files where decompression on load would use a prohibitive amount of memory.<br>播放时解压会有CPU开销（尤其是OGG / Vorbis格式的压缩文件），但可以提高加载速度并减少内存消 耗，因此这个选项适用于 <strong>大文件</strong> 。 </p><blockquote><p>The decompression is happening on the mixer thread and can be monitored in the “DSP CPU” section in the audio pane of the profiler window.</p></blockquote><h4 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h4><p>Decode sounds on the fly. This method uses a minimal amount of memory to buffer compressed data that is <strong>incrementally read from the disk and decoded on the fly.</strong></p><blockquote><p>Profiler中：“Streaming CPU” section in the audio pane of the profiler window.<br> Streaming clips has an overload of approximately 200KB, even if none of the audio data is loaded.</p></blockquote><p>直接从磁盘流音频数据。这只使用了原始声音占内存大小的很小一部分。 该方法使用最少的内存和最多的CPU，它有个很明显的缺点就是不能被引用超过一次。试着让 Audio Clip产生多个副本的时候会每个都产生数据缓冲区，如果非要这么做会产生大量的内存和cpu消耗。因此这个选择最好是给单实例的Audio Clip，如背景和环境音效。对于手游而言不要优先考虑使用这种方式。</p><h3 id="Compression-Format"><a href="#Compression-Format" class="headerlink" title="Compression Format"></a>Compression Format</h3><h4 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h4><p>全称是Pulse-Code Modulation。属于脉冲调制编码，它将模拟信号转换为数字信号，实质上没有经过编码，没有进行压缩，所以在音质上是属于完全无损的原始音频。而且相较于原生的模拟信号，它的抗干扰能力更强，保真效果更好。</p><p>This option offers higher quality at the expense of larger file size and is best for very short sound effects.</p><h4 id="ADPCM"><a href="#ADPCM" class="headerlink" title="ADPCM"></a>ADPCM</h4><p>Adaptive Differential Pulse Code Modulation，自适应差分脉冲编码调制。是一种基于PCM的优化压缩方式，但也属于有损压缩。<br>This format is useful for sounds that contain a fair bit of noise and need to be played in large quantities, such as footsteps, impacts, weapons. The compression ratio is 3.5 times smaller than PCM, but CPU usage is much lower than the MP3/Vorbis formats which makes it the preferrable choice for the aforementioned categories of sounds.</p><h4 id="Vorbis-MP3"><a href="#Vorbis-MP3" class="headerlink" title="Vorbis/MP3"></a>Vorbis/MP3</h4><p>应该叫做OGG Vorbis。类似mp3格式，但这是一种免费开发的非商业压缩格式。属于有损压缩。</p><p>The compression results in smaller files but with somewhat lower quality compared to PCM audio. The amount of compression is configurable via the Quality slider. This format is best for <strong>medium length</strong> sound effects and music.</p><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><h4 id="占据大量内存的长音频"><a href="#占据大量内存的长音频" class="headerlink" title="占据大量内存的长音频"></a>占据大量内存的长音频</h4><ul><li><p>使用流（Streaming）载入方式（Load Type），并且设置压缩格式（Compression Format）为Vorbis。如此设置即可使内存使用量减至最低，但相对的会占用更多CPU资源和I/O吞吐量。</p></li><li><p>使用压缩并存储至内存（Compressed In Memory）载入方式，设置压缩格式为Vorbis。与第一个方案唯一的区别是，前者占据更多I/O吞吐，而此种方式占用更多内存。可以调整Quality滑块来通过降低音频质量来减小音频剪辑压缩后的尺寸。一般来说，100%的Quality值略高，我们推荐70%。注意，使用该种设置添加两个以上的音乐或环境声剪辑时会大量消耗CPU。</p></li></ul><h4 id="短或中等长度的音频"><a href="#短或中等长度的音频" class="headerlink" title="短或中等长度的音频"></a>短或中等长度的音频</h4><ul><li><p>对于经常播放的短音频剪辑，使用载入时压缩（Decompress On Load）载入方式（Load Type），PCM或ADPCM压缩格式（Compression Format）。选择PCM时，播放无需解压，适用于短且使用频率高的音频剪辑。您也可以用ADPCM压缩格式，播放该格式需要解压缩，但解压缩ADPCM比Vorbis快很多。</p></li><li><p>对于经常播放的中等长度剪辑，使用压缩并存储至内存（Compressed In Memory）和ADPCM压缩格式（Compression Format）。原始PCM的大小大概是ADPCM的3.5倍，ADPCM的解压缩算法也比Vorbis解压缩算法占用更少CPU。</p></li><li><p>对于播放频率低的短音频剪辑，使用压缩并存储至内存（Compressed In Memory）和ADPCM压缩格式（Compression Format）</p></li><li><p>对于播放频率低的中等长度剪辑，使用压缩并存储至内存（Compressed In Memory）和Vorbis压缩格式（Compression Format）。使用ADPCM处理该种声音效果（SFX）未免显得浪费了存储空间，况且播放的频率又很低，所以使用更多CPU资源解压缩还是可以接受的。</p></li></ul><h3 id="Sample-Rate-Setting"><a href="#Sample-Rate-Setting" class="headerlink" title="Sample Rate Setting"></a>Sample Rate Setting</h3><p>Preserve Sample Rate: 保留采样率<br>Optimize Sample Rate：此设置根据分析的最高频率内容自动优化采样率。<br>Override Sample Rate：此设置允许手动覆盖采样率，因此可以有效地避免采样内容丢失。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://docs.unity3d.com/Manual/AudioOverview.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/AudioOverview.html</a><br><a href="https://www.xuanyusong.com/archives/550" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/550</a><br><a href="https://support.unity3d.com/hc/zh-cn/articles/208211393-%E6%B8%B8%E6%88%8F%E5%9C%A8%E6%92%AD%E6%94%BE%E5%A3%B0%E9%9F%B3%E5%8F%91%E7%94%9F%E5%8D%A1%E9%A1%BF" target="_blank" rel="noopener">https://support.unity3d.com/hc/zh-cn/articles/208211393-%E6%B8%B8%E6%88%8F%E5%9C%A8%E6%92%AD%E6%94%BE%E5%A3%B0%E9%9F%B3%E5%8F%91%E7%94%9F%E5%8D%A1%E9%A1%BF</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A计划</title>
      <link href="2023/07/25/Unity3D-A%E8%AE%A1%E5%88%92/"/>
      <url>2023/07/25/Unity3D-A%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="学前准备"><a href="#学前准备" class="headerlink" title="学前准备"></a>学前准备</h1><p>学习方法：<br>我已经算是能够熟练使用Unity了，基本算是一个资深的Unity开发者了，已经完全能够应付工作了，学习A计划只是为了把我的基础知识体系补充的更加全面，查缺补漏，在入门级别的小问题上就不值得浪费时间了，快速刷完就OK。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>先自己解决三小时以上，解决不了再提问<br>解决错误的时候，先解决第一个</p><blockquote><p>2019破解<br> <a href="https://www.isharepc.com/19012.html" target="_blank" rel="noopener">https://www.isharepc.com/19012.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assets, Resources and AssetBundles - Unity Le</title>
      <link href="2023/07/25/Unity3D-Assets-Resources-and-AssetBundles-Unity-Le/"/>
      <url>2023/07/25/Unity3D-Assets-Resources-and-AssetBundles-Unity-Le/</url>
      
        <content type="html"><![CDATA[<p>arn</p><h2 id="1-A-guide-to-AssetBundles-and-Resources"><a href="#1-A-guide-to-AssetBundles-and-Resources" class="headerlink" title="1.A guide to AssetBundles and Resources"></a>1.A guide to AssetBundles and Resources</h2><p>This is a series of articles that provides an in-depth discussion of Assets and resource management in the Unity engine. It seeks to provide expert developers with deep, source-level knowledge of Unity’s Asset and serialization systems. It examines both the technical underpinnings of Unity’s AssetBundle system and the current best practices for employing them.</p><p>The guide is broken down into four chapters:</p><ol><li>1. </li></ol><p>Assets, Objects and serialization discusses the low-level details of how Unity serializes Assets and handles references between Assets. It is strongly recommended that readers begin with this chapter as it defines terminology used throughout the guide.</p><ol><li>2. </li></ol><p>The Resources folder discusses the built-in Resources API.</p><ol><li>3. </li></ol><p>AssetBundle fundamentals builds on the information in chapter 1 to describe how AssetBundles operate, and discusses both the loading of AssetBundles and the loading of Assets from AssetBundles.</p><ol><li>4. </li></ol><p>AssetBundle usage patterns is a long article discussing many of the topics surrounding the practical uses of AssetBundles. It includes sections on assigning Assets to AssetBundles and on managing loaded Assets, and describes many common pitfalls encountered by developers using AssetBundles.</p><p>Note: This guide’s terms for Objects and Assets differ from Unity’s public API naming conventions.</p><p>The data this guide calls Objects are called Assets in many public Unity APIs, such as<a href="http://docs.unity3d.com/ScriptReference/AssetBundle.LoadAsset.html" target="_blank" rel="noopener"> AssetBundle.LoadAsset</a> and<a href="http://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html" target="_blank" rel="noopener"> Resources.UnloadUnusedAssets</a>. The files this guide calls Assets are rarely exposed to any public APIs. When they are exposed, it is generally only in build-related code, such as<a href="http://docs.unity3d.com/ScriptReference/AssetDatabase.html" target="_blank" rel="noopener"> AssetDatabase</a> and<a href="http://docs.unity3d.com/ScriptReference/BuildPipeline.html" target="_blank" rel="noopener"> BuildPipeline</a>. In these cases, they are called files in public APIs.</p><p></p><h2 id="2-Assets-Objects-and-serialization"><a href="#2-Assets-Objects-and-serialization" class="headerlink" title="2.Assets, Objects and serialization"></a>2.Assets, Objects and serialization</h2><p>This chapter covers the deep internals of Unity’s serialization system and how Unity maintains robust references between different Objects, both in the Unity Editor and at runtime. It also discusses the technical distinctions between Objects and Assets. The topics covered here are fundamental to understanding how to efficiently load and unload Assets in Unity. Proper Asset management is crucial to keeping loading times short and memory usage low.</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>2.1. Inside Assets and Objects</p><p>To understand how to properly manage data in Unity, it is important to understand how Unity identifies and serializes data. The first key point is the distinction between Assets and UnityEngine.Objects.</p><p>An Asset is a file on disk, stored in the Assets folder of a Unity project. Textures, 3D models, or audio clips are common types of Assets. Some Assets contain data in formats native to Unity, such as materials. Other Assets need to be processed into native formats, such as FBX files.</p><p>A UnityEngine.Object, or Object with a capitalized ‘O’, is a set of serialized data collectively describing a specific instance of a resource. This can be any type of resource which the Unity Engine uses, such as a mesh, sprite, AudioClip or AnimationClip. All Objects are subclasses of the<a href="http://docs.unity3d.com/ScriptReference/Object.html" target="_blank" rel="noopener"> UnityEngine.Object</a> base class.</p><p>While most Object types are built-in, there are two special types.</p><ol><li>1. </li></ol><p>A<a href="http://docs.unity3d.com/ScriptReference/ScriptableObject.html" target="_blank" rel="noopener"> ScriptableObject</a> provides a convenient system for developers to define their own data types. These types can be natively serialized and deserialized by Unity, and manipulated in the Unity Editor’s Inspector window.</p><ol><li>2. </li></ol><p>A<a href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank" rel="noopener"> MonoBehaviour</a> provides a wrapper that links to a<a href="http://docs.unity3d.com/ScriptReference/MonoScript.html" target="_blank" rel="noopener"> MonoScript</a>. A MonoScript is an internal data type that Unity uses to hold a reference to a specific scripting class within a specific assembly and namespace. The MonoScript does not contain any actual executable code.</p><p>There is a one-to-many relationship between Assets and Objects; that is, any given Asset file contains one or more Objects.</p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><p>2.2. Inter-Object references</p><p>All UnityEngine.Objects can have references to other UnityEngine.Objects. These other Objects may reside within the same Asset file, or may be imported from other Asset files. For example, a material Object usually has one or more references to texture Objects. These texture Objects are generally imported from one or more texture Asset files (such as PNGs or JPGs).</p><p>When serialized, these references consist of two separate pieces of data: a File GUID and a Local ID. The File GUID identifies the Asset file where the target resource is stored. A locally unique Local ID identifies each Object within an Asset file because an Asset file may contain multiple Objects. (Note: AA Local ID is unique from all the other Local IDs for the same Asset file.)</p><p>File GUIDs are stored in .meta files. These .meta files are generated when Unity first imports an Asset, and are stored in the same directory as the Asset.</p><p>The above identification and referencing system can be seen in a text editor: create a fresh Unity project and change its Editor Settings to expose Visible Meta Files and to serialize Assets as text. Create a material and import a texture into the project. Assign the material to a cube in the scene and save the scene.</p><p>Using a text editor, open the .meta file associated with the material. A line labeled “guid” will appear near the top of the file. This line defines the material Asset’s File GUID. To find the Local ID, open the material file in a text editor. The material Object’s definition will look like this:</p><pre><code>--- !u!21 &amp;2100000Material: serializedVersion: 3 ... more data …</code></pre><p>In the above example, the number preceded by an ampersand is the material’s Local ID. If this material Object were located inside an Asset identified by the File GUID “abcdefg”, then the material Object could be uniquely identified as the combination of the File GUID “abcdefg” and the Local ID “2100000”.</p><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><p>2.3. Why File GUIDs and Local IDs?</p><p>Why is Unity’s File GUID and Local ID system necessary? The answer is robustness and to provide a flexible, platform-independent workflow.</p><p>The File GUID provides an abstraction of a file’s specific location. As long as a specific File GUID can be associated with a specific file, that file’s location on disk becomes irrelevant. The file can be freely moved without having to update all Objects referring to the file.</p><p>As any given Asset file may contain (or produce via import) multiple UnityEngine.Object resources, a Local ID is required to unambiguously distinguish each distinct Object.</p><p>If the File GUID associated with an Asset file is lost, then references to all Objects in that Asset file will also be lost. This is why it is important that the .meta files must remain stored with the same file names and in the same folders as their associated Asset files. Note that Unity will regenerate deleted or misplaced .meta files.</p><p>The Unity Editor has a map of specific file paths to known File GUIDs. A map entry is recorded whenever an Asset is loaded or imported. The map entry links the Asset’s specific path to the Asset’s File GUID. If the Unity Editor is open when a .meta file goes missing and the Asset’s path does not change, the Editor can ensure that the Asset retains the same File GUID.</p><p>If the .meta file is lost while the Unity Editor is closed, or the Asset’s path changes without the .meta file moving along with the Asset, then all references to Objects within that Asset will be broken.</p><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><p>2.4. Composite Assets and importers</p><p>As mentioned in the Inside Assets and Objects section, non-native Asset types must be imported into Unity. This is done via an asset importer. While these importers are usually invoked automatically, they are also exposed to scripts via the <a href="http://docs.unity3d.com/ScriptReference/AssetImporter.html" target="_blank" rel="noopener">AssetImporter</a> API. For example, the <a href="http://docs.unity3d.com/ScriptReference/TextureImporter.html" target="_blank" rel="noopener">TextureImporter</a> API provides access to the settings used when importing individual texture Assets, such as PNG files.</p><p>The result of the import process is one or more UnityEngine.Objects. These are visible in the Unity Editor as multiple sub-assets within the parent Asset, such as multiple sprites nested beneath a texture Asset that has been imported as a sprite atlas. Each of these Objects will share a File GUID as their source data is stored within the same Asset file. They will be distinguished within the imported texture Asset by a Local ID.</p><p>The import process converts source Assets into formats suitable for the target platform selected in the Unity Editor. The import process can include a number of heavyweight operations, such as texture compression. As this is often a time-consuming process, imported Asset are cached in the Library folder, eliminating the need to re-import Assets again on the next Editor launch.</p><p>Specifically, the results of the import process are stored in a folder named for the first two digits of the Asset’s File GUID. This folder is stored inside the Library/metadata/ folder. The individual Objects from the Asset are serialized into a single binary file that has a name identical to the Asset’s File GUID.</p><p>This process applies to all Assets, not just non-native Assets. Native assets do not require lengthy conversion processes or re-serialization.</p><h2 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h2><p>2.5. Serialization and instances</p><p>While File GUIDs and Local IDs are robust, GUID comparisons are slow and a more performant system is needed at runtime. Unity internally maintains a cache that translates File GUIDs and Local IDs into simple, session-unique integers (note: Internally, this cache is called the PersistentManager.) These integers are called Instance IDs, and are assigned in a simple, monotonically-increasing order when new Objects are registered with the cache.</p><p>The cache maintains mappings between a given Instance ID, File GUID and Local ID defining the location of the Object’s source data, and the instance of the Object in memory (if any). This allows UnityEngine.Objects to robustly maintain references to each other. Resolving an Instance ID reference can quickly return the loaded Object represented by the Instance ID. If the target Object is not yet loaded, the File GUID and Local ID can be resolved to the Object’s source data, allowing Unity to load the object just-in-time.</p><p>At startup, the Instance ID cache is initialized with data for all Objects immediately required by the project (i.e., referenced in built Scenes), as well as all Objects contained in the Resources folder. Additional entries are added to the cache when new assets are imported at runtime and when Objects are loaded from AssetBundles (note: An example of an Asset created at runtime would be a Texture2D Object created in script, like so: var myTexture = new Texture2D(1024, 768);). Instance ID entries are only removed from the cache when an AssetBundle providing access to a specific File GUID and Local ID is unloaded. When this occurs, the mapping between the Instance ID, its File GUID and Local ID are deleted to conserve memory. If the AssetBundle is re-loaded, a new Instance ID will be created for each Object loaded from the re-loaded AssetBundle.</p><p>For a deeper discussion of the implications of unloading AssetBundles, see the Managing Loaded Assets section in the AssetBundle Usage Patterns step.</p><p>On specific platforms, certain events can force Objects out of memory. For example, graphical Assets can be unloaded from graphics memory on iOS when an app is suspended. If these Objects originated in an AssetBundle that has been unloaded, Unity will be unable to reload the source data for the Objects. Any extant references to these Objects will also be invalid. In the preceding example, the scene may appear to have invisible meshes or magenta textures.</p><p>Implementation note: At runtime, the above control flow is not literally accurate. Comparing File GUIDs and Local IDs at runtime would not be sufficiently performant during heavy loading operations. When building a Unity project, the File GUIDs and Local IDs are deterministically mapped into a simpler format. However, the concept remains identical, and thinking in terms of File GUIDs and Local IDs remains a useful analogy during runtime. This is also the reason why Asset File GUIDs cannot be queried at runtime.</p><h2 id="-5"><a href="#-5" class="headerlink" title=" "></a> </h2><p>2.6. MonoScripts</p><p>It is important to understand that a MonoBehaviour has a reference to a MonoScript, and MonoScripts simply contain the information needed to locate a specific script class. Neither type of Object contains the executable code of script class.</p><p>A MonoScript contains three strings: assembly name, class name, and namespace.</p><p>While building a project, Unity compiles all the loose script files in the Assets folder into Mono assemblies. C# scripts outside of the Plugins subfolder are placed into Assembly-CSharp.dll. Scripts within the Plugins subfolder are placed into Assembly-CSharp-firstpass.dll, and so on. In addition, Unity 2017.3 also introduces the ability to <a href="https://docs.unity3d.com/Manual/ScriptCompilationAssemblyDefinitionFiles.html" target="_blank" rel="noopener">define custom managed assemblies</a>.</p><p>These assemblies, as well as pre-built assembly DLL files, are included in the final build of a Unity application. They are also the assemblies to which a MonoScript refers. Unlike other resources, all assemblies included in a Unity application are loaded on application start-up.</p><p>This MonoScript Object is the reason why an AssetBundle (or a Scene or a prefab) does not actually contain executable code in any of the MonoBehaviour Components in the AssetBundle, Scene or prefab. This allows different MonoBehaviours to refer to specific shared classes, even if the MonoBehaviours are in different AssetBundles.</p><h2 id="-6"><a href="#-6" class="headerlink" title=" "></a> </h2><p>2.7. Resource lifecycle</p><p>To reduce loading times and manage an application’s memory footprint, it’s important to understand the resource lifecycle of UnityEngine.Objects. Objects are loaded into/unloaded from memory at specific and defined times.</p><p>An Object is loaded automatically when:</p><ol><li>1. </li></ol><p>The Instance ID mapped to that Object is dereferenced</p><ol><li>2. </li></ol><p>The Object is currently not loaded into memory</p><ol><li>3. </li></ol><p>The Object’s source data can be located.</p><p>Objects can also be explicitly loaded in scripts, either by creating them or by calling a resource-loading API (e.g., <a href="http://docs.unity3d.com/ScriptReference/AssetBundle.LoadAsset.html" target="_blank" rel="noopener">AssetBundle.LoadAsset</a>). When an Object is loaded, Unity tries to resolve any references by translating each reference’s File GUID and Local ID into an Instance ID. An Object will be loaded on-demand the first time its Instance ID is dereferenced if two criteria are true:</p><ol><li>1. </li></ol><p>The Instance ID references an Object that is not currently loaded</p><ol><li>2. </li></ol><p>The Instance ID has a valid File GUID and Local ID registered in the cache</p><p>This generally occurs very shortly after the reference itself is loaded and resolved.</p><p>If a File GUID and Local ID do not have an Instance ID, or if an Instance ID with an unloaded Object references an invalid File GUID and Local ID, then the reference is preserved but the actual Object will not be loaded. This appears as a “(Missing)” reference in the Unity Editor. In a running application, or in the Scene View, “(Missing)” Objects will be visible in different ways, depending on their types. For example, meshes will appear to be invisible, while textures may appear to be magenta.</p><p>Objects are unloaded in three specific scenarios:</p><ul><li><p>Objects are automatically unloaded when unused Asset cleanup occurs. This process is triggered automatically when scenes are changed destructively (i.e. when <a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html" target="_blank" rel="noopener">SceneManager.LoadScene</a> is invoked non-additively), or when a script invokes the<a href="http://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html" target="_blank" rel="noopener"> Resources.UnloadUnusedAssets</a> API. This process only unloads unreferenced Objects; an Object will only be unloaded if no Mono variable holds a reference to the Object, and there are no other live Objects holding references to the Object. Furthermore, note that anything marked with <a href="https://docs.unity3d.com/ScriptReference/HideFlags.DontUnloadUnusedAsset.html" target="_blank" rel="noopener">HideFlags.DontUnloadUnusedAsset</a> and <a href="https://docs.unity3d.com/ScriptReference/HideFlags.HideAndDontSave.html" target="_blank" rel="noopener">HideFlags.HideAndDontSave</a> will not be unloaded.</p></li><li><p>Objects sourced from the Resources folder can be explicitly unloaded by invoking the<a href="http://docs.unity3d.com/ScriptReference/Resources.UnloadAsset.html" target="_blank" rel="noopener"> Resources.UnloadAsset</a> API. The Instance ID for these Objects remains valid and will still contain a valid File GUID and LocalID entry. If any Mono variable or other Object holds a reference to an Object that is unloaded with<a href="http://docs.unity3d.com/ScriptReference/Resources.UnloadAsset.html" target="_blank" rel="noopener"> Resources.UnloadAsset</a>, then that Object will be reloaded as soon as any of the live references are dereferenced.</p></li><li><p>Objects sourced from AssetBundles are automatically and immediately unloaded when invoking the<a href="http://docs.unity3d.com/ScriptReference/AssetBundle.Unload.html" target="_blank" rel="noopener"> AssetBundle.Unload</a>(true) API. This invalidates the File GUID and Local ID of the Object’s Instance ID, and any live references to the unloaded Objects will become “(Missing)” references. From C# scripts, attempting to access methods or properties on an unloaded object will produce a NullReferenceException.</p></li></ul><p>If <a href="http://docs.unity3d.com/ScriptReference/AssetBundle.Unload.html" target="_blank" rel="noopener">AssetBundle.Unload</a>(false) is called, live Objects sourced from the unloaded AssetBundle will not be destroyed, but Unity will invalidate the File GUID and Local ID references of their Instance IDs. It will be impossible for Unity to reload these Objects if they are later unloaded from memory and live references to the unloaded Objects remain. </p><p>(Note: The most common case where Objects are removed from memory at runtime without being unloaded occurs when Unity loses control of its graphics context. This may occur when a mobile app is suspended and the app is forced into the background. In this case, the mobile OS usually evicts all graphical resources from GPU memory. When the app returns to the foreground, Unity must reload all needed Textures, Shaders and Meshes to the GPU before scene rendering can resume.)</p><h2 id="-7"><a href="#-7" class="headerlink" title=" "></a> </h2><p>2.8. Loading large hierarchies</p><p>When serializing hierarchies of Unity GameObjects, such as during prefabs serialization, it is important to remember that the entire hierarchy will be fully serialized. That is, every GameObject and Component in the hierarchy will be individually represented in the serialized data. This has interesting impacts on the time required to load and instantiate hierarchies of GameObjects.</p><p>When creating any GameObject hierarchy, CPU time is spent in several different ways:</p><ul><li><p>Reading the source data (from storage, from an AssetBundle, from another GameObject, etc.)</p></li><li><p>Setting up the parent-child relationships between the new Transforms</p></li><li><p>Instantiating the new GameObjects and Components</p></li><li><p>Awakening the new GameObjects and Components on the main thread</p></li></ul><p>The latter three time costs are generally invariant regardless of whether the hierarchy is being cloned from an existing hierarchy or is being loaded from storage. However, the time to read the source data increases linearly with the number of Components and GameObjects serialized into the hierarchy, and is also multiplied by the speed of the data source.</p><p>On all current platforms, it is considerably faster to read data from elsewhere in memory rather than loading it from a storage device. Further, the performance characteristics of the available storage media vary widely between different platforms. Therefore, when loading prefabs on platforms with slow storage, the time spent reading the prefab’s serialized data from storage can rapidly exceed the time spent instantiating the prefab. That is, the cost of the loading operation is bound to storage I/O time.</p><p>As mentioned before, when serializing a monolithic prefab, every GameObject and component’s data is serialized separately, which may duplicate data. For example, a UI screen with 30 identical elements will have the identical element serialized 30 times, producing a large blob of binary data. At load time, the data for all of the GameObjects and Components on each one of those 30 duplicate elements must be read from disk before being transferred to the newly-instantiated Object. This file reading time is a significant contributor to the overall cost of instantiating large prefabs. Large hierarchies should be instantiated in modular chunks, and then be stitched together at runtime.</p><p>Unity 5.4 note: Unity 5.4 altered the representation of transforms in memory. Each root transform’s entire child hierarchy is stored in compact, contiguous regions of memory. When instantiating new GameObjects that will be instantly reparented into another hierarchy, consider using the new <a href="https://docs.unity3d.com/ScriptReference/Object.Instantiate.html" target="_blank" rel="noopener">GameObject.Instantiate</a> overloaded variants which accept a parent argument. Using this overload avoids the allocation of a root transform hierarchy for the new GameObject. In tests, this speeds up the time required for an instantiate operation by about 5-10%.</p><p></p><h2 id="3-The-Resources-folder"><a href="#3-The-Resources-folder" class="headerlink" title="3.The Resources folder"></a>3.The Resources folder</h2><p>This chapter discusses the Resources system. This is the system that allows developers to store Assets within one or more folders named Resources and to load or unload Objects from those Assets at runtime using the<a href="http://docs.unity3d.com/ScriptReference/Resources.html" target="_blank" rel="noopener"> Resources</a> API.</p><h2 id="-8"><a href="#-8" class="headerlink" title=" "></a> </h2><p>3.1. Best Practices for the Resources System</p><p>Don’t use it.</p><p>This strong recommendation is made for several reasons:</p><ul><li><p>Use of the Resources folder makes fine-grained memory management more difficult</p></li><li><p>Improper use of Resources folders will increase application startup time and the length of builds</p></li><li><p>As the number of Resources folders increases, management of the Assets within those folders becomes very difficult</p></li><li><p>The Resources system degrades a project’s ability to deliver custom content to specific platforms and eliminates the possibility of incremental content upgrades</p></li><li><p>AssetBundle Variants are Unity’s primary tool for adjusting content on a per-device basis</p></li></ul><h3 id="-9"><a href="#-9" class="headerlink" title=" "></a> </h3><p>3.2. Proper uses of the Resources system</p><p>There are two specific use cases where the Resources system can be helpful without impeding good development practices:</p><ol><li>1. </li></ol><p>The ease of the Resources folder makes it an excellent system to rapidly prototype. However, when a project moves into full production, the use of the Resources folder should be eliminated.</p><ol><li>2. </li></ol><p>The Resources folder may be useful in some trivial cases, if the content is:</p><ol><li>3. </li></ol><p>Generally required throughout a project’s lifetime</p><ol><li>4. </li></ol><p>Not memory-intensive</p><ol><li>5. </li></ol><p>Not prone to patching, or does not vary across platforms or devices</p><ol><li>6. </li></ol><p>Used for minimal bootstrapping</p><p>Examples of this second case include MonoBehaviour singletons used to host prefabs, or ScriptableObjects containing third-party configuration data, such as a Facebook App ID.</p><h3 id="-10"><a href="#-10" class="headerlink" title=" "></a> </h3><p>3.3. Serialization of Resources</p><p>The Assets and Objects in all folders named “Resources” are combined into a single serialized file when a project is built. This file also contains metadata and indexing information, similar to an AssetBundle. As described in the <a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html" target="_blank" rel="noopener">AssetBundle documentation</a>, this index includes a serialized lookup tree that is used to resolve a given Object’s name into its appropriate File GUID and Local ID. It is also used to locate the Object at a specific byte offset in the serialized file’s body.</p><p>On most platforms, the lookup data structure is a balanced search tree, which has a construction time that grows at an O(n log(n)) rate. This growth also causes the index’s loading time to grow more-than-linearly as the number of Objects in Resources folders increases.</p><p>This operation is unskippable and occurs at application startup time while the initial non-interactive splash screen is displayed. Initializing a Resources system containing 10,000 assets has been observed to consume multiple seconds on low-end mobile devices, even though most of the Objects contained in Resources folders are rarely actually needed to load into an application’s first scene.</p><p></p><h2 id="4-AssetBundle-fundamentals"><a href="#4-AssetBundle-fundamentals" class="headerlink" title="4.AssetBundle fundamentals"></a>4.AssetBundle fundamentals</h2><p>This chapter discusses AssetBundles. It introduces the fundamental systems upon which AssetBundles are built, as well as the core APIs used to interact with AssetBundles. In particular, it discusses both the loading and unloading of AssetBundles themselves, as well as the loading and unloading of specific Asset and Objects from AssetBundles.</p><p>For more patterns and best practices on the uses of AssetBundles, see the next chapter in this series.</p><h2 id="-11"><a href="#-11" class="headerlink" title=" "></a> </h2><p>4.1. Overview</p><p>The AssetBundle system provides a method for storing one or more files in an archival format that Unity can index and serialize. AssetBundles are Unity’s primary tool for the delivery and updating of non-code content after installation. This permits developers to submit a smaller app package, minimize runtime memory pressure, and selectively load content optimized for the end-user’s device.</p><p>Understanding the way AssetBundles work is essential to building a successful Unity project for mobile devices. For an overall description of AssetBundle contents, review the <a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html" target="_blank" rel="noopener">AssetBundle documentation</a>.</p><h2 id="-12"><a href="#-12" class="headerlink" title=" "></a> </h2><p>4.2. AssetBundle layout</p><p>To summarize, an AssetBundle consists of two parts: a header and data segment.</p><p>The header contains information about the AssetBundle, such as its identifier, compression type, and a manifest. The manifest is a lookup table keyed by an Object’s name. Each entry provides a byte index that indicates where a given Object can be found within the AssetBundle’s data segment. On most platforms, this lookup table is implemented as a balanced search tree. Specifically, Windows and OSX-derived platforms (including iOS) employ a red-black tree. Therefore, the time needed to construct the manifest will increase more than linearly as the number of Assets within an AssetBundle grows.</p><p>The data segment contains the raw data generated by serializing the Assets in the AssetBundle. If LZMA is specified as the compression scheme, the complete byte array for all serialized assets is compressed. If LZ4 is instead specified, bytes for separate Assets are individually compressed. If no compression is used, the data segment will remain as raw byte streams.</p><p>Prior to Unity 5.3, Objects could not be compressed individually inside an AssetBundle. As a consequence, if a version of Unity before 5.3 is instructed to read one or more Objects from a compressed AssetBundle, Unity had to decompress the entire AssetBundle. Generally, Unity cached a decompressed copy of the AssetBundle to improve loading performance for subsequent loading requests on the same AssetBundle.</p><h2 id="-13"><a href="#-13" class="headerlink" title=" "></a> </h2><p>4.3. Loading AssetBundles</p><p>AssetBundles can be loaded via four distinct APIs. The behavior of these four APIs is different depending on two criteria:</p><ol><li>1. </li></ol><p>Whether the AssetBundle is LZMA compressed, LZ4 compressed or uncompressed</p><ol><li>2. </li></ol><p>The platform on which the AssetBundle is being loaded</p><p>These APIs are:</p><ul><li><p>AssetBundle.LoadFromMemory(Async optional)</p></li><li><p>AssetBundle.LoadFromFile(Async optional)</p></li><li><p>UnityWebRequest’s DownloadHandlerAssetBundle</p></li><li><p>WWW.LoadFromCacheOrDownload (on Unity 5.6 or older)</p></li></ul><h3 id="-14"><a href="#-14" class="headerlink" title=" "></a> </h3><p>4.3.1 AssetBundle.LoadFromMemory(Async)</p><p>Unity’s recommendation is not to use this API.</p><p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromMemoryAsync.html" target="_blank" rel="noopener">AssetBundle.LoadFromMemoryAsync</a> loads an AssetBundle from a managed-code byte array (byte[] in C#). It will always copy the source data from the managed-code byte array into a newly-allocated, contiguous block of native memory. If the AssetBundle is LZMA compressed, it will decompress the AssetBundle while copying. Uncompressed and LZ4-compressed AssetBundles will be copied verbatim.</p><p>The peak amount of memory consumed by this API will be at least twice the size of the AssetBundle: one copy in native memory created by the API, and one copy in the managed byte array passed to the API. Assets loaded from an AssetBundle created via this API will therefore be duplicated three times in memory: once in the managed-code byte array, once in the native-memory copy of the AssetBundle and a third time in GPU or system memory for the asset itself.</p><p>Prior to Unity 5.3.3, this API was known as <strong>AssetBundle.CreateFromMemory</strong>. Its functionality has not changed.</p><h3 id="-15"><a href="#-15" class="headerlink" title=" "></a> </h3><p>4.3.2. AssetBundle.LoadFromFile(Async)</p><p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html" target="_blank" rel="noopener">AssetBundle.LoadFromFile</a> is a highly-efficient API intended for loading uncompressed or LZ4-compressed AssetBundle from local storage, such as a hard disk or an SD card.</p><p>On desktop standalone, console, and mobile platforms, the API will only load the AssetBundle’s header, and will leave the remaining data on disk. The AssetBundle’s Objects will be loaded on-demand as loading methods (e.g. AssetBundle.Load) are called or as their InstanceIDs are dereferenced. No excess memory will be consumed in this scenario. In the Unity Editor, the API will load the entire AssetBundle into memory, as if the bytes were read off disk and AssetBundle.LoadFromMemoryAsync was used. This API can cause memory spikes to appear during AssetBundle loading if the project is profiled in the Unity Editor. This should not affect performance on-device and these spikes should be re-tested on-device before taking remedial action.</p><p>Note: On Android devices with Unity 5.3 or older, this API will fail when trying to load AssetBundles from the Streaming Assets path. This issue has been resolved in Unity 5.4. For more details, see the section Distribution - shipped with project section of the AssetBundle usage patterns step.</p><p>Prior to Unity 5.3, this API was known as <strong>AssetBundle.CreateFromFile</strong>. Its functionality has not been changed.</p><h3 id="-16"><a href="#-16" class="headerlink" title=" "></a> </h3><p>4.3.3. AssetBundleDownloadHandler</p><p>The <a href="http://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.html" target="_blank" rel="noopener">UnityWebRequest</a> API allows developers to specify exactly how Unity should handle downloaded data and allows developers to eliminate unnecessary memory usage. The simplest way to download an AssetBundle using UnityWebRequest is call <a href="http://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.GetAssetBundle.html" target="_blank" rel="noopener">UnityWebRequest.GetAssetBundle</a>.</p><p>For the purposes of this guide, the class of interest is <a href="http://docs.unity3d.com/ScriptReference/Networking.DownloadHandlerAssetBundle.html" target="_blank" rel="noopener">DownloadHandlerAssetBundle</a>. Using a worker thread, it streams downloaded data into a fixed-size buffer and then spools the buffered data to either temporary storage or the AssetBundle cache, depending on how the Download Handler has been configured. All of these operations occur in native code, eliminating the risk of expanding the managed heap. Additionally, this Download Handler does not keep a native-code copy of all downloaded bytes, further reducing the memory overhead of downloading an AssetBundle.</p><p>LZMA-compressed AssetBundles will be decompressed during download and cached using LZ4 compression. This behavior may be changed by setting <a href="https://docs.unity3d.com/ScriptReference/Caching-compressionEnabled.html" target="_blank" rel="noopener">Caching.CompressionEnabled</a>.</p><p>When the download is complete, the <a href="http://docs.unity3d.com/ScriptReference/Networking.DownloadHandlerAssetBundle-assetBundle.html" target="_blank" rel="noopener">assetBundle</a> property of the Download Handler provides access to the downloaded AssetBundle, as if AssetBundle.LoadFromFile had been called on the downloaded AssetBundle.</p><p>If caching information is provided to a UnityWebRequest object, and the requested AssetBundle already exists in Unity’s cache, then the AssetBundle will become available immediately and this API will operate identically to AssetBundle.LoadFromFile.</p><p>Prior to Unity 5.6, the UnityWebRequest system used a fixed pool of worker threads and an internal job system to safeguard against excessive, concurrent downloads. The size of the thread pool was not configurable. In Unity 5.6, these safeguards have been removed to accommodate more modern hardware, and allow for faster access to HTTP response codes and headers.</p><h3 id="-17"><a href="#-17" class="headerlink" title=" "></a> </h3><p>4.3.4. WWW.LoadFromCacheOrDownload</p><p>Note: Beginning in Unity 2017.1, <a href="http://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html" target="_blank" rel="noopener">WWW.LoadFromCacheOrDownload</a> simply wraps around UnityWebRequest. Accordingly, developers using Unity 2017.1 or higher should migrate to UnityWebRequest. WWW.LoadFromCacheOrDownload will be deprecated in a future release.</p><p>The following information is applicable to Unity 5.6 or older.</p><p><a href="http://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html" target="_blank" rel="noopener">WWW.LoadFromCacheOrDownload</a> is an API that allows loading of Objects from both remote servers and local storage. Files can be loaded from local storage via a file:// URL. If the AssetBundle is present in the Unity cache, this API will behave exactly like AssetBundle.LoadFromFile.</p><p>If an AssetBundle has not yet been cached, then WWW.LoadFromCacheOrDownload will read the AssetBundle from its source. If the AssetBundle is compressed, it will be decompressed using a worker thread and written into the cache. Otherwise, it will be written directly into the cache via the worker thread. Once the AssetBundle is cached, WWW.LoadFromCacheOrDownload will load header information from the cached, decompressed AssetBundle. The API will then behave identically to an AssetBundle loaded with AssetBundle.LoadFromFile. This cache is shared between WWW.LoadFromCacheOrDownload and UnityWebRequest. Any AssetBundle downloaded with one API will also be available via the other API.</p><p>While the data will be decompressed and written to the cache via a fixed-size buffer, the WWW object will keep a full copy of the AssetBundle’s bytes in native memory. This extra copy of the AssetBundle is kept to support the <a href="http://docs.unity3d.com/ScriptReference/WWW-bytes.html" target="_blank" rel="noopener">WWW.bytes</a> property.</p><p>Due to the memory overhead of caching an AssetBundle’s bytes in the WWW object, AssetBundles should remain small - a few megabytes, at most. For more discussion of AssetBundle sizing, see the<a href="https://unity3d.com/learn/tutorials/topics/best-practices/asset-bundle-usage-patterns#Asset_Assignment_Strategies" target="_blank" rel="noopener"> </a>Asset assignment strategies section in the<a href="https://unity3d.com/learn/tutorials/topics/best-practices/asset-bundle-usage-patterns" target="_blank" rel="noopener"> </a>AssetBundle usage patterns chapter.</p><p>Unlike UnityWebRequest, each call to this API will spawn a new worker thread. Accordingly, on platforms with limited memory, such as mobile devices, only a single AssetBundle at a time should be downloaded using this API, in order to avoid memory spikes. Be careful of creating an excessive number of threads when calling this API multiple times. If more than 5 AssetBundles need to be downloaded, create and manage a download queue in script code to ensure that only a few AssetBundle downloads are running occurring simultaneously.</p><h3 id="-18"><a href="#-18" class="headerlink" title=" "></a> </h3><p>4.3.5. Recommendations</p><p>In general, AssetBundle.LoadFromFile should be used whenever possible. This API is the most efficient in terms of speed, disk usage and runtime memory usage.</p><p>For projects that must download or patch AssetBundles, it is strongly recommended to use<a href="https://unity3d.com/learn/tutorials/topics/best-practices/assetbundle-fundamentals?playlist=30089#AssetBundleDownloadHandler" target="_blank" rel="noopener"> </a>UnityWebRequest for projects using Unity 5.3 or newer, and WWW.LoadFromCacheOrDownload for projects using Unity 5.2 or older. As detailed in the<a href="https://unity3d.com/learn/tutorials/topics/best-practices/asset-bundle-usage-patterns#Distribution" target="_blank" rel="noopener"> </a>Distribution section, it is possible to prime the AssetBundle Cache with Bundles included within a project’s installer.</p><p>When using either UnityWebRequest or WWW.LoadFromCacheOrDownload, ensure that the downloader code properly calls Dispose after loading the AssetBundle. Alternately, C#’s<a href="https://msdn.microsoft.com/en-us//library/yh598w02.aspx" target="_blank" rel="noopener"> using</a> statement is the most convenient way to ensure that a WWW or UnityWebRequest is safely disposed.</p><p>For projects with substantial engineering teams that require unique, specific caching or downloading requirements, a custom downloader may be considered. Writing a custom downloader is a non-trivial engineering task, and any custom downloader should be made compatible with AssetBundle.LoadFromFile. See the Distribution section of the next step for more details.</p><h2 id="-19"><a href="#-19" class="headerlink" title=" "></a> </h2><p>4.4. Loading Assets From AssetBundles</p><p>UnityEngine.Objects can be loaded from AssetBundles using three distinct APIs that are all attached to the AssetBundle object, which have both synchronous and asynchronous variants:</p><ul><li><p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadAsset.html" target="_blank" rel="noopener">LoadAsset</a> (<a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadAssetAsync.html" target="_blank" rel="noopener">LoadAssetAsync</a>)</p></li><li><p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadAllAssets.html" target="_blank" rel="noopener">LoadAllAssets</a> (<a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadAllAssetsAsync.html" target="_blank" rel="noopener">LoadAllAssetsAsync</a>)</p></li><li><p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadAssetWithSubAssets.html" target="_blank" rel="noopener">LoadAssetWithSubAssets</a> (<a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadAssetWithSubAssetsAsync.html" target="_blank" rel="noopener">LoadAssetWithSubAssetsAsync</a>)</p></li></ul><p>The synchronous versions of these APIs will always be faster than their asynchronous counterpart, by at least one frame.</p><p>Asynchronous loads will load multiple Objects per frame, up to their time-slice limits. See the<a href="https://unity3d.com/learn/tutorials/topics/best-practices/assetbundle-fundamentals?playlist=30089#Lowlevel_Loading_Details" target="_blank" rel="noopener"> </a>Low-level loading details section for the underlying technical reasons for this behavior.</p><p>LoadAllAssets should be used when loading multiple independent UnityEngine.Objects. It should only be used when the majority or all of the Objects within an AssetBundle need to be loaded. Compared to the other two APIs, LoadAllAssets is slightly faster than multiple individual calls to LoadAssets. Therefore, if the number of assets to be loaded is large, but less than 66% of the AssetBundle needs to be loaded at a single time, consider splitting the AssetBundle into multiple smaller bundles and using LoadAllAssets.</p><p>LoadAssetWithSubAssets should be used when loading a composite Asset which contains multiple embedded Objects, such as an FBX model with embedded animations or a sprite atlas with multiple sprites embedded inside it. If the Objects that need to be loaded all come from the same Asset, but are stored in an AssetBundle with many other unrelated Objects, then use this API.</p><p>For any other case, use LoadAsset or LoadAssetAsync.</p><h3 id="-20"><a href="#-20" class="headerlink" title=" "></a> </h3><p>4.4.1. Low-level loading details</p><p>UnityEngine.Object loading is performed off the main thread: an Object’s data is read from storage on a worker thread. Anything which does not touch thread-sensitive parts of the Unity system (scripting, graphics) will be converted on the worker thread. For example, VBOs will be created from meshes, textures will be decompressed, etc.</p><p>From Unity 5.3 onward, Object loading has been parallelized. Multiple Objects are deserialized, processed and integrated on worker threads. When an Object finishes loading, its Awake callback will be invoked and the Object will become available to the rest of the Unity Engine during the next frame.</p><p>The synchronous AssetBundle.Load methods will pause the main thread until Object loading is complete. They will also time-slice Object loading so that Object integration does not occupy more than a certain number of milliseconds of frame time. The number of milliseconds is set by the property Application.backgroundLoadingPriority:</p><ul><li><p>ThreadPriority.High: Maximum 50 milliseconds per frame</p></li><li><p>ThreadPriority.Normal: Maximum 10 milliseconds per frame</p></li><li><p>ThreadPriority.BelowNormal: Maximum 4 milliseconds per frame</p></li><li><p>ThreadPriority.Low: Maximum 2 milliseconds per frame.</p></li></ul><p>From Unity 5.2 onwards, multiple Objects are loaded until the frame-time limit for Object loading is reached. Assuming all other factors equal, the asynchronous variants of the asset loading APIs will always take longer to complete than the comparable synchronous version due to the minimum one-frame delay between issuing the asynchronous call and the object becoming available to the Engine.</p><h3 id="-21"><a href="#-21" class="headerlink" title=" "></a> </h3><p>4.4.2. AssetBundle dependencies</p><p>The dependencies among AssetBundles are automatically tracked using two different APIs, depending on the runtime environment. In the Unity Editor, AssetBundle dependencies can be queried via the<a href="http://docs.unity3d.com/ScriptReference/AssetDatabase.html" target="_blank" rel="noopener"> AssetDatabase</a> API. AssetBundle assignments and dependencies can be accessed and changed via the<a href="http://docs.unity3d.com/ScriptReference/AssetImporter.html" target="_blank" rel="noopener"> AssetImporter</a> API. At runtime, Unity provides an optional API to load the dependency information generated during an AssetBundle build via a ScriptableObject-based<a href="http://docs.unity3d.com/ScriptReference/AssetBundleManifest.html" target="_blank" rel="noopener"> AssetBundleManifest</a> API.</p><p>An AssetBundle is dependent upon another AssetBundle when one or more of the parent AssetBundle’s UnityEngine.Objects refers to one or more of the other AssetBundle’s UnityEngine.Objects. For more information on inter-Object references, see the<a href="https://unity3d.com/learn/tutorials/temas/best-practices/assets-objects-and-serialization#InterObject_References" target="_blank" rel="noopener"> </a>Inter-Object references section of the<a href="https://unity3d.com/learn/tutorials/temas/best-practices/assets-objects-and-serialization" target="_blank" rel="noopener"> </a>Assets, Objects and Serialization step.</p><p>As described in the Serialization and instances section of that step, AssetBundles serve as sources for the source data identified by the FileGUID &amp; LocalID of each Object contained within the AssetBundle.</p><p>Because an Object is loaded when its Instance ID is first dereferenced, and because an Object is assigned a valid Instance ID when its AssetBundle is loaded, the order in which AssetBundles are loaded is not important. Instead, it is important to load all AssetBundles that contain dependencies of an Object before loading the Object itself. Unity will not attempt to automatically load any child AssetBundles when a parent AssetBundle is loaded.</p><p>Example:</p><p>Assume material A refers to texture B. Material A is packaged into AssetBundle 1, and texture B is packaged into AssetBundle 2.</p><p><img src="assets/Assets,%20Resources%20and%20AssetBundles%20-%20Unity%20Le/f2a6f87c-5842-4acb-b220-2d7917e1f29f_ab1.jpg" alt=""></p><p>In this use case, AssetBundle 2 must be loaded prior to loading Material A out of AssetBundle 1.</p><p>This does not imply that AssetBundle 2 must be loaded before AssetBundle 1, or that Texture B must be loaded explicitly from AssetBundle 2. It is sufficient to have AssetBundle 2 loaded prior to loading Material A out of AssetBundle 1.</p><p>However, Unity will not automatically load AssetBundle 2 when AssetBundle 1 is loaded. This must be done manually in script code.</p><p>For more information on AssetBundle dependencies, refer to the <a href="https://docs.unity3d.com/Manual/AssetBundles-Dependencies.html" target="_blank" rel="noopener">manual page</a>.</p><h3 id="-22"><a href="#-22" class="headerlink" title=" "></a> </h3><p>4.4.3. AssetBundle manifests</p><p>When executing the AssetBundle build pipeline using the BuildPipeline.BuildAssetBundles API, Unity serializes an Object containing each AssetBundle’s dependency information. This data is stored in a separate AssetBundle, which contains a single Object of the<a href="http://docs.unity3d.com/ScriptReference/AssetBundleManifest.html" target="_blank" rel="noopener"> AssetBundleManifest</a> type.</p><p>This Asset will be stored in an AssetBundle with the same name as the parent directory where the AssetBundles are being built. If a project builds its AssetBundles to a folder at (projectroot)/build/Client/, then the AssetBundle containing the manifest will be saved as (projectroot)/build/Client/Client.manifest.</p><p>The AssetBundle containing the manifest can be loaded, cached and unloaded just like any other AssetBundle.</p><p>The AssetBundleManifest Object itself provides the<a href="http://docs.unity3d.com/ScriptReference/AssetBundleManifest.GetAllAssetBundles.html" target="_blank" rel="noopener"> GetAllAssetBundles</a> API to list all AssetBundles built concurrently with the manifest and two methods to query the dependencies of a specific AssetBundle:</p><ul><li><p><a href="http://docs.unity3d.com/ScriptReference/AssetBundleManifest.GetAllDependencies.html" target="_blank" rel="noopener">AssetBundleManifest.GetAllDependencies</a> returns all of an AssetBundle’s hierarchical dependencies, which includes the dependencies of the AssetBundle’s direct children, its children’s children, etc.</p></li><li><p><a href="http://docs.unity3d.com/ScriptReference/AssetBundleManifest.GetDirectDependencies.html" target="_blank" rel="noopener">AssetBundleManifest.GetDirectDependencies</a> returns only an AssetBundle’s direct children</p></li></ul><p>Note that both of these APIs allocate string arrays. Accordingly, they should only be used sparingly, and not during performance-sensitive portions of an application’s lifetime.</p><h3 id="-23"><a href="#-23" class="headerlink" title=" "></a> </h3><p>4.4.4. Recommendations</p><p>In many cases, it is preferable to load as many needed Objects as possible before players enter performance-critical areas of an application, such as the main game level or world. This is particularly critical on mobile platforms, where access to local storage is slow and the memory churn of loading and unloading Objects at play-time can trigger the garbage collector.</p><p>For projects that must load and unload Objects while the application is interactive, see the<a href="https://unity3d.com/learn/tutorials/topics/best-practices/asset-bundle-usage-patterns#Managing_Loaded_Assets" target="_blank" rel="noopener"> </a>Managing loaded assets section of the AssetBundle usage patterns step for more information on unloading Objects and AssetBundles.</p><p></p><h2 id="5-AssetBundle-usage-patterns"><a href="#5-AssetBundle-usage-patterns" class="headerlink" title="5.AssetBundle usage patterns"></a>5.AssetBundle usage patterns</h2><p>The previous step in this series covered the<a href="https://unity3d.com/learn/tutorials/topics/best-practices/asset-bundle-fundamentals" target="_blank" rel="noopener"> </a>fundamentals of AssetBundles, which included the low-level behavior of various loading APIs. This chapter discusses problems and potential solutions to various aspects of using AssetBundles in practice.</p><h2 id="-24"><a href="#-24" class="headerlink" title=" "></a> </h2><p>5.1 Managing loaded Assets</p><p>It is critical to carefully control the size and number of loaded Objects in memory-sensitive environments. Unity does not automatically unload Objects when they are removed from the active scene. Asset cleanup is triggered at specific times, and it can also be triggered manually.</p><p>AssetBundles themselves must be carefully managed. An AssetBundle backed by a file on local storage (either in the Unity cache or one loaded via <a href="http://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html" target="_blank" rel="noopener">AssetBundle.LoadFromFile</a>) has minimal memory overhead, rarely consuming more than a few dozen kilobytes. However, this overhead can still become problematic if a large number of AssetBundles are present.</p><p>As most projects allow users to re-experience content (such as replaying a level), it’s important to know when to load or unload an AssetBundle. If an AssetBundle is unloaded improperly, it can cause Object duplication in memory. Improperly unloading AssetBundles can also result in undesirable behavior in certain circumstances, such as causing textures to go missing. To understand why this can happen, refer to the Inter-Object references section of the Assets, Objects, and serialization step.</p><p>The most important thing to understand when managing assets and AssetBundles is the difference in behavior when calling <a href="http://docs.unity3d.com/ScriptReference/AssetBundle.Unload.html" target="_blank" rel="noopener">AssetBundle.Unload</a> with either true or false for the unloadAllLoadedObjects parameter.</p><p>This API will unload the header information of the AssetBundle being called. The unloadAllLoadedObjects parameter determines whether to also unload all Objects instantiated from this AssetBundle. If set to true, then all Objects originating from the AssetBundle will also be immediately unloaded – even if they are currently being used in the active scene.</p><p>For example, assume a material M was loaded from an AssetBundle AB, and assume M is currently in the active scene.</p><p><img src="assets/Assets,%20Resources%20and%20AssetBundles%20-%20Unity%20Le/76e89c67-741d-4b74-9356-fd72c187f4dc_ab2a.jpg" alt=""></p><p>If AssetBundle.Unload(true) is called, then M will be removed from the scene, destroyed and unloaded. However, if AssetBundle.Unload(false) is called, then AB’s header information will be unloaded but M will remain in the scene and will still be functional. Calling AssetBundle.Unload(false) breaks the link between M and AB. If AB is loaded again later, then fresh copies of the Objects contained in AB will be loaded into memory.</p><p><img src="assets/Assets,%20Resources%20and%20AssetBundles%20-%20Unity%20Le/f82652fb-5175-4b25-b362-bfdd8527a340_ab2b.jpg" alt=""></p><p>If AB is loaded again later, then a new copy of the AssetBundle’s header information will be reloaded. However, M was not loaded from this new copy of AB. Unity does not establish any link between the new copy of AB and M.</p><p><img src="assets/Assets,%20Resources%20and%20AssetBundles%20-%20Unity%20Le/9bad77ee-6cdd-4e5c-886d-dc02142e421d_ab2c.jpg" alt=""></p><p>If AssetBundle.LoadAsset() were called to reload M, Unity would not interpret the old copy of M as being an instance of the data in AB. Therefore, Unity will load a new copy of M and there will be two identical copies of M in the scene.</p><p><img src="assets/Assets,%20Resources%20and%20AssetBundles%20-%20Unity%20Le/e1119799-f21d-4d2f-a56a-550302752728_ab2d.jpg" alt=""></p><p>For most projects, this behavior is undesirable. Most projects should use AssetBundle.Unload(true) and adopt a method to ensure that Objects are not duplicated. Two common methods are:</p><ol><li>1. </li></ol><p>Having well-defined points during the application’s lifetime at which transient AssetBundles are unloaded, such as between levels or during a loading screen. This is the simpler and most common option.</p><ol><li>2. </li></ol><p>Maintaining reference-counts for individual Objects and unload AssetBundles only when all of their constituent Objects are unused. This permits an application to unload and reload individual Objects without duplicating memory.</p><p>If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways:</p><ol><li>1. </li></ol><p>Eliminate all references to an unwanted Object, both in the scene and in code. After this is done, call <a href="http://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html" target="_blank" rel="noopener">Resources.UnloadUnusedAssets</a>.</p><ol><li>2. </li></ol><p>Load a scene non-additively. This will destroy all Objects in the current scene and invoke <a href="http://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html" target="_blank" rel="noopener">Resources.UnloadUnusedAssets</a> automatically.</p><p>If a project has well-defined points where the user can be made to wait for Objects to load and unload, such as in between game modes or levels, these points should be used to unload as many Objects as necessary and to load new Objects.</p><p>The simplest way to do this is to package discrete chunks of a project into scenes, and then build those scenes into AssetBundles, along with all of their dependencies. The application can then enter a “loading” scene, fully unload the AssetBundle containing the old scene, and then load the AssetBundle containing the new scene.</p><p>While this is the simplest flow, some projects require more complex AssetBundle management. As every project is different, there is no universal AssetBundle design pattern.</p><p>When deciding how to group Objects into AssetBundles, it is generally best to start by bundling Objects into AssetBundles if they must be loaded or updated at the same time. For example, consider a role-playing game. Individual maps and cutscenes can be grouped into AssetBundles by scene, but some Objects will be needed in most scenes. AssetBundles could be built to provide portraits, the in-game UI, and different character models and textures. These latter Objects and Assets could then be grouped into a second set of AssetBundles that are loaded at startup and remain loaded for the lifetime of the app.</p><p>Another problem can arise if Unity must reload an Object from its AssetBundle after the AssetBundle has been unloaded. In this case, the reload will fail and the Object will appear in the Unity Editor’s hierarchy as a (Missing) Object.</p><p>This primarily occurs when Unity loses and regains control over its graphics context, such as when a mobile app is suspended or the user locks their PC. In this case, Unity must re-upload textures and shaders to the GPU. If the source AssetBundle for these assets is unavailable, the application will render Objects in the scene as magenta.</p><h2 id="-25"><a href="#-25" class="headerlink" title=" "></a> </h2><p>5.2. Distribution</p><p>There are two basic ways to distribute a project’s AssetBundles to clients: installing them simultaneously with the project or downloading them after installation.</p><p>The decision whether to ship AssetBundles within or after installation is driven by the capabilities and restrictions of the platforms on which the project will run. Mobile projects usually opt for post-install downloads to reduce initial install size and remain below over-the-air download size limits. Console and PC projects generally ship AssetBundles with their initial install.</p><p>Proper architecture permits patching new or revised content into your project post-install regardless of how the AssetBundles are delivered initially. For more information on this, see the <a href="https://docs.unity3d.com/Manual/AssetBundles-Patching.html" target="_blank" rel="noopener">Patching with AssetBundles</a> section of the Unity Manual.</p><h3 id="-26"><a href="#-26" class="headerlink" title=" "></a> </h3><p>5.2.1. Shipped with project</p><p>Shipping AssetBundles with the project is the simplest way to distribute them as it does not require additional download-management code. There are two major reasons why a project might include AssetBundles with the install:</p><ul><li><p>To reduce project build times and permit simpler iterative development. If these AssetBundles do not need to be updated separately from the application itself, then the AssetBundles can be included with the application by storing the AssetBundles in Streaming Assets. See the Streaming Assets section, below.</p></li><li><p>To ship an initial revision of updatable content. This is commonly done to save end-users time after their initial install or to serve as the basis for later patching. Streaming Assets is not ideal for this case. However, if writing a custom downloading and caching system is not an option, then an initial revision of updatable content can be loaded into the Unity cache from Streaming Assets (See the Cache Priming section, below).</p></li></ul><h4 id="-27"><a href="#-27" class="headerlink" title=" "></a> </h4><p>5.2.1.1. Streaming Assets</p><p>The easiest way to include any type of content, including AssetBundles, within a Unity application at install time is to build the content into the /Assets/StreamingAssets/ folder, prior to building the project. Anything contained in the StreamingAssets folder at build time will be copied into the final application.</p><p>The full path to the StreamingAssets folder on local storage is accessible via the property <a href="http://docs.unity3d.com/ScriptReference/Application-streamingAssetsPath.html" target="_blank" rel="noopener">Application.streamingAssetsPath</a> at runtime. The AssetBundles can then be loaded with via AssetBundle.LoadFromFile on most platforms.</p><p>Android Developers: On Android, assets in the StreamingAssets folders are stored into the APK and may take more time to load if they are compressed, as files stored in an APK can use different storage algorithms. The algorithm used may vary from one Unity version to another. You can use an archiver such as 7-zip to open the APK to determine if the files are compressed or not. If they are, you can expect AssetBundle.LoadFromFile() to perform more slowly. In this case, you can retrieve the cached version by using <a href="https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.GetAssetBundle.html" target="_blank" rel="noopener">UnityWebRequest.GetAssetBundle</a> as a workaround. By using UnityWebRequest, the AssetBundle will be uncompressed and cached during the first run, allowing for following executions to be faster. Note that this will will take more storage space, as the AssetBundle will be copied to the cache. Alternatively, you can export your Gradle project and add an extension to your AssetBundles at build time. You can then edit the build.gradle file and add that extension to the noCompress section. Once done, you should be able to use AssetBundle.LoadFromFile() without having to pay the decompression performance cost.</p><p>Note: Streaming Assets is not a writable location on some platforms. If a project’s AssetBundles need to be updated after installation, either use WWW.LoadFromCacheOrDownload or write a custom downloader.</p><h3 id="-28"><a href="#-28" class="headerlink" title=" "></a> </h3><p>5.2.2. Downloaded post-install</p><p>The favored method of delivering AssetBundles to mobile devices is to download them after app installation. This also allows the content to be updated after installation without forcing users to re-download the entire application. On many platforms, application binaries must undergo an expensive and lengthy re-certification process. Therefore, developing a good system for post-install downloads is vital.</p><p>The simplest way to deliver AssetBundles is to place them on a web server and deliver them via UnityWebRequest. Unity will automatically cache downloaded AssetBundles on local storage. If the downloaded AssetBundle is LZMA compressed, the AssetBundle will be stored in the cache either as uncompressed or re-compressed as LZ4 (dependent on the <a href="https://docs.unity3d.com/ScriptReference/Caching-compressionEnabled.html" target="_blank" rel="noopener">Caching.compressionEnabled</a> setting), for faster loading in the future. If the downloaded bundle is LZ4 compressed, the AssetBundle will be stored compressed. If the cache fills up, Unity will remove the least recently used AssetBundle from the cache. See the Built-in caching section for more details.</p><p>It is generally recommended to start by using UnityWebRequest when possible, or WWW.LoadFromCacheOrDownload only if using Unity 5.2 or older. Only invest in a custom download system if the built-in APIs’ memory consumption, caching behavior or performance are unacceptable for a specific project, or if a project must run platform-specific code to achieve its requirements.</p><p>Examples of situations which may prevent the use of UnityWebRequest or WWW.LoadFromCacheOrDownload:</p><ul><li><p>When fine-grained control over the AssetBundle cache is required</p></li><li><p>When a project needs to implement a custom compression strategy</p></li><li><p>When a project wishes to use platform-specific APIs to satisfy certain requirements, such as the need to stream data while inactive.</p></li><li><p>Example: Using iOS’ Background Tasks API to download data while in the background.</p></li><li><p>When AssetBundles must be delivered over SSL on platforms where Unity does not have proper SSL support (such as PC).</p></li></ul><h3 id="-29"><a href="#-29" class="headerlink" title=" "></a> </h3><p>5.2.3. Built-in caching</p><p>Unity has a built-in AssetBundle caching system that can be used to cache AssetBundles downloaded via the UnityWebRequest API, which has an overload accepting an AssetBundle version number as an argument. This number is not stored inside the AssetBundle, and is not generated by the AssetBundle system.</p><p>The caching system keeps track of the last version number passed to UnityWebRequest. When this API is called with a version number, the caching system checks to see if there is a cached AssetBundle by comparing version numbers. If these numbers match, the system will load the cached AssetBundle. If the numbers do not match, or there is no cached AssetBundle, then Unity will download a new copy. This new copy will be associated with the new version number.</p><p>AssetBundles in the caching system are identified only by their file names, and not by the full URL from which they are downloaded. This means that an AssetBundle with the same file name can be stored in multiple different locations, such as a Content Delivery Network. As long as the file names are identical, the caching system will recognize them as the same AssetBundle.</p><p>It is up to each individual application to determine an appropriate strategy for assigning version numbers to AssetBundles, and to pass these numbers to UnityWebRequest. The numbers may come from a unique identifiers of sorts, such as a CRC value. Note that while AssetBundleManifest.GetAssetBundleHash() may also be used for this purpose, we don’t recommend this function for versioning, as it provides just an estimation, and not a true hash calculation).</p><p>See the <a href="https://docs.unity3d.com/Manual/AssetBundles-Patching.html" target="_blank" rel="noopener">Patching with AssetBundles</a> section of the Unity Manual for more details.</p><p>In Unity 2017.1 onward, the <a href="https://docs.unity3d.com/ScriptReference/Caching.html" target="_blank" rel="noopener">Caching</a> API has been extended to provide more granular control, by allow developers to select an active cache from multiple caches. Prior versions of Unity may only modify <a href="https://docs.unity3d.com/560/Documentation/ScriptReference/Caching-expirationDelay.html" target="_blank" rel="noopener">Caching.expirationDelay</a> and <a href="https://docs.unity3d.com/560/Documentation/ScriptReference/Caching-maximumAvailableDiskSpace.html" target="_blank" rel="noopener">Caching.maximumAvailableDiskSpace</a> to remove cached items (these properties remain in Unity 2017.1 in the <a href="https://docs.unity3d.com/ScriptReference/Cache.html" target="_blank" rel="noopener">Cache class</a>).</p><p><a href="http://docs.unity3d.com/ScriptReference/Caching-expirationDelay.html" target="_blank" rel="noopener">expirationDelay</a> is the minimum number of seconds that must elapse before an AssetBundle is automatically deleted. If an AssetBundle is not accessed during this time, it will be deleted automatically.</p><p><a href="http://docs.unity3d.com/ScriptReference/Caching-maximumAvailableDiskSpace.html" target="_blank" rel="noopener">maximumAvailableDiskSpace</a> specifies the amount of space on local storage, in bytes, that the cache may use before it begins deleting AssetBundles that have been used less recently than the expirationDelay. When the limit is reached, Unity will delete the AssetBundle in the cache which was least recently opened (or marked as used via Caching.MarkAsUsed). Unity will delete cached AssetBundles until there is sufficient space to complete the new download.</p><h4 id="-30"><a href="#-30" class="headerlink" title=" "></a> </h4><p>5.2.3.1. Cache Priming</p><p>Because AssetBundles are identified by their file names, it is possible to “prime” the cache with AssetBundles shipped with the application. To do this, store the initial or base version of each AssetBundle in /Assets/StreamingAssets/. The process is identical to the one detailed in the<a href="https://unity3d.com/learn/tutorials/temas/best-practices/assetbundle-usage-patterns?playlist=30089#Shipped_with_Project" target="_blank" rel="noopener"> </a>Shipped with project section.</p><p>The cache can be populated by loading AssetBundles from Application.streamingAssetsPath the first time the application is run. From then on, the application can call UnityWebRequest normally (UnityWebRequest can also be used to initially load AssetBundles from the StreamingAssets path as well).</p><h3 id="-31"><a href="#-31" class="headerlink" title=" "></a> </h3><p>5.2.3. Custom downloaders</p><p>Writing a custom downloader gives an application full control over how AssetBundles are downloaded, decompressed and stored. As the engineering work involved is non-trivial, we recommend this approach only for larger teams. There are four major considerations when writing a custom downloader:</p><ul><li><p>Download mechanism</p></li><li><p>Storage location</p></li><li><p>Compression type</p></li><li><p>Patching</p></li></ul><p>For information on patching AssetBundles, see the<a href="https://docs.unity3d.com/Manual/AssetBundles-Patching.html" target="_blank" rel="noopener"> Patching with AssetBundles</a> section of the Unity Manual.</p><h4 id="-32"><a href="#-32" class="headerlink" title=" "></a> </h4><p>5.2.3.1. Downloading</p><p>For most applications, HTTP is the simplest method to download AssetBundles. However, implementing an HTTP-based downloader is not the simplest task. Custom downloaders must avoid excessive memory allocations, excessive thread usage and excessive thread wakeups. Unity’s WWW class is unsuitable for reasons exhaustively described in the WWW.LoadFromCacheOrDownload section of the AssetBundle fundamentals step.</p><p>When writing a custom downloader, there are three options:</p><ul><li><p>C#’s HttpWebRequest and WebClient classes</p></li><li><p>Custom native plugins</p></li><li><p>Asset store packages</p></li></ul><p>5.2.3.1.1. C# classes</p><p>If an application does not require HTTPS/SSL support, C#’s <a href="https://msdn.microsoft.com/en-us/library/system.net.webclient%28v=vs.110%29.aspx" target="_blank" rel="noopener">WebClient</a> class provides the simplest possible mechanism for downloading AssetBundles. It is capable of asynchronously downloading any file directly to local storage without excessive managed memory allocation.</p><p>To download an AssetBundle with WebClient, allocate an instance of the class and pass it the URL of the AssetBundle to download and a destination path. If more control is required over the request’s parameters, it is possible to write a downloader using C#’s <a href="https://msdn.microsoft.com/en-us/library/system.net.httpwebrequest%28v=vs.90%29.aspx" target="_blank" rel="noopener">HttpWebRequest</a> class:</p><ol><li>1. </li></ol><p>Get a byte stream from HttpWebResponse.GetResponseStream.</p><ol><li>2. </li></ol><p>Allocate a fixed-size byte buffer on the stack.</p><ol><li>3. </li></ol><p>Read from the response stream into the buffer.</p><ol><li>4. </li></ol><p>Write the buffer to disk using C#’s File.IO APIs, or any other streaming IO system.</p><p>5.2.3.1.2. Asset Store Packages</p><p>Several asset store packages offer native-code implementations to download files via HTTP, HTTPS and other protocols. Before writing a custom native-code plugin for Unity, it is recommended to evaluate available Asset Store packages.</p><p>5.2.3.1.3. Custom Native Plugins</p><p>Writing a custom native plugin is the most time-intensive, but most flexible method for downloading data in Unity. Due to the high programming time requirements and high technical risk, this method is only recommended if no other method is capable of satisfying an application’s requirements. For example, a custom native plugin may be necessary if an application must use SSL communication on platforms without C# SSL support in Unity.</p><p>A custom native plugin will generally wrap a target platform’s native downloading APIs. Examples include <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/" target="_blank" rel="noopener">NSURLConnection</a> on iOS and <a href="http://download.java.net/jdk7/archive/b123/docs/api/java/net/HttpURLConnection.html" target="_blank" rel="noopener">java.net.HttpURLConnection</a> on Android. Consult each platform’s native documentation for further details on using these APIs.</p><h4 id="-33"><a href="#-33" class="headerlink" title=" "></a> </h4><p>5.2.3.2. Storage</p><p>On all platforms, Application.persistentDataPath points to a writable location that should be used for storing data that should persist between runs of an application. When writing a custom downloader, it is strongly recommended to use a subdirectory of Application.persistentDataPath to store downloaded data.</p><p>Application.streamingAssetPath is not writable and is a poor choice for an AssetBundle cache. Example locations for streamingAssetsPath include:</p><ul><li><p>OSX: Within .app package; not writable.</p></li><li><p>Windows: Within install directory (e.g. Program Files); usually not writable</p></li><li><p>iOS: Within .ipa package; not writable</p></li><li><p>Android: Within .apk file; not writable</p></li></ul><h2 id="-34"><a href="#-34" class="headerlink" title=" "></a> </h2><p>5.3. Asset Assignment Strategies</p><p>Deciding how to divide a project’s assets into AssetBundles is not simple. It is tempting to adopt a simplistic strategy, such as placing all Objects in their own AssetBundle or using only a single AssetBundle, but these solutions have significant drawbacks:</p><ul><li><p>Having too few AssetBundles…</p></li><li><p>Increases runtime memory usage</p></li><li><p>Increases loading times</p></li><li><p>Requires larger downloads</p></li><li><p>Having too many AssetBundles…</p></li><li><p>Increases build times</p></li><li><p>Can complicate development</p></li><li><p>Increases total download time</p></li></ul><p>The key decision is how to group Objects into AssetBundles. The primary strategies are:</p><ul><li><p>Logical entities</p></li><li><p>Object Types</p></li><li><p>Concurrent content</p></li></ul><p>More information about these grouping strategies can be found in the <a href="https://docs.unity3d.com/Manual/AssetBundles-Preparing.html" target="_blank" rel="noopener">Manual</a>.</p><h2 id="-35"><a href="#-35" class="headerlink" title=" "></a> </h2><p>5.4. Common pitfalls</p><p>This section describes several problems that commonly appear in projects using AssetBundles.</p><h3 id="-36"><a href="#-36" class="headerlink" title=" "></a> </h3><p>5.5.1. Asset duplication</p><p>Unity 5’s AssetBundle system will discover all dependencies of an Object when the Object is built into an AssetBundle. This dependency information is used to determine the set of Objects that will be included in an AssetBundle.</p><p>Objects that are explicitly assigned to an AssetBundle will only be built into that AssetBundle. An Object is “explicitly assigned” when that Object’s AssetImporter has its assetBundleName property set to a non-empty string. This can be done in the Unity Editor by selecting an AssetBundle in the Object’s Inspector, or from Editor scripts.</p><p>Objects can also be assigned to an AssetBundle by defining them as part of an <a href="https://docs.unity3d.com/ScriptReference/AssetBundleBuild.html" target="_blank" rel="noopener">AssetBundle building map</a>, which is to be used in conjunction with the overloaded <a href="https://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundles.html" target="_blank" rel="noopener">BuildPipeline.BuildAssetBundles()</a> function that takes in an array of AssetBundleBuild.</p><p>Any Object that is not explicitly assigned in an AssetBundle will be included in all AssetBundles that contain 1 or more Objects that reference the untagged Object.</p><p>For example, if two different Objects are assigned to two different AssetBundles, but both have references to a common dependency Object, then that dependency Object will be copied into both AssetBundles. The duplicated dependency will also be instanced, meaning that the two copies of the dependency Object will be considered different Objects with a different identifiers. This will increase the total size of the application’s AssetBundles. This will also cause two different copies of the Object to be loaded into memory if the application loads both of its parents.</p><p>There are several ways to address this problem:</p><ol><li>1. </li></ol><p>Ensure that Objects built into different AssetBundles do not share dependencies. Any Objects which do share dependencies can be placed into the same AssetBundle without duplicating their dependencies.</p><ul><li>This method usually is not viable for projects with many shared dependencies. It produces monolithic AssetBundles that must be rebuilt and re-downloaded too frequently to be convenient or efficient.</li></ul><ol><li>1. </li></ol><p>Segment AssetBundles so that no two AssetBundles that share a dependency will be loaded at the same time.</p><ul><li>This method may work for certain types of projects, such as level-based games. However, it still unnecessarily increases the size of the project’s AssetBundles, and increases both build times and loading times.</li></ul><ol><li>1. </li></ol><p>Ensure that all dependency assets are built into their own AssetBundles. This entirely eliminates the risk of duplicated assets, but also introduces complexity. The application must track dependencies between AssetBundles, and ensure that the right AssetBundles are loaded before calling any AssetBundle.LoadAsset APIs.</p><p>Object dependencies are tracked via the AssetDatabase API, located in the UnityEditor namespace. As the namespace implies, this API is only available in the Unity Editor and not at runtime. AssetDatabase.GetDependencies can be used to locate all of the immediate dependencies of a specific Object or Asset. Note that these dependencies may have their own dependencies. Additionally, the AssetImporter API can be used to query the AssetBundle to which any specific Object is assigned.</p><p>By combining the AssetDatabase and AssetImporter APIs, it is possible to write an Editor script that ensures that all of an AssetBundle’s direct or indirect dependencies are assigned to AssetBundles, or that no two AssetBundles share dependencies that have not been assigned to an AssetBundle. Due to the memory cost of duplicating assets, it is recommended that all projects have such a script.</p><h3 id="-37"><a href="#-37" class="headerlink" title=" "></a> </h3><p>5.5.2. Sprite atlas duplication</p><p>Any automatically-generated sprite atlas will be assigned to the AssetBundle containing the Sprite Objects from which the sprite atlas was generated. If the sprite Objects are assigned to multiple AssetBundles, then the sprite atlas will not be assigned to an AssetBundle and will be duplicated. If the Sprite Objects are not assigned to an AssetBundle, then the sprite atlas will also not be assigned to an AssetBundle.</p><p>To ensure that sprite atlases are not duplicated, check that all sprites tagged into the same sprite atlas are assigned to the same AssetBundle.</p><p>Note that in Unity 5.2.2p3 and older, automatically-generated sprite atlases will never be assigned to an AssetBundle. Because of this, they will be included in any AssetBundles containing their constituent sprites and also any AssetBundles referencing their constituent sprites. Because of this problem, it is strongly recommended that all Unity 5 projects using Unity’s sprite packer upgrade to Unity 5.2.2p4, 5.3 or any newer version of Unity.</p><h3 id="-38"><a href="#-38" class="headerlink" title=" "></a> </h3><p>5.5.3. Android textures</p><p>Due to heavy device fragmentation in the Android ecosystem, it is often necessary to compress textures into several different formats. While all Android devices support ETC1, ETC1 does not support textures with alpha channels. Should an application not require OpenGL ES 2 support, the cleanest way to solve the problem is to use ETC2, which is supported by all Android OpenGL ES 3 devices.</p><p>Most applications need to ship on older devices where ETC2 support is unavailable. One way to solve this problem is with Unity 5’s AssetBundle Variants (refer to Unity’s Android optimization guide for details on other options).</p><p>To use AssetBundle Variants, all textures that cannot be cleanly compressed using ETC1 must be isolated into texture-only AssetBundles. Next, create sufficient variants of these AssetBundles to support the non-ETC2-capable slices of the Android ecosystem, using vendor-specific texture compression formats such as DXT5, PVRTC and ATITC. For each AssetBundle Variant, change the included textures’ TextureImporter settings to the compression format appropriate to the Variant.</p><p>At runtime, support for the different texture compression formats can be detected using the<a href="http://docs.unity3d.com/ScriptReference/SystemInfo.SupportsTextureFormat.html" target="_blank" rel="noopener"> SystemInfo.SupportsTextureFormat</a> API. This information should be used to select and load the AssetBundle Variant containing textures compressed in a supported format.</p><p>More information on Android texture compression formats can be found<a href="http://developer.android.com/guide/topics/graphics/opengl.html#textures" target="_blank" rel="noopener"> here</a>.</p><h3 id="-39"><a href="#-39" class="headerlink" title=" "></a> </h3><p>5.5.4. iOS file handle overuse</p><p>Current versions of Unity are not affected by this issue.</p><p>In versions prior to Unity 5.3.2p2, Unity would hold an open file handle to an AssetBundle the entire time that the AssetBundle is loaded. This is not a problem on most platforms. However, iOS limits the number of file handles a process may simultaneously have open to 255. If loading an AssetBundle causes this limit to be exceeded, the loading call will fail with a “Too Many Open File Handles” error.</p><p>This was a common problem for projects trying to divide their content across many hundreds or thousands of AssetBundles.</p><p>For projects unable to upgrade to a patched version of Unity, temporary solutions are:</p><ul><li><p>Reducing the number of AssetBundles in use by merging related AssetBundles</p></li><li><p>Using AssetBundle.Unload(false) to close an AssetBundle’s file handle, and managing the loaded Objects’ lifecycles manually</p></li></ul><h2 id="-40"><a href="#-40" class="headerlink" title=" "></a> </h2><p>5.5. AssetBundle Variants</p><p>A key feature of the AssetBundle system is the introduction of AssetBundle Variants. The purpose of Variants is to allow an application to adjust its content to better suit its runtime environment. Variants permit different UnityEngine.Objects in different AssetBundle files to appear as being the “same” Object when loading Objects and resolving Instance ID references. Conceptually, it permits two UnityEngine.Objects to appear to share the same File GUID &amp; Local ID, and identifies the actual UnityEngine.Object to load by a string Variant ID.</p><p>There are two primary use cases for this system:</p><ol><li>1. </li></ol><p>Variants simplify the loading of AssetBundles appropriate for a given platform.</p><ul><li>Example: A build system might create an AssetBundle containing high-resolution textures and complex shaders suitable for a standalone DirectX11 Windows build, and a second AssetBundle with lower-fidelity content intended for Android. At runtime, the project’s resource loading code can then load the appropriate AssetBundle Variant for its platform, and the Object names passed into the AssetBundle.Load API do not need to change.</li></ul><ol><li>1. </li></ol><p>Variants allow an application to load different content on the same platform, but with different hardware.</p><ul><li><p>This is key for supporting a wide range of mobile devices. An iPhone 4 is incapable of displaying the same fidelity of content as the latest iPhone in any real-world application.</p></li><li><p>On Android, AssetBundle Variants can be used to tackle the immense fragmentation of screen aspect ratios and DPIs between devices.</p></li></ul><h3 id="-41"><a href="#-41" class="headerlink" title=" "></a> </h3><p>5.5.1. Limitations</p><p>A key limitation of the AssetBundle Variant system is that it requires Variants to be built from distinct Assets. This limitation applies even if the only variations between those Assets is their import settings. If the only distinction between a texture built into Variant A and Variant B is the specific texture compression algorithm selected in the Unity texture importer, Variant A and Variant B must still be entirely different Assets. This means that Variant A and Variant B must be separate files on disk.</p><p>This limitation complicates the management of large projects as multiple copies of a specific Asset must be kept in source control. All copies of an Asset must be updated when developers wish to change the content of the Asset. There are no built-in workarounds for this problem.</p><p>Most teams implement their own form of AssetBundle Variants. This is done by building AssetBundles with well-defined suffixes appended to their filenames, in order to identify the specific variant a given AssetBundle represents. Custom code programmatically alters the importer settings of the included Assets when building these AssetBundles. Some developers have extended their custom systems to also be able to alter parameters on components attached to prefabs.</p><h2 id="-42"><a href="#-42" class="headerlink" title=" "></a> </h2><p>5.6. Compressed or uncompressed?</p><p>Whether to compress AssetBundles requires several important considerations, which include:</p><ul><li><p>Loading time: Uncompressed AssetBundles are much faster to load than compressed AssetBundles when loading from local storage or a local cache.</p></li><li><p>Build time: LZMA and LZ4 are very slow when compressing files, and the Unity Editor processes AssetBundles serially. Projects with a large number of AssetBundles will spend a lot of time compressing them.</p></li><li><p>Application size: If the AssetBundles are shipped in the application, compressing them will reduce the application’s total size. Alternatively, the AssetBundles can be downloaded post-install.</p></li><li><p>Memory usage: Prior to Unity 5.3, all of Unity’s decompression mechanisms required the entire compressed AssetBundle to be loaded into memory prior to decompression. If memory usage is important, use either uncompressed or LZ4 compressed AssetBundles.</p></li><li><p>Download time: Compression may only be necessary if the AssetBundles are large, or if users are in a bandwidth-constrained environment, such as downloading on low-speed or metered connections. If only a few tens of megabytes of data are being delivered to PCs on high-speed connections, it may be possible to omit compression.</p></li></ul><h4 id="-43"><a href="#-43" class="headerlink" title=" "></a> </h4><p>5.6.1. Crunch Compression</p><p>Bundles which consist primarily of DXT-compressed textures which use the Crunch compression algorithm should be built uncompressed.</p><h2 id="-44"><a href="#-44" class="headerlink" title=" "></a> </h2><p>5.7. AssetBundles and WebGL</p><p>All AssetBundle decompression and loading in a WebGL project must occur on the main thread, due to Unity’s WebGL export option not currently supporting worker threads. The downloading of AssetBundles is delegated to the browser using XMLHttpRequest. Once downloaded, compressed AssetBundles will be decompressed on Unity’s main thread, therefore stalling execution of the Unity content depending on the size of the bundle.</p><p>Unity recommends that developers prefer small asset bundles to avoid incurring performance issues. This approach will also be more memory efficient than using large asset bundles. Unity WebGL only supports LZ4-compressed and uncompressed asset bundles, however, it is possible to apply gzip/brotli compression on the bundles generated by Unity. In that case you will need to configure your web server accordingly so that the files are decompressed on download by the browser. See <a href="https://docs.unity3d.com/Manual/webgl-deploying.html" target="_blank" rel="noopener">here</a> for more details.</p><p>If you are using Unity 5.5 or older, consider avoiding LZMA for your AssetBundles and compress using LZ4 instead, which is decompressed very efficiently on-demand. Unity 5.6 removes LZMA as a compression option for the WebGL platform.</p><p></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assembly Definition File &amp; Package Manager</title>
      <link href="2023/07/25/Unity3D-Assembly-Definition-File-Package-Manager/"/>
      <url>2023/07/25/Unity3D-Assembly-Definition-File-Package-Manager/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_34329187/article/details/86016256?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34329187/article/details/86016256?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6</a>&gt;</p><h2 id="Assembly-Definition-File-XXX-asmdef"><a href="#Assembly-Definition-File-XXX-asmdef" class="headerlink" title="Assembly Definition File(XXX.asmdef)"></a>Assembly Definition File(XXX.asmdef)</h2><blockquote><p>Unity 2017.3中的新功能<br> 使用该特性，开发者可以在一个文件夹中自定义托管程序集。定义明晰的依赖文件，可以确保脚本被更改后，只会重新生成必需的程序集，提高工作效率，减少编译时间。</p></blockquote><p>Unity自动定义脚本编译为 <strong>托管程序集</strong> 的方式。Unity编辑器中进行脚本更改迭代的编译时间会随脚本数量的增加而增加。<br>你可以使用新的 <strong>程序集定义文件特性</strong> ，基于文件夹中的脚本定义你自己的托管程序集。如果你将项目脚本分为多个程序集，并进行良好的依赖定义，可以确保你在 <strong>更改某个脚本时，只会重新生成必需的程序集。</strong> 这减少了编译时间，因此你可以在Unity项目中将 <strong>每个托管程序集看做是单个的库</strong> 。</p><p><img src="assets/Assembly%20Definition%20File%20&amp;%20Package%20Manager/0ba13fb88d2746f6bd2ed681d1324d8c.png" alt="Alt text"></p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>都是JSON文件，包含以下字段:</p><div class="table-container"><table><thead><tr><th>Field</th><th>Type  </th></tr></thead><tbody><tr><td>name</td><td>string  </td></tr><tr><td>references(optional)</td><td>string array  </td></tr><tr><td>includePlatforms(optional)</td><td>string array  </td></tr><tr><td>excludePlatforms(optional)</td><td>string array  </td></tr></tbody></table></div><p>字段includePlatforms和 excludePlatforms不能在同一个程序集定义文件中使用</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li><p>将一个程序集定义文件添加到Unity项目中的一个文件夹里，对该文件夹里所有的脚本进行编译，然后在检视窗口中对程序集名称进行设置。</p></li><li><p>你还可以使用检视窗口添加对项目中其它程序集定义文件的引用。编译程序集和定义程序集间的依赖时会用到这些引用。</p></li><li><p>Unity使用引用来编译程序集，以及定义程序集之间的依赖关系。你可以在检视窗口中设置程序集定义文件的平台兼容性，也可以选择排除或包括特定平台。</p></li></ul><blockquote><p>假设你有一个Assets/ExampleFolder/MyLibrary.asmdef和一个Assets/ExampleFolder/ExampleFolder2/Utility.asmdef文件，那么：</p><ul><li><p>Assets &gt; ExampleFolder &gt; ExampleFolder2文件夹中的所有脚本将会被编译到Assets/ExampleFolder/ExampleFolder2/Utility.asmdef定义的程序集中。</p></li><li><p>Assets &gt; ExampleFolder文件夹中的所有脚本，除Assets &gt; ExampleFolder&gt; ExampleFolder2中的脚本之外，将会被编译到Assets/ExampleFolder/MyLibrary.asmdef定义的程序集中。</p></li></ul><p>程序集定义文件不属于程序集生成文件。它们不支持在生成系统中常见的条件化生成规则。这也是程序集定义文件不支持预处理指令（定义）的原因，因为它们一直是静态的。</p></blockquote><h3 id="向后兼容和隐式依赖"><a href="#向后兼容和隐式依赖" class="headerlink" title="向后兼容和隐式依赖"></a>向后兼容和隐式依赖</h3><p>程序集定义文件向后兼容Unity中现存的 <strong>[预定义编译系统]（Predefined Compilation System）</strong> 。<br><strong>预定义程序集</strong> 总是依赖于每个 <strong>程序集定义文件的程序集</strong> 。<br>这与Unity中 <strong>所有脚本</strong> 都依赖于所有和当前生成目标兼容的 <strong>预编译程序集</strong> （插件/.dll）的情况相似。</p><p><img src="assets/Assembly%20Definition%20File%20&amp;%20Package%20Manager/48350069f86f4fa59e4fdd25dbc6e399.png" alt="Alt text"></p><p>Unity给予程序集定义文件的优先级要比<a href="http://CompileOrderFolders" target="_blank" rel="noopener">预定义编译系统</a>高。<br>这意味着，任何来自程序集定义文件文件夹内的预定义编译的特殊文件夹名，都不会对编译产生任何影响。Unity只将它们视为常规文件夹。</p><blockquote><p>强烈建议你对项目中的所有脚本使用程序集定义文件，或完全不使用。否则，没有使用程序集定义文件的脚本会在每次程序集定义文件重新编译时也被重新编译。这会减少你在项目中程序集定义文件所带来的好处。</p></blockquote><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>要获取平台名，可使用：<br><code>CompilationPipeline.GetAssemblyDefinitionPlatforms</code><br>在<code>UnityEditor.Compilation</code>命名空间中，有一个静态的<code>CompilationPipeline</code>类，你可用它获取程序集定义文件以及所有由Unity生成的程序集的信息。</p><h2 id="Package-Manager"><a href="#Package-Manager" class="headerlink" title="Package Manager"></a>Package Manager</h2><p>一个包是一个容器，它可以包含各种资源的组合：shader、纹理、插件、图标、脚本等，可以增强项目的各个部分。</p><blockquote><p>优点：相对于Asset Store的包，Package Manager提供了更新，更容易集成的包管理方案，能够为Unity提供各种增强功能。</p></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>Window &gt; Package Manager 查看，安装，删除，更新<br>官方包名称会以 com.unity开头<br>一些包在版本号旁边显示标签。这些标签传达有关该包版本的信息。</p><div class="table-container"><table><thead><tr><th>标签</th><th>含义  </th></tr></thead><tbody><tr><td>verified</td><td>Unity的质量保证团队已正式确认此包可与编辑器的特定版本配合使用。  </td></tr><tr><td>preview</td><td>该包处于发布周期的早期阶段，可能尚未被开发团队或Unity的质量保证团队记录和完全验证。  </td></tr></tbody></table></div><h3 id="package-manifest-file包清单文件"><a href="#package-manifest-file包清单文件" class="headerlink" title="package manifest file包清单文件"></a>package manifest file包清单文件</h3><h4 id="project-manifests-manifest-json"><a href="#project-manifests-manifest-json" class="headerlink" title="project manifests: manifest.json"></a>project manifests: manifest.json</h4><p>tell the Package Manager which packages and versions are available to the project.</p><h4 id="package-manifests-package-json"><a href="#package-manifests-package-json" class="headerlink" title="package manifests: package.json"></a>package manifests: package.json</h4><p>determine which version of the package to load, and what information to display in the Package Manager window.</p><blockquote><p>name必须纯小写，否则是invalid</p></blockquote><pre><code class="lang-csharp">{ &quot;name&quot;: &quot;com.unity.package-4&quot;, &quot;displayName&quot;: &quot;Package Number 4&quot;, &quot;version&quot;: &quot;2.5.1&quot;, &quot;unity&quot;: &quot;2018.1&quot;, &quot;description&quot;: &quot;This package provides X, Y, and Z. \n\nTo find out more, click the \&quot;View Documentation\&quot; link.&quot;, &quot;keywords&quot;: [&quot;key X&quot;, &quot;key Y&quot;, &quot;key Z&quot;], &quot;category&quot;: &quot;Controllers&quot;, &quot;dependencies&quot;: { &quot;com.unity.package-1&quot;: &quot;1.0.0&quot;, &quot;com.unity.package-2&quot;: &quot;2.0.0&quot;, &quot;com.unity.package-3&quot;: &quot;3.0.0&quot;} }</code></pre><h3 id="The-Package-Registry"><a href="#The-Package-Registry" class="headerlink" title="The Package Registry"></a>The Package Registry</h3><p>Unity maintains a central registry of official packages that are available for distribution(可供分发的官方包的中央注册表。). When Unity loads, the Package Manager communicates with the registry, checks the project manifest file, and displays the status of each available package in the Package Manager window.</p><p>When you remove a package from the project, the Package Manager updates the project manifest to exclude that package from the list in In Project mode but it is still available in All mode because it is still on the registry.</p><p>When you install or update a package, the Package Manager downloads the package from the registry.</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An introduction to IL2CPP internalsВведение в</title>
      <link href="2023/07/25/Unity3D-An-introduction-to-IL2CPP-internals%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2/"/>
      <url>2023/07/25/Unity3D-An-introduction-to-IL2CPP-internals%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2/</url>
      
        <content type="html"><![CDATA[<p> IL2CPP - Unity Technologies Blog</p><h1 id="An-introduction-to-IL2CPP-internals"><a href="#An-introduction-to-IL2CPP-internals" class="headerlink" title="An introduction to IL2CPP internals"></a>An introduction to IL2CPP internals</h1><p><a href="https://blogs.unity3d.com/author/josh/" target="_blank" rel="noopener" title="Posts by Josh Peterson">Josh Peterson</a>, May 6, 2015</p><p><a href="https://blogs.unity3d.com/category/technology/" target="_blank" rel="noopener">Technology</a></p><p><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fblogs.unity3d.com%2F2015%2F05%2F06%2Fan-introduction-to-ilcpp-internals%2F" target="_blank" rel="noopener"><br><img src="data:image/svg+xml,%3csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; version=&#39;1.1&#39; x=&#39;0&#39; y=&#39;0&#39; width=&#39;470.5&#39; height=&#39;470.5&#39; viewBox=&#39;0 0 470.5 470.5&#39; xml:space=&#39;preserve&#39; fill=&#39;rgb\(0%2c 0%2c 0\" alt=""><br>‘ data-evernote-id=’278’ class=’js-evernote-checked’%3e%3cstyle data-evernote-id=’279’ class=’js-evernote-checked’%3e.s0 %7b fill: rgb(0%2c 0%2c 0)%3b %7d%3c/style%3e %3cpath d=’M271.5 154.2v-40.5c0-6.1 0.3-10.8 0.8-14.1 0.6-3.3 1.9-6.6 3.9-9.9 2-3.2 5.2-5.5 9.7-6.7 4.5-1.2 10.4-1.9 17.9-1.9h40.5V0h-64.8c-37.5 0-64.4 8.9-80.8 26.7 -16.4 17.8-24.6 44-24.6 78.7v48.8h-48.5v81.1h48.5v235.3h97.4V235.3h64.8l8.6-81.1H271.5z’ fill=’rgb(0%2c 0%2c 0)‘ data-evernote-id=’280’ class=’js-evernote-checked’%3e%3c/path%3e%3c/svg%3e) </a><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fblogs.unity3d.com%2F2015%2F05%2F06%2Fan-introduction-to-ilcpp-internals%2F&amp;text=An+introduction+to+IL2CPP+internals&amp;via=unity3d" target="_blank" rel="noopener"><br><img src="data:image/svg+xml,%3csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; version=&#39;1.1&#39; x=&#39;0&#39; y=&#39;0&#39; width=&#39;450&#39; height=&#39;450&#39; viewBox=&#39;0 0 450 450&#39; xml:space=&#39;preserve&#39; fill=&#39;rgb\(0%2c 0%2c 0\" alt=""><br>‘ data-evernote-id=’282’ class=’js-evernote-checked’%3e%3cstyle data-evernote-id=’283’ class=’js-evernote-checked’%3e.s0 %7b fill: rgb(0%2c 0%2c 0)%3b %7d%3c/style%3e %3cpath d=’M450 85.7c-17.7 7.6-35.4 12.4-53.1 14.3 20-12 33.5-28.9 40.5-50.8 -18.3 10.8-37.8 18.3-58.5 22.3 -18.3-19.4-40.7-29.1-67.4-29.1 -25.5 0-47.2 9-65.2 27 -18 18-27 39.7-27 65.2 0 6.9 0.8 13.9 2.3 21.1 -37.7-1.9-73-11.4-106.1-28.4C82.5 110.2 54.4 87.5 31.4 59.1c-8.4 14.3-12.6 29.8-12.6 46.5 0 15.8 3.7 30.5 11.1 44 7.4 13.5 17.4 24.5 30 32.8 -14.8-0.6-28.7-4.5-41.7-11.7v1.1c0 22.3 7 41.8 21 58.7 14 16.8 31.6 27.5 53 31.8 -8 2.1-16.1 3.1-24.3 3.1 -5.3 0-11.1-0.5-17.4-1.4 5.9 18.5 16.8 33.6 32.5 45.5 15.8 11.9 33.7 18 53.7 18.4 -33.5 26.3-71.7 39.4-114.5 39.4 -8.2 0-15.6-0.4-22.3-1.1 42.8 27.6 90 41.4 141.6 41.4 32.7 0 63.5-5.2 92.2-15.6 28.7-10.4 53.3-24.3 73.7-41.7 20.4-17.4 37.9-37.4 52.7-60.1 14.8-22.7 25.7-46.3 33-70.9 7.2-24.7 10.8-49.3 10.8-74.1 0-5.3-0.1-9.3-0.3-12C421.8 120.2 437.2 104.3 450 85.7z’ fill=’rgb(0%2c 0%2c 0)‘ data-evernote-id=’284’ class=’js-evernote-checked’%3e%3c/path%3e%3c/svg%3e) </a><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fblogs.unity3d.com%2F2015%2F05%2F06%2Fan-introduction-to-ilcpp-internals%2F&amp;title=An+introduction+to+IL2CPP+internals&amp;summary=Almost+a+year+ago+now%2C+we+started+to+talk+about+the+future+of+scripting+in+Unity.+The+new+IL2CPP+scripting+backend+promised+to+bring+a+highly-performant%2C+highly-portable+virtual+machine+to+Unity.+In+January%2C+we+shipped+our+first+platform+using+IL2CPP%2C+iOS+64-bit.+The+Unity+5+release+brought+another+platform%2C+WebGL.+Thanks+to+the+input+from+%5B%26hellip%3B%5D&amp;source=Unity3d+Blog" target="_blank" rel="noopener"><br><img src="data:image/svg+xml,%3csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; version=&#39;1.1&#39; x=&#39;0&#39; y=&#39;0&#39; width=&#39;438.5&#39; height=&#39;438.5&#39; viewBox=&#39;0 0 438.5 438.5&#39; xml:space=&#39;preserve&#39; fill=&#39;rgb\(0%2c 0%2c 0\" alt=""><br>‘ data-evernote-id=’286’ class=’js-evernote-checked’%3e%3cstyle data-evernote-id=’287’ class=’js-evernote-checked’%3e.s0 %7b fill: rgb(0%2c 0%2c 0)%3b %7d%3c/style%3e %3crect x=’5.4’ y=’145.9’ width=’94.2’ height=’282.9’ fill=’rgb(0%2c 0%2c 0)‘ data-evernote-id=’288’ class=’js-evernote-checked’%3e%3c/rect%3e %3cpath d=’M408.8 171.7c-19.8-21.6-46-32.4-78.5-32.4 -12 0-22.9 1.5-32.7 4.4 -9.8 3-18.1 7.1-24.8 12.4 -6.8 5.3-12.1 10.3-16.1 14.8 -3.8 4.3-7.5 9.4-11.1 15.1v-40.2h-93.9l0.3 13.7c0.2 9.1 0.3 37.3 0.3 84.5 0 47.2-0.2 108.8-0.6 184.7h93.9V270.9c0-9.7 1-17.4 3.1-23.1 4-9.7 10-17.8 18.1-24.4 8.1-6.6 18.1-9.9 30.1-9.9 16.4 0 28.4 5.7 36.1 17 7.7 11.3 11.6 27 11.6 47V428.8h93.9V266.7C438.5 225 428.6 193.3 408.8 171.7zM53.1 9.7c-15.8 0-28.6 4.6-38.4 13.8C4.9 32.8 0 44.4 0 58.5c0 13.9 4.8 25.5 14.3 34.8 9.5 9.3 22.1 14 37.7 14h0.6c16 0 28.9-4.7 38.7-14 9.8-9.3 14.6-20.9 14.4-34.8 -0.2-14.1-5-25.7-14.6-35C81.6 14.3 68.9 9.7 53.1 9.7z’ fill=’rgb(0%2c 0%2c 0)‘ data-evernote-id=’289’ class=’js-evernote-checked’%3e%3c/path%3e%3c/svg%3e) </a></p><p>Almost a year ago now, we started to talk about the <a href="http://blogs.unity3d.com/2014/05/20/the-future-of-scripting-in-unity/" target="_blank" rel="noopener">future</a> of scripting in Unity. The new IL2CPP scripting backend promised to bring a highly-performant, highly-portable virtual machine to Unity. In January, we shipped our first platform using IL2CPP, <a href="http://blogs.unity3d.com/2015/01/29/unity-4-6-2-ios-64-bit-support/" target="_blank" rel="noopener">iOS 64-bit</a>. The Unity 5 release brought another platform, <a href="http://blogs.unity3d.com/2014/04/29/on-the-future-of-web-publishing-in-unity/" target="_blank" rel="noopener">WebGL</a>. Thanks to the input from our tremendous community of users, we have shipped many patch release <a href="http://blogs.unity3d.com/2015/04/07/weekly-ios-64-bit-and-metal-update/" target="_blank" rel="noopener">updates</a> for IL2CPP, steadily improving its compiler and runtime.</p><p>We have no plans to stop improving IL2CPP, but we thought it might be a good idea to take a step back and tell you a little bit about how IL2CPP works from the inside out. Over the next few months, we’re planning to write about the following topics (and maybe others) in this IL2CPP Internals series of posts:</p><ol><li>The basics – toolchain and command line arguments (this post)</li><li><a href="http://blogs.unity3d.com/2015/05/13/il2cpp-internals-a-tour-of-generated-code/" target="_blank" rel="noopener">A tour of generated code</a></li><li><a href="http://blogs.unity3d.com/2015/05/20/il2cpp-internals-debugging-tips-for-generated-code/" target="_blank" rel="noopener">Debugging tips for generated code</a></li><li><a href="http://blogs.unity3d.com/2015/06/03/il2cpp-internals-method-calls/" target="_blank" rel="noopener">Method calls</a> (normal methods, virtual methods, etc.)</li><li><a href="http://blogs.unity3d.com/2015/06/16/il2cpp-internals-generic-sharing-implementation" target="_blank" rel="noopener">Generic sharing implementation</a></li><li><a href="http://blogs.unity3d.com/2015/07/02/il2cpp-internals-pinvoke-wrappers/" target="_blank" rel="noopener">P/invoke wrappers for types and methods</a></li><li><a href="http://blogs.unity3d.com/2015/07/09/il2cpp-internals-garbage-collector-integration/" target="_blank" rel="noopener">Garbage collection integration</a></li><li><a href="http://blogs.unity3d.com/2015/07/20/il2cpp-internals-testing-frameworks/" target="_blank" rel="noopener">Testing frameworks and usage</a></li></ol><p>In order to make this series of posts possible, we’re going to discuss some details about the IL2CPP implementation that will surely change in the future. Hopefully we can still provide some useful and interesting information.</p><p><strong>What is IL2CPP?</strong></p><p>The technology that we refer to as IL2CPP has two distinct parts.</p><ul><li>•An ahead-of-time (AOT) compiler</li><li>•A runtime library to support the virtual machine</li></ul><p>The AOT compiler translates Intermediate Language (IL), the low-level output from .NET compilers, to C++ source code. The runtime library provides services and abstractions like a garbage collector, platform-independent access to threads and files, and implementations of internal calls (native code which modifies managed data structures directly).</p><p><strong>The AOT compiler</strong></p><p>The IL2CPP AOT compiler is named il2cpp.exe. On Windows you can find it in the Editor\Data\il2cpp directory. On OSX it is in the Contents/Frameworks/il2cpp/build directory in the Unity installation. The il2cpp.exe utility is a managed executable, written entirely in C#. We compile it with both .NET and Mono compilers during our development of IL2CPP.</p><p>The il2cpp.exe utility accepts managed assemblies compiled with the Mono compiler that ships with Unity and generates C++ code which we pass on to a platform-specific C++ compiler.</p><p>You can think about the IL2CPP toolchain like this:</p><p><a href="https://blogs.unity3d.com/wp-content/uploads/2015/04/il2cpp-toolchain-smaller.png" target="_blank" rel="noopener"><br><img src="assets/An%20introduction%20to%20IL2CPP%20internalsВведение%20в/il2cpp-toolchain-smaller.png" alt=""></a></p><p><strong>The runtime library</strong></p><p>The other part of the IL2CPP technology is a runtime library to support the virtual machine. We have implemented this library using almost entirely C++ code (it has a little bit of platform-specific assembly code, but let’s keep that between the two of us). We call the runtime library libil2cpp, and it is shipped as a static library linked into the player executable. One of the key benefits of the IL2CPP technology is this simple and portable runtime library.</p><p>You can find some clues about how the libil2cpp code is organized by looking at the header files for libil2cpp we ship with Unity (you’ll find them in the Editor\Data\PlaybackEngines\webglsupport\BuildTools\Libraries\libil2cpp\include directory on Windows, or the Contents/Frameworks/il2cpp/libil2cpp directory on OSX). For example, the interface between the C++ code generated by il2cpp.exe and the libil2cpp runtime is located in the codegen/il2cpp-codegen.h header file.</p><p>One key part of the runtime is the garbage collector. We’re shipping Unity 5 with <a href="https://github.com/ivmai/bdwgc/" target="_blank" rel="noopener">libgc</a>, the Boehm-Demers-Weiser garbage collector. However, libil2cpp has been designed to allow us to use other garbage collectors. For example, we are researching an integration of the Microsoft GC which was open-sourced as part of the CoreCLR. We’ll have more to say about this in our post about garbage collector integration later in the series.</p><p><strong>How is il2cpp.exe executed?</strong></p><p>Let’s take a look at an example. I’ll be using Unity 5.0.1 on Windows, and I’ll start with a new, empty project. So that we have at least one user script to convert, I’ll add this simple MonoBehaviour component to the Main Camera game object:</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>| </p><p>using UnityEngine;</p><p>public class HelloWorld : MonoBehaviour {</p><p>void Start () {</p><p>Debug.Log(“Hello, IL2CPP!”);</p><p>}</p><p>}  </p><p>—-|—-  </p><p>When I build for the WebGL platform, I can use <a href="https://technet.microsoft.com/en-us/sysinternals/bb896653.aspx" target="_blank" rel="noopener">Process Explorer</a> to see the command line Unity used to run il2cpp.exe:</p><p>1</p><p>| </p><p>“C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe” “C:\Program Files\Unity\Editor\Data\il2cpp/il2cpp.exe” --copy-level=None --enable-generic-sharing --enable-unity-event-support --output-format=Compact --extra-types.file=”C:\Program Files\Unity\Editor\Data\il2cpp\il2cpp_default_extra_types.txt” “C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\Assembly-CSharp.dll” “C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\UnityEngine.UI.dll” “C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\il2cppOutput”  </p><p>—-|—-  </p><p>That command line is pretty long and horrible, so let’s unpack it. First, Unity is running this executable:</p><p>1</p><p>| </p><p>“C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe”  </p><p>—-|—-  </p><p>The next argument on the command line is the il2cpp.exe utility itself.</p><p>1</p><p>| </p><p>“C:\Program Files\Unity\Editor\Data\il2cpp/il2cpp.exe”  </p><p>—-|—-  </p><p>The remaining command line arguments are passed to il2cpp.exe, not mono.exe. Let’s look at them. First, Unity passes five flags to il2cpp.exe:</p><ul><li>•–copy-level=None <ul><li>Specify that il2cpp.exe should not perform an special file copies of the generated C++ code.</li></ul></li><li>•–enable-generic-sharing <ul><li>This is a code and binary size reduction feature. IL2CPP will share the implementation of generic methods when it can.</li></ul></li><li>•–enable-unity-event-support <ul><li>Special support to ensure that code for Unity events, which are accessed via reflection, is correctly generated.</li></ul></li><li>•–output-format=Compact <ul><li>Generate C++ code in a format that requires fewer characters for type and method names. This code is difficult to debug, since the names in the IL code are not preserved, but it often compiles faster, since there is less code for the C++ compiler to parse.</li></ul></li><li>•–extra-types.file=”C:\Program Files\Unity\Editor\Data\il2cpp\il2cpp_default_extra_types.txt” <ul><li>Use the default (and empty) extra types file. This file can be added in a Unity project to let il2cpp.exe know which generic or array types will be created at runtime, but are not present in the IL code.</li></ul></li></ul><p>It is important to note that these command line arguments can and will be changed in later releases. We’re not at a point yet where we have a stable and supported set of command line arguments for il2cpp.exe.</p><p>Finally, we have a list of two files and one directory on the command line:</p><ul><li>•“C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\Assembly-CSharp.dll”</li><li>•“C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\UnityEngine.UI.dll”</li><li>•“C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\il2cppOutput”</li></ul><p>The il2cpp.exe utility accepts a list of all of the IL assemblies it should convert. In this case they are the assembly containing my simple MonoBehaviour, Assembly-CSharp.dll, and the GUI assembly, UnityEngine.UI.dll. Note that there are a few conspicuously missing assembles here. Clearly, my script references UnityEngine.dll, and that references at least mscorlib.dll, and maybe other assemblies. Where are they? Actually, il2cpp.exe resolves those assemblies internally. They can be mentioned on the command line, but they are not necessary. Unity only needs to mention the root assemblies (those which are not referenced by any other assembly) explicitly.</p><p>The last argument on the il2cpp.exe command line is the directory where the output C++ files should be created. If you are curious, have a look at the generated files in that directory, they will be the subject of the next post in this series. Before you do though, you might want to choose the “Development Player” option in the WebGL build settings. That will remove the –output-format=Compact command line argument and give you better type and method names in the generated C++ code.</p><p>Try changing various options in the WebGL or iOS Player Settings. You should be able to see different command line options passed to il2cpp.exe to enable different code generation steps. For example, changing the “Enable Exceptions” setting in the WebGL Player Settings to a value of “Full” adds the –emit-null-checks, –enable-stacktrace, and –enable-array-bounds-check arguments to the il2cpp.exe command line.</p><p><strong>What does IL2CPP not do?</strong></p><p>I’d like to point out one of the challenges that we did not take on with IL2CPP, and we could not be happier that we ignored it. We did not attempt to re-write the C# standard library with IL2CPP. When you build a Unity project which uses the IL2CPP scripting backend, all of the C# standard library code in mscorlib.dll, System.dll, etc. is the exact same code used for the Mono scripting backend.</p><p>We rely on C# standard library code that is already well-known by users and well-tested in Unity projects. So when we investigate a bug related to IL2CPP, we can be fairly confident that the bug is in either the AOT compiler or the runtime library, and nowhere else.</p><p><strong>How we develop, test, and ship IL2CPP</strong></p><p>Since the initial public release of IL2CPP at version 4.6.1p5 in January, we’ve shipped 6 full releases and 7 patch releases (across versions 4.6 and 5.0 of Unity). We have corrected more than 100 bugs mentioned in the release notes.</p><p>In order to make this continuous improvement happen, we develop against only one version of the IL2CPP code internally, which sits on the bleeding edge of the trunk branch in Unity used to ship alpha and beta releases. Just before each release, we port the IL2CPP changes to the specific release branch, run our tests, and verify all of the bugs we fixed are corrected in that version. Our QA and Sustained Engineering teams have done incredible work to make delivery at this rate possible. This means that our users are never more than about one week away from the latest fixes for IL2CPP bugs.</p><p>Our user community has proven invaluable by submitting many high quality bug reports. We appreciate all the feedback from our users to help continually improve IL2CPP, and we look forward to more of it.</p><p>The development team working on IL2CPP has a strong test-first mentality. We often employee Test Driven Design practices, and seldom merge a pull request without good tests. This strategy works well for a technology like IL2CPP, where we have clear inputs and outputs. It means that the vast majority of the bugs we see are not unexpected behavior, but rather unexpected cases (e.g. it is possible to use an 64-bit IntPtr as a 32-bit array index, causing clang to fail with a C++ compiler error, and <a href="http://forum.unity3d.com/threads/4-6-3-il2cpp-xcode-build-errors.299561/" target="_blank" rel="noopener">real code</a> actually does this!). That difference allows us to fix bugs quickly with a high degree of confidence.</p><p>With the help of our community, we’re working hard to make IL2CPP as stable and fast as possible. By the way, if any of this excites you, <a href="http://unity3d.com/jobs/position?id=oWfh0fwc" target="_blank" rel="noopener">we’re hiring</a> (just sayin’).</p><p><strong>More to come</strong></p><p>I fear that I’ve spent too much time here teasing future blog posts. We have a lot to say, and it simply won’t all fit in one post. Next time, we’ll dig into the code generated by il2cpp.exe to see how your project actually looks to the C++ compiler.</p><p><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fblogs.unity3d.com%2F2015%2F05%2F06%2Fan-introduction-to-ilcpp-internals%2F" target="_blank" rel="noopener"><br><img src="data:image/svg+xml,%3csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; version=&#39;1.1&#39; x=&#39;0&#39; y=&#39;0&#39; width=&#39;470.5&#39; height=&#39;470.5&#39; viewBox=&#39;0 0 470.5 470.5&#39; xml:space=&#39;preserve&#39; fill=&#39;rgb\(0%2c 0%2c 0\" alt=""><br>‘ data-evernote-id=’599’ class=’js-evernote-checked’%3e%3cstyle data-evernote-id=’600’ class=’js-evernote-checked’%3e.s0 %7b fill: rgb(0%2c 0%2c 0)%3b %7d%3c/style%3e %3cpath d=’M271.5 154.2v-40.5c0-6.1 0.3-10.8 0.8-14.1 0.6-3.3 1.9-6.6 3.9-9.9 2-3.2 5.2-5.5 9.7-6.7 4.5-1.2 10.4-1.9 17.9-1.9h40.5V0h-64.8c-37.5 0-64.4 8.9-80.8 26.7 -16.4 17.8-24.6 44-24.6 78.7v48.8h-48.5v81.1h48.5v235.3h97.4V235.3h64.8l8.6-81.1H271.5z’ fill=’rgb(0%2c 0%2c 0)‘ data-evernote-id=’601’ class=’js-evernote-checked’%3e%3c/path%3e%3c/svg%3e) </a><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fblogs.unity3d.com%2F2015%2F05%2F06%2Fan-introduction-to-ilcpp-internals%2F&amp;text=An+introduction+to+IL2CPP+internals&amp;via=unity3d" target="_blank" rel="noopener"><br><img src="data:image/svg+xml,%3csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; version=&#39;1.1&#39; x=&#39;0&#39; y=&#39;0&#39; width=&#39;450&#39; height=&#39;450&#39; viewBox=&#39;0 0 450 450&#39; xml:space=&#39;preserve&#39; fill=&#39;rgb\(0%2c 0%2c 0\" alt=""><br>‘ data-evernote-id=’603’ class=’js-evernote-checked’%3e%3cstyle data-evernote-id=’604’ class=’js-evernote-checked’%3e.s0 %7b fill: rgb(0%2c 0%2c 0)%3b %7d%3c/style%3e %3cpath d=’M450 85.7c-17.7 7.6-35.4 12.4-53.1 14.3 20-12 33.5-28.9 40.5-50.8 -18.3 10.8-37.8 18.3-58.5 22.3 -18.3-19.4-40.7-29.1-67.4-29.1 -25.5 0-47.2 9-65.2 27 -18 18-27 39.7-27 65.2 0 6.9 0.8 13.9 2.3 21.1 -37.7-1.9-73-11.4-106.1-28.4C82.5 110.2 54.4 87.5 31.4 59.1c-8.4 14.3-12.6 29.8-12.6 46.5 0 15.8 3.7 30.5 11.1 44 7.4 13.5 17.4 24.5 30 32.8 -14.8-0.6-28.7-4.5-41.7-11.7v1.1c0 22.3 7 41.8 21 58.7 14 16.8 31.6 27.5 53 31.8 -8 2.1-16.1 3.1-24.3 3.1 -5.3 0-11.1-0.5-17.4-1.4 5.9 18.5 16.8 33.6 32.5 45.5 15.8 11.9 33.7 18 53.7 18.4 -33.5 26.3-71.7 39.4-114.5 39.4 -8.2 0-15.6-0.4-22.3-1.1 42.8 27.6 90 41.4 141.6 41.4 32.7 0 63.5-5.2 92.2-15.6 28.7-10.4 53.3-24.3 73.7-41.7 20.4-17.4 37.9-37.4 52.7-60.1 14.8-22.7 25.7-46.3 33-70.9 7.2-24.7 10.8-49.3 10.8-74.1 0-5.3-0.1-9.3-0.3-12C421.8 120.2 437.2 104.3 450 85.7z’ fill=’rgb(0%2c 0%2c 0)‘ data-evernote-id=’605’ class=’js-evernote-checked’%3e%3c/path%3e%3c/svg%3e) </a><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fblogs.unity3d.com%2F2015%2F05%2F06%2Fan-introduction-to-ilcpp-internals%2F&amp;title=An+introduction+to+IL2CPP+internals&amp;summary=Almost+a+year+ago+now%2C+we+started+to+talk+about+the+future+of+scripting+in+Unity.+The+new+IL2CPP+scripting+backend+promised+to+bring+a+highly-performant%2C+highly-portable+virtual+machine+to+Unity.+In+January%2C+we+shipped+our+first+platform+using+IL2CPP%2C+iOS+64-bit.+The+Unity+5+release+brought+another+platform%2C+WebGL.+Thanks+to+the+input+from+%5B%26hellip%3B%5D&amp;source=Unity3d+Blog" target="_blank" rel="noopener"><br><img src="data:image/svg+xml,%3csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; version=&#39;1.1&#39; x=&#39;0&#39; y=&#39;0&#39; width=&#39;438.5&#39; height=&#39;438.5&#39; viewBox=&#39;0 0 438.5 438.5&#39; xml:space=&#39;preserve&#39; fill=&#39;rgb\(0%2c 0%2c 0\" alt=""><br>‘ data-evernote-id=’607’ class=’js-evernote-checked’%3e%3cstyle data-evernote-id=’608’ class=’js-evernote-checked’%3e.s0 %7b fill: rgb(0%2c 0%2c 0)%3b %7d%3c/style%3e %3crect x=’5.4’ y=’145.9’ width=’94.2’ height=’282.9’ fill=’rgb(0%2c 0%2c 0)‘ data-evernote-id=’609’ class=’js-evernote-checked’%3e%3c/rect%3e %3cpath d=’M408.8 171.7c-19.8-21.6-46-32.4-78.5-32.4 -12 0-22.9 1.5-32.7 4.4 -9.8 3-18.1 7.1-24.8 12.4 -6.8 5.3-12.1 10.3-16.1 14.8 -3.8 4.3-7.5 9.4-11.1 15.1v-40.2h-93.9l0.3 13.7c0.2 9.1 0.3 37.3 0.3 84.5 0 47.2-0.2 108.8-0.6 184.7h93.9V270.9c0-9.7 1-17.4 3.1-23.1 4-9.7 10-17.8 18.1-24.4 8.1-6.6 18.1-9.9 30.1-9.9 16.4 0 28.4 5.7 36.1 17 7.7 11.3 11.6 27 11.6 47V428.8h93.9V266.7C438.5 225 428.6 193.3 408.8 171.7zM53.1 9.7c-15.8 0-28.6 4.6-38.4 13.8C4.9 32.8 0 44.4 0 58.5c0 13.9 4.8 25.5 14.3 34.8 9.5 9.3 22.1 14 37.7 14h0.6c16 0 28.9-4.7 38.7-14 9.8-9.3 14.6-20.9 14.4-34.8 -0.2-14.1-5-25.7-14.6-35C81.6 14.3 68.9 9.7 53.1 9.7z’ fill=’rgb(0%2c 0%2c 0)‘ data-evernote-id=’610’ class=’js-evernote-checked’%3e%3c/path%3e%3c/svg%3e) </a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Animation优化</title>
      <link href="2023/07/25/Unity3D-Animation%E4%BC%98%E5%8C%96/"/>
      <url>2023/07/25/Unity3D-Animation%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>标签：</strong>|  <em>优化</em>  </p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><ol><li><p>Rig-&gt;Animation Type:改为Generic</p></li><li><p>Animations-&gt;Anim.Compression:Optimal</p></li><li><p>其他高级方式</p></li></ol><h2 id="曲线数据存储与压缩"><a href="#曲线数据存储与压缩" class="headerlink" title="曲线数据存储与压缩"></a>曲线数据存储与压缩</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><h4 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream(流)"></a>Stream(流)</h4><p>Use the “stream” method of storing data (values with time and tangent data for curved interpolation).<br>（保留时间和切线数据进行 <strong>曲线插值</strong> ）<br>This data occupies significantly <strong>more memory</strong> than the “dense” method.</p><blockquote><p>Streaming curves are very fast to decompress in the average use case.</p></blockquote><h4 id="Dense-密集的"><a href="#Dense-密集的" class="headerlink" title="Dense(密集的)"></a>Dense(密集的)</h4><p>Optimize animation curves using the “dense” method of storing data (discrete values which are interpolated between linearly).<br>（离散数值之间的 <strong>线性差值</strong> ）<br>不含有切线数据，使用较少内存<br>This method uses less significantly less memory than the “stream” method.<br>与“流”方法相比，此方法使用的内存要少得多。</p><h4 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h4><p>Curves are optimised as constant (unchanging) values.<br>Unity selects this automatically if your animation files contain curves with unchanging values.</p><h3 id="Compression方式"><a href="#Compression方式" class="headerlink" title="Compression方式"></a>Compression方式</h3><p>Unity引擎对导入的Clip提供三种压缩格式，Off、KeyframeReduction和Optimal。其中Off表示不压缩，Keyframe Reduction表示使用关键帧进行处理，Optimal则表示Unity引擎会根据动画曲线的特点来自动选择一个最优的压缩方式。</p><h4 id="Off"><a href="#Off" class="headerlink" title="Off"></a>Off</h4><p>存储方式：Stream</p><p>不压缩，官方不推荐</p><blockquote><p>Unity文档: This means that Unity doesn’t reduce keyframe count on import. Disabling animation compression leads to the highest precision animations, but slower performance and bigger file and runtime memory size. It is generally not advisable to use this option - if you need higher precision animation, you should enable keyframe reduction and lower allowed Animation Compression Error values instead.</p></blockquote><h4 id="Keyframe-Reduction"><a href="#Keyframe-Reduction" class="headerlink" title="Keyframe Reduction"></a>Keyframe Reduction</h4><p>存储方式：Stream<br>压缩方式：关键帧缩减算法</p><h5 id="Keyframe-Reduction算法"><a href="#Keyframe-Reduction算法" class="headerlink" title="Keyframe Reduction算法"></a>Keyframe Reduction算法</h5><p>Basically key frame reduction will simply <strong>go through all key frames in your animation, and evaluate the animation curves with and without that key, and if the difference is smaller then some defined delta, the key is removed.</strong></p><p><strong>error tolerance(误差宽容度，容错值)</strong> 或者称为 <strong>error threshold(误差阈值)</strong><br>值越小动画的精度越高，如果默认值的表现效果不过好，可以通过减小容错值来调。</p><ul><li><p>Rotation Error 角度值</p></li><li><p>Position Error 百分比值</p></li><li><p>Scale Error 百分比值</p></li></ul><p>Unity compares the original curve to what the curve looks like after removing a specific keyframe and applies this test：<br>OriginalValue - ReducedValue &gt; OriginalValue * percentageOfError<br>Unity removes a keyframe if the delta between the original value and the reduced value is less than the original value multiplied by the error tolerance percentage.</p><h4 id="Optimal"><a href="#Optimal" class="headerlink" title="Optimal"></a>Optimal</h4><p>存储方式：(Unity官方)Unity will use a heuristic algorithm to determine whether it is best to use the <strong>dense</strong> or <strong>stream</strong> method to store the data for each curve.<br>(笔者推测，可能对于unchanging的值做优化处理，使用constant方式存储)<br>压缩方式：Unity decide how to compress, either by <strong>keyframe reduction</strong> or by using <strong>dense format</strong>.</p><p>If a track is very short or very noisy (which could happen with motion capture clips or baked simulations), the key reduction algorithm might not give appreciable gains and it is possible that a dense curve might end up having a smaller memory footprint than a streaming curve. </p><blockquote><p>Unity官方：<br> If your animation clips are imported with “Anim Compression” set to “Optimal” in the Animation import reference, Unity will use a heuristic（启发式的） algorithm to determine whether it is best to use the <strong>dense</strong> or <strong>stream</strong> method to <strong>store the data for each curve</strong>.</p></blockquote><h3 id="UWA性能对比实验"><a href="#UWA性能对比实验" class="headerlink" title="UWA性能对比实验"></a>UWA性能对比实验</h3><p><a href="https://blog.uwa4d.com/archives/Loading_AnimationClip.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Loading_AnimationClip.html</a></p><ol><li><p>Optimal压缩方式确实可以提升资源的加载效率，无论是在高端机、中端机还是低端机上；</p></li><li><p>硬件设备性能越好，其加载效率越高。但随着设备的提升，Keyframe Reduction和Optimal的加载效率提升已不十分明显；</p></li><li><p>Optimal压缩方式可能会降低动画的视觉质量，因此，是否最终选择Optimal压缩模式，还需根据最终视觉效果的接受程度来决定。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从性能的角度来看，Optimal的方式内存占用是最低的，是我们最推荐的方案，但是可能会降低动画的视觉质量。Off是不压缩，Unity官方都不推荐的。Keyframe Reduction内存稍高于Optimal，在内存性能和效果上算是折中的方案，用户手动设置Keyframe Reduction问题不大。</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="1-去掉AnimationClip中的无效曲线：例如ScaleCurve"><a href="#1-去掉AnimationClip中的无效曲线：例如ScaleCurve" class="headerlink" title="1. 去掉AnimationClip中的无效曲线：例如ScaleCurve"></a>1. 去掉AnimationClip中的无效曲线：例如ScaleCurve</h3><pre><code class="lang-csharp">using UnityEngine; using UnityEditor; using System.Collections.Generic; public class RemoveCurve : AssetPostprocessor{ void OnPostprocessModel(GameObject g){ Apply(g); } void Apply(GameObject g){ List&lt;AnimationClip&gt; animationClipList = new List&lt;AnimationClip&gt;(AnimationUtility.GetAnimationClips(g)); if (animationClipList.Count == 0) { AnimationClip[] objectList = UnityEngine.Object.FindObjectsOfType(typeof(AnimationClip)) as AnimationClip[]; animationClipList.AddRange(objectList); } foreach (AnimationClip theAnimation in animationClipList) { foreach (EditorCurveBinding theCurveBinding in AnimationUtility.GetCurveBindings(theAnimation)) { string name = theCurveBinding.propertyName.ToLower(); if (name.Contains(&quot;scale&quot;)) { AnimationUtility.SetEditorCurve(theAnimation, theCurveBinding, null); } } } } }</code></pre><h3 id="2-压缩AnimationClip文件float的精度"><a href="#2-压缩AnimationClip文件float的精度" class="headerlink" title="2. 压缩AnimationClip文件float的精度"></a>2. 压缩AnimationClip文件float的精度</h3><pre><code class="lang-csharp">public static bool CompressAnimationClip(Object o){ string animationPath = AssetDatabase.GetAssetPath(o); try{ //AnimationClip clip = GameObject.Instantiate(o) as AnimationClip;AnimationClip clip = o as AnimationClip; AnimationClipCurveData[] curves = null; curves = AnimationUtility.GetAllCurves(clip); Keyframe key; Keyframe[] keyFrames; for (int ii = 0; ii &lt; curves.Length; ++ii) { AnimationClipCurveData curveDate = curves[ii]; if (curveDate.curve == null || curveDate.curve.keys == null) { //Debug.LogWarning(string.Format(&quot;AnimationClipCurveData {0} don&#39;t have curve; Animation name {1} &quot;, curveDate, animationPath));continue; } keyFrames = curveDate.curve.keys; for (int i = 0; i &lt; keyFrames.Length; i++) { key = keyFrames[i]; key.value = float.Parse(key.value.ToString(&quot;f3&quot;)); key.inTangent = float.Parse(key.inTangent.ToString(&quot;f3&quot;)); key.outTangent = float.Parse(key.outTangent.ToString(&quot;f3&quot;)); keyFrames[i] = key; } curveDate.curve.keys = keyFrames; clip.SetCurve(curveDate.path, curveDate.type, curveDate.propertyName, curveDate.curve); } //AssetDatabase.CreateAsset(clip, animationPath);Debug.Log(string.Format(&quot; CompressAnimationClip {0} Success !!!&quot;, animationPath)); return true; } catch(Exception e) { Debug.LogError(string.Format(&quot;CompressAnimationClip Failed !!! animationPath : {0} error: {1}&quot;, animationPath, e)); return false; } }</code></pre><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><h3 id="optimize-gameobject"><a href="#optimize-gameobject" class="headerlink" title="optimize gameobject"></a>optimize gameobject</h3><p>针对Mecinam新版动画系统的优化选项，默认情况下会将动画网格下的所有骨骼结点隐藏，但是，你可以通过“Extra Transform to Expose”查看你想通过脚本获取的骨骼结点，这样既可以提升该角色的动画模块性能，又可以达到获取某个关键结点的需求。不过这种方式获得的骨骼节点是只读的，如果想要对其中的属性进行改变比如换装，就不可以开启这个选项。</p><h3 id="multithreaded-rendering"><a href="#multithreaded-rendering" class="headerlink" title="multithreaded rendering"></a>multithreaded rendering</h3><p>多线程渲染，将主线程的一部分渲染工作移到另一个线程里执行，Android平台下才有的优化渲染设置，但是对半透明物体支持不好，项目中需要进行测试来决定开不开启。</p><h3 id="Animation-Type"><a href="#Animation-Type" class="headerlink" title="Animation Type"></a>Animation Type</h3><p>Legacy Generic Humaniod<br>Legacy 老版动画系统<br>Generic 适合非人型动画<br>Humaniod 适合人型动画，可以动画重定向<br>cpu耗时 Generic &lt; Humanoid<br>Humanoid更省内存</p><h3 id="Apply-Root-Motion"><a href="#Apply-Root-Motion" class="headerlink" title="Apply Root Motion"></a>Apply Root Motion</h3><p>增加CPU计算量，不建议开启。如果要开启，建议勾上optimize gameobject。</p><h3 id="AnimationBlend"><a href="#AnimationBlend" class="headerlink" title="AnimationBlend"></a>AnimationBlend</h3><p>指的是混合树，多层动画，动画状态过渡三个方面。<br>会增加ProcessAnimations的开销<br>避免频繁blend<br>替换不必要的blend tree和layers</p><h3 id="Bake-Mesh"><a href="#Bake-Mesh" class="headerlink" title="Bake Mesh"></a>Bake Mesh</h3><p>将Skinned Mesh转换为普通的Mesh，运行时从网格中获取对应的网格数据进行渲染。<br>缺点：需要记录Mesh信息，占用大量内存。</p><h3 id="GPU-Skinning"><a href="#GPU-Skinning" class="headerlink" title="GPU Skinning"></a>GPU Skinning</h3><p>用GPU计算网格，<br>优点：<br>减少SkinnedMesh.Render的CPU耗时<br>骨骼结点信息通过纹理来存储，数据量较Bake Mesh会大幅降低<br>缺点：<br>增加GPU消耗，<br>要求DIrectX 11或者Opengl ES 3.0</p><h3 id="简化骨骼名字"><a href="#简化骨骼名字" class="headerlink" title="简化骨骼名字"></a>简化骨骼名字</h3><p>unity的动画数据存储的时候按每个骨骼节点的轨道拆分存储的，每个骨骼存储的是从根节点到这个骨骼节点的hierarchy路径，字符串的，骨骼多了之后这部分字符串不少。如果把所有骨骼名字都简化，这里可以省不少内存 </p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://nfrechette.github.io/2017/01/30/anim_compression_unity5/" target="_blank" rel="noopener">http://nfrechette.github.io/2017/01/30/anim_compression_unity5/</a><br><a href="http://www.manew.com/thread-103127-1-1.html" target="_blank" rel="noopener">http://www.manew.com/thread-103127-1-1.html</a><br><a href="https://blog.csdn.net/alexander_xfl/article/details/66975570" target="_blank" rel="noopener">https://blog.csdn.net/alexander_xfl/article/details/66975570</a><br><a href="https://blog.csdn.net/j756915370/article/details/79415841" target="_blank" rel="noopener">https://blog.csdn.net/j756915370/article/details/79415841</a><br><a href="https://blog.uwa4d.com/archives/Loading_AnimationClip.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Loading_AnimationClip.html</a><br><a href="http://www.360doc.com/content/17/0424/15/6432946_648246543.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/0424/15/6432946_648246543.shtml</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-3  Unity3D_index</title>
      <link href="2023/07/25/Unity3D-4-3-Unity3D-index/"/>
      <url>2023/07/25/Unity3D-4-3-Unity3D-index/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="【内存】PSS内存组成.html">【内存】PSS内存组成</a></li><li><a href="优化知识点链接收藏.html">优化知识点链接收藏</a></li><li><a href="Mesh%20in%20U3D\(ToUpdate\">Mesh in U3D(ToUpdate)</a>.html)</li><li><a href="【资源】Asset%20Bundle\(2020-10-25%20022900\">【资源】Asset Bundle(2020-10-25 02:29:00)</a>.html)</li><li><a href="【疑难问题处理】异常捕获与处理.html">【疑难问题处理】异常捕获与处理</a></li><li><a href="UGUI.html">UGUI</a></li><li><a href="Unity%20Addressasble.html">Unity Addressasble</a></li><li><a href="NavMesh.html">NavMesh</a></li><li><a href="Draw%20Call与Batching\(TODO\">Draw Call与Batching(TODO)</a>.html)</li><li><a href="Unity中Culling相关技术.html">Unity中Culling相关技术</a></li><li><a href="Unity相关Culling知识.html">Unity相关Culling知识</a></li><li><a href="Unity的渲染顺序.html">Unity的渲染顺序</a></li><li><a href="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协.html">从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协程、异步执行究竟有什么关系？</a></li><li><a href="Unity渲染相关API.html">Unity渲染相关API</a></li><li><a href="Project%20Settings与优化相关知识点.html">Project Settings与优化相关知识点</a></li><li><a href="【动画】Unity动画系统.html">【动画】Unity动画系统</a></li><li><a href="【动画】Animator%20%26%20ApplyRootMotion.html">【动画】Animator &amp; ApplyRootMotion</a></li><li><a href="CubeMap%20%26%20Skybox.html">CubeMap &amp; Skybox</a></li><li><a href="Unity中的Texture相关知识\(To%20Update\">Unity中的Texture相关知识(To Update)</a>.html)</li><li><a href="【Editor%20Extension】IMGUI.html">【Editor Extension】IMGUI</a></li><li><a href="Windows与MacOS在U3D项目中的使用.html">Windows与MacOS在U3D项目中的使用</a></li><li><a href="CSharp调用Java%26与Android交互.html">CSharp调用Java&amp;与Android交互</a></li><li><a href="Graphics%20-%20Tier%20Settings%20%26%20Quality%20Level.html">Graphics - Tier Settings &amp; Quality Level</a></li><li><a href="UPM自定义资源包及相关规范.html">UPM自定义资源包及相关规范</a></li><li><a href="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题.html">实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题</a></li><li><a href="U3D资源优化（零碎）知识点汇总.html">U3D资源优化（零碎）知识点汇总</a></li><li><a href="Animation优化.html">Animation优化</a></li><li><a href="0.0%20Unity与Mono和.NET的关系.html">0.0 Unity与Mono和.NET的关系</a></li><li><a href="A计划.html">A计划</a></li><li><a href="研究Unity引擎的技巧.html">研究Unity引擎的技巧</a></li><li><a href="Unity场景管理和切换.html">Unity场景管理和切换</a></li><li><a href="Profiler使用技巧.html">Profiler使用技巧</a></li><li><a href="资源路径与文件加载.html">资源路径与文件加载</a></li><li><a href="资源与内存\(加载、卸载、Destroy\">资源与内存(加载、卸载、Destroy)</a>.html)</li><li><a href="Unity大气散射.html">Unity大气散射</a></li><li><a href="小知识点与小工具.html">小知识点与小工具</a></li><li><a href="编辑器扩展.html">编辑器扩展</a></li><li><a href="An%20introduction%20to%20IL2CPP%20internalsВведение%20в.html">An introduction to IL2CPP internalsВведение в IL2CPP - Unity Technologies Blog</a></li><li><a href="获取场景点数和面数.html">获取场景点数和面数</a></li><li><a href="Unity控制程序停止运行.html">Unity控制程序停止运行</a></li><li><a href="Unity%26C预处理指令.html">Unity&amp;C#预处理指令</a></li><li><a href="Unity中的路径获取.html">Unity中的路径获取</a></li><li><a href="GPU和CPU的区别.html">GPU和CPU的区别</a></li><li><a href="出错汇总.html">出错汇总</a></li><li><a href="【内存】内存底层深入.html">【内存】内存底层深入</a></li><li><a href="【内存】Unity内存组成.html">【内存】Unity内存组成</a></li><li><a href="Unity%20Native%20Programming（C与C++互相调用）.html">Unity Native Programming（C#与C++互相调用）</a></li><li><a href="Atlas\(图集\">Atlas(图集)</a>.html)</li><li><a href="资源管理工具.html">资源管理工具</a></li><li><a href="ScriptableObject.html">ScriptableObject</a></li><li><a href="强哥UI课.html">强哥UI课</a></li><li><a href="0.1_Unity%20%20Profiler.html">0.1_Unity Profiler</a></li><li><a href="关于脚本的生命周期、函数的执行顺序.html">关于脚本的生命周期、函数的执行顺序</a></li><li><a href="0.2_IL2CPP，%20IL2CPP%20VM.html">0.2_IL2CPP， IL2CPP VM</a></li><li><a href="00_实用插件、工具、网站整理.html">00_实用插件、工具、网站整理</a></li><li><a href="Assembly%20Definition%20File%20%26%20Package%20Manager.html">Assembly Definition File &amp; Package Manager</a></li><li><a href="LUA相关.html">LUA相关</a></li><li><a href="GPU%20Skinning.html">GPU Skinning</a></li><li><a href="0.2_IL2CPP.html">0.2_IL2CPP</a></li><li><a href="BatchMode.html">BatchMode</a></li><li><a href="Destroy.html">Destroy</a></li><li><a href="0.1_Android内存管理.html">0.1_Android内存管理</a></li><li><a href="一些属性.html">一些属性</a></li><li><a href="Overdraw.html">Overdraw</a></li><li><a href="DrawCall.html">DrawCall</a></li><li><a href="序列化与反序列化.html">序列化与反序列化</a></li><li><a href="Collider.html">Collider</a></li><li><a href="”游戏程序员核心竞争力“问题总结.html">”游戏程序员核心竞争力“问题总结</a></li><li><a href="Unity的架构.html">Unity的架构</a></li><li><a href="Assets,%20Resources%20and%20AssetBundles%20-%20Unity%20Le.html">Assets, Resources and AssetBundles - Unity Learn</a></li><li><a href="【转载】RenderTexture及其用途.html">【转载】RenderTexture及其用途</a></li><li><a href="Shader变体相关知识与优化.html">Shader变体相关知识与优化</a></li><li><a href="Skinned%20Mesh%20Renderer.html">Skinned Mesh Renderer</a></li><li><a href="Image%20%26%20Raw%20Image.html">Image &amp; Raw Image</a></li><li><a href="Unity线上技术大会.html">Unity线上技术大会</a></li><li><a href="Camera%20%26%20Screen.html">Camera &amp; Screen</a></li><li><a href="Map及其与Material、Texture的关系.html">Map及其与Material、Texture的关系</a></li><li><a href="Material.html">Material</a></li><li><a href="Audio.html">Audio</a></li><li><a href="U3D工具链积累.html">U3D工具链积累</a></li><li><a href="YAML.html">YAML</a></li><li><a href="Unity%20Crash%20与%20符号表.html">Unity Crash 与 符号表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00_实用插件、工具、网站整理</title>
      <link href="2023/07/25/Unity3D-00-%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/"/>
      <url>2023/07/25/Unity3D-00-%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ol><li><p>网格变换与优化：</p><ol><li><p>Low Poly Mesh Generator 将场景网格变为低多边形风格 <a href="https://www.assetstore.unity3d.com/en/#!/content/59295" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/59295</a></p></li><li><p>Per-Vertex Ambient Occlusion And Indirect Lighting Generator 快速逐顶点生成环境光遮蔽与间接光照 <a href="https://www.assetstore.unity3d.com/en/#!/content/46880" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/46880</a></p></li><li><p>Mesh Materializer 改变场景风格的工具 Flat Mesh Generator及Ambient Occlusion And Indirect Lighting工具，另外还带有用于将地形转换为网格的Terrain To Mesh、调整顶点颜色的Vertex Color Adjustments、网格资源优化器以及计算网格厚度的烘焙工具。以上所有工具都同时支持编辑器模式及运行模式。<a href="https://www.assetstore.unity3d.com/en/#!/content/28583" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/28583</a></p></li><li><p><a href="https://blog.csdn.net/hebirechenai/category_6673178.html" target="_blank" rel="noopener">https://blog.csdn.net/hebirechenai/category_6673178.html</a> Mesh编程专栏</p></li><li><p><a href="https://blog.csdn.net/nanggong/article/details/85050343" target="_blank" rel="noopener">https://blog.csdn.net/nanggong/article/details/85050343</a> Mesh绘制点云</p></li></ol></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.2_IL2CPP， IL2CPP VM</title>
      <link href="2023/07/25/Unity3D-0-2-IL2CPP%EF%BC%8C-IL2CPP-VM/"/>
      <url>2023/07/25/Unity3D-0-2-IL2CPP%EF%BC%8C-IL2CPP-VM/</url>
      
        <content type="html"><![CDATA[<h1 id="0-2IL2CPP，-IL2CPP-VM"><a href="#0-2IL2CPP，-IL2CPP-VM" class="headerlink" title="0.2IL2CPP， IL2CPP VM"></a>0.2IL2CPP， IL2CPP VM</h1><p>IL to CPP : 把IL中间语言转换成CPP文件</p><h2 id="IL2CPP的出现意义"><a href="#IL2CPP的出现意义" class="headerlink" title="IL2CPP的出现意义"></a>IL2CPP的出现意义</h2><ol><li><p>Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成<br>Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，像Unity这样支持多平台的引擎，Mono官方的VM肯定是不能满足需求的。所以针对不同的新平台，Unity的项目组就要把VM给移植一遍，同时解决VM里面发现的bug。这非常耗时耗力。这些能移植的平台还好说，还有比如WebGL这样基于浏览器的平台。要让WebGL支持Mono的VM几乎是不可能的。</p></li><li><p>Mono版本授权受限<br>大家有没有意识到Mono的版本已经更新到3.X了，但是在Unity中，C#的运行时版本一直停留在2.8，这也是Unity社区开发者抱怨的最多一 条：很多C#的新特性无法使用。这是因为Mono授权受限，导致Unity无法升级Mono。如果换做是IL2CPP，IL2CPP VM这套完全自己开发的组件，就解决了这个问题。</p></li><li><p>提高运行效率<br>根据官方的实验数据，换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p></li><li><p>可以利用现成的在各个平台的C++编译器对代码执行编译期优化，这样可以进一步减小最终游戏的尺寸并提高游戏运行速度。</p></li></ol><h2 id="IL2CPP与Mono"><a href="#IL2CPP与Mono" class="headerlink" title="IL2CPP与Mono"></a>IL2CPP与Mono</h2><p>Mono</p><p><img src="assets/0.2_IL2CPP，%20IL2CPP%20VM/1591264208473.png" alt="Mono编译运行结构"></p><p>IL2CPP</p><p><img src="assets/0.2_IL2CPP，%20IL2CPP%20VM/1591264524127.png" alt="Alt text"></p><p>在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</p><h2 id="IL2CPP-VM"><a href="#IL2CPP-VM" class="headerlink" title="IL2CPP VM"></a>IL2CPP VM</h2><p>通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 IL2CPP VM的原因：它负责提供诸如 <strong>GC管理</strong> ， <strong>线程创建</strong> 这类的服务性工作。但是由于去除了IL加载和动态解析的工作，使得IL2CPP VM可以做的很小，并且使得 <strong>游戏载入时间缩短</strong> 。</p><h2 id="AOT方式"><a href="#AOT方式" class="headerlink" title="AOT方式"></a>AOT方式</h2><p>由于C++是一门静态语言，这就意味着我们不能使用动态语言的那些酷炫特性。运行时生 成代码并执行肯定是不可能了。这就是Unity里面提到的所谓AOT（Ahead Of Time，运行前编译）编译而非JIT（Just In Time）编译。其实很多平台出于安全的考虑是不允许JIT的，大家最熟悉的有iOS平台，在Console游戏机上，不管是微软的Xbox360， XboxOne，还是Sony的PS3，PS4，PSV，没有一个是允许JIT的。使用了IL2CPP，就完全是AOT方式了，如果原来使用了动态特性的 代码肯定会编译失败。这些代码在编译iOS平台的时候天生也会失败，所以如果你是为iOS开发的游戏代码，就不用担心了。因此就这点而言，我们开发上几乎 不会感到什么问题。</p><h3 id="JIT优点："><a href="#JIT优点：" class="headerlink" title="JIT优点："></a>JIT优点：</h3><p>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）<br>可以根据当前程序的运行情况生成最优的机器指令序列<br>当程序需要支持动态链接时，只能使用JIT<br>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</p><h3 id="JIT缺点："><a href="#JIT缺点：" class="headerlink" title="JIT缺点："></a>JIT缺点：</h3><p>编译需要占用运行时资源，会导致进程卡顿<br>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡<br>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</p><h3 id="AOT优点："><a href="#AOT优点：" class="headerlink" title="AOT优点："></a>AOT优点：</h3><p>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗<br>可以在程序运行初期就达到最高性能<br>可以显著的加快程序的启动</p><h3 id="AOT缺点："><a href="#AOT缺点：" class="headerlink" title="AOT缺点："></a>AOT缺点：</h3><p>在程序运行前编译会使程序安装的时间增加<br>牺牲Java的一致性<br>将提前编译的内容保存会占用更多的外</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://zhuanlan.zhihu.com/indieace" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/indieace</a><br>IL2CPP怎么用：<a href="https://zhuanlan.zhihu.com/p/19972666" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19972666</a><br>IL2CPP深入讲解：<br><a href="https://zhuanlan.zhihu.com/p/20063880" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20063880</a><br><a href="https://zhuanlan.zhihu.com/p/20207712" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20207712</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/19972689" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19972689</a><br>via IndieACE</p><p><a href="https://www.cnblogs.com/linghu-java/p/10577515.html" target="_blank" rel="noopener">https://www.cnblogs.com/linghu-java/p/10577515.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.2_IL2CPP</title>
      <link href="2023/07/25/Unity3D-0-2-IL2CPP/"/>
      <url>2023/07/25/Unity3D-0-2-IL2CPP/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IL2CPP 是 Unity 自 4.6.1p5版本 提出的一种新的 scripting backend 方式，为Unity提供了更加高效、更加便携的虚拟机。<br>IL2CPP (Intermediate Language To C++) is a Unity-developed scripting backend<br>which you can use as an alternative to Mono when building projects for various platforms. When building a project using IL2CPP, Unity converts IL code from scripts<br>and assemblies to C++, before creating a native binary file (.exe, apk, .xap, for example) for your chosen platform.</p><ul><li><p>increasing the performance</p><ul><li><p>security</p></li><li><p>platform compatibility</p></li></ul></li></ul><blockquote><p>Scripting backend is a framework that powers scripting in Unity( 支持脚本的框架 ). </p></blockquote><p>IL2CPP分为两个独立的部分：</p><ul><li><p>AOT编译器<br>AOT编译器将 IL（由.Net编译器输出的中间语言）转换为C++源码</p></li><li><p>运行时库<br>运行时库则会提供诸如 <strong>垃圾回收</strong> 、 <strong>线程/文件获取</strong> （独立于平台，与平台无关）、 <strong>内部调用直接修改托管数据结构的原生代码</strong> 的服务与抽象。</p></li></ul><h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><p>AOT(Ahead Of Time)(运行前编译，静态编译)<br>所谓AOT编辑器即 <strong>il2cpp.exe</strong><br>在 Windows 系统中你可以在 Editor\Data\il2cpp 目录中找到它，在 OSX 系统中你可以在 Contents/Frameworks/il2cpp/build，即Unity的安装目录中找到它。<br>il2cpp.exe 是由C#编写的 <strong>受托管的可执行程序</strong> ，它 <strong>接受我们在Unity中通过Mono编译器生成的托管程序集，并生成指定平台下的C++代码</strong> 。</p><p><img src="0.2_IL2CPP/IL2CPP_WorkFlow.png" alt="Alt text"></p><h2 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h2><p><strong>运行时库（libil2cpp）</strong> 的存在是为了支持 <strong>IL2CPP虚拟机</strong> 的运行，几乎完全由C++代码编写，并作为一个静态库与最终的可执行程序链接。（值得一提的是，IL2CPP技术十分得益于使用了libil2cpp这一更轻便的运行时库）</p><p>你可以通过查看 libil2cpp 的头文件了解其的代码构成，例如你可以在 codegen/il2cpp-codegen.h 文件中看到 il2cpp.exe 生成C++代码的接口以及 运行时库 的接口。</p><p>运行时库的另一关键功能是提供了垃圾回收。</p><h2 id="AOT编译器是如何运行的"><a href="#AOT编译器是如何运行的" class="headerlink" title="AOT编译器是如何运行的"></a>AOT编译器是如何运行的</h2><p>看一个例子（该例子运行在 Windows 系统下 Unity 5.0.1版本中）<br>发布一个WebGL平台下的程序，并使用 Process Explorer 工具查看命令行调用过程</p><p>首先，Unity启动 mono.exe</p><p><code>&quot;C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe&quot;</code><br>接着启动 il2cpp.exe<br><code>&quot;C:\Program Files\Unity\Editor\Data\il2cpp/il2cpp.exe</code></p><pre><code class="lang-csharp">&quot;C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe&quot;&quot;C:\Program Files\Unity\Editor\Data\il2cpp/il2cpp.exe&quot;rem 传递给 il2cpp.exe ，而非传递给 mono.exe的参数(5个标识符)rem 告诉 il2cpp.exe 不要复制生成的C++代码.\--copy-level=None rem IL2CPP将会共享泛型以此来减少最终包体的大小。\--enable-generic-sharing rem 支持通过反射获取的Unity事件，保证代码能够正确生成。\--enable-unity-event-support rem 在生成的C++代码中，为类与方法使用更少的字符数来命名，这样会使得代码更难以调试，因为IL代码的命名将会发生改变（笔者注：应该类似于代码混淆），但是却能够被编译器更快编译，因为编译器所需要解析的字符数变少了。\--output-format=Compactrem 使用默认的额外类型文件 ，这个文件会被加入到你的Unity工程里，并告知 il2cpp.exe 哪些泛型类型或者数组类型没有在IL代码中出现，却会在运行时被创建。\--extra-types.file=&quot;C:\Program Files\Unity\Editor\Data\il2cpp\il2cpp_default_extra_types.txt&quot;``` ```csharp &quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\Assembly-CSharp.dll&quot;&quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\UnityEngine.UI.dll&quot;</code></pre><p>il2cpp.exe 接受所有应该被转换的 IL 程序集，在这里例子中它应该包含我的 MonoBehaviour脚本、 Assembly-CSharp.dll 以及 GUI assembly 和 UnityEngine.UI.dll。<br>我的脚本引用了 UnityEngine.dll 和 mscorlib.dll，但是它们却没有被包含在上述的命令行中。事实上，il2cpp.exe 在内部对这些程序集进行了处理，因此在上述的命令行中它们不是必须的，Unity只显式地需要 <strong>根程序集</strong> （不被任何程序集引用的程序集）在命令行中被提及。</p><pre><code class="lang-csharp">&quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\il2cppOutput&quot;</code></pre><p>最后的一个参数表示 il2cpp.exe 的输出目录，即 il2cpp.exe 生成代码的输出位置，如果你对此感兴趣的话，可以看一看生成目录下的C++文件，而这一块内容我们也会在后续的文章中对其进行详解。此外，如果你希望浏览生成目录下的代码的话，推荐在出包的时候选择 <strong>Development Player</strong> 模式，这样一来将会移除 –output-format=Compact 命令行，使得你的代码更具可读性。</p><blockquote><p>PS:你可以通过改变 Player Settings 中的设置来观察 Unity 传递给 il2cpp.exe 的命令行的差异，例如将<br> Enable Exceptions 设置为 Full，那么命令行中就会增加 –emit-null-checks、–enable-stacktrace 、 –enable-array-bounds-check 三项.</p></blockquote><h2 id="IL2CPP没有做的工作"><a href="#IL2CPP没有做的工作" class="headerlink" title="IL2CPP没有做的工作"></a>IL2CPP没有做的工作</h2><p>Unity官方并没有重写C#的标准库，因此当你发布一个Unity工程的时候，即使你选择了 IL2CPP 的方式来生成你的代码，所有在 mscorlib.dll、System.dll 等标准库中的代码都将使用Mono2X的方式来生成。</p><p>Ref: <a href="https://www.jianshu.com/p/7cfcb7b0cfe7" target="_blank" rel="noopener">https://www.jianshu.com/p/7cfcb7b0cfe7</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.1_Unity  Profiler</title>
      <link href="2023/07/25/Unity3D-0-1-Unity-Profiler/"/>
      <url>2023/07/25/Unity3D-0-1-Unity-Profiler/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1-Unity-Profiler"><a href="#0-1-Unity-Profiler" class="headerlink" title="0.1_Unity Profiler"></a>0.1_Unity Profiler</h1><h1 id="0-1-Unity-Profiler-1"><a href="#0-1-Unity-Profiler-1" class="headerlink" title="0.1_Unity Profiler"></a>0.1_Unity Profiler</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Profiler 中看到的内存是通过 unity 自身引擎看到的内存分配,凡是 <strong>引擎创建和销毁的内存</strong> ,引擎有记录,可以给出准确的引用内存占用信息。第三方库的内存分配无法进行统计,以及一些其他的内存分配是无法进行统计的。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="真实环境内存"><a href="#真实环境内存" class="headerlink" title="真实环境内存"></a>真实环境内存</h4><p>在真实环境上面,(例如移动设备上面,Xcode的 instrument,Android 的 USS)内存都比 profiler 上要多<br>因为这些内存包括2部分</p><ul><li><p>真实的 used 的物理内存</p></li><li><p>缓存的(cached)的物理内存,这是不同平台决定的.Android 和 iOS 系统在资源不使用的时候均不会立即将其进行回收,而是将其放在缓存的物理内存中,以便下次再使用时,可以快速的加载.</p></li></ul><p>unity 的 profiler 只记录目前真实使用的物理内存,即上述所说的 A 部分内存.</p><p>当系统发现 APP 的内存不够用时,才会在底层调用一个 memory killer 线程来轮询缓存物理内存,为 APP 清理内存.</p><h4 id="PersistentManager-Remapper"><a href="#PersistentManager-Remapper" class="headerlink" title="PersistentManager.Remapper"></a>PersistentManager.Remapper</h4><p>主要提供文件的持久化存储,包括各种序列化的 asset,项目的 setting 文件,维护文件系统中的文件与内存中数据的对应关系.如果项目中大量适用 AssetBundle ,在对 AsserBundle 进行 Unload 之前都会需要占用 Remapper 的内存的,而 Remapper 本身的实现适用内存池,其数值只会增大,那么为了使 Remapper 占用的内存保持稳定,则在加载一定数量的 AssetBundle 之后需要进行 Unload 操作,而不要一次性把所有的 AssetBundle 进行 Unload.(这样的操作对维持整个 mono heap 的大小也是重要的,mono heap 本身也是只增大不减小的)</p><h2 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h2><p>Unity 在本机联合代码中分配的内存数量<br>Mono 托管代码所使用的堆大小和堆大小。这个内存是垃圾收集的<br>GfxDriver 驱动程序在纹理上使用的估计内存数量，呈现目标、着色器和网格数据。<br>FMOD 音频驱动程序的内存使用情况<br>Profiler 用于分析器数据的内存</p><p>内存统计信息显示在一些最常见的asset/object类型中。这些统计数据包括计数和使用的内存：<br>Textures<br>Meshes<br>Materials<br>Animations<br>Audio<br>Object Count</p><p>游戏对象在内存中常见的原因包括:<br>Assets:从用户或本机代码引用的资产<br>Built-in Resources:统一编辑器资源或统一缺省资源<br>Not Saved:标记为DontSave的GameObjects<br>Scene Memory: GameObject和附加组件<br>Other: 在上面的类别中没有标记的配子</p><h2 id="Profiler-UI显示数据"><a href="#Profiler-UI显示数据" class="headerlink" title="Profiler UI显示数据"></a>Profiler UI显示数据</h2><p>Uesd Total :<br>当前帧的Unity内存，Mono内存，GfxDriver内存，Profiler内存以及额外内存的总和。<br>Used total = Unity + Mono + GfxDriver + Profiler + additionalUsedMemory.</p><blockquote><p>additionalUsedMemory在profiler 中没有显示,因为在大多数平台下都为 0(PC/Android/iOS 都为 0),一般情况下 Used Total 的值就是除 FMOD 之外各项的总和了.Reserved Total 同样适用的.</p></blockquote><p>Reserved Total：<br>系统在当前帧申请的总体物理内存</p><p>Total System Memory Usage：<br>当前帧的虚拟内存使用量</p><p>GameObjects in Scene：<br>当前帧场景中的GameObject数量</p><p>Total Objects in Scene：<br>当前帧场景中的Object数量（除GameObject外，还有各种Component）</p><p>Total Object Count：<br>所有Object数量</p><h2 id="API-UnityEngine-Profiling-Profiler"><a href="#API-UnityEngine-Profiling-Profiler" class="headerlink" title="API UnityEngine.Profiling.Profiler"></a>API UnityEngine.Profiling.Profiler</h2><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><h4 id="in-your-built-app"><a href="#in-your-built-app" class="headerlink" title="in your built app"></a>in your built app</h4><p>most of the Profiler API functionality is only available when “Development Build” is enabled. This means you must enable “Developer Build” if you want to use profiler API methods in your built app.</p><p>Disabling “Development Build” makes your app run faster, but prevents you from using most of the Profiler API methods.</p><p>The exception to this are the Profiler API methods relating to memory usage. Because Unity manages most of its system memory at run-time, it can provide that information with no performance penalty, therefore those methods are available even if “Development Build” is not enabled. </p><h3 id="Static-Properties"><a href="#Static-Properties" class="headerlink" title="Static Properties"></a>Static Properties</h3><h4 id="usedHeapSizeLong"><a href="#usedHeapSizeLong" class="headerlink" title="usedHeapSizeLong"></a>usedHeapSizeLong</h4><p>Returns the number of bytes that Unity has allocated. This does not include bytes allocated by external libraries or drivers.</p><h3 id="Static-Methods"><a href="#Static-Methods" class="headerlink" title="Static Methods"></a>Static Methods</h3><h4 id="GetAllocatedMemoryForGraphicsDriver"><a href="#GetAllocatedMemoryForGraphicsDriver" class="headerlink" title="GetAllocatedMemoryForGraphicsDriver"></a>GetAllocatedMemoryForGraphicsDriver</h4><p>Returns the amount of <strong>allocated memory for the graphics driver</strong> , in bytes.<br>Only available in development players and editor.</p><h4 id="GetMonoHeapSizeLong-Reserved-Mono"><a href="#GetMonoHeapSizeLong-Reserved-Mono" class="headerlink" title="GetMonoHeapSizeLong (Reserved Mono)"></a>GetMonoHeapSizeLong (Reserved Mono)</h4><p>Returns the size of the <strong>reserved space for managed-memory</strong>.</p><h4 id="GetMonoUsedSizeLong-Used-Mono"><a href="#GetMonoUsedSizeLong-Used-Mono" class="headerlink" title="GetMonoUsedSizeLong (Used Mono)"></a>GetMonoUsedSizeLong (Used Mono)</h4><p>The <strong>allocated managed-memory</strong> for live objects and non-collected objects.</p><h4 id="GetRuntimeMemorySizeLong-native-memory-by-Unity-Obj"><a href="#GetRuntimeMemorySizeLong-native-memory-by-Unity-Obj" class="headerlink" title="GetRuntimeMemorySizeLong (native-memory by Unity Obj)"></a>GetRuntimeMemorySizeLong (native-memory by Unity Obj)</h4><p>Gathers the <strong>native-memory used by a Unity object</strong>.</p><h4 id="GetTempAllocatorSize"><a href="#GetTempAllocatorSize" class="headerlink" title="GetTempAllocatorSize"></a>GetTempAllocatorSize</h4><p>Returns the size of the temp allocator.</p><h4 id="GetTotalAllocatedMemoryLong"><a href="#GetTotalAllocatedMemoryLong" class="headerlink" title="GetTotalAllocatedMemoryLong"></a>GetTotalAllocatedMemoryLong</h4><p>The total memory allocated by the internal allocators in Unity. </p><blockquote><p>Unity <strong>reserves large pools of memory</strong> from the system. This function returns <strong>the amount of used memory in those pools</strong>.</p></blockquote><h4 id="GetTotalReservedMemoryLong"><a href="#GetTotalReservedMemoryLong" class="headerlink" title="GetTotalReservedMemoryLong"></a>GetTotalReservedMemoryLong</h4><p>The total memory Unity has reserved.</p><h4 id="GetTotalUnusedReservedMemoryLong"><a href="#GetTotalUnusedReservedMemoryLong" class="headerlink" title="GetTotalUnusedReservedMemoryLong"></a>GetTotalUnusedReservedMemoryLong</h4><p>Unity allocates memory in pools for usage when unity needs to allocate memory. This function returns the amount of unused memory in these pools.</p><h3 id="API和UI界面数据对应关系Table"><a href="#API和UI界面数据对应关系Table" class="headerlink" title="API和UI界面数据对应关系Table"></a>API和UI界面数据对应关系Table</h3><div class="table-container"><table><thead><tr><th>Profiler UI界面</th><th>API  </th></tr></thead><tbody><tr><td>Reserved Unity</td><td>GetTotalReservedMemoryLong  </td></tr><tr><td>Used Unity</td><td>GetTotalAllocatedMemoryLong  </td></tr><tr><td>Reserved Mono</td><td>GetMonoHeapSizeLong  </td></tr><tr><td>Used Mono</td><td>GetMonoUsedSizeLong  </td></tr></tbody></table></div><h2 id="优化项目（对于选定帧）"><a href="#优化项目（对于选定帧）" class="headerlink" title="优化项目（对于选定帧）"></a>优化项目（对于选定帧）</h2><h3 id="显示的项"><a href="#显示的项" class="headerlink" title="显示的项"></a>显示的项</h3><p>选中后，unity会自动获取这一帧的内存占用数据项，主要分为：Other、Assets、BuiltinResources、Scene Memory、NotSaved这五大部分</p><h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><h5 id="System-ExecutableAndDlls"><a href="#System-ExecutableAndDlls" class="headerlink" title="System.ExecutableAndDlls"></a>System.ExecutableAndDlls</h5><p>统可执行程序和DLL，是只读的内存，用来执行所有的脚本和DLL引用。不同平台和不同硬件得到的值会不一样，可以通过修改Player Setting的Stripping Level来调节大小。<br>Ricky：我试着修改了一下Stripping Level似乎没什么改变，感觉虽占用内存大但不会影响游戏运行。我们暂时忽略它吧(- -)!</p><h5 id="GfxDeviceClient"><a href="#GfxDeviceClient" class="headerlink" title="GfxDeviceClient"></a>GfxDeviceClient</h5><p>GFX（图形加速\图形加速器\显卡 (GraphicsForce Express)）客户端设备。<br>Ricky：虽占用较大内存，但这也是必备项，没办法优化。继续忽略吧(- -)!!</p><h5 id="ManagedHeap-UsedSize"><a href="#ManagedHeap-UsedSize" class="headerlink" title="ManagedHeap.UsedSize"></a>ManagedHeap.UsedSize</h5><p>托管堆使用大小。<br>Ricky：重点监控对象，不要让它超过20MB，否则可能会有性能问题！</p><h5 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h5><p>Unity自带的着色器语言工具相关资源。<br>Ricky：这个东西大家都比较熟悉了，忽略它吧。</p><h5 id="SerializedFile"><a href="#SerializedFile" class="headerlink" title="SerializedFile"></a>SerializedFile</h5><p>序列化文件，把显示中的Prefab、Atlas和metadata等资源加载进内存。<br>Ricky：重点监控对象，这里就是你要监控的哪些预设在序列化中在内存中占用大小，根据需求进行优化。</p><h5 id="PersistentManager-Remapper-1"><a href="#PersistentManager-Remapper-1" class="headerlink" title="PersistentManager.Remapper"></a>PersistentManager.Remapper</h5><p>持久化数据重映射管理相关<br>Ricky：与持久化数据相关，比如AssetBundle之类的。注意监控相关的文件。</p><h5 id="ManagedHeap-ReservedUnusedSize"><a href="#ManagedHeap-ReservedUnusedSize" class="headerlink" title="ManagedHeap.ReservedUnusedSize"></a>ManagedHeap.ReservedUnusedSize</h5><p>托管堆预留不使用内存大小，只由Mono使用。<br>Ricky：无法优化。</p><h4 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h4><h5 id="Texture2D"><a href="#Texture2D" class="headerlink" title="Texture2D"></a>Texture2D</h5><p>2D贴图及纹理。<br>Ricky：重点优化对象，有以下几点可以优化：</p><ol><li><p>许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。</p></li><li><p>当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先 <strong>把物体制空(null)，然后调用Resources.UnloadUnusedAssets()</strong> ，才能真正释放内存。</p></li><li><p>有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。</p></li></ol><h5 id="AudioManager"><a href="#AudioManager" class="headerlink" title="AudioManager"></a>AudioManager</h5><p>音频管理器<br>Ricky：随着音频文件的增多而增大。</p><h5 id="AudioClip"><a href="#AudioClip" class="headerlink" title="AudioClip"></a>AudioClip</h5><p>音效及声音文件<br>Ricky：重点优化对象，播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。</p><h5 id="Cubemap"><a href="#Cubemap" class="headerlink" title="Cubemap"></a>Cubemap</h5><p>立方图纹理<br>Ricky：这个一般在天空盒中比较常见，我也不知道如何优化这个。。。</p><h5 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h5><p>模型网格<br>Ricky：主要检查是否有重复的资源，还有尽量减少点面数。</p><h4 id="Scene-Memory"><a href="#Scene-Memory" class="headerlink" title="Scene Memory"></a>Scene Memory</h4><h5 id="Mesh-1"><a href="#Mesh-1" class="headerlink" title="Mesh"></a>Mesh</h5><p>场景中使用的网格模型<br>Ricky：注意网格模型的点面数，能合并的mesh尽量合并。</p><h5 id="Builtin-Resources"><a href="#Builtin-Resources" class="headerlink" title="Builtin Resources"></a>Builtin Resources</h5><p>Ricky：这些都是Unity的一些内部资源，对于项目内存没有什么分析价值，所以我就暂时不对其进行分析了。</p><h3 id="Profiler内存重点关注优化项目"><a href="#Profiler内存重点关注优化项目" class="headerlink" title="Profiler内存重点关注优化项目"></a>Profiler内存重点关注优化项目</h3><ol><li><p>ManagedHeap.UsedSize: 移动游戏建议不要超过20MB.</p></li><li><p>SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.</p></li><li><p>WebStream: 通过异步WWW下载的资源文件在内存中的解压版本，比SerializedFile大几倍或几十倍，</p></li><li><p>Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等.</p></li><li><p>AnimationClip: 重点检查是否有重复资源.</p></li><li><p>Mesh： 重点检查是否有重复资源.</p></li></ol><h3 id="项目中可能遇到的问题"><a href="#项目中可能遇到的问题" class="headerlink" title="项目中可能遇到的问题"></a>项目中可能遇到的问题</h3><h4 id="1-Device-Present"><a href="#1-Device-Present" class="headerlink" title="1.Device.Present:"></a>1.Device.Present:</h4><p>1）GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader.<br>2）GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间.<br>3）同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.<br>4）Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片).<br>5）StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace(): 一般是由Debug.Log或类似API造成，游戏发布后需将Debug API进行屏蔽。</p><h4 id="2-Overhead"><a href="#2-Overhead" class="headerlink" title="2.Overhead:"></a>2.Overhead:</h4><p>1）一般情况为Vsync所致.<br>2）通常出现在Android设备上.</p><h4 id="3-GC-Collect"><a href="#3-GC-Collect" class="headerlink" title="3.GC.Collect:"></a>3.GC.Collect:</h4><p>原因：<br>1）代码分配内存过量(恶性的)<br>2）一定时间间隔由系统调用(良性的).<br>占用时间：<br>1）与现有Garbage size相关<br>2）与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排)</p><h4 id="4-GarbageCollectAssetsProfile"><a href="#4-GarbageCollectAssetsProfile" class="headerlink" title="4.GarbageCollectAssetsProfile:"></a>4.GarbageCollectAssetsProfile:</h4><p>1）引擎在执行UnloadUnusedAssets操作（该操作是比较耗时的,建议在切场景的时候进行）。<br>2）尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GCAllow.<br>3）if(other.tag == a.tag)改为other.CompareTag(a.tag).因为other.tag为产生180B的GC Allow.<br>4）少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for.<br>5）Lambda表达式，使用不当会产生内存泄漏.</p><h4 id="5-尽量少用LINQ："><a href="#5-尽量少用LINQ：" class="headerlink" title="5.尽量少用LINQ："></a>5.尽量少用LINQ：</h4><p>1）部分功能无法在某些平台使用.<br>2）会分配大量GC Allow.</p><h4 id="6-控制StartCoroutine的次数："><a href="#6-控制StartCoroutine的次数：" class="headerlink" title="6.控制StartCoroutine的次数："></a>6.控制StartCoroutine的次数：</h4><p>1）开启一个Coroutine(协程)，至少分配37B的内存.<br>2）Coroutine类的实例 -&gt; 21B.<br>3）Enumerator -&gt; 16B.</p><h4 id="7-使用StringBuilder替代字符串直接连接"><a href="#7-使用StringBuilder替代字符串直接连接" class="headerlink" title="7.使用StringBuilder替代字符串直接连接."></a>7.使用StringBuilder替代字符串直接连接.</h4><h4 id="8-缓存组件"><a href="#8-缓存组件" class="headerlink" title="8.缓存组件:"></a>8.缓存组件:</h4><p>1）每次GetComponent均会分配一定的GC Allow.<br>2）每次Object.name都会分配39B的堆内存.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/yanghui0702/p/yanghui20181026.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanghui0702/p/yanghui20181026.html</a><br><a href="https://zhuanlan.zhihu.com/p/139235851" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/139235851</a><br><a href="https://www.jianshu.com/p/3c5540637525" target="_blank" rel="noopener">https://www.jianshu.com/p/3c5540637525</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.1_Android内存管理</title>
      <link href="2023/07/25/Unity3D-0-1-Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2023/07/25/Unity3D-0-1-Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Android 运行时 ( <strong>ART</strong> ) 和 <strong>Dalvik 虚拟机</strong> 使用 <strong>分页</strong> 和 <strong>内存映射</strong> 来管理内存。这意味着应用修改的任何内存，无论修改的方式是分配新对象还是轻触内存映射的页面，都会一直驻留在 RAM 中，并且无法换出。 <strong>要从应用中释放内存，只能释放应用保留的对象引用，使内存可供垃圾回收器回收。</strong> 这种情况有 <strong>一个例外</strong> ：对于任何未经修改的内存映射文件（如代码），如果系统想要在其他位置使用其内存，可将其从 RAM 中换出。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>Ref: <a href="https://blog.csdn.net/greedylin/article/details/103711555" target="_blank" rel="noopener">https://blog.csdn.net/greedylin/article/details/103711555</a><br>Android的内存大，但是管理不太好<br>基本单位: Page</p><ol><li><p>默认4K一个page（与linux相同），但并不意味是4K对齐的</p></li><li><p>回收和分配以page为单位</p></li><li><p>分为用户态和内核态，常见的一个问题是，用户态中的一个指针越界到内核态，该程序就会挂掉</p></li></ol><h3 id="LMK"><a href="#LMK" class="headerlink" title="LMK"></a>LMK</h3><p>内存管理工具-low memory killer（AKA lmk）<br>一些现象都和它有关，例如闪退 服务消失 手机重启等<br>当内存不足时，killer会从下往上杀应用，当杀到前台（Foreground）时，你的应用就会闪退，如果继续使用内存，会一致杀到System层，这时设备会重启</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>ART 或 Dalvik 虚拟机之类的 <strong>受管内存环境</strong> 会 <strong>跟踪每次内存分配</strong> 。一旦确定程序不再使用某块内存，它就会将该内存重新释放到堆中，无需程序员进行任何干预。这种 <strong>回收受管内存环境中的未使用内存的机制</strong> 称为“ <strong>垃圾回收”</strong> 。垃圾回收有两个目标： <strong>在程序中查找将来无法访问的数据对象</strong> ，并 <strong>回收这些对象使用的资源</strong> 。</p><h4 id="Android做法"><a href="#Android做法" class="headerlink" title="Android做法"></a>Android做法</h4><p>Android 的内存堆是分代的，这意味着它会根据分配对象的 <strong>预期寿命和大小</strong> 跟踪不同的 <strong>分配存储分区</strong> 。例如，最近分配的对象属于“ <strong>新生代</strong> ”。当某个对象保持活动状态达足够长的时间时，可将其提升为 <strong>较老代</strong> ，然后是 <strong>永久代</strong> 。<br>堆的每一代对相应对象可占用的内存量都有其自身的专用上限。 <strong>每当一代开始填满时，系统便会执行垃圾回收事件以释放内存。</strong></p><p>垃圾回收的 <strong>持续时间</strong> 取决于它 <strong>回收的是哪一代</strong> 对象以及 <strong>每一代有多少个活动对象</strong> 。</p><p>尽管垃圾回收速度非常快，但仍会影响应用的性能。系统有一套专门确定何时执行垃圾回收的标准。当条件满足时，系统会停止执行进程并开始垃圾回收。如果 <em>在动画或音乐播放等密集型处理循环过程中发生垃圾回收，则可能会增加处理时间</em> ，进而可能会导致应用中的代码执行超出建议的 16ms 阈值， <em>无法实现高效、流畅的帧渲染</em> 。</p><p>此外，您的代码流执行的各种工作可能迫使垃圾回收事件发生得更频繁或导致其持续时间超过正常范围。 例如， <em>如果您在 Alpha 混合动画的每一帧期间，在 for 循环的最内层分配多个对象，则可能会使内存堆受到大量对象的影响</em> 。在这种情况下，垃圾回收器会执行多个垃圾回收事件，并可能降低应用的性能。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>为了在 RAM 中容纳所需的一切，Android 会尝试跨进程共享 RAM 页面。<br>方式：</p><ul><li><p>每个应用进程都从一个 <strong>名为 Zygote 的现有进程分叉</strong> 。系统启动并加载通用框架代码和资源（如 Activity 主题背景）时，Zygote 进程随之启动。为启动新的应用进程，系统会分叉 Zygote 进程，然后在新进程中加载并运行应用代码。这种方法使为框架代码和资源分配的大多数 RAM 页面可在所有应用进程之间共享。</p></li><li><p>大多数 <strong>静态数据会内存映射到一个进程中</strong> 。这种方法使得数据不仅可以在进程之间共享，还可以在需要时换出。静态数据示例包括：Dalvik 代码（通过将其放入预先链接的 .odex 文件中进行直接内存映射）、应用资源（通过将资源表格设计为可内存映射的结构以及通过对齐 APK 的 zip 条目）和传统项目元素（如 .so 文件中的原生代码）。</p></li><li><p>在很多地方，Android 使用 <strong>明确分配的共享内存区域（通过 ashmem 或 gralloc）</strong> 在进程间共享同一 <strong>动态 RAM</strong> 。例如，窗口 surface 在应用和屏幕合成器之间使用共享内存，而光标缓冲区则在内容提供程序和客户端之间使用共享内存。</p></li></ul><h3 id="分配与回收应用内存"><a href="#分配与回收应用内存" class="headerlink" title="分配与回收应用内存"></a>分配与回收应用内存</h3><p><strong>Dalvik 堆</strong> 局限于 <strong>每个应用进程的单个虚拟内存范围</strong> 。这定义了 <strong>逻辑堆大小</strong> ，该大小可以根据需要增长，但不能超过系统为每个应用定义的上限。</p><p>堆的逻辑大小与 <strong>堆使用的物理内存量</strong> 不同。在检查应用堆时，Android 会 <strong>计算</strong> 按比例分摊的内存大小 <strong>(PSS) 值</strong> ，该值同时考虑与其他进程共享的脏页和干净页，但其数量与共享该 RAM 的应用数量成正比。此 (PSS) 总量是系统认为的 <strong>物理内存占用</strong> 量。有关 PSS 的详情，请参阅调查 RAM 使用量指南: <a href="https://developer.android.com/studio/profile/memory-profiler" target="_blank" rel="noopener">https://developer.android.com/studio/profile/memory-profiler</a>。</p><p>Dalvik 堆不压缩堆的逻辑大小，这意味着 Android 不会对堆进行碎片整理来缩减空间。只有当堆末尾存在未使用的空间时，Android 才能缩减逻辑堆大小。但是，系统仍然可以减少堆使用的物理内存。垃圾回收之后，Dalvik 遍历堆并查找未使用的页面，然后使用 madvise 将这些页面返回给内核。因此，大数据块的配对分配和解除分配应该使所有（或几乎所有）使用的物理内存被回收。但是，从较小分配量中回收内存的效率要低得多，因为用于较小分配量的页面可能仍在与其他尚未释放的数据块共享。</p><h4 id="PSS"><a href="#PSS" class="headerlink" title="PSS"></a>PSS</h4><p>PSS(Proportional Set Size)：按比例分摊的内存大小</p><blockquote><p>Proportional 比例的，成比例的<br> Proportional Set Size: 按照比例设置的大小，按比例分摊的内存大小，即 <strong>实际使用的物理内存</strong></p></blockquote><h3 id="限制应用内存"><a href="#限制应用内存" class="headerlink" title="限制应用内存"></a>限制应用内存</h3><p>为了维持多任务环境的正常运行，Android 会为每个应用的 <strong>堆大小</strong> 设置硬性 <strong>上限</strong> 。如果您的应用在达到堆容量上限后尝试分配更多内存，则可能会收到 <strong>OutOfMemoryError</strong> 。<br>在某些情况下，例如，为了确定在缓存中保存多少数据比较安全，您可能需要查询系统以确定 <strong>当前设备上确切可用的堆空间大小</strong> 。您可以通过调用 <strong>getMemoryClass()</strong> 向系统查询此数值。此方法返回一个整数，表示 <strong>应用堆的可用兆字节数</strong> 。</p><h3 id="切换应用"><a href="#切换应用" class="headerlink" title="切换应用"></a>切换应用</h3><p>当用户在应用之间切换时，Android 会在最近最少使用 (LRU) 缓存中保留 <strong>非前台应用</strong> ，即用户看不到或不在运行前台服务（如 <em>音乐播放</em> ）的应用。例如，当用户首次启动某个应用时，系统会为其创建一个进程；但是当用户离开此应用时，该进程不会退出。系统会将该进程保留在缓存中。如果用户稍后返回该应用，则系统会重复使用该进程，从而加快应用切换速度。</p><p>如果您的应用具有缓存进程且保留了目前不需要的内存，那么即使用户不在使用您的应用，它也会影响系统的整体性能。当系统 <strong>内存不足时</strong> ，它会从最近最少使用的进程开始， <strong>终止 LRU 缓存中的进程</strong> 。系统还会考虑终止占用最多内存的进程以释放 RAM。</p><h2 id="进程间内存分配"><a href="#进程间内存分配" class="headerlink" title="进程间内存分配"></a>进程间内存分配</h2><p>Android 平台在运行时不会浪费可用的内存。它会一直尝试利用所有可用内存。</p><h3 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h3><p>Android 设备包含三种不同类型的内存：RAM、zRAM 和存储器</p><p><img src="0.1_Android内存管理/1592449330748.png" alt="Alt text"></p><p>RAM 是最快的内存类型，但其大小通常有限。高端设备通常具有最大的 RAM 容量。</p><p>zRAM 是用于交换空间的 RAM 分区。所有数据在放入 zRAM 时都会进行压缩，然后在从 zRAM 向外复制时进行解压缩。这部分 RAM 会随着页面进出 zRAM 而增大或缩小。设备制造商可以设置 zRAM 大小上限。</p><p>存储器中包含所有持久性数据（例如文件系统等），以及为所有应用、库和平台添加的对象代码。存储器比另外两种内存的容量大得多。在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间，因为频繁写入会导致这种内存出现损坏，并缩短存储媒介的使用寿命。</p><h3 id="内存页面"><a href="#内存页面" class="headerlink" title="内存页面"></a>内存页面</h3><p>RAM 分为多个“页面”。通常，每个页面为 4KB 的内存。</p><p>系统会将页面视为“可用”或“已使用”。</p><h4 id="可用页面"><a href="#可用页面" class="headerlink" title="可用页面"></a>可用页面</h4><h4 id="已使用页面"><a href="#已使用页面" class="headerlink" title="已使用页面"></a>已使用页面</h4><h5 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h5><p>有存储器中的文件（例如代码或内存映射文件）支持的内存。缓存内存有两种类型：</p><ol><li><p>私有页：由一个进程拥有且未共享</p><ul><li><p>干净页：存储器中未经修改的文件副本，可由 kswapd 删除以增加可用内存</p></li><li><p>脏页：存储器中经过修改的文件副本；可由 kswapd 移动到 zRAM 或在 zRAM 中进行压缩以增加可用内存</p></li></ul></li><li><p>共享页：由多个进程使用</p><ul><li><p>干净页：存储器中未经修改的文件副本，可由 kswapd 删除以增加可用内存</p></li><li><p>脏页：存储器中经过修改的文件副本；允许通过 kswapd 或者通过明确使用 msync() 或 munmap() 将更改写回存储器中的文件，以增加可用空间</p></li></ul></li></ol><h5 id="匿名页："><a href="#匿名页：" class="headerlink" title="匿名页："></a>匿名页：</h5><p>没有存储器中的文件支持的内存（例如，由设置了 MAP_ANONYMOUS 标记的 mmap() 进行分配）<br>脏页：可由 kswapd 移动到 zRAM/在 zRAM 中进行压缩以增加可用内存</p><blockquote><p>注意：干净页包含存在于存储器中的文件（或文件一部分）的精确副本。如果干净页不再包含文件的精确副本（例如，因应用操作所致），则会变成脏页。干净页可以删除，因为始终可以使用存储器中的数据重新生成它们；脏页则不能删除，否则数据将会丢失。<br> 随着系统积极管理 RAM，可用和已使用页面的比例会不断变化。</p></blockquote><h3 id="内存不足管理"><a href="#内存不足管理" class="headerlink" title="内存不足管理"></a>内存不足管理</h3><p>Android 有两种处理内存不足情况的主要机制： <strong>内核交换守护进程</strong> 和 <strong>低内存终止守护进程</strong> 。</p><h4 id="内核交换守护进程"><a href="#内核交换守护进程" class="headerlink" title="内核交换守护进程"></a>内核交换守护进程</h4><p>内核交换守护进程 (kernel swap daemon, kswapd) 是 Linux 内核的一部分，用于将已使用内存转换为可用内存。当设备上的可用内存不足时，该守护进程将变为活动状态。Linux 内核设有可用内存上下限阈值。当可用内存降至下限阈值以下时，kswapd 开始回收内存。当可用内存达到上限阈值时，kswapd 停止回收内存。</p><p>kswapd 可以删除干净页来回收它们，因为这些页受到存储器的支持且未经修改。如果某个进程尝试处理已删除的干净页，则系统会将该页面从存储器复制到 RAM。此操作称为“请求分页”。</p><p>kswapd 可以将缓存的私有脏页和匿名脏页移动到 zRAM 进行压缩。这样可以释放 RAM 中的可用内存（可用页面）。如果某个进程尝试处理 zRAM 中的脏页，该页将被解压缩并移回到 RAM。如果与压缩页面关联的进程被终止，则该页面将从 zRAM 中删除。</p><p>如果可用内存量低于特定阈值，系统会开始终止进程。</p><h4 id="低内存终止守护进程"><a href="#低内存终止守护进程" class="headerlink" title="低内存终止守护进程"></a>低内存终止守护进程</h4><p>很多时候，kswapd 不能为系统释放足够的内存。在这种情况下，系统会使用 onTrimMemory() 通知应用内存不足，应该减少其分配量。如果这还不够，内核会开始终止进程以释放内存。它会使用低内存终止守护进程 ( low-memory killer, LMK) 来执行此操作。</p><p>LMK 使用一个名为 oom_adj_score 的“内存不足”分值来确定正在运行的进程的优先级，以此决定要终止的进程。最高得分的进程最先被终止。后台应用最先被终止，系统进程最后被终止。下表列出了从高到低的 LMK 评分类别。评分最高的类别，即第一行中的项目将最先被终止：</p><p><img src="0.1_Android内存管理/1592451159557.png" alt="Alt text"></p><ul><li><p>后台应用：之前运行过且当前不处于活动状态的应用。LMK 将首先从具有最高 oom_adj_score 的应用开始终止后台应用。</p></li><li><p>上一个应用：最近用过的后台应用。上一个应用比后台应用具有更高的优先级（得分更低），因为相比某个后台应用，用户更有可能切换到上一个应用。</p></li><li><p>主屏幕应用：这是启动器应用。终止该应用会使壁纸消失。</p></li><li><p>服务：服务由应用启动，可能包括同步或上传到云端。</p></li><li><p>可觉察的应用：用户可通过某种方式察觉到的非前台应用，例如运行一个显示小界面的搜索进程或听音乐。</p></li><li><p>前台应用：当前正在使用的应用。终止前台应用看起来就像是应用崩溃了，可能会向用户提示设备出了问题。</p></li><li><p>持久性（服务）：这些是设备的核心服务，例如电话和 WLAN。</p></li><li><p>系统：系统进程。这些进程被终止后，手机可能看起来即将重新启动。</p></li><li><p>原生：系统使用的极低级别的进程（例如，kswapd）。</p></li></ul><h3 id="计算内存占用量"><a href="#计算内存占用量" class="headerlink" title="计算内存占用量"></a>计算内存占用量</h3><blockquote><p>在确定应用使用的内存量时，系统必须考虑共享的页面。访问相同服务或库的应用将共享内存页面。<br> 如需确定应用的内存占用量，可以使用以下任一指标：</p></blockquote><ul><li><p>常驻内存大小 (Resident Set Size, RSS)：应用使用的共享和非共享页面的数量</p></li><li><p>按比例分摊的内存大小 (Proportional Set Size, PSS)：应用使用的非共享页面的数量加上共享页面的均匀分摊数量（例如，如果三个进程共享 3MB，则每个进程的 PSS 为 1MB）</p></li><li><p>独占内存大小 (Unique Set Size, USS)：应用使用的非共享页面数量（不包括共享页面）</p></li></ul><p>如果操作系统想要知道所有进程使用了多少内存，那么 <strong>PSS</strong> 非常有用，因为页面只会统计一次。计算 PSS 需要花很长时间，因为系统需要确定共享的页面以及共享页面的进程数量。RSS 不区分共享和非共享页面（因此计算起来更快），更适合跟踪内存分配量的变化。</p><h2 id="管理应用内存"><a href="#管理应用内存" class="headerlink" title="管理应用内存"></a>管理应用内存</h2><p>随机存取存储器 (RAM) 在任何软件开发环境中都是一项宝贵资源。虽然 Android 运行时 (ART) 和 Dalvik 虚拟机都执行例行的垃圾回收任务，但这并不意味着您可以忽略应用分配和释放内存的位置和时间。您仍然需要避免引入 <strong>内存泄漏</strong> 问题（ <strong>通常因在静态成员变量中保留对象引用而引起</strong> ），并在适当时间（如生命周期回调所定义）释放所有 Reference 对象。</p><h3 id="监控可用内存和内存使用量"><a href="#监控可用内存和内存使用量" class="headerlink" title="监控可用内存和内存使用量"></a>监控可用内存和内存使用量</h3><p>您需要 <strong>先找到应用中的内存使用问题，然后才能修复问题</strong> 。Android Studio 中的内存分析器可以通过以下方式帮助您查找和诊断内存问题：</p><ul><li><p>了解您的应用在一段时间内如何分配内存。内存分析器可以显示实时图表，说明应用的内存使用量、分配的 Java 对象数量以及垃圾回收事件发生的时间。</p></li><li><p>发起垃圾回收事件，并在应用运行时拍摄 Java 堆的快照。</p></li><li><p>记录应用的内存分配情况，然后检查所有分配的对象、查看每个分配的堆栈轨迹，并在 Android Studio 编辑器中跳转到相应代码。</p></li></ul><h4 id="释放内存以响应事件"><a href="#释放内存以响应事件" class="headerlink" title="释放内存以响应事件"></a>释放内存以响应事件</h4><p>如 Android 内存管理概览中所述，Android 可以通过多种方式从应用中回收内存，或在必要时完全终止应用，从而释放内存以执行关键任务。为了进一步帮助平衡系统内存并避免系统需要终止您的应用进程，您可以在 Activity 类中实现 ComponentCallbacks2 接口。借助所提供的 onTrimMemory() 回调方法，您的应用可以在处于前台或后台时监听与内存相关的事件，然后释放对象以响应指示系统需要回收内存的应用生命周期事件或系统事件。</p><h4 id="查看您应该使用多少内存"><a href="#查看您应该使用多少内存" class="headerlink" title="查看您应该使用多少内存"></a>查看您应该使用多少内存</h4><p>为了允许多个进程同时运行，Android 针对为每个应用分配的堆大小设置了硬性限制。设备的确切堆大小限制因设备总体可用的 RAM 多少而异。如果您的应用已达到堆容量上限并尝试分配更多内存，系统就会抛出 OutOfMemoryError。</p><p>为了避免用尽内存，您可以查询系统以确定当前设备上可用的堆空间。您可以通过调用 getMemoryInfo() 向系统查询此数值。它将返回一个 ActivityManager.MemoryInfo 对象，其中会提供与设备当前的内存状态有关的信息，包括可用内存、总内存和内存阈值（如果达到此内存级别，系统就会开始终止进程）。ActivityManager.MemoryInfo 对象还会提供一个简单的布尔值lowMemory，您可以根据此值确定设备是否内存不足。</p><p>以下代码段示例演示了如何在应用中使用 getMemoryInfo() 方法。</p><h3 id="使用内存效率更高的代码结构"><a href="#使用内存效率更高的代码结构" class="headerlink" title="使用内存效率更高的代码结构"></a>使用内存效率更高的代码结构</h3><p>某些 Android 功能、Java 类和代码结构所使用的内存往往多于其他功能、类和结构。您可以在代码中选择效率更高的替代方案，以尽可能降低应用的内存使用量。</p><h4 id="谨慎使用服务"><a href="#谨慎使用服务" class="headerlink" title="谨慎使用服务"></a>谨慎使用服务</h4><p>在不需要某项服务时让其保持运行状态，是 Android 应用可能犯下的最严重的内存管理错误之一。如果您的应用需要某项服务在后台执行工作，请不要让其保持运行状态，除非其需要运行作业。请注意在服务完成任务后使其停止运行。否则，您可能会在无意中导致内存泄漏。</p><p>在您启动某项服务后，系统更倾向于让此服务的进程始终保持运行状态。这种行为会导致服务进程代价十分高昂，因为一旦服务使用了某部分 RAM，那么这部分 RAM 就不再可供其他进程使用。这会减少系统可以在 LRU 缓存中保留的缓存进程数量，从而降低应用切换效率。当内存紧张，并且系统无法维护足够的进程以托管当前运行的所有服务时，这甚至可能导致系统出现颠簸。</p><p>您通常应该避免使用持久性服务，因为它们会对可用内存提出持续性的要求。我们建议您采用 JobSchedulerJobScheduler 等替代实现方式。要详细了解如何使用 JobScheduler 调度后台进程，请参阅后台优化。</p><p>如果您必须使用某项服务，则限制此服务的生命周期的最佳方式是使用 IntentService，它会在处理完启动它的 intent 后立即自行结束。有关详情，请参阅在后台服务中运行。</p><h4 id="使用经过优化的数据容器"><a href="#使用经过优化的数据容器" class="headerlink" title="使用经过优化的数据容器"></a>使用经过优化的数据容器</h4><p>编程语言所提供的部分类并未针对移动设备做出优化。例如，常规 HashMap 实现的内存效率可能十分低下，因为每个映射都需要分别对应一个单独的条目对象。</p><p>Android 框架包含几个经过优化的数据容器，包括 SparseArray、SparseBooleanArray 和 LongSparseArray。 例如，SparseArray 类的效率更高，因为它们可以避免系统需要对键（有时还对值）进行自动装箱（这会为每个条目分别再创建 1-2 个对象）。</p><p>如果需要，您可以随时切换到原始数组以获得非常精简的数据结构。</p><h4 id="谨慎对待代码抽象"><a href="#谨慎对待代码抽象" class="headerlink" title="谨慎对待代码抽象"></a>谨慎对待代码抽象</h4><p>开发者往往会将抽象简单地当做一种良好的编程做法，因为抽象可以提高代码灵活性和维护性。不过，抽象的代价很高：通常它们需要更多的代码才能执行，需要更多的时间和更多的 RAM 才能将代码映射到内存中。因此，如果抽象没有带来显著的好处，您就应该避免使用抽象。</p><h4 id="针对序列化数据使用精简版-Protobuf"><a href="#针对序列化数据使用精简版-Protobuf" class="headerlink" title="针对序列化数据使用精简版 Protobuf"></a>针对序列化数据使用精简版 Protobuf</h4><p>协议缓冲区是 Google 设计的一种无关乎语言和平台，并且可扩展的机制，用于对结构化数据进行序列化。该机制与 XML 类似，但更小、更快也更简单。如果您决定针对数据使用 Protobuf，则应始终在客户端代码中使用精简版 Protobuf。常规 Protobuf 会生成极其冗长的代码，这会导致应用出现多种问题，例如 RAM 使用量增多、APK 大小显著增加以及执行速度变慢。</p><p>有关详情，请参阅 Protobuf 自述文件中的“精简版”部分。</p><h4 id="避免内存抖动"><a href="#避免内存抖动" class="headerlink" title="避免内存抖动"></a>避免内存抖动</h4><p>如前所述，垃圾回收事件通常不会影响应用的性能。不过，如果在短时间内发生许多垃圾回收事件，就可能会快速耗尽帧时间。系统花在垃圾回收上的时间越多，能够花在呈现或流式传输音频等其他任务上的时间就越少。</p><p>通常，“内存抖动”可能会导致出现大量的垃圾回收事件。实际上，内存抖动可以说明在给定时间内出现的已分配临时对象的数量。</p><p>例如，您可以在 for 循环中分配多个临时对象。或者，您也可以在视图的 onDraw() 函数中创建新的 Paint 或 Bitmap 对象。在这两种情况下，应用都会快速创建大量对象。这些操作可以快速消耗新生代 (young generation) 区域中的所有可用内存，从而迫使垃圾回收事件发生。</p><p>当然，您必须先在代码中找到内存抖动较高的位置，然后才能进行修复。为此，您应该使用 Android Studio 中的内存分析器。</p><p>确定代码中的问题区域后，请尝试减少对性能至关重要的区域中的分配数量。您可以考虑将某些代码逻辑从内部循环中移出，或将其移到基于 Factory 的分配结构中。</p><h3 id="移除会占用大量内存的资源和库"><a href="#移除会占用大量内存的资源和库" class="headerlink" title="移除会占用大量内存的资源和库"></a>移除会占用大量内存的资源和库</h3><p>代码中的某些资源和库可能会在您不知情的情况下吞噬内存。APK 的总体大小（包括第三方库或嵌入式资源）可能会影响应用的内存消耗量。您可以通过从代码中移除任何冗余、不必要或臃肿的组件、资源或库，降低应用的内存消耗量。</p><h4 id="缩减总体-APK-大小"><a href="#缩减总体-APK-大小" class="headerlink" title="缩减总体 APK 大小"></a>缩减总体 APK 大小</h4><p>您可以通过缩减应用的总体大小来显著降低应用的内存使用量。位图大小、资源、动画帧数和第三方库都会影响 APK 的大小。Android Studio 和 Android SDK 提供了可帮助您缩减资源和外部依赖项大小的多种工具。这些工具支持现代代码收缩方法，例如 R8 编译。（Android Studio 3.3 及更低版本使用 ProGuard，而不是 R8 编译。）</p><p>要详细了解如何缩减 APK 的总体大小，请参阅有关如何缩减应用大小的指南。</p><h4 id="使用-Dagger-2-实现依赖注入"><a href="#使用-Dagger-2-实现依赖注入" class="headerlink" title="使用 Dagger 2 实现依赖注入"></a>使用 Dagger 2 实现依赖注入</h4><p>依赖注入框架可以简化您编写的代码，并提供一个可供您进行测试及其他配置更改的自适应环境。</p><p>如果您打算在应用中使用依赖注入框架，请考虑使用 Dagger 2。Dagger 不使用反射来扫描您应用的代码。Dagger 的静态编译时实现意味着它可以在 Android 应用中使用，而不会带来不必要的运行时代价或内存消耗量。</p><p>其他使用反射的依赖注入框架倾向于通过扫描代码中的注释来初始化进程。此过程可能需要更多的 CPU 周期和 RAM，并可能在应用启动时导致出现明显的延迟。</p><h4 id="谨慎使用外部库"><a href="#谨慎使用外部库" class="headerlink" title="谨慎使用外部库"></a>谨慎使用外部库</h4><p>外部库代码通常不是针对移动环境编写的，在移动客户端上运行时可能效率低下。如果您决定使用外部库，则可能需要针对移动设备优化该库。在决定是否使用该库之前，请提前规划，并在代码大小和 RAM 消耗量方面对库进行分析。</p><p>即使是一些针对移动设备进行了优化的库，也可能因实现方式不同而导致问题。例如，一个库可能使用的是精简版 Protobuf，而另一个库使用的是 Micro Protobuf，导致您的应用出现两种不同的 Protobuf 实现。日志记录、分析、图像加载框架和缓存以及许多您意料之外的其他功能的不同实现都可能导致这种情况。</p><p>虽然 ProGuard 可以使用适当的标记移除 API 和资源，但无法移除库的大型内部依赖项。您所需要的这些库中的功能可能需要较低级别的依赖项。如果存在以下情况，这就特别容易导致出现问题：您使用某个库中的 Activity 子类（往往会有大量的依赖项）、库使用反射（这很常见，意味着您需要花费大量的时间手动调整 ProGuard 以使其运行）等。</p><p>此外，请避免仅针对数十个功能中的一两个功能使用共享库。您一定不希望产生大量您甚至根本用不到的代码和开销。在考虑是否使用某个库时，请查找与您的需求十分契合的实现。否则，您可以决定自己去创建实现。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.0 Unity与Mono和.NET的关系</title>
      <link href="2023/07/25/Unity3D-0-0-Unity%E4%B8%8EMono%E5%92%8C-NET%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>2023/07/25/Unity3D-0-0-Unity%E4%B8%8EMono%E5%92%8C-NET%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>&gt;</p><p><a href="https://www.cnblogs.com/u3ddjw/p/10909975.html" target="_blank" rel="noopener">https://www.cnblogs.com/u3ddjw/p/10909975.html</a></p><p><a href="https://www.cnblogs.com/u3ddjw/p/10909975.html" target="_blank" rel="noopener">https://www.cnblogs.com/u3ddjw/p/10909975.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决困惑-Actor与component关系</title>
      <link href="2022/04/11/Unreal-%E8%A7%A3%E5%86%B3%E5%9B%B0%E6%83%91-Actor%E4%B8%8Ecomponent%E5%85%B3%E7%B3%BB/"/>
      <url>2022/04/11/Unreal-%E8%A7%A3%E5%86%B3%E5%9B%B0%E6%83%91-Actor%E4%B8%8Ecomponent%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>Actor不支持嵌套？</p><p>那GetComponents函数的“bIncludeFromChildActors”是什么意思？</p><p>Components是否支持嵌套？</p><p>如果不支持，为什么Details中的Components可有父子关系？</p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CG】齐次坐标(homogeneous coordinates )与坐标变换(transformation)</title>
      <link href="2020/11/17/CG-homogeneous-coordinates-and-transformation/"/>
      <url>2020/11/17/CG-homogeneous-coordinates-and-transformation/</url>
      
        <content type="html"><![CDATA[<p>同一个事物，从不同的视角去看，会有不同的理解。而任何一个视角看到的，都不是事物的全部，任何一种解释，都无法完全描述这个事物。单纯用一种方式去理解它，一定是片面的。只有从不同的层次、不同的角度去理解，我们的认知才能不断逼近这个事物的真相。<br>本文借鉴多位博主的研究成果，企图整理从不同的角度对齐次坐标的理解，帮助感兴趣的朋友更透彻地理解齐次坐标到底是什么，有什么意义，如何应用。</p><h2 id="齐次坐标引入"><a href="#齐次坐标引入" class="headerlink" title="齐次坐标引入"></a>齐次坐标引入</h2><h3 id="Problem-Two-parallel-lines-can-intersect"><a href="#Problem-Two-parallel-lines-can-intersect" class="headerlink" title="Problem: Two parallel lines can intersect."></a>Problem: Two parallel lines can intersect.</h3><ul><li><p>欧氏几何空间<br>In <strong>Euclidean space (geometry)</strong> - two parallel lines on the same plane cannot intersect, or cannot meet each other forever.</p></li><li><p>透视空间 - 无穷远处相交<br>In projective space - Finally, the two parallel rails meet at the horizon, which is a point at infinity.<br><img src="./1605592065160.png" alt="Alt text"></p></li></ul><blockquote><p>(Actually, Euclidean geometry is a subset of projective geometry</p></blockquote><p>The Cartesian coordinates of a 2D point can be expressed as (x, y).</p><p>What if this point goes far away to infinity? The point at infinity would be (∞,∞), and it becomes meaningless in Euclidean space. <strong>The parallel lines should meet at infinity in projective space, but cannot do in Euclidean space.</strong></p><h3 id="Solution-Homogeneous-Coordinates"><a href="#Solution-Homogeneous-Coordinates" class="headerlink" title="Solution: Homogeneous Coordinates"></a>Solution: Homogeneous Coordinates</h3><p>Homogeneous coordinates are a way of <strong>representing N-dimensional coordinates with N+1 numbers</strong>.</p><p>(1, 2) becomes (1, 2, 1) in Homogeneous<br>If (1, 2) moves toward infinity, it becomes (∞,∞) in Cartesian coordinates. And it becomes (1, 2, 0) in Homogeneous coordinates.</p><p><strong>We can express the point at infinity without using “∞”.</strong></p><h3 id="Why-is-it-called-“homogeneous”"><a href="#Why-is-it-called-“homogeneous”" class="headerlink" title="Why is it called “homogeneous”?"></a>Why is it called “homogeneous”?</h3><p>Homogeneous coordinates are scale invariant.<br>(1a, 2a, 3a) in Homogeneous coordinates is the same point as (1/3, 2/3) in Euclidean space.<br>These points are “homogeneous” because they represent the same point in Euclidean space (or Cartesian space).</p><h3 id="Proof-Two-parallel-lines-can-intersect"><a href="#Proof-Two-parallel-lines-can-intersect" class="headerlink" title="Proof: Two parallel lines can intersect."></a>Proof: Two parallel lines can intersect.</h3><p><img src="./1605593492210.png" alt="Alt text"></p><ul><li>if C ≠ D -&gt; there is no solution</li><li>if C = D -&gt; two lines are identical (overlapped)</li></ul><p>笛卡尔坐标系下，两平行线要么重叠，要么永不相交。</p><hr><p>Rewrite the equations for projective space：<br><img src="./1605593639293.png" alt="Alt text"><br>we have a solution, (x, y, 0)<br>two parallel lines meet at (x, y, 0), which is the point at infinity.</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>从数学的角度讲：</p><ul><li>区分向量和点</li><li>可以表示无穷远的点</li><li>易于进行 仿射变化（Affine Transformation）。提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法。</li></ul><p>从现实意义的角度讲：</p><ul><li>描述透视空间</li><li>区分不同位置的向量</li></ul><h3 id="区分向量和点"><a href="#区分向量和点" class="headerlink" title="区分向量和点"></a>区分向量和点</h3><p>问题：笛卡尔坐标系下，三维坐标既可以表示向量，也可以表示点，从坐标上无法区分。<br>而实质上，向量和点是有区别的，点的位置是对这个基的原点o所进行的一个位移。<br>当我们在坐标系 xOy 中</p><ul><li>用 (a,b) 定义一个向量 <strong>v</strong> 时，表示 <strong>v</strong> =a<strong>x</strong> +b<strong>y</strong></li><li>用 (a,b) 表示一个点 p 时，表示 p−o=a<strong>x</strong> +b<strong>y</strong></li></ul><p>假若写下 (2,1)，如无附加说明，不能区别出它是向量还是点。<br>将点的表示重写为：<br><img src="./1605605087117.png" alt="Alt text"></p><p>将向量的表示写为:<br><img src="./1605605093577.png" alt="Alt text"></p><p>这样能够清晰地区分向量和点。数学家使用这种方式表示坐标 - 在n维向量（或坐标点）后面增加一维，这便是齐次坐标的思想。</p><p>通过如下方式可将三维坐标转换成齐次坐标：</p><ul><li>把3D向量的第4个代数分量设置为0</li><li>把3D点的第4个代数分量设置为1</li></ul><p>对于一个普通坐标的点P=(Px, Py, Pz)，有对应的<strong>一族</strong>齐次坐标(wPx, wPy, wPz, w)，其中w不等于零。</p><blockquote><p>比如，P(1, 4, 7)的齐次坐标有(1, 4, 7, 1)、（2, 8, 14, 2）、（-0.1, -0.4, -0.7, -0.1）等等。</p></blockquote><p>最后一个代数分量w称为<strong>比例因子</strong><br>当w=0时，可解释为无穷远的“点”，其意义是描述方向（既然已经是“无穷远”了，其实际位置已经没有意义了，只有用于描述方向的意义）。因此，w=0时，该坐标表示一个向量。对该坐标进行平移变换，不会产生效果，计算过程如图：<br><img src="./1605606438308.png" alt="Alt text"><br>这也符合我们原先的认知：向量没有位置，只有大小和方向。</p><h3 id="描述投影几何（-projective-geometry）"><a href="#描述投影几何（-projective-geometry）" class="headerlink" title="描述投影几何（ projective geometry）"></a>描述投影几何（ projective geometry）</h3><p>用眼睛观察世界有一个特点，就是越远的物体看起来就越小，而且我们还能通过“越远越小”这种视觉效果估算距离。 这种现象被称为透视现象，同样的存在这种现象的空间被称为<strong>投影空间</strong>。<br>在笛卡尔空间中，两条平行线是永远不会相交的，但是在透视空间中，两条平行线会相交于一点，这是两种空间最大的区别。</p><p>Projective geometry has an extra dimension, called W, in addition to the X, Y, and Z dimensions. This four-dimensional space is called “projective space,” and coordinates in projective space are called “homogeneous coordinates.”<br>（x,y,z）在齐次空间中有无数多个点与之对应。所有点的形式是（wx,wy,wz,w），其轨迹是通过齐次空间原点的“直线”</p><h4 id="An-Analogy-In-2D"><a href="#An-Analogy-In-2D" class="headerlink" title="An Analogy In 2D"></a>An Analogy In 2D</h4><p><img src="./1605607149931.png" alt="Alt text"><br>The W dimension is the distance from the projector to the screen.<br>The value of W affects the size (a.k.a. scale) of the image.</p><h4 id="Applying-It-To-3D"><a href="#Applying-It-To-3D" class="headerlink" title="Applying It To 3D"></a>Applying It To 3D</h4><p> When W increases, the coordinate expands (scales up). When W decreases, the coordinate shrinks (scales down). The W is basically a scaling transformation for the 3D coordinate.</p><p>The usual advice for 3D programming beginners is to always set W=1 whenever converting a 3D coordinate to a 4D coordinate.<br>when you scale a coordinate by 1 it doesn’t shrink or grow, it just stays the same size.</p><p>When W=1 it has no effect on the X, Y or Z values.<br>For this reason, when it comes to 3D computer graphics, coordinates are said to be “<strong>correct</strong>” only when W=1.</p><ul><li>If you rendered coordinates with W&gt;1 then everything would look too small, and with W&lt;1 everything would look too big.</li><li>If you tried to render with W=0 your program would crash when it attempted to divide by zero.</li><li>With W&lt;0 everything would flip upside-down and back-to-front.</li></ul><blockquote><p>Mathematically speaking, there is no such thing as an “incorrect” homogeneous coordinate. Using coordinates with <strong>W=1</strong> is just <strong>a useful convention</strong> for 3D computer graphics.</p></blockquote><h4 id="Uses-Of-Homogeneous-Coordinates-In-Computer-Graphics"><a href="#Uses-Of-Homogeneous-Coordinates-In-Computer-Graphics" class="headerlink" title="Uses Of Homogeneous Coordinates In Computer Graphics"></a>Uses Of Homogeneous Coordinates In Computer Graphics</h4><h5 id="Translation-Matrices-For-3D-Coordinates"><a href="#Translation-Matrices-For-3D-Coordinates" class="headerlink" title="Translation Matrices For 3D Coordinates"></a>Translation Matrices For 3D Coordinates</h5><p>In order to do translation, the matrices need to have at least four columns.<br>A four-column matrix can only be multiplied with a four-element vector, which is why we often use homogeneous 4D vectors instead of 3D vectors.</p><blockquote><p>W的几何意义与投影有关，也只有投影变换矩阵影响到w的值。平移、旋转、缩放矩阵都不影响W。</p></blockquote><p>The 4th dimension W is usually unchanged, when using homogeneous coordinates in matrix transformation. <strong>W is set to 1 when converting a 3D coordinate into 4D, and it is usually still 1 after the transformation matrices are applied, at which point it can be converted back into a 3D coordinate by ignoring the W.</strong> This is true for all <strong>translation</strong>, <strong>rotation</strong>, and <strong>scaling</strong> transformations, which are by far the most common types of transformations. <strong>The notable exception is projection matrices, which do affect the W dimension</strong>.</p><h5 id="Perspective-Transformation"><a href="#Perspective-Transformation" class="headerlink" title="Perspective Transformation"></a>Perspective Transformation</h5><p>Perspective is implemented in 3D computer graphics by using a transformation matrix that changes the W element of each vertex.<br>After the the camera matrix is applied to each vertex, but before the projection matrix is applied, <strong>the Z element of each vertex represents the distance away from the camera</strong>. Therefore, the larger Z is, the more the vertex should be scaled down. The W dimension affects the scale, so <strong>the projection matrix just changes the W value based on the Z value</strong>.<br>投影矩阵根据深度（Z）计算W值，W值影响缩放。<br><img src="./1605610411957.png" alt="Alt text"></p><p>投影矩阵相乘之后，执行透视除法，把齐次坐标转换成W=1的形式。<br>After the perspective projection matrix is applied, each vertex undergoes “perspective division.” Perspective division is just a specific term for converting the homogeneous coordinate back to W=1, as explained earlier in the article.<br><img src="./1605610619279.png" alt="Alt text"><br>After perspective division, the W value is discarded, and we are left with a 3D coordinate that has been correctly scaled according to a 3D perspective projection.</p><blockquote><p> In OpenGL, <strong>perspective division happens automatically after the vertex shader runs on each vertex.</strong> This is one reason why gl_Position, the main output of the vertex shader, is a 4D vector, not a 3D vector.</p></blockquote><h5 id="Positioning-Directional-Lights"><a href="#Positioning-Directional-Lights" class="headerlink" title="Positioning Directional Lights"></a>Positioning Directional Lights</h5><p>Points at <strong>infinity</strong> occur when W=0. Coordinates with W=0 can not be converted into 3D coordinates.</p><p><strong>Directional lights</strong></p><ul><li>point lights that are infinitely far away.</li><li>the rays of light become parallel, and all of the light travels in a single direction.</li></ul><p>W=1, then it is a point light.<br>W=0, then it is a directional light.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lightPosition.w == <span class="number">0.0</span>)&#123;</span><br><span class="line">    <span class="comment">//directional light code here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//point light code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仿射变换总结"><a href="#仿射变换总结" class="headerlink" title="仿射变换总结"></a>仿射变换总结</h2><h3 id="旋转、缩放到平移"><a href="#旋转、缩放到平移" class="headerlink" title="旋转、缩放到平移"></a>旋转、缩放到平移</h3><p>对于一个 2 维点 p=(x,y)，<strong>仿射变换</strong>（T）是线性变换（Ap）和平移变换（+t）的叠加:<br>T(p)=Ap+t</p><blockquote><p>计算机图形学中的图形变换，实际上是在仿射空间中进行的</p></blockquote><p>线性变换在欧式空间中可以表示为矩阵乘积形式，如旋转变换和缩放变换：<br><img src="./1605604356384.png" alt="Alt text"></p><p>而平移变换<br><img src="./1605604375076.png" alt="Alt text"><br>却不能用矩阵相乘的形式表达。</p><p>现在引入齐次坐标系表达 p~=(x,y,1)，（尺度不变性，实际上在高一维的空间映射到 w=1 平面, 这样计算后结果直接可导出到欧式空间）。可以将旋转变换和缩放变换表示为：<br><img src="./1605604526234.png" alt="Alt text"></p><p>以二维向量为例，平移变换则为：<br><img src="./1605604714025.png" alt="Alt text"></p><p>仿射变换的矩阵形式<br><img src="./1605604635107.png" alt="Alt text"></p><p>齐次坐标把各种变换都在统一了起来，不管怎样变换，变换多少次，都可以表示成一连串的矩阵相乘。任何三维坐标空间的转换，都可以用一个四维矩阵表示。</p><hr><p>三维向量平移运算：<br><img src="./1605624685160.png" alt="Alt text"></p><h3 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h3><h4 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h4><p>正交投影矩阵的视锥体是一个长方体[l,r][b,t][f,n]，我们要把这个长方体转换到一个正方体[-1,1][-1,1][-1,1]中，如图。<br><img src="./1605619846921.png" alt="Alt text"><br><img src="./1605619859591.png" alt="Alt text"><br>第一步平移，计算出长方体的中心点为[(l+r)/2,(b+t)/2,(f+n)/2]，然后将中心点移动到原点，矩阵为<br><img src="./1605619868421.png" alt="Alt text"><br>第二步缩放，例如从[l,r]缩放到[-1,1]，缩放系数为2/(r-l)，所以矩阵为<br><img src="./1605619877457.png" alt="Alt text"><br>所以正交投影矩阵Mortho = Mscale*Mtranslate</p><h4 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h4><p>透视投影的视锥体是一个四棱锥的一部分，其中近平面为z=n，远平面为z=f，我们要把这个视锥体转换到一个正方体[-1,1][-1,1][-1,1]中，可以先把远平面压缩，把视锥体压缩成一个长方体，然后再通过第二步中的正交投影矩阵就可以变换到正方体中，如图。<br><img src="./1605620068159.png" alt="Alt text"><br>三个原则：</p><ol><li>近平面的所有点坐标不变</li><li>远平面的所有点坐标z值不变 都是f</li><li>远平面的中心点坐标值不变 为(0,0,f)<br><img src="./1605620366905.png" alt="Alt text"><br>由三角形相似性，对于(x,y,z,1)一点，它在视锥体压缩以后坐标应该为(nx/z,ny/z,unknow,1)。<br><img src="./1605620393640.png" alt="Alt text"><br>也就是我们现在需要找到一个矩阵Mpersp-&gt;ortho，使得上面的转换成立。<br>(x,y,z,1)与(kx,ky,kz,k!=0)这两个点是完全等价的点<br><img src="./1605620546915.png" alt="Alt text"><br>需要找到矩阵Mpersp-&gt;ortho，使得上面的转换成立。</li></ol><p>Ax+By+Cz+D = nx，求出 A=n,B=C=D=0<br>Ex+Fy+Gz+H = ny，求出F=n,E=G=H=0<br>Mx+Ny+Oz+P = z，求出O=1,M=N=P=0。<br><img src="./1606293635777.png" alt="Alt text"></p><p>由（1）近平面的所有点坐标不变<br><img src="./1605621055364.png" alt="Alt text"><br>对于第一二四行，我们写出等式<br>nx+0y+0n+0<em>1=x<br>0x+ny+0n+0</em>1=y<br>0x+0y+1n+0<em>1=1<br>很明显这是有问题的，因为n应该是任意常数，但是现在只有在n等于1时，一二四行的运算才成立<br>所以我们根据前面的方法，再把(x,y,n,1)都乘以一个n等价变为(nx,ny,n</em>n,n)。<br><img src="./1605621104726.png" alt="Alt text"><br>对于第一二四行，我们写出等式<br>nx+0y+0n+0<em>1=nx,<br>0x+ny+0n+0</em>1=ny,<br>0x+0y+1n+0<em>1=n<br>完美成立。现在我们可以安心的求第三行了。<br>设第三行的四个数分别为ABCD<br>可以获得等式 Ax+By+Cn+D = n</em>n。<br>明显A=0,B=0<br>Cn+D = n*n (式1)</p><p>我们接下来考虑第三个原则，远平面的中心点坐标值不变 为(0,0,f)<br>同样为了保证之前求的矩阵一二四行成立，我们需要把(0,0,f,1)写成(0,0,f<em>f,f)<br><img src="./1605621167044.png" alt="Alt text"><br>Cf+D = f</em>f（式2）</p><p>联立式1式2，解得<br>C = n+f<br>D = -nf</p><p>终于，我们求得了Mpersp-&gt;ortho矩阵为<br><img src="./1605621187419.png" alt="Alt text"><br>也就是通过这个矩阵，我们可以把原来的透视投影的视锥体压缩为正交投影的视锥体(长方体)<br>最后我们再乘上一开始求出来正交投影矩阵Morth就得到了透视投影矩阵<br>Mpersp = Mortho*Mpersp-&gt;ortho<br><img src="./1605621299525.png" alt="Alt text"></p><p><img src="./1605621446770.png" alt="Alt text"></p><p>推导过程及代码：<br><a href="http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html" target="_blank" rel="noopener">http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html</a></p><p><strong>After multiplying the vertex position by the projection matrix the coordinates are said to be in Clip Space and after performing the perspective divide the coordinates are in NDC Space (Normalized Device Coordinates).</strong></p><h2 id="Prin对齐次坐标、透视投影的理解"><a href="#Prin对齐次坐标、透视投影的理解" class="headerlink" title="Prin对齐次坐标、透视投影的理解"></a>Prin对齐次坐标、透视投影的理解</h2><p>如何理解四维坐标，如何理解w分量？<br>本质问题是，将一个frustum(截头锥体)压缩成一个正方体，求frustum中的点的坐标到正方体空间中点的坐标的一个映射关系。并用矩阵、线性代数的语言描述这一变换，使得所有的点的变换可以用同一个矩阵乘法进行描述，从而可以让计算机对所有顶点批量处理这一变换。</p><p>关键点：这个变换不是线性变换，无法用三维矩阵乘法描述。这个变换对所有点不是统一的，还与点到摄像机的距离有关系，不能对所有的点进行统一的变换，意味着对每个点增加一个属性，来描述点到摄像机的距离属性，从而使得这个变换与距离有关，这个属性就是点的w分量。</p><p>引入w分量之后，点的坐标扩充到四维，变换矩阵是4x4的矩阵。使用四维矩阵进行投影变换本质上是使用四维空间下的线性变换描述三维空间下的非线性变换（将frustum“捏”成正方体的变换）。<br>引入w分量后，实际上将一个点映射成了无数个点。我们定义了三维空间中点(x, y, z)对应的齐次坐标为(wx, wy, wz, w),(w!=0)。</p><p>之前“捏”frustum的操作，用三维空间线性变换是无法描述的，用3x3矩阵乘法进行变换是无法达到要求的。我们发现，当扩充一个维度之后，看待这个问题，之前的一些”无理要求”是可以满足的。</p><p>按照把frustum“捏”成正方体的条件，建立方程，在齐次空间下求这个映射函数，求出了满足要求的变换矩阵。变换之后，点的坐标是下图右边这个样子：<br><img src="./1606297457393.png" alt="Alt text"><br>再映射到三维空间的点就是这个样子：<br><img src="./1606297509696.png" alt="Alt text"></p><p>这样一来，我们对所有的点都可以进行这个变换过程:</p><ol><li>映射到齐次坐标空间（增加一个w分量，变为四维坐标）</li><li>按照我们对视锥体进行形变的要求，求得4x4变换矩阵。</li><li>齐次空间下做统一的缩放、平移变换，这个变换过程中，点将到摄像机的距离体现在w分量上面。</li><li>变换后，再将点映射到三维空间，发现原视锥体经变换后成功映射为正方体，其他所有点也经过了相同的映射，结果是合理的。</li></ol><h2 id="渲染管线中坐标变换总结"><a href="#渲染管线中坐标变换总结" class="headerlink" title="渲染管线中坐标变换总结"></a>渲染管线中坐标变换总结</h2><h3 id="坐标变换过程"><a href="#坐标变换过程" class="headerlink" title="坐标变换过程"></a>坐标变换过程</h3><p>物体空间(object space)-&gt;世界空间(World Space)-&gt;观察空间(View Space)-&gt;裁剪空间(clip space)-&gt;屏幕空间(Screen Space)<br><img src="./1605627042134.png" alt="Alt text"></p><ul><li>Object Coordinate System: 也称作Local coordinate System，用来定义一个模型本身的坐标系。</li><li>World Coordinate System: 3d 虚拟世界中的绝对坐标系，定义好这个坐标系的原点就可以用来描述模型的实现的位置，Camera 的位置，光源的位置。</li><li>View Coordinate System: 一般使用用来计算光照效果。</li><li>Clip Coordinate System:  对3D场景使用投影变换裁剪视锥。</li><li>Normalized device coordinate System (NDC): 归一化设备坐标系</li><li>Windows Coordinate System: 最后屏幕显示的2D坐标系统，一般原点定义在屏幕左上角。<h3 id="MVP矩阵及使用"><a href="#MVP矩阵及使用" class="headerlink" title="MVP矩阵及使用"></a>MVP矩阵及使用</h3>模型（Model）、观察（View）和投影（Projection）矩阵</li></ul><p><img src="./1605625875848.png" alt="Alt text"></p><h4 id="The-Model-matrix"><a href="#The-Model-matrix" class="headerlink" title="The Model matrix"></a>The Model matrix</h4><p>We went from Model Space (all vertices defined relatively to the center of the model) to World Space (all vertices defined relatively to the center of the world).<br><img src="./1605625959705.png" alt="Alt text"></p><h4 id="The-View-matrix"><a href="#The-View-matrix" class="headerlink" title="The View matrix"></a>The View matrix</h4><p>We went from World Space (all vertices defined relatively to the center of the world, as we made so in the previous section) to Camera Space (all vertices defined relatively to the camera).</p><blockquote><p>Unity中</p><ul><li>模型空间 &amp; 世界空间: 左手坐标系.</li><li>观察空间: 右手坐标系 (+x轴指向右方, +y轴指向上方, +z轴指向相机的后方)</li></ul></blockquote><p><img src="./1605626040517.png" alt="Alt text"></p><blockquote><p>The engines don’t move the ship at all. The ship stays where it is and the engines move the universe around it.</p></blockquote><h4 id="The-Projection-matrix"><a href="#The-Projection-matrix" class="headerlink" title="The Projection matrix"></a>The Projection matrix</h4><p>We’re now in Camera Space. This means that after all theses transformations, a vertex that happens to have x==0 and y==0 should be rendered at the center of the screen. But we can’t use only the x and y coordinates to determine where an object should be put on the screen : its distance to the camera (z) counts, too ! <strong>For two vertices with similar x and y coordinates, the vertex with the biggest z coordinate will be more on the center of the screen than the other.</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generates a really hard-to-read matrix, but a normal, standard 4x4 matrix nonetheless</span></span><br><span class="line">glm::<span class="type">mat4</span> projectionMatrix = glm::perspective(</span><br><span class="line">    glm::<span class="built_in">radians</span>(FoV), <span class="comment">// The vertical Field of View, in radians: the amount of "zoom". Think "camera lens". Usually between 90° (extra wide) and 30° (quite zoomed in)</span></span><br><span class="line">    <span class="number">4.0</span>f / <span class="number">3.0</span>f,       <span class="comment">// Aspect Ratio. Depends on the size of your window. Notice that 4/3 == 800/600 == 1280/960, sounds familiar ?</span></span><br><span class="line">    <span class="number">0.1</span>f,              <span class="comment">// Near clipping plane. Keep as big as possible, or you'll get precision issues.</span></span><br><span class="line">    <span class="number">100.0</span>f             <span class="comment">// Far clipping plane. Keep as little as possible.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>We went from Camera Space (all vertices defined relatively to the camera) to Homogeneous Space (all vertices defined in a small cube. Everything inside the cube is onscreen).</p><p>Before projection, we’ve got our blue objects, in Camera Space, and the red shape represents the <strong>frustum</strong> of the camera : the part of the scene that the camera is actually able to see.<br><img src="./1605626582117.png" alt="Alt text"><br>Multiplying everything by the Projection Matrix has the following effect :<br><img src="./1605626624387.png" alt="Alt text"><br>In this image, the frustum is now a perfect cube (between -1 and 1 on all axes, it’s a little bit hard to see it), and all blue objects have been deformed in the same way. Thus, the objects that are near the camera ( = near the face of the cube that we can’t see) are big, the others are smaller. Seems like real life !<br><img src="./1605626691338.png" alt="Alt text"></p><p>Another mathematical transformation is applied (this one is automatic, you don’t have to do it yourself in the shader) to fit this to the actual window size :<br><img src="./1605626743536.png" alt="Alt text"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://oncemore2020.github.io/blog/homogeneous/" target="_blank" rel="noopener">https://oncemore2020.github.io/blog/homogeneous/</a><br><a href="http://www.songho.ca/math/homogeneous/homogeneous.html" target="_blank" rel="noopener">http://www.songho.ca/math/homogeneous/homogeneous.html</a><br><a href="https://zhuanlan.zhihu.com/p/110503121" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110503121</a><br><a href="https://blog.csdn.net/yinhun2012/article/details/79566148" target="_blank" rel="noopener">https://blog.csdn.net/yinhun2012/article/details/79566148</a><br><a href="https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/" target="_blank" rel="noopener">https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/</a><br><a href="https://zhuanlan.zhihu.com/p/122411512" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/122411512</a><br><a href="http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-3-matrices/" target="_blank" rel="noopener">http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-3-matrices/</a><br><a href="http://www.guidebee.info/wordpress/?m=201106" target="_blank" rel="noopener">http://www.guidebee.info/wordpress/?m=201106</a></p>]]></content>
      
      
      <categories>
          
          <category> CG&amp;Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> CG </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础】纹理(Texture)知识知多少</title>
      <link href="2020/11/06/Basic-About-Texture/"/>
      <url>2020/11/06/Basic-About-Texture/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><strong>纹理</strong>最初的目的就是使用一张图片来控制模型的外观。使用<strong>纹理映射（texture mapping）</strong>技术，我们可以把一张图“黏”在模型表面，逐<strong>纹素（texel）</strong>（纹素的名字是为了和像素进行区分）地控制模型的颜色。</p><h2 id="UV坐标"><a href="#UV坐标" class="headerlink" title="UV坐标"></a>UV坐标</h2><p><strong>纹理映射坐标（texture-mapping coordinates） / UV坐标：</strong> 存储在每个顶点上，定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个二维变量(u，v)来表示，其中u是横向坐标，而v是纵向坐标。</p><blockquote><p>顶点UV坐标的范围通常都被归一化到[0，1]范围内。<br>在OpenGL里，纹理空间的原点位于左下角，而在DirectX中，原点位于左上角。Unity使用的纹理空间是符合OpenGL的传统的</p></blockquote><h3 id="uv-uv2-uv3-uv4"><a href="#uv-uv2-uv3-uv4" class="headerlink" title="uv, uv2, uv3, uv4"></a>uv, uv2, uv3, uv4</h3><p><img src="./UV.png" alt="Alt text"><br>unity一共支持4套uv，在shader编程中，分别叫UV0, UV1, UV2, UV3，而在c＃编程中分别叫uv, uv2, uv3, uv4。<br>通常来说(使用c# API中的命名)，uv用于主纹理, uv2用于光照贴图(Lightmap)的采样, uv3用于实时动态光照, uv4可进行自定义。<br>uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。如果在建模软件中只做了一套uv，将模型导入unity的时候，在导入设置中勾选Generate Lightmap UVs, unity会自动为我们生成用于光照贴图的uv2。uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p><blockquote><p>3DMax和maya等软件都能对模型加多套uv<br>注意模型在fbx里可以保留多套uv，但是obj里只能保留默认的第一套<br>另外unity里现在貌似支持最多四套</p></blockquote><h3 id="清除不必要的UV通道"><a href="#清除不必要的UV通道" class="headerlink" title="清除不必要的UV通道"></a>清除不必要的UV通道</h3><p>某些时候，因为美术的一些意外操作，会引入多个我们不需要的UV通道。<br>由于unity的光照贴图会自动占用uv2通道，如果你的项目中又使用的是动态加载光照贴图的方式的话，最好不要在导入模型的时候把UV2设置为null，如果你这样做了有可能会导致光照贴图显示不出来的问题。<br>如果物体不需要烘培，你自己也不使用uv2，则可以删除该通道。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除color和uv</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClearModelUV</span>:<span class="title">AssetPostprocessor</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnPostprocessModel</span>(<span class="params">GameObject rImaportModel</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ClearMeshUVAndColorChannel(rImaportModel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ClearMeshUVAndColorChannel</span>(<span class="params">GameObject rImportModel</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">List&lt;Vector2&gt; rNewUV = <span class="literal">null</span>;</span><br><span class="line">List&lt;Color32&gt; rNewColor = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> rFilters= rImportModel.GetComponentsInChildren&lt;MeshFilter&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> filter_index = <span class="number">0</span>; filter_index &lt; rFilters.Length; filter_index++)</span><br><span class="line">&#123;</span><br><span class="line">rFilters[filter_index].sharedMesh.SetColors(rNewColor);</span><br><span class="line">rFilters[filter_index].sharedMesh.SetUVs(<span class="number">1</span>, rNewUV);</span><br><span class="line">rFilters[filter_index].sharedMesh.SetUVs(<span class="number">2</span>, rNewUV);</span><br><span class="line">rFilters[filter_index].sharedMesh.SetUVs(<span class="number">3</span>, rNewUV);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Texture-Type"><a href="#Texture-Type" class="headerlink" title="Texture Type"></a>Texture Type</h3><p>Default 默认的纹理类型，普通的图片<br>Normal map 法线贴图</p><blockquote><p>【关于法线贴图：就是看起来与3D效果无异的2D贴图】<br>游戏场景中譬如雕刻这种3D细节，如果做3D模型的话，就会浪费显示芯片，使游戏性能下降，便会用法线贴图，既不影响玩家体验游戏又不影响游戏性能</p></blockquote><p>Editor GUI and Legacy GUI  GUI编辑器用到的UI贴图<br>Sprite(2D and UI)  图片精灵，主要用于2D游戏中，把一张大的图分割成一张张小图，大的图叫图集atlas,<br>小的图叫精灵sprite,可以通过精灵名字来使用精灵.<br>Cursor 鼠标或者叫光标的贴图<br>Cubemap 立方体的纹理<br>Cookie  遮罩贴图 聚光灯贴图<br>Lightmap 光照或者叫烘焙贴图<br>Advanced 高级(可自定义一些贴图属性)</p><h3 id="Alpha-Source-α通道来源"><a href="#Alpha-Source-α通道来源" class="headerlink" title="Alpha Source (α通道来源)"></a>Alpha Source (α通道来源)</h3><ol><li>None：强制无α通道。</li><li>Input Texture Alpha：使用纹理自带的α通道。</li><li>From Gray Scale：使用纹理RGB通道的均值来生成α通道。</li></ol><h3 id="Alpha-Is-Transparen"><a href="#Alpha-Is-Transparen" class="headerlink" title="Alpha Is Transparen"></a>Alpha Is Transparen</h3><p>当alpha用于透明处理时，我们要勾上该选项，可以防止不透明边缘锯齿现象</p><p>性”alpha is transparency”，原理是在压缩之前对贴图进行颜色放大处理来搞定边缘锯齿问题，这个颜色放大处理等同于ps里的最小值滤镜操作，对图片边缘做强化处理。</p><p>一个坑：（<a href="http://blog.coolcoding.cn/?p=198）" target="_blank" rel="noopener">http://blog.coolcoding.cn/?p=198）</a><br>如果有一张PNG图片, 95%的地方是全透明的,而在全透明的地方,RGB值是有意义的;<br>如果设置了alphaIsTransparency属性,则全透明的地方,Unity会将RGB值全部丢失!!!<br>如果要使用此纹理的4个通道做数据存储时(比如地型的4通道混合)<br>千万不能勾选alphaIsTransparency属性<br>除非此PNG图片仅仅用于UI显示。</p><h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><p>Non Power of 2：NPOT的处理方式。<br>Read/Write Enabled：读写开关，非必要不开启，否则会增加一倍的 内存。<br>Generate Mip Maps：生成Mip Maps，会增加33%的内存。一般用 于模型纹理，UI、天空盒等纹理不需要开启。<br>Border Mip Maps：防止低阶的Mip Map的色彩值溢出边界，一般用 于光照Cookie。<br>Mip Map Filtering：过滤算法，Box和Kaiser。<br>Fadeout Mip Maps：根据层阶使Mip Map慢慢变灰，一般用于细节 贴图（DetailMaps）。</p><h3 id="Wrap-Mode"><a href="#Wrap-Mode" class="headerlink" title="Wrap Mode"></a>Wrap Mode</h3><p>Wrap mode determines how texture is sampled when texture coordinates are outside of the typical 0..1 range.<br>这由纹理的映射函数来决定。在OpenGL中，这类映射函数称为“Texture Wrapping Mode”；在D3D中，称为“Texture Addressing Mode”。</p><h4 id="Repeat-重复"><a href="#Repeat-重复" class="headerlink" title="Repeat   重复"></a>Repeat   重复</h4><p>Tiles the texture, creating a repeating pattern.<br>When UVs are outside of the 0…1 range, the integer part will be ignored, thus creating a repeating pattern.<br>在算法上，忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上。对于大多数复制纹理的使用，在纹理顶部的纹理单元应与底部的纹理单元相匹配，在纹理左侧的纹理单元也应与右侧的纹理单元相匹配。这样才能做到无缝连接。</p><h4 id="Clamp-拉伸"><a href="#Clamp-拉伸" class="headerlink" title="Clamp    拉伸"></a>Clamp    拉伸</h4><p>makes the texture edge pixels be stretched when outside of of 0..1 range.<br>This is useful for preventing wrapping artifacts when mapping an image onto an object and you don’t want the texture to tile. UV coordinates will be clamped to the range 0…1. When UVs are larger than 1 or smaller than 0, the last pixel at the border will be used.<br>将大于1.0的数值设置为1.0，将小于0.0的数值设置为0.0，即将超出[0.0,1.0]范围的数值截取到[0.0,1.0]范围内，这样会导致纹理边缘的重复。</p><h4 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h4><p>Tiles the texture, creating a repeating pattern by mirroring it at every integer boundary.</p><h4 id="Mirror-Once"><a href="#Mirror-Once" class="headerlink" title="Mirror Once"></a>Mirror Once</h4><p>Mirrors the texture once, then clamps to edge pixels.<br>This effectively mirrors the texture around zero UV coordinates, and repeats edge pixel values when outside of [-1..1] range.</p><blockquote><p>This mode is called “mirror and clamp to edge” in graphics APIs like Vulkan, Metal and OpenGL. This feature is not always supported when using OpenGL ES and Vulkan graphics APIs, specifically on ARM and Qualcomm GPUs platforms. Check SystemInfo.supportsTextureWrapMirrorOnce to figure out whether the system is capable..</p></blockquote><h4 id="Per-axis"><a href="#Per-axis" class="headerlink" title="Per-axis"></a>Per-axis</h4><p>Choose this to individually control how Unity wraps Textures at the U axis and V axis.</p><h3 id="Filter-Mode"><a href="#Filter-Mode" class="headerlink" title="Filter Mode"></a>Filter Mode</h3><p>控制纹理通过三维变换拉伸的计算(过滤)方式</p><p>Point：最近点采样，当纹理坐标没有刚好对应Texture上的一个采样点时，它会选择最近的一个采样点作为该坐标的采样值，</p><p>当纹理没有拉伸变形时，这样还不错，因为速度是最快的，但如果拉伸变形了，会出现马赛克现象。</p><p>Bilinear：双线性过滤，以像素对应的纹理坐标为中心，采样它周围4个texel（纹素）的像素，取平均值作为该坐标采样值。这是Unity默认的模式，过渡效果相对平滑，当然速度会比最近点采样有一定下降。会有模糊化现象。</p><p>Trilinear：三线性过滤，会对像素大小和纹素大小最接近的两层Mipmap level分别进行双线性过滤，再对结果进行线性插值。由于使用了两次双线性过滤，也就是计算2x4=8个像素的值，速度会更加下降，当然滤波效果更好。同上也会有模糊化现象。</p><h3 id="Aniso-Level"><a href="#Aniso-Level" class="headerlink" title="Aniso Level"></a>Aniso Level</h3><p>各向异性级别。当以一个过小的角度观察纹理时，此数值越高观察的纹理质量就越高，该参数对于提高地面等纹理的显示效果非常明显。</p><blockquote><p>Default  点了没效果不能重置所有设置，还是得手动选择.废弃的按钮</p></blockquote><h3 id="对不同平台的压缩设置"><a href="#对不同平台的压缩设置" class="headerlink" title="对不同平台的压缩设置"></a>对不同平台的压缩设置</h3><ul><li>Max Size：最大尺寸。</li><li>Compression：压缩质量。</li><li>Format：压缩格式。<br>格化式存储该纹理的类型，纹理的精度越高，占用的内存越大，得到的效果也越好</li><li>Compressed    默认压缩方式,PVRTC图片格式，压缩选项将会针对你的目标平台来选择最合适的压缩算法替换原来的我们给的图片格式(比如我们给的是PNG格式)。<br>  16 bits            无压缩16位格式，比32位节省一半的空间和内存。<br>  Truecolor       无压缩32位以上真彩色,适合对色彩要求较高的情况下使用，比较占空间和内存。</li><li>Compressor Quality：压缩质量</li><li>Use Crunch Compression：紧凑压缩<blockquote><p>Crunched  这种类型将会根据显卡的GPU来选择合适的压缩格式进行压缩然后会选用一种CPU上就能处理的压缩格式再压缩一遍。如果在制作供人下载的资源包的时候这种类型非常的合适。这个类型的压缩需要很长时间，但在运行时解压是非常快的。</p></blockquote></li></ul><h3 id="其他纹理类型设置"><a href="#其他纹理类型设置" class="headerlink" title="其他纹理类型设置"></a>其他纹理类型设置</h3><h3 id="Normal-Map"><a href="#Normal-Map" class="headerlink" title="Normal Map"></a>Normal Map</h3><p>与Default相比增加了一下设置：<br>Create from Grayscale：从灰度高度图（Heightmap）创建。<br>Bumpiness：崎岖度。<br>Filtering：滤波算法。</p><ol><li>Smooth：平滑，标准前向差分算法。 2. Sharp：尖锐，Sobel滤波器。</li></ol><h4 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h4><p>与Default相比增加了一下设置：<br>Sprite Mode：精灵模式。</p><ol><li>Single：单图。</li><li>Multiple：多图。</li><li>Polygon：多边形，在SpriteEditor里使用多边形裁剪精灵。<br>PackingTag：指定图集。<br>PixelsPer Unit：每单位像素数，在世界场景中，每单位距离有多少个 像素。</li></ol><p>Mesh Type：网格类型（Polygon模式无此属性）。</p><ol><li>FullRect：矩形。 2. Tight：紧凑的，根据Alpha通道生成Mesh。（2DObject）<br>ExtrudeEdge：拉伸边缘。</li></ol><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie类型的纹理设置<br>与Default相比增加了一下设置：<br>Light Type：光照类型。</p><ol><li>Spotlight：聚光灯，形状必须为2D。</li><li>Directional：平行光，形状必须为2D。</li><li>Point：点光源，形状必须为立方体。</li></ol><h2 id="Sprite及图集的使用"><a href="#Sprite及图集的使用" class="headerlink" title="Sprite及图集的使用"></a>Sprite及图集的使用</h2><blockquote><p>只有Sprite模式的图片才可以打包成图集</p></blockquote><p>旧版：<br>Sprite Mode 设置为 Muitiple 设置Packing Tag<br>Window-&gt;Sprite Packer –&gt;点击 Pack 即可</p><p>新版：<br>Project Setting -&gt; Editor  -&gt; Sprite Packer -&gt; Mode = Always Enabled<br>新建 Sprite Atlas<br>选择打包图集的文件夹或者依次添加单独图片，点击Pack Preview后自动打包成一个图集</p><p>代码获取图集并动态选择Sprite：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.U2D;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpriteAtlasExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SpriteAtlas atlas = AssetDatabase.LoadAssetAtPath&lt;SpriteAtlas&gt;(<span class="string">"Assets/TestAtlas.spriteatlas"</span>);</span><br><span class="line">        Sprite sprite = atlas.GetSprite(<span class="string">"Icon2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (sprite != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetComponent&lt;Image&gt;().sprite = sprite;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="压缩格式相关"><a href="#压缩格式相关" class="headerlink" title="压缩格式相关"></a>压缩格式相关</h2><h3 id="图像文件格式"><a href="#图像文件格式" class="headerlink" title="图像文件格式"></a>图像文件格式</h3><p>文件格式是图像为了存储信息而使用的对信息的特殊编码方式，它存储在磁盘中，或者内存中，但是并不能被GPU所识别，因为以向量计算见长的GPU对于这些 复杂的计算无能为力。这些文件格式当被游戏读入后，还是需要经过CPU转换成图形硬件支持的格式，再传送到GPU端进行使用。<br>常用的图片格式及特点如下：</p><ul><li>JPG 有损压缩 文件小 不支持透明</li><li>PNG 无损压缩 文件小 支持透明</li><li>TAG 无损压缩 文件大 支持透明</li><li>DDS 无损压缩 文件最小 支持透明</li></ul><p>不同格式的本质区别在于压缩算法不一样，结果图片大小，还原度也各不相同。</p><blockquote><p>TIFF（Tag Image File Format）文件是由Aldus和Microsoft公司为扫描仪和桌上出版系统研制开发的一种较为通用的图像文件格式。TIFF格式灵活易变，同时定义了四类不同的格式：TIFF－B适用于二值图像；TIFF－G适用黑白灰度图像；TIFF－P适用于带调色板的彩色图像；TIFF－R适用于RGB真彩图像。TIFF支持多种编码方法，其中包括RGB无损压缩、RLE压缩以及JPEG压缩等。</p><p>GIF（Graphics Interchange Format ）是CompuServe公司在1987年开发的图像文件格式。GIF文件的数据是经过压缩的，它采用了可变长度的压缩算法。GIF的图像深度从1 bit到8 bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。</p></blockquote><h3 id="3D-图形硬件支持的压缩格式"><a href="#3D-图形硬件支持的压缩格式" class="headerlink" title="3D 图形硬件支持的压缩格式"></a>3D 图形硬件支持的压缩格式</h3><p>JPG, PNG, PSD are  not used <strong>during realtime rendering by 3D graphics hardware</strong>  such as a graphics card or mobile device. 3D graphics hardware requires Textures to be compressed in specialized formats which are <strong>optimised for fast Texture sampling</strong> . The various different platforms and devices available each have their own different proprietary formats.</p><p>By default, the Unity Editor automatically converts Textures to the most appropriate format to match the build target you have selected. Only the converted Textures are included in your build; your source Asset<br> files are left in their original format, in your project’s Assets folder.</p><blockquote><p>如果发现GPU不支持当前压缩格式，Unity就会将纹理转换成RGB（A），首先是解压过程的消耗，其次是内存中会保存两个纹理。</p></blockquote><h4 id="简单纹理格式"><a href="#简单纹理格式" class="headerlink" title="简单纹理格式"></a>简单纹理格式</h4><p>RGBA8888 每个像素4字节，RGBA通道各占用8位<br>RGBA4444 每个像素2字节，RGBA通道各占用4位<br>RGB888 每个像素3字节，RGB通道各占用8位，无透明通道<br>RGB565 每个像素2字节，RGB通道各占用5/6/5位，无透明通道<br>RGBA5551 每个像素2字节，RGB通道各占用5位，透明通道1位，所以要么完全透明要么不透明</p><blockquote><p>所有设备对RGB 16BITS/ARGB 16BITS/RGB A16BITS/RGB 24BITS/ARGB 32BITS等支持都很好，只是这些格式算是非压缩格式，对内存消耗和渲染消耗非常不友好。</p></blockquote><h4 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h4><ul><li>DXT - 有损压缩方式</li><li>ETC - （Ericsson Texture Compression），在移动平台中广泛采用。它是一种为感知质量设计的有损算法，其依据是人眼对亮度改变的反应要高于色度改变。<ul><li>ETC1：安卓原生支持，在各种Android设备上非透明纹理都可以采用ETC1格式。ETC1不支持透明，对于透明纹理，在Android设备上，可以把RGB和Alpha拆到2张ETC1纹理上，游戏中再合成使用。</li><li>ETC2是ETC1的扩张，向后兼容ETC1，对RGB的压缩质量更好，并且支持透明通道。ETC2比ETC1压缩质量更高，而且支持透明，在Android设备上再也不需要打不同纹理格式的包了。不过需要OpenGL ES 3.0以上才可以，目前很多设备只支持OpenGL ES 2.0。</li></ul></li><li>PVRTC（PowerVR Texture Compression） - 压缩比高，也是有损压缩。iOS只支持PVRTC的压缩格式。</li></ul><p>关于压缩后的在储存上的大小，假设高清(ARGB32)大小为1，那么大概数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RGB PVRTC 4BITS:0.25</span><br><span class="line">ARGB PVRTC 4BITS:0.25</span><br><span class="line">RGB PVRTC 2BITS:0.13</span><br><span class="line">ARGB PVRTC 2BITS:0.13</span><br><span class="line">RGBA ETC2 4BITS:0.25</span><br><span class="line">RGBA ETC2 8BITS:0.25</span><br><span class="line">RGB + 1-bit ALPHA ETC2 8BITS:0.2</span><br><span class="line">DXT1 :0.3</span><br><span class="line">DXT5 : 0.6</span><br><span class="line">ARGB 16BITS:0.33</span><br><span class="line">RGB 16BITS:0.5</span><br><span class="line">RGB 24BITS:0.85</span><br><span class="line">ARGB 32BITS:1</span><br></pre></td></tr></table></figure><br>内存中的大小，假设高清(ARGB32)大小为1，那么大概数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RGB PVRTC 2BITS:0.0625</span><br><span class="line">ARGB PVRTC 2BITS:0.0625</span><br><span class="line">RGB PVRTC 4BITS:0.125</span><br><span class="line">ARGB PVRTC 4BITS:0.125</span><br><span class="line">RGBA ETC2 4BITS:0.125</span><br><span class="line">RGBA ETC2 8BITS:0.25</span><br><span class="line">RGB + 1-bit ALPHA ETC2 8BITS:0.125</span><br><span class="line">DXT1 : 0.125</span><br><span class="line">DXT5 : 0.25</span><br><span class="line">ARGB 16BITS:0.5</span><br><span class="line">RGB 16BITS:0.5</span><br><span class="line">RGB 24BITS:0.8</span><br><span class="line">ARGB 32BITS:1</span><br></pre></td></tr></table></figure></p><h4 id="格式选择"><a href="#格式选择" class="headerlink" title="格式选择"></a>格式选择</h4><p>一般方案：ETC1+Alpha/PVRTC4 和 RGB16/RGBA16 搭配使用。</p><hr><h5 id="高清无压缩"><a href="#高清无压缩" class="headerlink" title="高清无压缩"></a>高清无压缩</h5><p>RGBA32 （等同于原图了，效果最好，效率最差。）</p><hr><h5 id="中清晰中压缩"><a href="#中清晰中压缩" class="headerlink" title="中清晰中压缩"></a>中清晰中压缩</h5><ul><li>不透明贴图 ：RGB 16BITS</li><li>透明贴图：RGBA 16BITS + Dithering<blockquote><p>RGBA16在遇到渐变的时候表现很差，可能需要做抖动（Dithering）处理。<br>16位压缩会带来颜色损失，但如果本来美术就是按16BITS画的话，就不会损失，日本好些手游都是按16BITS来画的。这样的游戏一般少渐变艳度高比较容易看出来。</p></blockquote></li></ul><hr><h5 id="低清晰高压缩"><a href="#低清晰高压缩" class="headerlink" title="低清晰高压缩"></a>低清晰高压缩</h5><p>ETC1+Alpha/PVRTC4（能直接被GPU使用，占用少，效率高。）</p><p>IOS下</p><ul><li>普通不透明：RGB PVRTC 4BITS</li><li>普通透明：RGBA PVRTC 4BITS</li></ul><blockquote><p>PVRTC 要求方形的图集贴图<br>非方形的贴图会被转成16位RGB(A)的压缩格式。</p></blockquote><p>Android下：</p><ul><li>普通不透明：RGB ETC 4BITS</li><li>普通透明：<ul><li>RGBA 16BIT</li><li>有针对性的选择DXT5/ATC8 BITS/ETC2 8BITS</li><li>如果有技术支持，可以采用RGB ETC 4BITS加一张ALPHA 8的贴图来实现透明效果。</li></ul></li></ul><p><strong>对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16</strong></p><blockquote><p>Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；<br>iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。<br>另外，针对Android 上的带Alpha通道的图片，还有一种常见的做法，即把Alpha通道独立出来作为另一张纹理，从而将 RGB 部分和 Alpha 部分分别采用 ETC1来压缩，但渲染时就需要自定义的 Shader来处理。</p></blockquote><p>windows：<br>使用Compressed格式。会压缩为DXT5（带透明通道），DXT1 格式。</p><h4 id="关于POT-Power-Of-Two"><a href="#关于POT-Power-Of-Two" class="headerlink" title="关于POT(Power Of Two)"></a>关于POT(Power Of Two)</h4><p>Only textures with width/height being multiple of 4 can be compressed to ETC1 format.（ 只有宽/高的尺寸是4的倍数才能被压缩成ETC1格式。)<br>Only POT textures can be compressed to ETC1 format. ( 只有POT(Power of two,2的幂次方)的贴图才能被压缩成ETC1格式。)</p><p>如果纹理的原始尺寸不是2的幂次方的话，则可在Unity中可以通过导入设置来进行更正。<br><img src="./1604336979482.png" alt="Alt text"></p><ul><li>None不做处理</li><li>ToNearest（选择最接近的幂次方）</li><li>ToLarger（选择最大尺寸的幂次方）</li><li>ToSmaller（选择最小尺寸的幂次方）</li></ul><p>以一张513x1023尺寸的图片来举例：</p><ul><li>None：513x1023</li><li>ToNearest：512x1024</li><li>ToLarger：1024x1024</li><li>ToSmaller：512x512</li></ul><h2 id="实用的小工具"><a href="#实用的小工具" class="headerlink" title="实用的小工具"></a>实用的小工具</h2><h3 id="Texture转换成Texture2D"><a href="#Texture转换成Texture2D" class="headerlink" title="Texture转换成Texture2D"></a>Texture转换成Texture2D</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Texture转换成Texture2D...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="texture"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">Texture2D <span class="title">TextureToTexture2D</span>(<span class="params">Texture texture</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Texture2D texture2D = <span class="keyword">new</span> Texture2D(texture.width, texture.height, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    RenderTexture currentRT = RenderTexture.active;</span><br><span class="line"></span><br><span class="line">    RenderTexture renderTexture = RenderTexture.GetTemporary(texture.width, texture.height, <span class="number">32</span>);</span><br><span class="line">    Graphics.Blit(texture, renderTexture);</span><br><span class="line"></span><br><span class="line">    RenderTexture.active = renderTexture;</span><br><span class="line">    texture2D.ReadPixels(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, renderTexture.width, renderTexture.height), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    texture2D.Apply();</span><br><span class="line"></span><br><span class="line">    RenderTexture.active = currentRT;</span><br><span class="line">    RenderTexture.ReleaseTemporary(renderTexture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> texture2D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Texture2D形式截图"><a href="#Texture2D形式截图" class="headerlink" title="Texture2D形式截图"></a>Texture2D形式截图</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 截图...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="rect"&gt;</span>截图的区域<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">Texture2D <span class="title">CaptureScreenshot</span>(<span class="params">Rect rect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先创建一个的空纹理，大小可根据实现需要来设置</span></span><br><span class="line">Texture2D screenShot = <span class="keyword">new</span> Texture2D((<span class="keyword">int</span>)rect.width, (<span class="keyword">int</span>)rect.height, TextureFormat.RGB24,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取屏幕像素信息并存储为纹理数据，</span></span><br><span class="line">screenShot.ReadPixels(rect, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">screenShot.Apply();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将这些纹理数据，成一个png图片文件</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = screenShot.EncodeToPNG();</span><br><span class="line"><span class="keyword">string</span> filename = Application.dataPath + <span class="string">"/Screenshot.png"</span>;</span><br><span class="line">System.IO.File.WriteAllBytes(filename, bytes);</span><br><span class="line">Debug.Log(<span class="keyword">string</span>.Format(<span class="string">"截屏了一张图片: &#123;0&#125;"</span>, filename));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，我返回这个Texture2d对象，这样我们直接，所这个截图图示在游戏中，当然这个根据自己的需求的。</span></span><br><span class="line"><span class="keyword">return</span> screenShot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Texture保存到本地"><a href="#Texture保存到本地" class="headerlink" title="Texture保存到本地"></a>Texture保存到本地</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将Texture转为本地PNG...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filePath"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="teture"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">saveMainTextureToPng</span>(<span class="params"><span class="keyword">string</span> filePath, Texture teture</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (teture.GetType() != <span class="keyword">typeof</span>(Texture2D))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Texture2D savedTexture = (Texture2D)teture;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Texture2D newTexture = <span class="keyword">new</span> Texture2D(savedTexture.width, savedTexture.height, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">        newTexture.SetPixels(<span class="number">0</span>, <span class="number">0</span>, savedTexture.width, savedTexture.height, savedTexture.GetPixels());</span><br><span class="line">        newTexture.Apply();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = newTexture.EncodeToPNG();</span><br><span class="line">        <span class="keyword">if</span> (bytes != <span class="literal">null</span> &amp;&amp; bytes.Length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (File.Exists(filePath))</span><br><span class="line">            &#123;</span><br><span class="line">                File.Delete(filePath);</span><br><span class="line">            &#125;</span><br><span class="line">            System.IO.File.WriteAllBytes(filePath, bytes);                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将图片转换为byte数组"><a href="#将图片转换为byte数组" class="headerlink" title="将图片转换为byte数组"></a>将图片转换为byte数组</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 将图片转换为byte数组...</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filePath"&gt;</span>图片路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">ReadTexture</span>(<span class="params"><span class="keyword">string</span> filePath</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      FileStream fileStream = <span class="keyword">new</span> FileStream(filePath, FileMode.Open, System.IO.FileAccess.Read);</span><br><span class="line">      fileStream.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line"><span class="comment">//创建byte数组 ...  </span></span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[fileStream.Length];  </span><br><span class="line">      fileStream.Read(buffer, <span class="number">0</span>, (<span class="keyword">int</span>)fileStream.Length);</span><br><span class="line"></span><br><span class="line">      fileStream.Close();</span><br><span class="line">      fileStream.Dispose();</span><br><span class="line">      fileStream = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h2><p><a href="https://www.cnblogs.com/suogasus/p/5311264.html" target="_blank" rel="noopener">https://www.cnblogs.com/suogasus/p/5311264.html</a></p><p>Alpha通道是计算机图形学中的术语，指的是特别的通道，意思是“非彩色”通道，主要是用来保存选区和编辑选区</p><ul><li>Alpha 没有透明度的意思，不代表透明度。opacity 和 transparency 才和透明度有关，前者是不透明度，后者是透明度。比如 css 中的「opacity: 0.5」就是设定元素有 50% 的不透明度。</li><li>一个图像的每个像素都有 RGB 三个通道，后来 Alvy Ray Smith 提出每个像素再增加一个 Alpha 通道，取值为0到1，用来储存这个像素是否对图片有「贡献」，0代表透明、1代表不透明。也就是说，「Alpha 通道」储存一个值，其外在表现是「透明度」，Alpha 和透明度没啥关系。</li><li>为什么取名为 Alpha 通道，我觉得是因为这是除RGB以外「第一个通道」的意思，没有别的更深刻的含义。</li><li>Alpha 通道」是图片内在的一个属性，用 css 或者其他外部方法设定透明度，并没有改变图片的 Alpha 通道的值。</li></ul><p>真正让图片变透明的不是Alpha 实际是Alpha所代表的数值和其他数值做了一次运算<br>比如你有一张图片你想抠出图片中间的一部分 在PS里你会建立一个蒙板 然后在蒙板里把不需要的地方填充成黑色 需要的留成白色 这个时候实际上是是做了一次乘法<br>用黑色所代表的数值0去乘以你所填充的地方 那么这个地方就变透明了</p><p>设Alpha值[0，255]区间映射为[0，1]区间相对应的值表示，即Alpha值为0—1之间的数值。则图形文件中各个像素点可表示为：<br>Graphx（Redx，Greenx，Bulex，Alphax）<br>屏幕上相应像素点的显示值就转换为：<br>Dispx（Redx<em>Alphax，Greenx</em>Alphax，Bluex*Alphax）</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>Alpha通道<br>颜色通道<br>复合通道<br>专色通道<br>矢量通道</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>《Unity Shader入门精要》 冯乐乐<br><a href="https://zhuanlan.zhihu.com/p/126752791" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126752791</a><br><a href="https://www.jianshu.com/p/bec1a7514b08" target="_blank" rel="noopener">https://www.jianshu.com/p/bec1a7514b08</a><br><a href="https://blog.csdn.net/ynnmnm/article/details/44983545" target="_blank" rel="noopener">https://blog.csdn.net/ynnmnm/article/details/44983545</a><br><a href="https://www.jianshu.com/p/832e242523a4" target="_blank" rel="noopener">https://www.jianshu.com/p/832e242523a4</a><br><a href="https://blog.csdn.net/skymanwu/article/details/295121" target="_blank" rel="noopener">https://blog.csdn.net/skymanwu/article/details/295121</a><br><a href="https://blog.csdn.net/qq_29266497/article/details/81515326" target="_blank" rel="noopener">https://blog.csdn.net/qq_29266497/article/details/81515326</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asset </tag>
            
            <tag> Rendering </tag>
            
            <tag> Texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渲染】纹理滤波(Texture Filtering)相关知识整理</title>
      <link href="2020/10/28/CG-About-Texture-Filtering/"/>
      <url>2020/10/28/CG-About-Texture-Filtering/</url>
      
        <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="纹理映射-与-纹理采样"><a href="#纹理映射-与-纹理采样" class="headerlink" title="纹理映射 与 纹理采样"></a>纹理映射 与 纹理采样</h3><p>纹理映射：使用uv坐标将纹理像素(texel)映射到屏幕像素(pixel)的过程。</p><p>纹理采样（Texture Sample）：既然纹理是一张图片，那么自然就有分辨率的存在，纹理采样便是从纹理图片中采集一个像素颜色的操作。</p><h3 id="插值-Interpolation-的概念"><a href="#插值-Interpolation-的概念" class="headerlink" title="插值(Interpolation)的概念"></a>插值(Interpolation)的概念</h3><p>在数学的数值分析领域中，内插或称插值（英语：interpolation）是一种通过已知的、离散的数据点，在范围内推求新数据点的过程或方法。求解科学和工程的问题时，通常有许多数据点借由采样、实验等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。而根据这些数据，我们往往希望得到一个连续的函数（也就是曲线）；或者更密集的离散方程与已知数据互相吻合，这个过程叫做拟合。</p><p>常用的插值方法有：最近邻插值（Nearest-neighbor interpolation）、线性插值（线性插值）、多项式插值（Polynomial interpolation）、样条曲线插值（Spline interpolation）等。</p><p>高维度空间的计算中，需要用到多元插值（Multivariate interpolation）。方法有：</p><ul><li>双线性插值(bilinear interpolation) 和 双三次插值(bicubic interpolation) in two dimensions</li><li>trilinear interpolation in three dimensions.</li></ul><h4 id="线性插值-Linear-interpolation"><a href="#线性插值-Linear-interpolation" class="headerlink" title="线性插值(Linear interpolation)"></a>线性插值(Linear interpolation)</h4><p>In mathematics, linear interpolation is a method of curve fitting using linear polynomials to construct new data points within the range of a discrete set of known data points.<br><img src="./1603809936492.png" alt="Alt text"></p><h2 id="纹理滤波（Texture-Filtering）"><a href="#纹理滤波（Texture-Filtering）" class="headerlink" title="纹理滤波（Texture Filtering）"></a>纹理滤波（Texture Filtering）</h2><p><strong>纹理滤波（Texture Filtering）</strong>又称为<strong>纹理平滑（texture smoothing ）</strong> - the method used to determine the texture color for a texture mapped pixel, using the colors of nearby texels (pixels of the texture).</p><blockquote><p>当三维空间里面的多边形经过坐标变换、投影、光栅化等过程，变成二维屏幕上的一组象素的时候，对每个象素需要到相应纹理图像中进行采样，<strong>纹理过滤</strong>或者说<strong>纹理平滑</strong>是在纹理采样中使采样结果更加合理，以减少各种人为产生的穿帮现象的技术。</p></blockquote><p>纹理滤波主要分为两类：</p><ul><li><p><strong>放大过滤（magnification filtering）</strong>: reconstruction filter where sparse data is interpolated to fill gaps. （填充缺口）。一个纹理单元对应着多个像素。需要进行插值，平滑，防止马赛克现象。</p></li><li><p><strong>缩小过滤（minification filtering）</strong>: anti-aliasing (AA), where texture samples exist at a higher frequency than required for the sample frequency needed for texture fill. （抗锯齿）。一个像素对应着多个纹理单元。</p></li></ul><blockquote><p>There are many methods of texture filtering, which make different trade-offs between computational complexity, memory bandwidth and image quality.</p></blockquote><h3 id="为什么需要纹理滤波"><a href="#为什么需要纹理滤波" class="headerlink" title="为什么需要纹理滤波"></a>为什么需要纹理滤波</h3><p>对于任意的3D表面在纹理映射过程中，需要进行纹理查找来找到屏幕上的一个像素对应于纹理上的哪个位置，而在纹理采样过程中，可能出现如下问题：</p><ol><li>三维图形上的pixel中心和纹理上的texel中心并不一至。屏幕上像素的纹理映射坐标可能不会完美地落到像素格上。</li><li>取决于观察者，textured surface可能在任意的距离和方向，一个像素（pixel）通常不会直接对应一个纹素（texel），可能一个像素被映射到许多纹理像素，或者许多个像素都映射到相同纹素。<br>因此，需要执行一些形式的滤波来决定屏幕像素的最佳颜色。滤波不足或不正确将在图像中表现为伪像（图像中的错误），例如“块状”，锯齿状或闪烁。</li></ol><hr><ul><li><p>纹理放大(Texture Magnification)：the texels are larger than screen pixels, and need to be scaled up appropriately - a process known as texture magnification.<br>当最后呈现到屏幕中的尺寸比纹理实际尺寸大的时候，许多个像素都映射到同一纹素。纹理放大如果不进行过滤，会造成马赛克现象。此时需要对纹理进行放大过滤（magnification filtering），使用插值方法，进行平滑。</p></li><li><p>纹理缩小(Texture Minification)：each texel is smaller than a pixel, and so one pixel covers multiple texels. In this case an appropriate color has to be picked based on the covered texels, via texture minification.<br>当最后呈现到屏幕中的尺寸比纹理实际尺寸小的时候，一个像素被映射到许多纹理像素上。此时需要对纹理进行缩小过滤（minification filtering）。纹理缩小会由于精度损失造成贴图的扭曲。</p></li></ul><p>如图所示，过度的纹理缩小会造成高频走样问题，贴图出现扭曲（波纹）。<br><img src="./1605006132395.png" alt="Alt text"></p><h3 id="为什么称为滤波-Filter"><a href="#为什么称为滤波-Filter" class="headerlink" title="为什么称为滤波(Filter)"></a>为什么称为滤波(Filter)</h3><p><strong>图像其实是一种波，可以用波的算法处理图像</strong></p><h4 id="图像是波"><a href="#图像是波" class="headerlink" title="图像是波"></a>图像是波</h4><p>每个像素的颜色，可以用红、绿、蓝、透明度四个值描述，大小范围都是0 ～ 255，比如黑色是[0, 0, 0, 255]，白色是[255, 255, 255, 255]。<br><img src="./bg2017121302.png" alt="Alt text"><br>每条曲线都在不停的上下波动。有些区域的波动比较小，有些区域突然出现了大幅波动（比如 54 和 324 这两点）。曲线波动较大的地方，也是图像出现突变的地方。这说明波动与图像是紧密关联的。图像本质上就是各种色彩波的叠加。</p><h4 id="频率（frequency）"><a href="#频率（frequency）" class="headerlink" title="频率（frequency）"></a>频率（frequency）</h4><p>图像就是色彩的波动：波动大，就是色彩急剧变化；波动小，就是色彩平滑过渡。因此，波的各种指标可以用来描述图像。<br>频率（frequency）是波动快慢的指标，单位时间内波动次数越多，频率越高，反之越低。<br><strong>色彩剧烈变化的地方，就是图像的高频区域；色彩稳定平滑的地方，就是低频区域。</strong></p><h4 id="滤波器（filter）及在图像中的应用"><a href="#滤波器（filter）及在图像中的应用" class="headerlink" title="滤波器（filter）及在图像中的应用"></a>滤波器（filter）及在图像中的应用</h4><p>物理学对波的研究已经非常深入，提出了很多处理波的方法，其中就有滤波器（filter）：过滤掉某些波，保留另一些波。物理中两种常见的滤波器：</p><ul><li>低通滤波器（lowpass）：减弱或阻隔高频信号，保留低频信号</li><li>高通滤波器（highpass）：减弱或阻隔低频信号，保留高频信号</li></ul><p>应用在图像中：<br><strong>lowpass</strong>使得图像的高频区域变成低频，即色彩变化剧烈的区域变得平滑，也就是出现<strong>模糊效果</strong>。<br><img src="./1603787295513.png" alt="Alt text"></p><p><strong>highpass</strong>正好相反，过滤了低频，只保留那些变化最快速最剧烈的区域，也就是图像里面的物体边缘，所以常用于<strong>边缘识别</strong>。<br><img src="./1603787306380.png" alt="Alt text"></p><h3 id="Mipmapping"><a href="#Mipmapping" class="headerlink" title="Mipmapping"></a>Mipmapping</h3><p>Mipmapping is a standard technique used to <strong>save some of the filtering work</strong> needed during <strong>texture minification</strong>.<br>为了加快渲染速度和减少纹理锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为Mipmap。</p><h4 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h4><p>背景：Textured objects can be viewed at different distances from the viewpoint</p><p>Problem：Which level of detail (Resolution) should one use for the texture image?</p><ul><li>Too high resolution: Aliasing effects</li><li>Too small resolution: Too few details visible</li></ul><p>Solution: Use different levels of detail according to the distance between object and viewpoint → <strong>mipmaps</strong></p><blockquote><p>名称由来：mip = “multum in parvo”，拉丁语。</p></blockquote><p>在纹理缩小过程中，被贴上纹理的多边形距离很远时，纹理的多个纹素可能只落在一个屏幕像素中。需要读取多个纹素并通过合并他们的值的方式来决定屏幕像素的颜色，这样计算开销很大。Mipmapping会对纹理进行预过滤，并以较小的分辨率进行存储，从而避免运行时进行如此计算的开销。</p><blockquote><p>在3D场景中，由于距离问题，物体的纹理需要经常被缩放、拉伸，使用Mipmap会减小运行过程中的计算量，提升GPU效率。而在UI中，一般不需要繁缩放图片（特殊需求除外），因此不建议开启Mipmap，否则会造成内存浪费。</p></blockquote><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>Solves LOD problem by generating a pyramid of textures：</p><ul><li>Highest texture resolution at pyramid level 0</li><li>Halfed Resolution at each subsequent level</li></ul><p>预先生成一系列以2为倍数缩小（长宽）的纹理序列，在采样纹理时根据图形的大小自动选择相近等级的Mipmap进行采样。</p><blockquote><p>As the textured surface moves farther away, the texture being applied switches to the prefiltered smaller size. Different sizes of the mipmap are referred to as ‘levels’, with Level 0 being the largest size (used closest to the viewer), and increasing levels used at increasing distances.</p></blockquote><p>所需空间：(1 + 1/3) times the space<br><img src="./MemoryOfMipmap.png" alt="Alt text"></p><p>OpenGL automatically determines the mipmap level to use based on the projected size of the object.</p><blockquote><p>Mipmap通过下采样（downsampling）原始纹理生成。具体算法有：Nearest Neighbour, Boxfilter, Gaussian filter等</p></blockquote><h4 id="如何选择Mipmap-Level"><a href="#如何选择Mipmap-Level" class="headerlink" title="如何选择Mipmap Level"></a>如何选择Mipmap Level</h4><p>像素着色器是以像素为单位运行的，采样时该如何得知图形的大小呢？<br>现在的GPU在光栅化后不是逐像素单个渲染，而是分成2x2=4个的像素分块，每个线程处理4个。之所以这样处理是为了保存像素的偏导数信息，在计算mipmap等级和面法线等时候很有用。OpenGL提供了（唯一）一组获取相邻像素信息的函数——偏导函数dFdx和dFdy。偏导数代表了函数在某一方向的变化率，那么如果相邻两个像素间纹理坐标变化很大，则说明绘制的图形很小。<br>如下，计算出纹理坐标在纵向和横向的偏导数（并取最大值）来计算Mipmap级别：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MipmapLevel</span><span class="params">(vec2 texCoord)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The OpenGL Graphics System: A Specification 4.2</span></span><br><span class="line">    <span class="comment">//  - chapter 3.9.11, equation 3.21</span></span><br><span class="line">    vec2 dx = dFdx(texCoord);</span><br><span class="line">    vec2 dy = dFdy(texCoord);</span><br><span class="line">    <span class="keyword">float</span> delta = max(dot(dx, dx), dot(dy, dy));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * log2(delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MipmapLOD计算详解可见：<a href="http://warmcat.org/chai/blog/?p=1183" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1183</a></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>Mipmap除了能消除采样率过低带来的失真问题，还有一个重要的优点是<strong>节约显存带宽</strong>，注意是带宽而不是容量。Mipmap实际消耗的显存大约增加了1/3，但每次仅从需要的mipmap级别进行读取，而不必每次都访问原始大小的纹理，因此可以节约带宽。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>Mipmap贴图文件占用更多硬盘空间     — 解决方法：使用dds进行压缩存储</li><li>Mipmap纹理占用更多内存、显存空间</li></ol><h2 id="常用滤波方法（插值算法）"><a href="#常用滤波方法（插值算法）" class="headerlink" title="常用滤波方法（插值算法）"></a>常用滤波方法（插值算法）</h2><p>不同的过滤模式，计算复杂度不一样，会得到不同的效果。</p><h3 id="最近邻插值采样-Nearest-neighbor-interpolation"><a href="#最近邻插值采样-Nearest-neighbor-interpolation" class="headerlink" title="最近邻插值采样(Nearest-neighbor interpolation)"></a>最近邻插值采样(Nearest-neighbor interpolation)</h3><blockquote><p>OpenGL中对应的滤波方式为GL_NEAREST，Unity中对应的为Point。<br>Unity官方文档描述: Point 单点插值，纹理将变得块状化（blocky up close）</p></blockquote><p><strong>Nearest-neighbor interpolation</strong> (also known as <strong>proximal interpolation</strong> or, <strong>point sampling</strong>)<br>临近返回采样点所落在的像素内，即中心距离采样点曼哈顿距离最近的texel。</p><p>The nearest neighbor algorithm selects the value of the nearest point and does not consider the values of neighboring points at all, yielding a piecewise-constant interpolant.</p><p><img src="./1603790161075.png" alt="Alt text"></p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>临近采样的结果始终是纹理中的颜色，在做一些像素风格游戏的时候采用临近。临近通常带来锋利的结果（不是锯齿），颜色之间没有过渡。</p><p>当纹理的大小与贴图的三维图形的大小差不多时，这种方法非常有效和快捷。</p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><h5 id="块状（blocky-）"><a href="#块状（blocky-）" class="headerlink" title="块状（blocky ）"></a>块状（blocky ）</h5><p>不同的UV可能会得到相同的颜色，在放大观察时(Magify状态)会有明显色块(马赛克）。当一个texel对应多个pixel时，所有落在这个texel的pixel都会得到同样的颜色值，在屏幕上就会产生明显的像素锯齿，如果是3D游戏的话，就会显得很假。</p><blockquote><p>双线性插值解决了texel magnify时像素锯齿的问题，能根据采样点得到不同的颜色值，增加像素细节，只要不是一个uv，就会根据插值得到不同的结果。</p></blockquote><h5 id="高频走样（波纹和闪烁现象）"><a href="#高频走样（波纹和闪烁现象）" class="headerlink" title="高频走样（波纹和闪烁现象）"></a>高频走样（波纹和闪烁现象）</h5><p>当minify时，一个pixel”覆盖”多个texel，相邻的两个pixel取的texel太远，在纹理图上可能是两个完全不相邻、完全没有关系的像素。对于高频图像，大量信息被压缩在相对比较小的空间中，则像素变化微小时，色彩变化会剧烈，这个问题在物理上叫做高频走样。在绘制地板和远处物体时会由于这个原因，导致<strong>波纹（扭曲）和闪烁（sparkling）</strong>。</p><p>在看向地板远端的时候，会发现采样的结果并不连续，而是扭曲的波纹，移动摄像机后，会出现闪烁的问题，看起来非常糟糕。这是由于纹理在远处采样时pixel和它相邻的pixel跨越的texel太长，使在纹理中不相邻的两个texel（或者它们双线性插值的结果）被绘制在了一起。</p><ul><li>波纹是由于屏幕像素有限，原本不相邻的像素被绘制在一起导致的</li><li>闪烁是由于图像的高频，采样的低频，轻微偏移就会产生巨大变化导致的。</li></ul><h5 id="性能上"><a href="#性能上" class="headerlink" title="性能上"></a>性能上</h5><p>放大的情况下非常快，但是在缩小时开销却极高，因为屏幕上相邻的像素点，可能对应于纹理上距离很远的两个点，而这会破坏纹理采样时的内存连续性，导致L1或者L2缓存的命中率极低，使得纹理采样性能大大降低。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="./1603854909317.png" alt="Alt text"><br>如图所示，近处纹理放大过滤，造成了明显的马赛克现象。远处出现闪烁。</p><h3 id="最近点插值-mipmap的方式"><a href="#最近点插值-mipmap的方式" class="headerlink" title="最近点插值+mipmap的方式"></a>最近点插值+mipmap的方式</h3><p>这种方式在最近点插值的基础上，引入了mipmap，当距离相机很近时，使用miplevel0，此时和最近点插值完全一样。当距离下相机很远时，使用更高的miplevel等级，此时使用最近点插值采样更小尺寸的纹理。因此可以缓解缩小时的闪烁和锯齿现象，并且能够充分利用纹理采样时的内存连续性，使得纹理采样性能提高。但是在纹理放大时，不能解决产生的色块现象。<br><img src="./1603855058444.png" alt="Alt text"><br>加了mipmap之后可以看到噪点消失，但是远处纹理明显模糊，而且不同mipmap过渡处有明显分界，而近处的纹理仍然有色块现象。</p><h3 id="双线性插值-Bilinear-interpolation"><a href="#双线性插值-Bilinear-interpolation" class="headerlink" title="双线性插值 (Bilinear interpolation)"></a>双线性插值 (Bilinear interpolation)</h3><blockquote><p>OpenGL对应的设置为GL_LINEAR，unity对应的设置为bilinear。<br>Unity 官方文档描述：Bilinear 双线性插值，纹理将变得模糊（blurry up close）；</p></blockquote><p><strong>Bilinear interpolation</strong> is also called <strong>bilinear filtering</strong> or <strong>bilinear texture mapping</strong>.<br>在数学上，双线性插值是对线性插值在二维直角网格上的扩展<br>Bilinear interpolation is performed using linear interpolation first in one direction, and then again in the other direction. Although each step is linear in the sampled values and in the position, the interpolation as a whole is not linear but rather quadratic in the sample location.<br>首先在 X 轴方向插值两次，对得到的两个插值结果再在 Y 轴方向上进行一次插值。</p><p><img src="./1603810157411.png" alt="Alt text"></p><p><img src="./1603857020919.png" alt="Alt text"></p><p><img src="./1603857053404.png" alt="Alt text"><br>图像的双线性插值放大算法中，目标图像中新创造的象素值，是由源图像位置在它附近的2*2区域4个邻近象素的值通过加权平均计算得出的。</p><p>双线性过滤对于锯齿问题会有一个很明显的提升。该方法中，采样目标点附近的4个纹素，并且根据权重(距离中心点的距离)进行加权平均。这种方法使得放大纹理时的色块现象得以消失，因为此时两个相邻像素之间是平滑过度的。当缩小纹理时可以结合mipmap进行使用，尽管当缩小很多时，依然会有和最近点过滤方法一样的锯齿和闪烁现象，但是对于大部分合理的缩小比例，可以作为一种开销较少的有硬件加速的纹理超采样方案。<br><img src="./1603855288637.png" alt="Alt text"><br>近处纹理放大导致的马赛克现象明显消失，但是不同mipmap等级间的分界依然明显</p><h3 id="三线性插值-Trilinear-interpolation"><a href="#三线性插值-Trilinear-interpolation" class="headerlink" title="三线性插值 (Trilinear interpolation)"></a>三线性插值 (Trilinear interpolation)</h3><p>Trilinear interpolation is a method of multivariate interpolation on a 3-dimensional regular grid.<br>对两个相邻的mipmap等级的纹理进行双线性过滤采样，并对两个采样结果线性插值得到最终的颜色。<br>三线性过滤是对双线性过滤中当纹理距离相机的距离刚好处于两个mipmap等级的交界处时的明显的一个过渡现象的解决方案。<br>通过对两个相邻的mipmap等级的纹理进行双线性过滤采样，并对两个采样结果线性插值得到最终的颜色。这样当纹理到相机的距离逐渐增加时，可以得到平滑的一个过渡，而不是突兀的变化。当然，对于足够近的纹理，因为使用miplevel0这个等级，因此和双线性过滤完全一致。</p><p>经过mipmap+三线性插值，解决了</p><ul><li>点采样法引起的像素值不连续</li><li>远景的高频走样</li><li>不同lod level区域的明显分界</li><li>切换lod level的突变</li></ul><p><img src="./1603855360374.png" alt="Alt text"></p><h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4><p>然而mipmap自身定义上就导致严重的问题。为了解决高频走样，引入了mipmap，强行将高频区域变为低频区域，减少信息量。这样的后果就是随着lod越来越远，采样结果就越模糊。在游戏中，往往表现为感觉越往远看，地面上就越感觉蒙着一层雾，像眼睛近视了一样。</p><p>为了增强远景的清晰度，显卡厂商增加了一个新的过程，即各向异性过滤。这个效果对GPU的要求较高，所以在游戏中属于“最高画质”的选项。</p><h3 id="各向异性过滤-Anisotropic-filtering"><a href="#各向异性过滤-Anisotropic-filtering" class="headerlink" title="各向异性过滤(Anisotropic filtering)"></a>各向异性过滤(Anisotropic filtering)</h3><p>当一个物体的表面和相机有很大的夹角时，纹理在屏幕上的对应填充区域就不是方形的。例如一个地板，距离相机远的地方，填充区域的宽高是不对等的，此时方形的纹理贴图就不是很合适了，此时就会导致模糊或者闪烁或者两者皆有。各向异性过滤通过采样一个非方形纹理解决了这个问题。</p><p>在Unity中通过Aniso Level设置该过滤效果。</p><blockquote><p>Texture.anisoLevel - Anisotropic filtering level of the texture. Anisotropic filtering makes textures look better when viewed at a shallow angle, but comes at a performance cost in the graphics hardware. Usually you use it on floor, ground or road textures to make them look better.<br>The value range of this variable goes from 1 to 9, where 1 equals no filtering applied and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at shallow angles. Lower values mean the texture will be more blurry at shallow angles.</p></blockquote><p>Aniso Level == 0<br><img src="./1603855799619.png" alt="Alt text"><br>Aniso Level == 9<br><img src="./1603855820036.png" alt="Alt text"></p><h2 id="OpenGL对Minification-Magnification-Filter的选择"><a href="#OpenGL对Minification-Magnification-Filter的选择" class="headerlink" title="OpenGL对Minification/Magnification Filter的选择"></a>OpenGL对Minification/Magnification Filter的选择</h2><p>此处摘录自CHAI’S BLOG：<a href="http://warmcat.org/chai/blog/?p=1222" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1222</a><br>OpenGL允许设置纹理的过滤，分为GL_TEXTURE_MIN_FILTER和GL_TEXTURE_MAG_FILTER两种。<br>如果采样点的像素被认为是Minify了的，则用GL_TEXTURE_MIN_FILTER，如果是为认为是Magnify了的，用GL_TEXTURE_MAG_FILTER，决定用哪一个和mipmap无关，mipmap的三线性过滤通过_MIPMAP_NEAREAST和_MIPMAP_LINEAR决定。<br>默认情况下，GL_TEXTURE_MAG_FILTER 的过滤方式是GL_LINEAR，GL_TEXTURE_MIN_FILTER 的过滤方式是GL_NEAREST_MIPMAP_LINEAR。</p><p>opengl提供了dfdx,dfdy两个函数对片段的属性做屏幕空间的偏微分，如果对uv做偏微分的话就是:</p><script type="math/tex; mode=display">dfdx(uv)=(\frac{\partial u}{\partial x}, \frac{\partial v}{\partial x})</script><script type="math/tex; mode=display">dfdy(uv)=(\frac{\partial u}{\partial y}, \frac{\partial v}{\partial y})</script><p><img src="./1603865152983.png" alt="Alt text"><br>∂u/∂x和∂v/∂x是左下角的像素和它水平方向的邻居的差，∂u/∂y和∂v/∂y是左下角的像素和它上面的邻居的差，由于∂x=1，∂y=1，则<br>dfdx(uv) = P1.uv - P0.uv<br>dfdy(uv) = P3.uv - P0.uv</p><p>使用以下公式判断此纹素是min还是mag<br><img src="./1603864791127.png" alt="Alt text"><br>如果ρ&lt;=1，此纹素被放大了，即mag<br>如果ρ&gt;1，此纹素被缩小了，即min</p><h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="纹理环绕（Texture-Wrap）"><a href="#纹理环绕（Texture-Wrap）" class="headerlink" title="纹理环绕（Texture Wrap）"></a>纹理环绕（Texture Wrap）</h3><p>纹理环绕的作用是为了处理超出0.0~1.0范围的纹理坐标，例如采用重复（REPEAT）的环绕方式，采样（4.5,-4.5）的纹理坐标，实际采样的纹理坐标应是（0.5，0.5）。对于负数纹理坐标，采样的实际位置应是1-uv，例如（-0.2,-0.6）应该采样（0.8,0.4）</p><h3 id="上-下采样"><a href="#上-下采样" class="headerlink" title="上/下采样"></a>上/下采样</h3><h4 id="downsampled（下采样）"><a href="#downsampled（下采样）" class="headerlink" title="downsampled（下采样）"></a>downsampled（下采样）</h4><p>目的：</p><ul><li>使得图像符合显示区域的大小；</li><li>生成对应图像的缩略图；</li></ul><p>方法：对于一幅图像尺寸为M<em>N，对其进行s倍的下采样，即得到（M/s）</em>（N/s）尺寸的分辨率图像，当然，s应该是M和N的公约数才可以，如果考虑是矩阵形式的图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点就是窗口内所有像素的均值 Pk = (∑ Xi)/ S^2</p><h4 id="upsampling（上采样）"><a href="#upsampling（上采样）" class="headerlink" title="upsampling（上采样）"></a>upsampling（上采样）</h4><p>放大图像（或称为上采样（upsampling）或图像插值（interpolating））的主要目的是放大原图像，从而可以显示在更高分辨率的显示设备上。</p><p>上采样的原理：图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。插值算法还包括了传统插值，基于边缘图像的插值，还有基于区域的图像插值。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.sohu.com/a/397647922_468740" target="_blank" rel="noopener">https://www.sohu.com/a/397647922_468740</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC</a><br><a href="https://en.wikipedia.org/wiki/Texture_filtering" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Texture_filtering</a><br><a href="https://en.wikipedia.org/wiki/Linear_interpolation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Linear_interpolation</a><br><a href="http://warmcat.org/chai/blog/?p=1077" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1077</a><br><a href="http://warmcat.org/chai/blog/?p=1222" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1222</a></p>]]></content>
      
      
      <categories>
          
          <category> CG&amp;Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Texture </tag>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础】U3D中的Mesh</title>
      <link href="2020/10/25/Basic-Mesh-in-Unity3D/"/>
      <url>2020/10/25/Basic-Mesh-in-Unity3D/</url>
      
        <content type="html"><![CDATA[<p>Unity3D中的 <strong>Mesh(网格)</strong> 事实上就是我们所说的 <strong>三角网格</strong> 。<br>三角网格就是由一系列三角形组成的多边形网格，主要用于模拟复杂物体的表面。</p><h2 id="数据结构——索引三角网格"><a href="#数据结构——索引三角网格" class="headerlink" title="数据结构——索引三角网格"></a>数据结构——索引三角网格</h2><p>用c++语言模拟Unity3D中Mesh数据的存储结构。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点表</span></span><br><span class="line"><span class="comment">//-----------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span>   <span class="comment">//由于存储三角形顶点级信息</span></span><br><span class="line">Vector3 p;</span><br><span class="line">.......    <span class="comment">//其他信息 纹理映射坐标 法向量 光照信息</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形表</span></span><br><span class="line"><span class="comment">//-----------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triangle</span>&#123;</span>  <span class="comment">//保存三角形级信息</span></span><br><span class="line"><span class="keyword">int</span> vertex[<span class="number">3</span>];  <span class="comment">//三个顶点在顶点列表的索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//存放三角网格的结构 维护两个表 定点表和三角形表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriangleMesh</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> vertexCount; <span class="comment">//顶点数</span></span><br><span class="line">Vertex *vertexList; <span class="comment">//顶点存放链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *uv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> triangleCount; <span class="comment">//三角形数量</span></span><br><span class="line">Triangle *triangleCount; <span class="comment">//存放三角形的链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">........</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="vertices"><a href="#vertices" class="headerlink" title="vertices"></a>vertices</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3[] vertices; <span class="comment">//所有的顶点。</span></span><br></pre></td></tr></table></figure><p>每个三角形面三个顶点，面与面之间不一定共用顶点。<br>法向量相同的两个面可以公用顶点，法向量不同的两个面，在同一个位置会分别有两个顶点数据，坐标相同，法向量不同。</p><p>每个顶点包含一个3D位置，一般也会包括<strong>纹理映射坐标(UV坐标)</strong>，表面<strong>法向量</strong>，<strong>光照值</strong>等附加信息</p><h4 id="为何有冗余顶点"><a href="#为何有冗余顶点" class="headerlink" title="为何有冗余顶点"></a>为何有冗余顶点</h4><p>正方体6个面，每个面由2个三角形组成，所以共需要36个三角形顶点索引。但是正方体只有8个顶点，为什么需要24个顶点坐标数据呢？</p><p>答案是：Unity3D的Mesh.triangles是<strong>三角形索引数组</strong>，不仅依靠这个索引值<strong>索引三角形顶点坐标</strong>，而且<strong>索引纹理坐标</strong>，<strong>索引法线向量</strong>。即正方体的<strong>每个顶点都参与了3个平面，而这3个平面的法线向量是不同的</strong>，该顶点在渲染这3个平面的时候需要索引到不同的法线向量。而由于顶点坐标和法线向量是由同一个索引值triangles[Index]取得的，例如，根据triangles[0],triangles[14],triangles[17]在vertices中索引到的顶点都为（0.5，－0.5，0.5），但是在normals中索引到的法向量值各不相同。这就决定了在正方体中一个顶点，需要有<strong>3份存储</strong>。（如果你需要创建其它模型，需要根据实际情况决定顶点坐标的冗余度。实质上顶点坐标的冗余正是方便了法线坐标、纹理坐标的存取。）</p><h3 id="triangles"><a href="#triangles" class="headerlink" title="triangles"></a>triangles</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] triangles <span class="comment">// a list of triangles that contains indices into the vertex array</span></span><br></pre></td></tr></table></figure><p>三角形的哪一面可见是由顶点序号的方向来确定的。如果顶点顺序是顺时针方向的话那么三角形是正面可见。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.vertices = <span class="keyword">new</span> Vector3[] &#123;<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)&#125;;</span><br><span class="line">mesh.uv = <span class="keyword">new</span> Vector2[] &#123;<span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>)&#125;;</span><br><span class="line">mesh.triangles =  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="normals"><a href="#normals" class="headerlink" title="normals"></a>normals</h3><p>每个顶点对应一个法线，即顶点所在平面的法线</p><ul><li>法线是垂直于面的向量。我们通常使用单位长度的法向量，并向量指向面的外部，而不是内部。</li><li>法线可以用于确定光线与顶点的夹角。这个细节的使用取决于Shader。<blockquote><p>作为三角面它永远是平的，因此它不应该需要被提供一个单独的法线信息。然而，我们需要造假。在现实中，顶点是不存在法线的，三角面才有。通过附加自定义顶点法线和三角面插着，我们可以奖状我们有一个平滑的曲面代替一堆平的三角面。这个错觉是令人信服的，只要你不去注意网格锋利的轮廓（锯齿）。</p></blockquote></li></ul><p>法线用于规定每个顶点，所以我们必须填充另一个向量数组。另一种选择，我们可以依据网格的三角面来计算出法线。</p><h3 id="Tangent"><a href="#Tangent" class="headerlink" title="Tangent"></a>Tangent</h3><blockquote><p>tangent: 切线，切面，正切</p></blockquote><p>法线贴图在切线空间中定义。<br>所以切线是一个三维向量，但是在Unity中它是使用四维向量定义的。第四个值通常是1或者-1，用于控制第三切线空间唯独方向-朝前或朝后,这有助于展示法线贴图，通常用于左右对称的3D模型，像人一样。Untiy的shader执行此计算要求我们使用-1。</p><h4 id="法线贴图-Normal-Map"><a href="#法线贴图-Normal-Map" class="headerlink" title="法线贴图(Normal Map)"></a>法线贴图(Normal Map)</h4><p>使用颜色值记录了法相向量</p><h3 id="UV坐标-纹理坐标"><a href="#UV坐标-纹理坐标" class="headerlink" title="UV坐标(纹理坐标)"></a>UV坐标(纹理坐标)</h3><p>UV mapping is the 3D modeling process of projecting a 2D image to a 3D model’s surface for <strong>texture mapping</strong>.</p><blockquote><p>The letters “U” and “V” denote the axes of the 2D texture because “X”, “Y”, and “Z” are already used to denote the axes of the 3D object in model space, while “W” (in addition to XYZ) is used in calculating quaternion rotations, a common operation in computer graphics.</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>U3D中的<strong>纹理贴图的原理</strong>应该是你的模型坐标进过顶点变化到投影坐标系，然后在接下来的片段着色的时候通过传递过来的UV值用<code>tex2D(_texName, UV)</code>来获取颜色值，然后渲染到屏幕上。</p></blockquote><p>UV坐标通常在(0,0)到(1,1)之间，它覆盖了整个纹理。超出范围的坐标将造成<strong>clamped</strong>或者<strong>Tiling</strong>平铺的效果，这去取决于纹理设置。</p><h4 id="uv、uv2、uv3、uv4"><a href="#uv、uv2、uv3、uv4" class="headerlink" title="uv、uv2、uv3、uv4"></a>uv、uv2、uv3、uv4</h4><p>如果在模型导入时就存在 uv2，uv3，uv4，那么这是因为在建模软件中添加了这些顶点属性。<br>uv2通常被用于Lightmap，uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。<br>一般来说uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p><h3 id="colors属性"><a href="#colors属性" class="headerlink" title="colors属性"></a>colors属性</h3><p>在一些建模软件中导出的网格模型(Mesh)可能会带有colors属性，描述每个顶点的颜色。有些Shader可以使用这个属性进行运算与着色。然而很多时候colors属性是用不到的，<strong>如Unity标准着色器就不使用这个属性</strong>。</p><blockquote><p>Most shaders choose to ignore vertex color, with exception of sprites shader.<br>大多数着色器选择忽略顶点颜色，但精灵着色器除外<br><a href="https://stackoverflow.com/questions/34460587/unity-changing-only-certain-part-of-3d-models-color" target="_blank" rel="noopener">https://stackoverflow.com/questions/34460587/unity-changing-only-certain-part-of-3d-models-color</a></p></blockquote><p>colors属性与tangents属性一样，如果网格顶点拥有该属性，同样会对内存、物理体积和加载性能造成影响。</p><p>默认情况下，在3d建模软件中并不会导出Color属性。以3ds max为例，Color通常是通过modifier添加的，因此只需要在导出前将其删除即可。<br>去除方法：<a href="https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf</a></p><blockquote><p>注意：切忌将不同属性的网格模型拼合在一起。举个例子 ，100个网格模型进行Static Batching，如果99个模型只有Position和UV两种属性，而剩下1个模型函数有Position、UV、Normal、Tangent和Color五种属性。那么引擎在进行拼合时，会将前99个模型的顶点属性补齐，然后再进行拼合。这样无形中会增加大量的内存占用，从而造成不必要的内存浪费。</p></blockquote><h3 id="无用属性的去除方法"><a href="#无用属性的去除方法" class="headerlink" title="无用属性的去除方法"></a>无用属性的去除方法</h3><p>1.如果有3dmax的源文件，可以直接在3dmax里操作，在那个channelinfo—清掉那个vc<br>2.如果只有fbx，或者这类文件太多，可以直接下载一个fbx的sdk，拿里面的例子改一下，生成一个exe。然后在unity里直接调用就行了。<br>其实从外包回来的fbx，一般都有问题，要么顶点色，要么会出现uv3、uv4。我这里附上工具和c++、及在unity调用的代码，你可以试一下。如果运行不了，缺dll，你就到网上找一下，多半可以用。 clear_fbx_clr_uv_tool.rar<br>注意这个工具会清掉顶点色和uv3、uv4！！<br>3.印象中在unity里也可以直接清顶点色，好像是meshfiter那里把colors直接置空，再重新保存回去。</p><h2 id="Unity中Mesh重要属性和方法"><a href="#Unity中Mesh重要属性和方法" class="headerlink" title="Unity中Mesh重要属性和方法"></a>Unity中Mesh重要属性和方法</h2><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>(1) vertices 网格顶点数组;<br>(2) normals 网格的法线数组;<br>(3) tangents 网格的切线数组;<br>(4) uv 网格的基础纹理坐标;<br>(5) uv2 网格设定的第二个纹理坐标;<br>(6) bounds 网格的包围盒;<br>(7) Colors 网格的顶点颜色数组;<br>(8) triangles 包含所有三角形的顶点索引数组;<br>(9) vectexCount 网格中的顶点数量(只读的);<br>(10) subMeshCount 子网格的数量，每个材质都有一个独立的网格列表;<br>(11) bonesWeights: 每个顶点的骨骼权重;<br>(12) bindposes: 绑定姿势，每个索引绑定的姿势使用具有相同的索引骨骼;</p><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>(1) Clear 清空所有的顶点数据和所有的三角形索引;<br>(2) RecalculateBounds 重新计算网格的包围盒;<br>(3) RecalculateNormals 重新计算网格的法线;<br>(4) Optimze 显示优化的网格;<br>(5) GetTriangles 返回网格的三角形列表;<br>(6) SetTriangles 为网格设定三角形列表;<br>(7) CominMeshes组合多个网格到同一个网格;</p><h2 id="Import-Settings"><a href="#Import-Settings" class="headerlink" title="Import Settings"></a>Import Settings</h2><h3 id="Mesh-Compression（通常禁用，优化渲染和发布文件大小时启用）"><a href="#Mesh-Compression（通常禁用，优化渲染和发布文件大小时启用）" class="headerlink" title="Mesh Compression（通常禁用，优化渲染和发布文件大小时启用）"></a>Mesh Compression（通常禁用，优化渲染和发布文件大小时启用）</h3><p>启用网格压缩，unity会按照一定的级别来压缩网格数据，压缩级别越高，网格的精度越低，这对于渲染优化和发布时游戏文件大小的降低很有用，但可能会导致失真。官方的想法是，尽可能的压缩网格，只要模型看起来不至于太奇怪。</p><h3 id="Optimize-Mesh"><a href="#Optimize-Mesh" class="headerlink" title="Optimize Mesh"></a>Optimize Mesh</h3><p>优化网格，如果开启，网格的定点和三角形会按照U3D既定的一套规则重新排序用以提高GPU性能。<br>The Optimize Meshes option in a mesh’s import settings will reorganize the vertex data for quicker readability, and sometimes regenerate the low-level rendering style (down to the level of points versus tris versus strips) to optimize the rendering speed of the mesh.</p><p>该优化方法也可以在代码中调用：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mesh mesh = gameObject.GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line">mesh.Optimize();</span><br></pre></td></tr></table></figure><br>This function causes the geometry and vertices of the mesh to be reordered internally in an attempt to improve vertex cache utilisation on the graphics hardware and thus rendering performance.<br>This operation can take a few seconds or more for complex meshes and should only be used where <strong>the ordering of the geometry and vertices is not significant</strong> as both will change.<br>理论上如果模型对顶点和面片顺序没有要求的话，不会导致显示问题。</p><h2 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h2><h3 id="MeshFiler组件"><a href="#MeshFiler组件" class="headerlink" title="MeshFiler组件"></a>MeshFiler组件</h3><p>MeshFilter 这个组件记录了你想要展示的网格数据</p><h3 id="MeshRender组件"><a href="#MeshRender组件" class="headerlink" title="MeshRender组件"></a>MeshRender组件</h3><p>MeshRenderer 使用这个组件告诉网格如何渲染，比如使用哪个材质球，是否接受阴影和其他设置。</p><h2 id="Mesh编程"><a href="#Mesh编程" class="headerlink" title="Mesh编程"></a>Mesh编程</h2><h3 id="画面片"><a href="#画面片" class="headerlink" title="画面片"></a>画面片</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenMesh</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"MeshEditor/GenMesh"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenMeshM</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Mesh m1 = CreateRect();</span><br><span class="line">        AssetDatabase.CreateAsset(m1, <span class="string">"Assets/models/m1.asset"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mesh <span class="title">CreateRect</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Mesh mesh = <span class="keyword">new</span> Mesh();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> particleNum = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//顶点坐标</span></span><br><span class="line">        Vector3[] verts = <span class="keyword">new</span> Vector3[<span class="number">4</span> * particleNum];</span><br><span class="line">        <span class="comment">//uv坐标</span></span><br><span class="line">        Vector2[] uvs = <span class="keyword">new</span> Vector2[<span class="number">4</span> * particleNum];</span><br><span class="line">        <span class="comment">//三角形索引</span></span><br><span class="line">        <span class="keyword">int</span>[] tris = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * <span class="number">3</span> * particleNum];</span><br><span class="line"></span><br><span class="line">        Vector3 position;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; particleNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i4 = i * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">int</span> i6 = i * <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">            position.x = <span class="number">5</span> * i;</span><br><span class="line">            position.y = <span class="number">5</span> * i;</span><br><span class="line">            position.z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点坐标</span></span><br><span class="line">            verts[i4 + <span class="number">0</span>] = position;</span><br><span class="line">            verts[i4 + <span class="number">1</span>] = position + <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            verts[i4 + <span class="number">2</span>] = position + <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            verts[i4 + <span class="number">3</span>] = position + <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//四个顶点在UV坐标系中的位置</span></span><br><span class="line">            uvs[i4 + <span class="number">0</span>] = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">            uvs[i4 + <span class="number">1</span>] = <span class="keyword">new</span> Vector2(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">            uvs[i4 + <span class="number">2</span>] = <span class="keyword">new</span> Vector2(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            uvs[i4 + <span class="number">3</span>] = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顺时针绘制三角形0 1 2 / 0 2 3</span></span><br><span class="line">            tris[i6 + <span class="number">0</span>] = i4 + <span class="number">0</span>;</span><br><span class="line">            tris[i6 + <span class="number">1</span>] = i4 + <span class="number">1</span>;</span><br><span class="line">            tris[i6 + <span class="number">2</span>] = i4 + <span class="number">2</span>;</span><br><span class="line">            tris[i6 + <span class="number">3</span>] = i4 + <span class="number">0</span>;</span><br><span class="line">            tris[i6 + <span class="number">4</span>] = i4 + <span class="number">2</span>;</span><br><span class="line">            tris[i6 + <span class="number">5</span>] = i4 + <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mesh.vertices = verts;</span><br><span class="line">        mesh.triangles = tris;</span><br><span class="line">        mesh.uv = uvs;</span><br><span class="line">        mesh.RecalculateBounds();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mesh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">region</span> 画圆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 画圆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="radius"&gt;</span>圆的半径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="segments"&gt;</span>圆的分割数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="centerCircle"&gt;</span>圆心得位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawCircle</span>(<span class="params"><span class="keyword">float</span> radius, <span class="keyword">int</span> segments, Vector3 centerCircle</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">        gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        gameObject.GetComponent&lt;MeshRenderer&gt;().material = mat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顶点</span></span><br><span class="line">        Vector3[] vertices = <span class="keyword">new</span> Vector3[segments + <span class="number">1</span>];</span><br><span class="line">        vertices[<span class="number">0</span>] = centerCircle;</span><br><span class="line">        <span class="keyword">float</span> deltaAngle = Mathf.Deg2Rad * <span class="number">360f</span> / segments;</span><br><span class="line">        <span class="keyword">float</span> currentAngle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> cosA = Mathf.Cos(currentAngle);</span><br><span class="line">            <span class="keyword">float</span> sinA = Mathf.Sin(currentAngle);</span><br><span class="line">            vertices[i] = <span class="keyword">new</span> Vector3(cosA * radius + centerCircle.x, sinA * radius + centerCircle.y, <span class="number">0</span>);</span><br><span class="line">            currentAngle += deltaAngle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三角形</span></span><br><span class="line">        <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[segments * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; segments * <span class="number">3</span> - <span class="number">3</span>; i += <span class="number">3</span>, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            triangles[i] = <span class="number">0</span>;</span><br><span class="line">            triangles[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            triangles[i + <span class="number">2</span>] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">1</span>] = segments;</span><br><span class="line"></span><br><span class="line">        Vector2[] uvs = <span class="keyword">new</span> Vector2[vertices.Length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            uvs[i] = <span class="keyword">new</span> Vector2(vertices[i].x / radius / <span class="number">2</span> + <span class="number">0.5f</span>, vertices[i].y / radius / <span class="number">2</span> + <span class="number">0.5f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line">        mesh.Clear();</span><br><span class="line"></span><br><span class="line">        mesh.vertices = vertices;</span><br><span class="line">        mesh.triangles = triangles;</span><br><span class="line">        mesh.uv = uvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h3 id="画圆环"><a href="#画圆环" class="headerlink" title="画圆环"></a>画圆环</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">region</span> 画圆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 画圆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="radius"&gt;</span>圆的半径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="segments"&gt;</span>圆的分割数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="centerCircle"&gt;</span>圆心得位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawCircle</span>(<span class="params"><span class="keyword">float</span> radius, <span class="keyword">int</span> segments, Vector3 centerCircle</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">        gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        gameObject.GetComponent&lt;MeshRenderer&gt;().material = mat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顶点</span></span><br><span class="line">        Vector3[] vertices = <span class="keyword">new</span> Vector3[segments + <span class="number">1</span>];</span><br><span class="line">        vertices[<span class="number">0</span>] = centerCircle;</span><br><span class="line">        <span class="keyword">float</span> deltaAngle = Mathf.Deg2Rad * <span class="number">360f</span> / segments;</span><br><span class="line">        <span class="keyword">float</span> currentAngle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> cosA = Mathf.Cos(currentAngle);</span><br><span class="line">            <span class="keyword">float</span> sinA = Mathf.Sin(currentAngle);</span><br><span class="line">            vertices[i] = <span class="keyword">new</span> Vector3(cosA * radius + centerCircle.x, sinA * radius + centerCircle.y, <span class="number">0</span>);</span><br><span class="line">            currentAngle += deltaAngle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三角形</span></span><br><span class="line">        <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[segments * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; segments * <span class="number">3</span> - <span class="number">3</span>; i += <span class="number">3</span>, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            triangles[i] = <span class="number">0</span>;</span><br><span class="line">            triangles[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            triangles[i + <span class="number">2</span>] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">1</span>] = segments;</span><br><span class="line"></span><br><span class="line">        Vector2[] uvs = <span class="keyword">new</span> Vector2[vertices.Length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            uvs[i] = <span class="keyword">new</span> Vector2(vertices[i].x / radius / <span class="number">2</span> + <span class="number">0.5f</span>, vertices[i].y / radius / <span class="number">2</span> + <span class="number">0.5f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line">        mesh.Clear();</span><br><span class="line"></span><br><span class="line">        mesh.vertices = vertices;</span><br><span class="line">        mesh.triangles = triangles;</span><br><span class="line">        mesh.uv = uvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h3 id="Mesh顶点编辑器"><a href="#Mesh顶点编辑器" class="headerlink" title="Mesh顶点编辑器"></a>Mesh顶点编辑器</h3><p>摘自：<a href="https://gameinstitute.qq.com/community/detail/129174" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/129174</a><br>思路：获取mesh上的所有顶点，然后在每个顶点位置创建一个控制点，控制点可以是任意你喜欢的物体，通过判断控制点的位置信息来修改mesh的顶点位置。<br>把每个顶点的坐标转为字符串，使用该坐标的字符串作为<strong>key</strong>来把<strong>控制点</strong>与<strong>顶点数据</strong>联系起来。</p><hr><p>控制点：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">public class MeshEditorPoint : MonoBehaviour ｛</span><br><span class="line">    <span class="comment">//顶点id，（顶点初始位置转字符串）</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>] <span class="keyword">public</span> <span class="keyword">string</span> pointid;</span><br><span class="line">    <span class="comment">//记录坐标点上一次移动的位置，用于判断控制点是否移动</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>] <span class="keyword">private</span> Vector3 lastPosition;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MoveDelegate</span>(<span class="params"><span class="keyword">string</span> pid,Vector3 pos</span>)</span>;</span><br><span class="line">    <span class="comment">//控制点移动时的回调</span></span><br><span class="line">    <span class="keyword">public</span> MoveDelegate onMove = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Use this for initialization</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) ｛</span></span><br><span class="line"><span class="function">        lastPosition</span> = transform.position;</span><br><span class="line">｝</span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) ｛</span></span><br><span class="line"><span class="function">        <span class="title">if</span>(<span class="params">transform.position != lastPosition</span>)｛</span></span><br><span class="line"><span class="function">            <span class="title">if</span>(<span class="params">onMove != <span class="literal">null</span></span>) <span class="title">onMove</span>(<span class="params">pointid, transform.localPosition</span>)</span>;</span><br><span class="line">            lastPosition = transform.position;</span><br><span class="line">        ｝</span><br><span class="line">｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><hr><p>顶点编辑器<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line">public class ModelMeshEditor : MonoBehaviour ｛</span><br><span class="line">    <span class="comment">//控制点的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> pointScale = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastPointScale = <span class="number">1.0f</span>;</span><br><span class="line">    Mesh mesh;</span><br><span class="line">    <span class="comment">//顶点列表</span></span><br><span class="line">    List&lt;Vector3&gt; positionList = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line">    <span class="comment">//顶点控制物体列表</span></span><br><span class="line">    List&lt;GameObject&gt; positionObjList = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> key:顶点字符串</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> value:顶点在列表中的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt; pointmap = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"><span class="comment">// Use this for initialization</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) ｛</span></span><br><span class="line"><span class="function">        lastPointScale</span> = pointScale;</span><br><span class="line">        mesh = GetComponent&lt;MeshFilter&gt;().sharedMesh;</span><br><span class="line">        CreateEditorPoint();</span><br><span class="line">｝</span><br><span class="line">    <span class="comment">//创建控制点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateEditorPoint</span>(<span class="params"></span>)｛</span></span><br><span class="line"><span class="function">        positionList</span> = <span class="keyword">new</span> List&lt;Vector3&gt;(mesh.vertices);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh.vertices.Length; i++)</span><br><span class="line">        ｛</span><br><span class="line">            <span class="keyword">string</span> vstr = Vector2String(mesh.vertices[i]);</span><br><span class="line">            <span class="keyword">if</span>(!pointmap.ContainsKey(vstr))｛</span><br><span class="line">                pointmap.Add(vstr,<span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            ｝</span><br><span class="line">            pointmap[vstr].Add(i);</span><br><span class="line">        ｝</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> key <span class="keyword">in</span> pointmap.Keys)</span><br><span class="line">        ｛</span><br><span class="line">            GameObject editorpoint = (GameObject)Resources.Load(<span class="string">"Prefabs/MeshEditor/MeshEditorPoint"</span>);</span><br><span class="line">            editorpoint = Instantiate(editorpoint);</span><br><span class="line">            editorpoint.transform.parent = transform;</span><br><span class="line">            editorpoint.transform.localPosition = String2Vector(key);</span><br><span class="line">            editorpoint.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">1f</span>);</span><br><span class="line">            MeshEditorPoint editorPoint = editorpoint.GetComponent&lt;MeshEditorPoint&gt;();</span><br><span class="line">            editorPoint.onMove = PointMove;</span><br><span class="line">            editorPoint.pointid = key;</span><br><span class="line">            positionObjList.Add(editorpoint);</span><br><span class="line">        ｝</span><br><span class="line">    ｝</span><br><span class="line">    <span class="comment">//顶点物体被移动时调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PointMove</span>(<span class="params"><span class="keyword">string</span> pointid,Vector3 position</span>)｛</span></span><br><span class="line"><span class="function">        <span class="title">if</span>(<span class="params">!pointmap.ContainsKey(pointid</span>))｛</span></span><br><span class="line"><span class="function">            return</span>;</span><br><span class="line">        ｝</span><br><span class="line">        List&lt;<span class="keyword">int</span>&gt; _list = pointmap[pointid];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _list.Count; i ++)｛</span><br><span class="line">            positionList[_list[i]] = position;</span><br><span class="line">        ｝</span><br><span class="line">        mesh.vertices = positionList.ToArray();</span><br><span class="line">        mesh.RecalculateNormals();</span><br><span class="line">    ｝</span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) ｛</span></span><br><span class="line"><span class="function">        <span class="comment">//检测控制点尺寸是否改变</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> (<span class="params">Math.Abs(lastPointScale - pointScale</span>) &gt; 0.1f)｛</span></span><br><span class="line"><span class="function">            lastPointScale</span> = pointScale;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; positionObjList.Count; i ++)｛</span><br><span class="line">                positionObjList[i].transform.localScale = <span class="keyword">new</span> Vector3(pointScale, pointScale, pointScale);</span><br><span class="line">            ｝</span><br><span class="line">        ｝</span><br><span class="line">｝</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">Vector2String</span>(<span class="params">Vector3 v</span>)｛</span></span><br><span class="line"><span class="function">        StringBuilder str</span> = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        str.Append(v.x).Append(<span class="string">","</span>).Append(v.y).Append(<span class="string">","</span>).Append(v.z);</span><br><span class="line">        <span class="keyword">return</span> str.ToString();</span><br><span class="line">    ｝</span><br><span class="line">    <span class="function">Vector3 <span class="title">String2Vector</span>(<span class="params"><span class="keyword">string</span> vstr</span>)</span></span><br><span class="line"><span class="function">    ｛</span></span><br><span class="line"><span class="function">        <span class="keyword">try</span>｛</span></span><br><span class="line"><span class="function">            <span class="keyword">string</span>[] strings</span> = vstr.Split(<span class="string">','</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Vector3(<span class="keyword">float</span>.Parse(strings[<span class="number">0</span>]), <span class="keyword">float</span>.Parse(strings[<span class="number">1</span>]), <span class="keyword">float</span>.Parse(strings[<span class="number">2</span>]));</span><br><span class="line">        ｝<span class="keyword">catch</span>(Exception e)｛</span><br><span class="line">            Debug.LogError(e.ToString());</span><br><span class="line">            <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">        ｝</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="关于锯齿"><a href="#关于锯齿" class="headerlink" title="关于锯齿"></a>关于锯齿</h3><p>曲面的或者是圆的面只能被大量小的三角形来接近组成。如果三角面显示足够的小（不大于一个像素），那么你就不会感觉曲面或者是圆是由三角面组成的。从实时性能角度来讲通常这种情况是不可能的，所以我们总能够在面的某个程度上发现锯齿。</p><h3 id="Texture相关"><a href="#Texture相关" class="headerlink" title="Texture相关"></a>Texture相关</h3><p>Wrap Mode（包装方式）: Repeat(重复), Clamp(固定，贴不上的部分，会按照边缘进行延伸，而不会拉伸图片)</p><h3 id="3D建模软件"><a href="#3D建模软件" class="headerlink" title="3D建模软件"></a>3D建模软件</h3><p>1:Autodesk 3D Studio Max 支持mac os windows;<br>2: Autodesk 3D Maya 支持windows<br>3: Cinema4D 支持mac os windows<br>4: Blender 开源跨平台的全能三维制作软件, 支持mac os windows, linux;<br>5: Cheetah3D: 支持mac os<br>6: Unity与建模软件的单位比例:</p><div class="table-container"><table><thead><tr><th style="text-align:center">软件</th><th style="text-align:center">内部米</th><th style="text-align:center">导入unity后的尺寸/m</th><th style="text-align:center">与Unity单位的比例关系</th></tr></thead><tbody><tr><td style="text-align:center">3Dmax</td><td style="text-align:center">1</td><td style="text-align:center">0.01</td><td style="text-align:center">100:1</td></tr><tr><td style="text-align:center">Maya</td><td style="text-align:center">1</td><td style="text-align:center">0.01</td><td style="text-align:center">1:100</td></tr><tr><td style="text-align:center">Cinema 4D</td><td style="text-align:center">1</td><td style="text-align:center">0.01</td><td style="text-align:center">1:100</td></tr><tr><td style="text-align:center">Light Wave</td><td style="text-align:center">1</td><td style="text-align:center">0.01</td><td style="text-align:center">100:1</td></tr></tbody></table></div><p>　　　　　　　</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs:"></a>Refs:</h2><p><a href="https://www.cnblogs.com/zhanghaipeng-Unity3D/p/4714973.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhanghaipeng-Unity3D/p/4714973.html</a><br><a href="https://blog.csdn.net/qq_29579137/article/details/77369734" target="_blank" rel="noopener">https://blog.csdn.net/qq_29579137/article/details/77369734</a><br><a href="https://www.bbsmax.com/A/QV5ZQvObJy/" target="_blank" rel="noopener">https://www.bbsmax.com/A/QV5ZQvObJy/</a><br><a href="https://blog.csdn.net/nanggong/article/details/54728823" target="_blank" rel="noopener">https://blog.csdn.net/nanggong/article/details/54728823</a><br><a href="https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rendering </tag>
            
            <tag> Asset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渲染】基础——渲染管线(Rendering Pipeline)</title>
      <link href="2020/10/25/Basic-Render-pipeline/"/>
      <url>2020/10/25/Basic-Render-pipeline/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染管线概览"><a href="#渲染管线概览" class="headerlink" title="渲染管线概览"></a>渲染管线概览</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="渲染管线（流水线）"><a href="#渲染管线（流水线）" class="headerlink" title="渲染管线（流水线）"></a>渲染管线（流水线）</h4><p>《Render-Time Rendering Third Edition》一书中将计算机图形渲染的流程划分为3个阶段<br><img src="./RenderingPipeline.png" alt="Alt text"><br>定义：也称渲染流水线，是显示芯片内部处理图形信号<strong>相互独立</strong>的<strong>并行</strong>的处理单位。</p><blockquote><p>一个<strong>流水线</strong>是一序列可以<strong>并行</strong>和<strong>按固定顺序进行</strong>的阶段。也就是说每个阶段都是从它的前一阶段输入，然后输出发给随后的阶段。</p></blockquote><p>渲染机理：将图像所具备的图形信息（顶点、纹理、材质、摄像机位置等）经过一系列阶段的处理，最终转换成屏幕上的图像。<br>实质是输入3D模型，输出2D图片显示出来的过程</p><p><strong>渲染过程中的坐标转换：物体空间-&gt;世界空间-&gt;观察空间-&gt;裁剪空间-&gt;屏幕空间</strong></p><h4 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h4><p>此处的Shader区别于Unity Shader文件<br>Shader（着色器），是一种较为短小的程序片段，用于告诉图形硬件如何加速输出图像，过去是有汇编语言来编写。<br>总而来说，Shader是<strong>可编程图形管线的算法片段</strong><br>分类:</p><ul><li>Vertex Shader</li><li>Fragment Shader</li></ul><p><img src="./20171201155916085.jpg" alt="Alt text"><br>物体空间-&gt;世界空间-&gt;观察空间-&gt;裁剪空间-&gt;屏幕空间<br><strong>Shader和材质、贴图的关系：</strong><br>Shader将顶点数据以指定的方式和贴图或者颜色组合起来，将输出数据绘制到屏幕上。<br><strong>材质</strong>就是将<strong>Shader</strong>以及<strong>输入参数（包括贴图）</strong>打包存储起来，将材质赋予到三维物体上进行渲染<br>这样就是说材质就是引擎最终使用的商品（每个渲染的物体都需要一个材质）<br>Shader就是生产这种商品的加工过程或方法，贴图就是商品材料之一。</p><h3 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h3><p><img src="./1603770851323.png" alt="Alt text"><br>绿色表示完全可编程控制，黄色表示可配置，蓝色表示由GPU固定实现，不可修改。实线表示必须由开发者编程实现，虚线表示该Shader是可选的。</p><h4 id="应用阶段-Application-Stage-CPU"><a href="#应用阶段-Application-Stage-CPU" class="headerlink" title="应用阶段 Application Stage ( CPU )"></a>应用阶段 Application Stage ( CPU )</h4><p><strong>目标：</strong> 准备好场景数据，设置好渲染状态，然后输出渲染图元（rendering primitives），即为下一阶段提供所需的几何信息。</p><blockquote><p><strong>图元</strong>是指渲染的基本图形，通俗来讲图元可以是顶点，线段，三角面等，复杂的图形可以通过渲染多个三角形来实现。</p></blockquote><p>可细分为3个子阶段</p><h5 id="加载数据到显存"><a href="#加载数据到显存" class="headerlink" title="加载数据到显存"></a>加载数据到显存</h5><p>所有渲染所需的数据都需要从硬盘加载到系统内存中（RAM），然后网格和纹理等数据又被加载到显存（VRAM）。这是因为显卡对于显存的访问速度更快，而且大多数显卡对于RAM没有直接的访问权利。</p><h5 id="设置渲染状态"><a href="#设置渲染状态" class="headerlink" title="设置渲染状态"></a>设置渲染状态</h5><p>比如设置使用的着色器，材质，纹理，光源属性等。</p><h5 id="调用DrawCall"><a href="#调用DrawCall" class="headerlink" title="调用DrawCall"></a>调用DrawCall</h5><p>Draw Call就是一个命令，它的发起方是CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元列表，而不会再包含任何材质信息，这是因为我们已经在上一个阶段设置过了。当给定了一个Draw Call时，GPU就会根据渲染状态和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。</p><h4 id="几何阶段-Geometry-Stage-GPU"><a href="#几何阶段-Geometry-Stage-GPU" class="headerlink" title="几何阶段 Geometry Stage ( GPU )"></a>几何阶段 Geometry Stage ( GPU )</h4><p><strong>接受数据：</strong> 应用阶段所准备好的<strong>渲染图源</strong>信息，也就是顶点数据（模型自身坐标系、顶点颜色、纹理UV等）<br><strong>目标：</strong> 与每个渲染图元打交道，进行逐顶点，逐多边形的操作。把顶点坐标变换到屏幕空间中，输出屏幕空间的顶点信息（绘制方法、绘制坐标），再交给光栅化器进行处理。<br><strong>基本流程：</strong></p><h5 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器(Vertex Shader)"></a>顶点着色器(Vertex Shader)</h5><p>对每个顶点均调用一次。<br>通过一系列的<strong>坐标转换</strong>，将模型的顶点在摄像机前进行位移，并最终投影到摄像机的投影屏幕上<br><strong>本地坐标系-&gt;世界坐标系-&gt;观察坐标系-&gt;投影坐标系</strong></p><p>顶点处理这个阶段包括顶点的<strong>坐标变换</strong>、<strong>逐顶点雾化</strong>、<strong>材质属性</strong>、<strong>光照属性</strong>处理</p><p>坐标变换：把顶点坐标从模型空间转换到齐次裁剪空间，接着通常再由硬件做透视除法，最终得到归一化的设备坐标（NDC）。</p><blockquote><p>顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点和顶点之间的关系，例如我们无法得知两个顶点是否属于同一个三角网格。但正因为这样的相互独立性，GPU可以利用本身的特性并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。</p></blockquote><h5 id="曲面细分着色器-Tessellation-Shader"><a href="#曲面细分着色器-Tessellation-Shader" class="headerlink" title="曲面细分着色器(Tessellation Shader)"></a>曲面细分着色器(Tessellation Shader)</h5><p>细分图元，例如将三角面细分成更小的三角面来添加几何细节。</p><blockquote><p>In Direct3D 11 pipeline (a part of DirectX 11), the graphics primitive is the patch.[4] The tessellator generates a triangle-based tessellation of the patch according to tessellation parameters such as the TessFactor, which controls the degree of fineness of the mesh.<br>Tessellation: 棋盘型布置，密铺，曲面细分</p></blockquote><h5 id="几何着色器-Geometry-Shader"><a href="#几何着色器-Geometry-Shader" class="headerlink" title="几何着色器(Geometry Shader)"></a>几何着色器(Geometry Shader)</h5><p>逐图元着色操作或是生成新的图元(减少CPU负担)。可决定输出的图元类型和个数，当输出的图元减少时，实际上起到了裁剪的作用，当输出的图元增多或类型改变时，起到了产生或改变图元的作用</p><h5 id="裁剪-Clipping"><a href="#裁剪-Clipping" class="headerlink" title="裁剪(Clipping)"></a>裁剪(Clipping)</h5><p>将那些不在摄像机视野内的顶点裁减掉，并剔除某些三角图元的面片（面片通常是由一个一个更小的图元来构成的）。</p><blockquote><p> 一个图元和摄像机视野的关系有3种：完全在视野内，部分在视野内，完全在视野外。完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会继续向下传递，因为它们不需要被渲染。而那些部分在视野内的图元需要被裁剪。<br><img src="./1603771738881.png" alt="Alt text"></p></blockquote><h5 id="屏幕映射-Screen-Mapping"><a href="#屏幕映射-Screen-Mapping" class="headerlink" title="屏幕映射(Screen Mapping)"></a>屏幕映射(Screen Mapping)</h5><p>把每个图元的x和y坐标转换到屏幕坐标系下，这实际上是一个缩放的过程。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。<br><img src="./1603771941717.png" alt="Alt text"></p><p>屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远。 屏幕映射不会对输入的z坐标做任何处理。实际上，屏幕坐标系和z坐标一起构成了<strong>窗口坐标系</strong>。这些值会被一起传递到光栅化阶段。</p><h4 id="光栅化阶段-Rasterizer-Stage-GPU"><a href="#光栅化阶段-Rasterizer-Stage-GPU" class="headerlink" title="光栅化阶段 Rasterizer Stage ( GPU )"></a>光栅化阶段 Rasterizer Stage ( GPU )</h4><blockquote><p>光栅化：是把顶点数据转换为片元的过程，具有将图转化为一个个栅格组成的图象的作用，特点是每个元素对应帧缓冲区中的一像素。（将以向量为基本结构的面转换为一个个点阵形式的像素。）</p></blockquote><p><strong>接受数据：</strong> 几何阶段准备好的顶点信息<br><strong>目标：</strong> 对几何阶段传递过来的<strong>屏幕空间的顶点信息</strong>进行处理,最终生成<strong>屏幕像素,</strong>渲染出图像</p><p>需要对上一个阶段得到的逐顶点数据（例如纹理坐标，顶点颜色等）进行插值，然后再进行逐像素处理。<br>例如对于三角形图元，得到的就是三个顶点的坐标和颜色信息等。而光栅化阶段要做的就是根据这三个顶点，计算出这个三角形<strong>覆盖了哪些像素</strong>，并为这些像素通过<strong>插值</strong>计算出它们的颜色。</p><h5 id="三角形设置-Triangle-Setup"><a href="#三角形设置-Triangle-Setup" class="headerlink" title="三角形设置(Triangle Setup)"></a>三角形设置(Triangle Setup)</h5><p>计算光栅化一个三角网格所需的信息。具体来说，上一个阶段输出的都是三角网格的顶点，但如果要得到整个三角网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个计算三角网格表示数据的过程就叫做三角形设置。</p><h5 id="三角形遍历-Triangle-Traversal"><a href="#三角形遍历-Triangle-Traversal" class="headerlink" title="三角形遍历(Triangle Traversal)"></a>三角形遍历(Triangle Traversal)</h5><p>检查每个像素是否被一个三角网格所覆盖。如果被覆盖的话，就会生成一个片元。而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换。<br>三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行<strong>插值</strong>。<strong>像素</strong>和<strong>片元</strong>是一一对应的，每个像素都会生成一个片元，<strong>片元中的状态记录了对应像素的信息</strong>，是对三个顶点的信息进行插值得到的。<br><img src="./1603772117005.png" alt="Alt text"></p><blockquote><p>片元包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括了但不限于它的屏幕坐标，深度信息，以及其他从几何阶段输出的顶点信息，例如法线，纹理坐标等。</p></blockquote><h5 id="片元着色器-Fragment-Shader"><a href="#片元着色器-Fragment-Shader" class="headerlink" title="片元着色器(Fragment Shader)"></a>片元着色器(Fragment Shader)</h5><p>又称<strong>像素着色器(Pixel Shader)</strong>。逐片元的着色操作(Per-Fragment Operations)，输出是一个或者多个颜色值（即计算该片元对应像素的颜色，但不是最终颜色）。</p><ol><li>纹理采样<br>这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是<strong>纹理采样</strong>。为了在片元着色器中进行纹理采样，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行插值后，就可以得到其覆盖的片元的纹理坐标了。</li><li>计算光照(阴影、明暗…)</li></ol><p>根据上一步插值后的片元信息，片元着色器计算该片元的输出颜色 虽然片元着色器可以完成很多重要效果，但它的局限在于，它<strong>仅可以影响单个片元</strong>。也就是说，当执行片元着色器时，它不可以将自己的任何结果直接发送给它的邻居们。当然导数信息例外。</p><h5 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h5><ol><li>决定每个片元的可见性。这涉及了很多测试工作，例如深度测试，模板<strong>测试</strong>等。</li><li>如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者所是<strong>混合</strong>。</li></ol><p>片元-&gt; 模板测试-&gt;深度测试-&gt;混合-&gt;颜色缓冲区</p><blockquote><p>模板测试<br>模板测试，可以作为一种丢弃片元的辅助方法，与之相关的是模板缓冲。如果开启了模板测试，GPU会首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取到（使用读取掩码）的参考值进行比较，这个比较函数可以是由开发者指定的，例如小于时舍弃该片元，或者大于等于时舍弃。如果这个片元没有通过这个测试，该片元就会被舍弃。不管一个片元有没有通过模板测试，我们都可以根据模板测试和下面的深度测试结果来修改模板缓冲区，这个修改操作也是由开发者指定的。开发者可以设置不同结果下的修改操作，例如，在失败时模板缓冲区保持不变，通过时将模板缓冲区中对应位置的值加1等。模板测试通常用于限制渲染的区域。另外模板测试还有一些更高级的用法，如渲染阴影，轮廓渲染等。</p><p>深度测试<br>如果开启了深度测试，GPU会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。这个比较函数也是由开发者设置的。通常如果这个片元的深度值大于等于当前深度缓冲区中的值，那么就会舍弃它。因为我们总想只显示出离摄像机最近的物体，而那些被其他物体遮挡的就不需要出现在屏幕上。如果这个片元没有通过这个测试，该片元就会被舍弃。和模板测试不同的是，如果一个片元没有通过深度测试，它就没有权利更改深度缓冲区中的值。而如果它通过了测试，开发者还可以指定是否要用这个片元的深度值覆盖掉原有的深度值，这是通过开启/关闭<strong>深度写入</strong>来做到的。</p><p>混合<br>为什么需要混合？渲染过程是一个物体接着一个物体画到屏幕上的。而每个像素的颜色信息被存储在一个名为颜色缓冲的地方。因此，当我们执行这次渲染时，颜色缓冲中往往已经有了上次渲染之后的颜色结果，那么我们是使用这次渲染得到的颜色完全覆盖掉之前的结果，还是进行其他处理？这就是混合需要解决的问题。对于不透明物体，开发者可以关闭混合操作。但对于不透明物体，我们就需要使用混合操作来让这个物体看起来是透明的。</p></blockquote><h3 id="CPU与GPU"><a href="#CPU与GPU" class="headerlink" title="CPU与GPU"></a>CPU与GPU</h3><p>CPU在内存中建立以下资源</p><ul><li>顶点定义</li><li>顶点缓存</li><li>索引缓存</li><li>贴图</li><li>摄像机</li><li>投影</li></ul><p>CPU从内存中发送以下资源到显存中供GPU使用</p><ul><li>顶点定义</li><li>顶点缓存</li><li>索引缓存</li><li>贴图</li><li>坐标系变换矩阵</li><li>渲染状态</li><li>贴图采样方式</li></ul><h4 id="GPU渲染管线理解"><a href="#GPU渲染管线理解" class="headerlink" title="GPU渲染管线理解"></a>GPU渲染管线理解</h4><p><img src="./o4YBAFtVNLGART11AADOMqy6xRY961.jpg" alt="Alt text"></p><p><a href="https://www.cnblogs.com/timlly/p/11471507.html" target="_blank" rel="noopener">深入GPU硬件架构及运行机制</a></p><h2 id="数学相关具体处理过程"><a href="#数学相关具体处理过程" class="headerlink" title="数学相关具体处理过程"></a>数学相关具体处理过程</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>视锥体（view frustum）<br>frustum(截头锥体)</p><h3 id="坐标转换过程"><a href="#坐标转换过程" class="headerlink" title="坐标转换过程"></a>坐标转换过程</h3><p>物体空间(object space)-&gt;世界空间(World Space)-&gt;观察空间(View Space)-&gt;裁剪空间(clip space)-&gt;屏幕空间(Screen Space)</p><h4 id="NDC-Normalized-Device-Coordinate-归一化设备坐标"><a href="#NDC-Normalized-Device-Coordinate-归一化设备坐标" class="headerlink" title="NDC(Normalized Device Coordinate)归一化设备坐标"></a>NDC(Normalized Device Coordinate)归一化设备坐标</h4><p>在这一步会进行一个叫齐次除法的步骤，说白了就是各个点（x,y,z,w）会除以w的值（注：计算机图形学中经常使用四元数代表一个点，叫齐次空间，齐次点等 ）<br><img src="./20180524234721665.jpg" alt="Alt text"><br><img src="./2018052423464776.jpg" alt="Alt text"></p><h4 id="屏幕空间（Screen-Space）"><a href="#屏幕空间（Screen-Space）" class="headerlink" title="屏幕空间（Screen Space）"></a>屏幕空间（Screen Space）</h4><p>pixelWidth:屏幕横向分辨率<br>pixelHeight:屏幕纵向分辨率<br>OpenGL规范<br><img src="./20180525000554600.jpg" alt="OpenGL规范"><br>DirectX规范<br><img src="./20180525000613422.jpg" alt="DirectX规范"></p><p>screenx={clipx<em>pixelWidth/(2</em>clipw)}+pixelWidth/2<br>screeny={clipy<em>pixelHeight/(2</em>clipw)}+pixelHeight/2</p><h3 id="Vertex-Shader-amp-Fragment-Shader"><a href="#Vertex-Shader-amp-Fragment-Shader" class="headerlink" title="Vertex Shader &amp; Fragment Shader"></a>Vertex Shader &amp; Fragment Shader</h3><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>将物体从<strong>物体空间</strong>-&gt;<strong>世界空间</strong>-&gt;<strong>观察空间</strong>-&gt;<strong>裁剪空间</strong>就是顶点着色器的工作。</p><blockquote><ol><li>将物体空间的数据（点）作为顶点着色器的输入</li><li>将所有在自己范围中的点全部遍历一遍，就是每个点都会算进行加工</li><li>高度可编程配置！</li></ol></blockquote><h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><p> 将裁剪空间中的点从<strong>裁剪空间</strong>-&gt;<strong>屏幕空间</strong>就是片元着色器的工作。<br>片元着色器会返回一个四元数-（r,g,b,a）-&gt;分别为（red&lt;红&gt;，green&lt;绿&gt;，blue&lt;蓝&gt;，alpha&lt;透明度&gt;）</p><blockquote><ol><li>将裁减空间的数据（点）作为片元着色器的输入</li><li>将所有在自己范围中的像素全部遍历一遍（三角遍历Rasterizer—-Triangle Traversal），就是每个片元（像素）都会运算进行加工。</li><li>高度可编程配置！</li></ol></blockquote><h2 id="Shader-1"><a href="#Shader-1" class="headerlink" title="Shader"></a>Shader</h2><h3 id="简单的Shader-Demo"><a href="#简单的Shader-Demo" class="headerlink" title="简单的Shader Demo"></a>简单的Shader Demo</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Test/Shader"</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</span><br><span class="line">LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vertex vert//告诉编译器 顶点着色器叫什么名字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> fragment frag//告诉编译器 片元着色器叫什么名字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include "UnityCG.cginc"//包含内置文件，方便写代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> appdata</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex : POSITION;<span class="comment">//物体坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> v2f</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex : SV_POSITION;<span class="comment">//裁剪空间坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)<span class="comment">//顶点着色器，以物体坐标为输入（appdata下的vertex）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.vertex = UnityObjectToClipPos(v.vertex);<span class="comment">//将物体坐标变换到裁剪空间</span></span><br><span class="line"><span class="keyword">return</span> o;<span class="comment">//返回裁剪空间的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target<span class="comment">//片元着色器，以裁剪空间数据作为输入（上面顶点着色器的输出）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fixed4 col = fixed4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//定义一个白色</span></span><br><span class="line"><span class="keyword">return</span> col;<span class="comment">//返回白色</span></span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h3><p>UnityObjectToClipPos()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> float4 <span class="title">UnityObjectToClipPos</span><span class="params">(in float3 pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// More efficient than computing M*VP matrix product</span></span><br><span class="line">   <span class="keyword">return</span> mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, float4(pos, <span class="number">1.0</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> float4 <span class="title">UnityObjectToClipPos</span><span class="params">(float4 pos)</span> <span class="comment">// overload for float4; avoids "implicit truncation" warning for existing shaders</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UnityObjectToClipPos(pos.xyz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unity_ObjectToWorld是物体空间到世界空间的转换矩阵mul()矩阵乘法内置函数。<br>UNITY_MATRIX_VP（观察空间和裁剪空间合一起了），乘完后将从世界空间变换到裁剪空间。</p><p>完全手动自定义计算的话，这么写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float4 <span class="title">UnityObjectToClipPos</span><span class="params">(in float3 pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">float4 objectSpaceData = float4(pos, <span class="number">1.0f</span>);</span><br><span class="line">float4 worldSpaceData = mul(unity_ObjectToWorld, objectSpaceData);</span><br><span class="line">float4 viewSpaceData = mul(UNITY_MATRIX_V, worldSpaceData);</span><br><span class="line">float4 clipSpaceData = mul(UNITY_MATRIX_P，viewSpaceData );</span><br><span class="line"><span class="keyword">return</span> clipSpaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/SouthBegonia/p/11564407.html" target="_blank" rel="noopener">https://www.cnblogs.com/SouthBegonia/p/11564407.html</a><br><a href="https://blog.csdn.net/AvatarForTest/article/details/80438344" target="_blank" rel="noopener">https://blog.csdn.net/AvatarForTest/article/details/80438344</a><br><a href="http://m.elecfans.com/article/713834.html" target="_blank" rel="noopener">http://m.elecfans.com/article/713834.html</a><br><a href="https://juejin.im/post/6844903975712489485" target="_blank" rel="noopener">https://juejin.im/post/6844903975712489485</a><br>《Unity Shader入门精要》</p>]]></content>
      
      
      <categories>
          
          <category> CG&amp;Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【加载】Asset bundle</title>
      <link href="2020/10/25/Load-AssetBundle/"/>
      <url>2020/10/25/Load-AssetBundle/</url>
      
        <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h4 id="从资源的角度"><a href="#从资源的角度" class="headerlink" title="从资源的角度"></a>从资源的角度</h4><p>它是一个<strong>存在于硬盘上的文件</strong>。可以称之为<strong>压缩包</strong>。这个压缩包可以认为是一个文件夹，里面包含了多个文件。这些文件可以分为两类：serialized file 和 resource files。（序列化文件和源文件）</p><ul><li>serialized files：资源被打碎放在一个对象中，最后统一被写进一个单独的文件（只有一个）。相当于是一个头文件，里面记录了关于这个AB的相关信息，当我们调用<strong>LoadFromFile</strong>接口加载AB的时候实际上就是去加载的这一部分信息。这部分信息在Profiler里面的SerilizeField选项里。</li><li>resource files：某些二进制资源（图片、声音）被单独保存，方便快速加载</li></ul><h4 id="从API的角度"><a href="#从API的角度" class="headerlink" title="从API的角度"></a>从API的角度</h4><p>它是一个AssetBundle对象，我们可以通过代码从一个特定的压缩包加载出来的对象。这个对象包含了所有我们当初添加到这个压缩包里面的内容，我们可以通过这个对象加载出来使用。</p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ol><li>AssetBundle是一个压缩包包含模型、贴图、预制体、声音、甚至整个场景，可以在游戏运行的时候被加载；</li><li>AssetBundle自身保存着互相的依赖关系；</li><li>压缩包可以使用LZMA和LZ4压缩算法，减少包大小，更快的进行网络传输；</li><li>把一些可以下载内容放在AssetBundle里面，可以减少安装包的大小；</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);</span><br><span class="line"></span><br><span class="line">AssetBundle ab = AssetBundle.LoadFromFile(<span class="string">"AssetBundles/scene/wall.unity3d"</span>);</span><br><span class="line">GameObject wallPrefab = ab.LoadAsset&lt;GameObject&gt;(<span class="string">"CubeWall"</span>);</span><br><span class="line">Instantiate(wallPrefab);</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle.LoadFromMemoryAsync</span><br><span class="line">AssetBundle.LoadFromFile</span><br><span class="line">WWW.LoadFromCacheOrDownload</span><br><span class="line">UnityWebRequest</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一般</span><br><span class="line">T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</span><br><span class="line">GameObject</span><br><span class="line">GameObject gameObject =</span><br><span class="line">loadedAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);</span><br><span class="line">所有资源</span><br><span class="line">Unity.Object[] objectArray =</span><br><span class="line">loadedAssetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure><h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><h3 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h3><ol><li>把经常更新的资源放在一个单独的包里面，跟不经常更新的包分离</li><li>把需要同时加载的资源放在一个包里面</li><li>可以把其他包共享的资源放在一个单独的包里面</li><li>把一些需要同时加载的小资源打包成一个包</li><li>如果对于一个同一个资源有两个版本，可以考虑通过后缀来区分  v1  v2  v3  unity3dv1 unity3dv2</li></ol><h4 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h4><p>a. 一个UI界面或者所有UI界面一个包（这个界面里面的贴图和布局信息一个包）<br>b. 一个角色或者所有角色一个包（这个角色里面的模型和动画一个包）<br>c. 所有的场景所共享的部分一个包（包括贴图和模型）</p><h4 id="按照类型分组"><a href="#按照类型分组" class="headerlink" title="按照类型分组"></a>按照类型分组</h4><p>所有<strong>声音</strong>资源打成一个包，所有<strong>shader</strong>打成一个包，所有<strong>模型</strong>打成一个包，所有材质打成一个包</p><h4 id="按照使用分组"><a href="#按照使用分组" class="headerlink" title="按照使用分组"></a>按照使用分组</h4><p>把在某一时间内使用的所有资源打成一个包。可以按照关卡分，一个关卡所需要的所有资源包括角色、贴图、声音等打成一个包。也可以按照场景分，一个场景所需要的资源一个包</p><h3 id="依赖打包"><a href="#依赖打包" class="headerlink" title="依赖打包"></a>依赖打包</h3><p>(Mat + Cube1) (Mat + Cube2)<br>(Mat) (Cube1) (Cube2)<br>Unity会自动识别，共享的依赖如果已经单独打包，则不会重复打包</p><h3 id="Build-AssetBundles"><a href="#Build-AssetBundles" class="headerlink" title="Build AssetBundles"></a>Build AssetBundles</h3><ol><li>Build的路径（随意只要是在硬盘上都可以的）</li><li>BuildAssetBundleOptions<br>BuildAssetBundleOptions.None：使用LZMA算法压缩，压缩的包更小，但是加载时间更长。使用之前需要整体解压。一旦被解压，这个包会使用LZ4重新压缩。使用资源的时候不需要整体解压。在下载的时候可以使用LZMA算法，一旦它被下载了之后，它会使用LZ4算法保存到本地上。<br>BuildAssetBundleOptions.UncompressedAssetBundle：不压缩，包大，加载快<br>BuildAssetBundleOptions.ChunkBasedCompression：使用LZ4压缩，压缩率没有LZMA高，但是我们可以加载指定资源而不用解压全部。</li></ol><blockquote><p> 注意使用LZ4压缩，可以获得可以跟不压缩想媲美的加载速度，而且比不压缩文件要小。</p></blockquote><h2 id="LoadAssetBundles"><a href="#LoadAssetBundles" class="headerlink" title="LoadAssetBundles"></a>LoadAssetBundles</h2><h3 id="LoadFromMemoryAsync"><a href="#LoadFromMemoryAsync" class="headerlink" title="LoadFromMemoryAsync"></a>LoadFromMemoryAsync</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">LoadFromMemoryAsync</span>(<span class="params"><span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> createRequest;</span><br><span class="line">        AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">        <span class="keyword">var</span> prefab = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LoadFromFile"><a href="#LoadFromFile" class="headerlink" title="LoadFromFile"></a>LoadFromFile</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function">function <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle</span><br><span class="line">            = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">"myassetBundle"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (myLoadedAssetBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Failed to load AssetBundle!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LoadFromCacheOrDownload"><a href="#LoadFromCacheOrDownload" class="headerlink" title="LoadFromCacheOrDownload"></a>LoadFromCacheOrDownload</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromCacheOrDownloadExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Caching.ready)</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> www = WWW.LoadFromCacheOrDownload(<span class="string">"http://myserver.com/myassetBundle"</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> www;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">string</span>.IsNullOrEmpty(www.error))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(www.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = www.assetBundle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> asset = myLoadedAssetBundle.mainAsset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> uri = <span class="string">"file:///"</span> + Application.dataPath + <span class="string">"/AssetBundles/"</span> + assetBundleName;</span><br><span class="line">    UnityEngine.Networking.UnityWebRequest request</span><br><span class="line">        = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.Send();</span><br><span class="line">    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"Cube"</span>);</span><br><span class="line">    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"Sprite"</span>);</span><br><span class="line">    Instantiate(cube);</span><br><span class="line">    Instantiate(sprite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FromFileABLoader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AssetBundle cubeAB;</span><br><span class="line">    <span class="keyword">string</span> abPath = <span class="string">"Assets/AssetBundles/waterobjs/"</span>;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> ABPath = Application.dataPath + <span class="string">"/AssetBundles"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LoadABFromFile();</span></span><br><span class="line">        <span class="comment">//StartCoroutine(LoadABFromMemoryAsync());</span></span><br><span class="line">        LoadABFromMemory();</span><br><span class="line">        <span class="comment">//AssetBundle matAB = AssetBundle.LoadFromFile("Assets/AssetBundles/watermat.asbd");</span></span><br><span class="line">        <span class="keyword">if</span> (cubeAB != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject cubePrefab = cubeAB.LoadAsset&lt;GameObject&gt;(<span class="string">"cube"</span>);</span><br><span class="line">            Instantiate(cubePrefab);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object[] objABs = cubeAB1.LoadAllAssets();</span></span><br><span class="line">        <span class="comment">//Debug.Log(objABs[0]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.M))</span><br><span class="line">        &#123;</span><br><span class="line">            AssetBundle.LoadFromFile(<span class="string">"Assets/AssetBundles/watermat.asbd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadABFromFile</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        cubeAB = AssetBundle.LoadFromFile(abPath + <span class="string">"cube.asbd"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">LoadABFromMemoryAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AssetBundleCreateRequest cubeRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(abPath + <span class="string">"cube.asbd"</span>));</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> cubeRequest;</span><br><span class="line">        cubeAB = cubeRequest.assetBundle;</span><br><span class="line">        GameObject cubePrefab = cubeAB.LoadAsset&lt;GameObject&gt;(<span class="string">"cube"</span>);</span><br><span class="line">        Instantiate(cubePrefab);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadABFromMemory</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AssetBundleCreateRequest cubeRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(abPath + <span class="string">"cube.asbd"</span>));</span><br><span class="line">        cubeAB = cubeRequest.assetBundle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h3><blockquote><p><strong>若把Start()函数声明成返回IEnumrator，编译器会自动将Start的调用处理成协程的模式</strong></p><h3 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h3><h3 id="WWW-LoadFromCacheOrDownload"><a href="#WWW-LoadFromCacheOrDownload" class="headerlink" title="WWW.LoadFromCacheOrDownload"></a>WWW.LoadFromCacheOrDownload</h3><p>Loading an AB from a remote location will automatically cache the AssetBundles. If the AssetBundle is compressed, a worker thread will spin up to decompress the bundle and write it to the cache. Once a bundle has been decompressed and cached, it will load exactly like AssetBundle.LoadFromFile .</p><h3 id="UnityWebRequest-1"><a href="#UnityWebRequest-1" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h3><p>从服务器下载</p><ol><li>NetBox可以在本地启动服务器，把当前目录作为服务器端的网站</li></ol></blockquote><h3 id="同步和异步的优缺点"><a href="#同步和异步的优缺点" class="headerlink" title="同步和异步的优缺点"></a>同步和异步的优缺点</h3><p>Ref: <a href="https://blog.csdn.net/qq_40093529/article/details/85290686" target="_blank" rel="noopener">https://blog.csdn.net/qq_40093529/article/details/85290686</a><br>异步<br>优点：速度快，与主线程无关，<br>缺点：调用比较麻烦，因为你不知道啥时候你的资源准备好了，最好的做法也是使用回调，这样回调就会很多，很乱个人感觉管理起来很不舒服。</p><p>同步<br>优点：管理起来方便，而且资源准备好了是可以及时返回的，<br>缺点：是没有异步快<br>综合上诉，最终我选择了 同步，因为我不希望代码不整洁，也不希望写太多的回调函数来通知调用者，资源准备妥当了。那么问题来了，如何解决同步的缺点呢。也就是卡主线程。之前一直以为corotine这玩意可以帮到我们。但是当我深入理解了coroutine以后发现他其实也是在主线程中的。最终我选择了使用c# 的多线程机制来解决这个问题。</p><h2 id="加载Manifests"><a href="#加载Manifests" class="headerlink" title="加载Manifests"></a>加载Manifests</h2><p>加载Manifests文件可以处理资源的依赖<br>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);<br>AssetBundleManifest manifest =<br>assetBundle.LoadAsset<AssetBundleManifest>(“AssetBundleManifest”);<br>string[] dependencies = manifest.GetAllDependencies(“assetBundle”); //Pass the name of the bundle you want the dependencies for.<br>foreach(string dependency in dependencies)<br>{<br>    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));<br>}</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>卸载有两个方面</p><ol><li>减少内存使用</li><li>有可能导致丢失<br>所以什么时候去卸载资源<h4 id="AssetBundle-Unload-true"><a href="#AssetBundle-Unload-true" class="headerlink" title="AssetBundle.Unload(true)"></a>AssetBundle.Unload(true)</h4></li></ol><p>When unloadAllLoadedObjects is true, all objects that were loaded from this bundle will be destroyed as well. If there are GameObjects in your Scene referencing those assets, the references to them will become missing.</p><p>卸载所有资源，即使有资源被使用着</p><pre><code>1. 在关卡切换、场景切换2. 资源没被用的时候调用</code></pre><h4 id="AssetBundle-Unload-false"><a href="#AssetBundle-Unload-false" class="headerlink" title="AssetBundle.Unload(false)"></a>AssetBundle.Unload(false)</h4><p>When unloadAllLoadedObjects is false, compressed file data inside the bundle itself will be freed, but any instances of objects loaded from this bundle will remain intact.</p><p>If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways:</p><ol><li>先去除对不想要的Objects的引用（包括场景和代码当中），然后调用 Resources.UnloadUnusedAssets.</li><li>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.</li></ol><h2 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h2><p>CRC MD5 SHA1<br>相同点：<br>CRC、MD5、SHA1都是通过对数据进行计算，来生成一个校验值，该校验值用来校验数据的完整性。<br>不同点：</p><ol><li>算法不同。CRC采用多项式除法，MD5和SHA1使用的是替换、轮转等方法；</li><li>校验值的长度不同。CRC校验位的长度跟其多项式有关系，一般为16位或32位；MD5是16个字节（128位）；SHA1是20个字节（160位）；</li><li>校验值的称呼不同。CRC一般叫做CRC值；MD5和SHA1一般叫做哈希值（Hash）或散列值；</li><li>安全性不同。这里的安全性是指检错的能力，即数据的错误能通过校验位检测出来。CRC的安全性跟多项式有很大关系，相对于MD5和SHA1要弱很多；MD5的安全性很高，不过大概在04年的时候被山东大学的王小云破解了；SHA1的安全性最高。</li><li>效率不同，CRC的计算效率很高；MD5和SHA1比较慢。</li><li>用途不同。CRC一般用作通信数据的校验；MD5和SHA1用于安全（Security）领域，比如文件校验、数字签名等。</li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>依赖包重复问题<br>a. 把需要共享的资源打包到一起<br>b. 分割包，这些包不是在同一时间使用的<br>c. 把共享部分打包成一个单独的包</li><li>图集重复问题<br>在Unity当中，Sprite2D会被打包到一个图集当中（由Packing Tag决定）。如果不指定PackingTag，Sprite会打包到同一个图集当中。一个Sprite打包到AssetBundle中时，它所在的整个图集都会被打包进去。<br>解决方法：确保同一个图集当中的图片打包到同一个AssetBundle当中去。</li><li>Android贴图问题</li><li>iOS文件处理重复fixed in Unity 5.3.2p2.</li></ol><h2 id="UnityAssetBundleBrowserTool"><a href="#UnityAssetBundleBrowserTool" class="headerlink" title="UnityAssetBundleBrowserTool"></a>UnityAssetBundleBrowserTool</h2><h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><p>Build的时候，该文件夹下的所有东西会被原封不动地打包到我们的安装包当中。<br>一般放一些二进制文件、 AssetBundles。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asset </tag>
            
            <tag> 加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渲染】Draw Call与Batching(合批)</title>
      <link href="2020/10/25/U3D-Draw-Call-Batching/"/>
      <url>2020/10/25/U3D-Draw-Call-Batching/</url>
      
        <content type="html"><![CDATA[<h2 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>To draw a GameObject on the screen, the engine has to issue a draw call to the graphics API (such as OpenGL or Direct3D).<br><strong>每次引擎准备数据并通知GPU的过程称为一次Draw Call</strong>。<br><strong>The command that tells the GPU to render a certain set of vertices as triangles with a certain state (shaders, blend state and so on)</strong></p><h3 id="耗时原因"><a href="#耗时原因" class="headerlink" title="耗时原因"></a>耗时原因</h3><p>在没有进行拼合的情况下，引擎准备数据并通知GPU的过程是逐个物体进行的，对于每个物体，不只GPU的渲染，CPU重新<strong>设置材质/Shader</strong>也是一项非常耗时的操作。</p><p><strong>Draw Call耗时主要是CPU端的耗时——</strong><br>Unity3d官方 - Draw calls are often resource-intensive(资源密集型的，大量占用资源的), with the graphics API doing significant work for every draw call, causing <strong>performance overhead(开销)on the CPU side</strong>. This is mostly caused <strong>by the state changes done between the draw calls</strong> (such as switching to a different Material), which causes resource-intensive validation and translation steps in the graphics driver.</p><p>There are some real costs with making draw calls, it requires <strong>setting up a bunch of state</strong> (<strong>which set of vertices to use, what shader to use and so on</strong>), and state changes have a cost both on the hardware side (updating a bunch of registers) and on the driver side (validating and translating your calls that set state).</p><p>为何要减少DrawCall？<br><strong>The main reason to make fewer draw calls is that graphics hardware can transform and render triangles much faster than you can submit them.</strong> If you submit few triangles with each call, you will be completely bound by the CPU and the GPU will be mostly idle. The CPU won’t be able to feed the GPU fast enough.</p><p> <strong>The main cost of draw calls only apply if each call submits too little data</strong>, since this will cause you to be CPU-bound, and stop you from utilizing the hardware fully.</p><blockquote><p>Making a single draw call with two triangles is cheap, but if you submit too little data with each call, you won’t have enough CPU time to submit as much geometry to the GPU as you could have.</p><p>(我还不太懂的)draw calls can also cause the command buffer to be flushed, but in my experience that usually happens when you call SwapBuffers, not when submitting geometry. Video drivers generally try to buffer as much as they can get away with (several frames sometimes!) to squeeze out as much parallelism from the GPU as possible.</p></blockquote><h3 id="方法与建议"><a href="#方法与建议" class="headerlink" title="方法与建议"></a>方法与建议</h3><p>目前，我们建议DrawCall的主体范围(5%~95%) 控制在[0,150]范围内。</p><p>方法：减少所渲染物体的材质种类，并通过Draw Call Batching 来减少其数量。</p><h3 id="Note：游戏性能并非Draw-Call越小越好。"><a href="#Note：游戏性能并非Draw-Call越小越好。" class="headerlink" title="Note：游戏性能并非Draw Call越小越好。"></a>Note：游戏性能并非Draw Call越小越好。</h3><p>决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的<strong>总线带宽</strong>。当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。</p><h2 id="Draw-call-batching"><a href="#Draw-call-batching" class="headerlink" title="Draw call batching"></a>Draw call batching</h2><blockquote><p>You can enable or disable Dynamic and Static batching through Unity’s Player settings under Other Settings.</p><p>Built-in Batching的优劣：<br>Built-in batching has several <strong>benefits</strong> compared to manually merging GameObjects together; most notably, GameObjects <strong>can still be culled individually</strong>.<br>However, it also has some <strong>downsides</strong>; <strong>static</strong> batching incurs <strong>memory and storage overhead</strong>, and <strong>dynamic</strong> batching incurs some <strong>CPU overhead</strong>.</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="Dynamic-batching-Meshes"><a href="#Dynamic-batching-Meshes" class="headerlink" title="Dynamic batching (Meshes)"></a>Dynamic batching (Meshes)</h4><p>条件:</p><ol><li>share the same Material(共享相同的材质<strong>实例</strong>)</li><li>fulfill other criteria<ul><li>Batching dynamic GameObjects has certain overhead per vertex, so batching is applied only to Meshes containing no more than 900 vertex attributes, and no more than 300 vertices.</li><li>GameObjects are not batched if they contain mirroring on the transform</li><li>Using different <strong>Material instances</strong> causes GameObjects not to batch together, even if they are essentially the same. The exception is shadow caster rendering.</li><li>GameObjects with lightmaps have additional renderer parameters: lightmap index and offset/scale into the lightmap. Generally, dynamic lightmapped GameObjects should point to exactly the same lightmap location to be batched.</li><li>Multi-pass Shaders break batching.</li></ul></li></ol><blockquote><p>如果Draw Call的开销比合批要低, 那么合批就没有意义了. Dynamic batching works by transforming all GameObject vertices into world space on the CPU, so it is only an advantage if that work is smaller than doing a draw call. The resource requirements of a draw call depends on many factors, primarily the graphics API used. For example, on consoles or modern APIs like Apple Metal, the draw call overhead is generally much lower, and often dynamic batching cannot be an advantage at all.</p></blockquote><h4 id="Dynamic-batching-Particle-Systems-Line-Renderers-Trail-Renderers"><a href="#Dynamic-batching-Particle-Systems-Line-Renderers-Trail-Renderers" class="headerlink" title="Dynamic batching (Particle Systems, Line Renderers, Trail Renderers)"></a>Dynamic batching (Particle Systems, Line Renderers, Trail Renderers)</h4><p>ParticleSystem等属于<strong>Components with geometry that Unity generates dynamically(带有动态生成的几何图形的组件)</strong></p><p>具体处理方式:</p><ul><li>For each compatible renderer type, Unity builds all batchable content into 1 large Vertex Buffer.</li><li>The renderer sets up the Material state for the batch.</li><li>Unity binds the Vertex Buffer to the Graphics Device.</li><li>For each Renderer in the batch, Unity updates the offset into the Vertex Buffer, and then submits a new draw call.</li></ul><p>When measuring the cost of the Graphics Device calls, the slowest part of rendering a Component is the set-up of the Material state. Submitting draw calls at different offsets into a shared Vertex Buffer is very fast by comparison.</p><h4 id="Static-batching"><a href="#Static-batching" class="headerlink" title="Static batching"></a>Static batching</h4><p><strong>本质上是用空间换时间,要在渲染耗时与内存占用之间做权衡.</strong></p><p>Static batching allows the engine to reduce draw calls for geometry of any size provided it <strong>shares the same material</strong>, and <strong>does not move</strong>.</p><ul><li>优点：more efficient than dynamic batching (it does not transform vertices on the CPU)</li><li>缺点：uses more memory.</li></ul><blockquote><p>Using static batching requires <strong>additional memory for storing the combined geometry</strong>. If several GameObjects shared the same geometry before static batching, then a copy of geometry is created for each GameObject, either in the Editor or at runtime. This might not always be a good idea; sometimes you have to sacrifice rendering performance by avoiding static batching for some GameObjects to keep a smaller memory footprint. For example, marking trees as static in a dense forest level can have serious memory impact.</p></blockquote><p>内部实现: Internally, static batching works by transforming the static GameObjects into world space and building one shared vertex and index buffer for them.</p><h3 id="怎样才能合批——Material-set-up-for-batching"><a href="#怎样才能合批——Material-set-up-for-batching" class="headerlink" title="怎样才能合批——Material set-up for batching"></a>怎样才能合批——Material set-up for batching</h3><p>Only GameObjects sharing the same Material can be batched together. Therefore, if you want to achieve good batching, you should aim to share Materials among as many different GameObjects as possible.</p><p>使用图集合并Material<br>If you have two identical Materials which differ only in Texture, you can combine those Textures into a single big Texture. This process is often called Texture atlasing (see the Wikipedia page on Texture atlases for more information). Once Textures are in the same atlas, you can use a single Material instead.</p><blockquote><p>If you need to access shared Material properties from the scripts, then it is important to note that <strong>modifying Renderer.material creates a copy of the Material</strong>. Instead, use Renderer.sharedMaterial to keep Materials shared.</p><p>Shadow casters can often be batched together while rendering, even if their Materials are different. Shadow casters in Unity can use dynamic batching even with different Materials, as long as the values in the Materials needed by the shadow pass are the same. For example, many crates could use Materials with different Textures on them, but for the shadow caster rendering the textures are not relevant, so in this case they can be batched together.</p></blockquote><h4 id="Texture-altas概念"><a href="#Texture-altas概念" class="headerlink" title="Texture altas概念"></a>Texture altas概念</h4><p>In computer graphics, a texture atlas (also called a sprite sheet or an image sprite) is an image containing multiple smaller images, usually packed together to reduce overall dimensions.<br><strong>Benefits</strong><br>In an application where many small textures are used frequently, it is often more efficient to store the textures in a texture atlas which is treated as a single unit by the graphics hardware. This reduces the overhead of a context switch by increasing memory locality.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.uwa4d.com/archives/Simple_PA_Rendering.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Simple_PA_Rendering.html</a><br><a href="https://blog.uwa4d.com/archives/optimzation_cpu.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/optimzation_cpu.html</a><br><a href="https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive" target="_blank" rel="noopener">https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive</a><br><a href="https://docs.unity3d.com/Manual/DrawCallBatching.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br><a href="https://en.wikipedia.org/wiki/Texture_atlas" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Texture_atlas</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Draw Call </tag>
            
            <tag> Batching </tag>
            
            <tag> 渲染 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OS】Shell on UNIX-like systems</title>
      <link href="2020/10/25/TestSubFolder-OS-Shell-on-UNIX-like-systems/"/>
      <url>2020/10/25/TestSubFolder-OS-Shell-on-UNIX-like-systems/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-overview"><a href="#Shell-overview" class="headerlink" title="Shell overview"></a>Shell overview</h1><p>shell即“壳”，是用户和操作系统（系统内核）之间的接口程序，是个命令解释程序，拥有自己内建的 shell 命令集。提示符下输入的每个命令都由shell先解释然后传给操作系统内核。</p><p>Linux下有Bash、Zsh等，Windows下有CMD、PowerShell等，都是Shell。</p><h2 id="Linux中Shell的类型"><a href="#Linux中Shell的类型" class="headerlink" title="Linux中Shell的类型"></a>Linux中Shell的类型</h2><p>Linux 中的 shell 有很多类型，其中最常用的几种是: Bourne shell (sh)、C shell (csh) 和 Korn shell (ksh), 各有优缺点。Bourne shell 是 UNIX 最初使用的 shell，并且在每种 UNIX 上都可以使用, 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。Linux 操作系统缺省的 shell 是Bourne Again shell，它是 Bourne shell 的扩展，简称 Bash，与 Bourne shell 完全向后兼容，并且在Bourne shell 的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p><a href="https://blog.csdn.net/MonMama/article/details/53390610" target="_blank" rel="noopener">https://blog.csdn.net/MonMama/article/details/53390610</a><br><a href="https://blog.csdn.net/wenlifu71022/article/details/4069929" target="_blank" rel="noopener">https://blog.csdn.net/wenlifu71022/article/details/4069929</a></p><h1 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h1><p><a href="http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html</a></p><h1 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h1><h1 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h1><h2 id="管理者权限"><a href="#管理者权限" class="headerlink" title="管理者权限"></a>管理者权限</h2><p><strong>sudo命令</strong> - 以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。<br>使用权限：在 /etc/sudoers 中有出现的使用者。</p><p><strong>su</strong>命令为切换用户的命令。</p><p>切换为root用户执行命令：<br> <code>sudo su root</code>或·<code>sudo su</code>: 切换到root用户，不改变当前变量<br> <code>sudo su - root</code>或·<code>sudo su -</code>: 切换到root用户，并获得root的环境变量及执行权限<br>只要当前用户为管理员用户，即可使用sudo切换到root用户，此时输入的密码为当前管理员用户的密码。</p><p>若直接使用命令<code>su root</code>，则需要输入的密码为root用户的密码。输入当前管理员用户的密码会返回 su: Sorry。<br>可以使用管理员权限修改root用户的密码后，再执行<code>su root</code>命令，这样输入刚刚修改好的root密码即可切换到root用户如下图：</p><p><img src="./su_root.png" alt="Alt text"></p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l 文件夹</span><br></pre></td></tr></table></figure><p>权限说明一共10位: drwxrwxrwx<br>第一位 - 文件类型，” + “代表目录，” - “代表非目录。<br>2-4位 - 所有者user的权限说明<br>5-7位 - 组群group的权限说明<br>8-10位 - 其他人other的权限说明</p><p>r代表可读权限，w代表可写权限，x代表可执行权限。</p><blockquote><p>MacOS上，权限说明后可能有 + 或 @<br>‘+’ 表示扩展属性(extended attributes)<br>‘@’ 表示扩展安全信息(extended security information)<br>详情可通过命令 ls -le 或 ls -l@ 查看</p></blockquote><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod o w xxx.xxx</span><br></pre></td></tr></table></figure><p>授予其他人写xxx.xxx这个文件的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod go-rw xxx.xxx</span><br></pre></td></tr></table></figure><p>删除xxx.xxx中组群和其他人的读和写的权限</p><blockquote><p>u 代表所有者（user）<br>g 代表所有者所在的组群（group）<br>o 代表其他人，但不是u和g （other）<br>a 代表全部的人，也就是包括u，g和o</p></blockquote><p>r w x可以换成数字表示：<br>r 对应 4， w 对应 2， x 对应 1<br>rwx 或 - 的任意组合对应的数字是唯一的，所以可用一个数字表示一组rwx权限。<br>如 7 = 4+2+1 表示赋予目录可读可写可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod  -R 777 /var/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h1 id="环境变量相关"><a href="#环境变量相关" class="headerlink" title="环境变量相关"></a>环境变量相关</h1><p>环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或多个应用程序将使用到的信息。Linux是一个多用户的操作系统，每个用户登录系统时都会有一个专用的运行环境。这个默认环境就是一组环境变量的定义。每个用户都可以通过修改环境变量的方式对自己的运行环境进行配置。</p><h2 id="环境变量分类"><a href="#环境变量分类" class="headerlink" title="环境变量分类"></a>环境变量分类</h2><h3 id="对所有用户生效的永久性变量（系统级）"><a href="#对所有用户生效的永久性变量（系统级）" class="headerlink" title="对所有用户生效的永久性变量（系统级）"></a>对所有用户生效的永久性变量（系统级）</h3><p>位置：/etc/profile<br>添加方式：vim打开/etc/ profile文件，用export指令添加环境变量。<br>调用<code>source /etc/profile</code>才能立即生效，否则下次进入此用户生效。</p><h3 id="对单一用户生效的永久性变量（用户级）"><a href="#对单一用户生效的永久性变量（用户级）" class="headerlink" title="对单一用户生效的永久性变量（用户级）"></a>对单一用户生效的永久性变量（用户级）</h3><p>设置方法：在用户主目录”~”下的隐藏文件 “.bashrc”中添加自己想要的环境变量。<br>同样调用<code>source ./.bashrc</code>该文件才会生效。否则只能在下次重进此用户时才能生效。</p><blockquote><ul><li>~/.bash_profile是交互式login方式进入bash shell运行，只会在用户登录的时候读取一次。</li><li>~/ .bashrc是交互式non-login方式进入bash shell运行，在每次打开终端进行一次新的会话时都会读取。<h3 id="临时有效的环境变量（只对当前shell有效）"><a href="#临时有效的环境变量（只对当前shell有效）" class="headerlink" title="临时有效的环境变量（只对当前shell有效）"></a>临时有效的环境变量（只对当前shell有效）</h3>此类环境变量只对当前的shell有效。当我们退出登录或者关闭终端再重新打开时，这个环境变量就会消失。是临时的。<br>设置方法：直接使用export指令添加。 如<code>export PATH=/usr/local/bin:$PATH</code></li></ul></blockquote><h2 id="常用环境变量"><a href="#常用环境变量" class="headerlink" title="常用环境变量"></a>常用环境变量</h2><ul><li>PPID: 是当前进程的父进程的PID</li><li>PWD: 当前工作目录。命令pwd的输出该变量值。</li><li>RANDOM: 随机数变量。每次引用这个变量会得到一个0~32767的随机数。</li><li>SECONDS: 脚本已经运行的时间（以秒为单位）</li><li><p>PATH 指定命令的搜索路径。通过设置环境变量PATH可以让我们运行程序或指令更加方便。</p><blockquote><p>每一个冒号都是一个路径，这些搜索路径都是一些可以找到可执行程序的目录列表。当我们输入一个指令时，shell会先检查命令是否是内部命令，不是的话会再检查这个命令是否是一个应用程序。然后shell会试着从搜索路径，即PATH中寻找这些应用程序。如果shell在这些路径目录里没有找到可执行文件。则会报错。若找到，shell内部命令或应用程序将被分解为系统调用并传给Linux内核。</p></blockquote></li><li><p>SHELL  指当前用户用的是哪种shell</p></li></ul><h2 id="设置环境变量常用的几个指令"><a href="#设置环境变量常用的几个指令" class="headerlink" title="设置环境变量常用的几个指令"></a>设置环境变量常用的几个指令</h2><ul><li>echo - 查看显示环境变量，变量使用时要加上符号“$”<br>  <code>echo $PATH</code></li><li>export - 设置新的环境变量<br><code>export PATH=/usr/local/bin:$PATH</code></li><li>修改环境变量 - 修改环境变量没有指令，可以直接使用环境变量名进行修改。<br><code>MYNAME=&quot;Prin&quot;</code></li><li>env  查看所有环境变量</li><li>set  查看本地定义的所有shell变量</li><li>unset 删除一个环境变量</li><li>readonly 设置只读环境变量<br><code>readonly MYNAME</code></li></ul><h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$variable</span></span><br><span class="line"><span class="variable">$&#123;variable&#125;</span></span><br><span class="line"><span class="string">"<span class="variable">$variable</span>"</span></span><br><span class="line"><span class="string">"<span class="variable">$&#123;variable&#125;</span>"</span></span><br></pre></td></tr></table></figure><h3 id="命令替换：-command"><a href="#命令替换：-command" class="headerlink" title="命令替换：$(command)"></a>命令替换：$(command)</h3><p>命令替换的目的是获取命令的输出、为变量赋值，或对命令的输出做进一步的处理。</p><h1 id="进程相关技巧"><a href="#进程相关技巧" class="headerlink" title="进程相关技巧"></a>进程相关技巧</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A | grep name</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-grep.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-grep.html</a><br>grep 命令用于查找文件里符合条件的字符串。上条命令可用于查找包含特定字符串的进程</p><p>如果出现进程未响应的状况，则查找到进程的PID后，可调用<code>kill -9 PID</code>强制终止进程</p><h1 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>.tar<br>解包：tar xvf FileName.tar<br>打包：tar cvf FileName.tar DirName<br>（注：tar是打包，不是压缩！）</p><p>.gz<br>解压1：gunzip FileName.gz<br>解压2：gzip -d FileName.gz<br>压缩：gzip FileName<br>.tar.gz 和 .tgz<br>解压：tar zxvf FileName.tar.gz<br>压缩：tar zcvf FileName.tar.gz DirName</p><p>.bz2<br>解压1：bzip2 -d FileName.bz2<br>解压2：bunzip2 FileName.bz2<br>压缩： bzip2 -z FileName<br>.tar.bz2<br>解压：tar jxvf FileName.tar.bz2<br>压缩：tar jcvf FileName.tar.bz2 DirName</p><p>.bz<br>解压1：bzip2 -d FileName.bz<br>解压2：bunzip2 FileName.bz<br>压缩： 未知<br>.tar.bz<br>解压：tar jxvf FileName.tar.bz<br>压缩： 未知</p><p>.Z<br>解压：uncompress FileName.Z<br>压缩：compress FileName<br>.tar.Z<br>解压：tar Zxvf FileName.tar.Z<br>压缩：tar Zcvf FileName.tar.Z DirName</p><p>.zip<br>解压：unzip FileName.zip<br>压缩：zip FileName.zip DirName</p><p>.rar<br>解压：rar x FileName.rar<br>压缩：rar a FileName.rar DirName</p><h2 id="zip-unzip-命令"><a href="#zip-unzip-命令" class="headerlink" title="zip / unzip 命令"></a>zip / unzip 命令</h2><p>unzip指令 格式如下：</p><p>//待更</p><p>-d 目录名    将压缩文件解压到指定目录下</p><h1 id="拓展延伸-Console-TTY等"><a href="#拓展延伸-Console-TTY等" class="headerlink" title="拓展延伸 Console, TTY等"></a>拓展延伸 Console, TTY等</h1><p><a href="https://www.zhihu.com/question/26860370" target="_blank" rel="noopener">https://www.zhihu.com/question/26860370</a></p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.iteye.com/blog/henry-cong-1060014" target="_blank" rel="noopener">https://www.iteye.com/blog/henry-cong-1060014</a><br><a href="https://www.jianshu.com/p/09f521c60c30" target="_blank" rel="noopener">https://www.jianshu.com/p/09f521c60c30</a><br><a href="https://blog.csdn.net/Axela30W/article/details/78981749" target="_blank" rel="noopener">https://blog.csdn.net/Axela30W/article/details/78981749</a><br><a href="https://blog.csdn.net/huayangshiboqi/article/details/80150842" target="_blank" rel="noopener">https://blog.csdn.net/huayangshiboqi/article/details/80150842</a></p>]]></content>
      
      
      <categories>
          
          <category> 从硬件到OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> OS </tag>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统下Lua及Luacheck环境配置</title>
      <link href="2020/10/03/TestSubFolder-Lua-installation-of-luacheck/"/>
      <url>2020/10/03/TestSubFolder-Lua-installation-of-luacheck/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>说明: 本文描述了windows系统上从Lua环境安装配置到使用luarocks安装luacheck的详细步骤。笔者参考网上的博客进行配置时踩了不少坑，最终整理出一套尽可能简洁且可行的步骤，希望帮到各位伙伴</strong><br><strong>另，笔者后来发现Luacheck在windows上的安装有更简洁的方法，一步即可，甚至不需要配置lua环境，详见文末。</strong></p></blockquote><h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><ul><li>Windows 10 专业版</li><li>Visual Studio 2017 community</li><li>Lua for Windows v5.1.5-52 Released</li><li>Luarocks 2.2.2<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-安装配置Lua环境"><a href="#1-安装配置Lua环境" class="headerlink" title="1. 安装配置Lua环境"></a>1. 安装配置Lua环境</h2>(1) Lua for Windows下载地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases" target="_blank" rel="noopener">https://github.com/rjpcomputing/luaforwindows/releases</a><br>(2) 直接下载<code>LuaForWindows_v5.1.5-52.exe</code>,双击安装(路径等设置按照默认即可)</li></ul><p><img src="./1.png" alt="1"></p><hr><p>(3) 安装好后，环境变量会自动配置好，命令行输入lua，显示结果如下，则配置成功<br><img src="./2.png" alt="Alt text"></p><hr><h2 id="2-安装并升级luarocks"><a href="#2-安装并升级luarocks" class="headerlink" title="2. 安装并升级luarocks"></a>2. 安装并升级luarocks</h2><p>(1) 在下载Lua for windows的网页中往下拉，可以看到LuaRocks updater，分别下载红框中的两个文件，得到<code>luarocks-2.2.2-win32.zip</code>和<code>lfw_luarocks-2.2.2-win32.7z</code><br><img src="./3.png" alt="Alt text"></p><hr><p>(2) 分别解压两个压缩文件，并将<code>lfw_luarocks-2.2.2-win32</code>中的文件全部拷贝到<code>luarocks-2.2.2-win32</code>中，如下图<br><img src="./4.png" alt="Alt text"></p><hr><p>(3) 将文件夹<code>luarocks-2.2.2-win32</code>移动到lua目录下。(若按照本文步骤1安装lua，则目录为C:\Program Files (x86)\Lua)<br>(4) 使用管理员身份运行windows命令提示符（方法：在Windows10系统的搜索框中直接输入命令CMD，在命令提示符上单击右键，选择管理员身份运行）<br><img src="./5.png" alt="Alt text"></p><hr><p>(5) 进入luarocks目录<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Program Files (x86)\Lua\luarocks-<span class="number">2</span>.<span class="number">2</span>.<span class="number">2</span>-win32</span><br></pre></td></tr></table></figure></p><hr><p>(6) 执行<code>install.bat</code>， 显示以下内容表明安装成功<br><img src="./6.png" alt="Alt text"></p><hr><p>(7) 执行<code>lfw_install.bat</code>。（若非管理员身份运行cmd，本步骤会出错）<br>此时，输入luarocks，可看到版本信息为2.2.2，</p><hr><h2 id="3-使用luarocks安装luacheck"><a href="#3-使用luarocks安装luacheck" class="headerlink" title="3. 使用luarocks安装luacheck"></a>3. 使用luarocks安装luacheck</h2><blockquote><p><strong>Note:</strong> luacheck的安装涉及到一些依赖，需要先安装一些其他的模块，包括：argparse, lanes, luafilesystem。（luacheck对所依赖的模块的版本也有一些要求）。</p></blockquote><p>(1) 继续在命令提示符中输入<code>luarocks install argparse</code>示如下信息，表明安装成功。<br><img src="./7.png" alt="Alt text"></p><hr><p>(2) 紧接着 <code>luarocks install luafilesystem</code>（在此之前，其实已经有安装好的luafilesystem模块，因其版本过低，需要重新安装）。<br>此处在编译时报错，信息如下：<br><img src="./8.png" alt="Alt text"><br>这是因为缺乏VC++编译的环境。根据luarocks的readme文档中的说明：</p><blockquote><p>if you want to install rocks, make it a “Visual Studio Command Prompt”</p></blockquote><p>我们需要在Visual Studio Command Prompt下使用luarocks进行相应模块的安装。<br>使用搜索功能搜索相应的快捷方式：<strong>VS 2017的开发人员命令提示符</strong> 或者<strong>Command Prompt for VS 2017</strong>，笔者计算机中其所在位置如下：<br><img src="./10.png" alt="Alt text"><br>同样右键，以管理员方式运行，执行命令<code>luarocks install luafilesystem</code>，则可安装成功。<br><img src="./11.png" alt="Alt text"></p><hr><p>(3) 直接安装luacheck：<code>luarocks install luacheck</code>，此时，luacheck安装成功<br><img src="./12.png" alt="Alt text"></p><hr><h2 id="4-使用测试"><a href="#4-使用测试" class="headerlink" title="4. 使用测试"></a>4. 使用测试</h2><p>将任意lua文件放置在任意位置，使用cmd进入相应目录，输入命令<code>luacheck XXX.lua</code>，即可使用luacheck对lua文件进行检测。<br><img src="./13.png" alt="Alt text"></p><h1 id="最简单的Luacheck配置方法-只需一步"><a href="#最简单的Luacheck配置方法-只需一步" class="headerlink" title="最简单的Luacheck配置方法(只需一步)"></a>最简单的Luacheck配置方法(只需一步)</h1><p>Luacheck的<a href="https://github.com/mpeterv/luacheck" target="_blank" rel="noopener">开源库</a>上提供了Windows 二进制Luacheck.exe文件的<a href="https://github.com/mpeterv/luacheck/releases/download/0.23.0/luacheck.exe" target="_blank" rel="noopener">下载链接</a>，该可执行文件将Luacheck所依赖的Lua，LuaFileSystem，Lualanes程序绑定在一起。因此，直接用命令行调用Luacheck.exe即可使用，甚至不需要配置Lua环境。</p><hr><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p> <a href="https://blog.csdn.net/Stupid_kidofObj/article/details/105043561" target="_blank" rel="noopener">https://blog.csdn.net/Stupid_kidofObj/article/details/105043561</a><br> <a href="https://github.com/mpeterv/luacheck" target="_blank" rel="noopener">https://github.com/mpeterv/luacheck</a></p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渲染】理解伽马校正(Gamma Correction)与Unity的Gamma or Linear workflow</title>
      <link href="2020/09/14/CG-gamma-correction-in-unity/"/>
      <url>2020/09/14/CG-gamma-correction-in-unity/</url>
      
        <content type="html"><![CDATA[<p>By Prin@UWA</p><p>笔者搜集阅读了一些与Gamma校正(Gamma Correction)、sRGB颜色空间等概念相关的资料，在学习相关知识时，由于理解的错误踩了很多坑。本文结合自己的理解，对相关理论以及在Unity中的处理方式进行了整理，希望能帮助刚接触这个知识的同学有一个粗浅的理解。</p><h1 id="伽马校正（Gamma-Correction）"><a href="#伽马校正（Gamma-Correction）" class="headerlink" title="伽马校正（Gamma Correction）"></a>伽马校正（Gamma Correction）</h1><h2 id="存在的原因"><a href="#存在的原因" class="headerlink" title="存在的原因"></a>存在的原因</h2><p>对于Gamma校正存在的原因，在网络上略有争议。汇总各种资料，主要存在以下两种观点：</p><ol><li>历史原因：去的CRT显示器屏幕上显示的颜色对于传递而来的原始值并不是线性的</li><li>人眼对自然亮度感知是非线性的</li></ol><p>笔者认为，以上两种因素是同时存在且不冲突的，都是Gamma校正产生的原因。以下来自<a href="https://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ" target="_blank" rel="noopener">kinematicsoup官网</a>的说法笔者比较认同：</p><blockquote><p>The need for gamma arises for two main reasons: The first is that screens have a non-linear response to intensity. The other is that the human eye can tell the difference between darker shades better than lighter shades. This means that when images are compressed to save space, we want to have greater accuracy for dark intensities at the expense of lighter intensities. Both of these problems are resolved using gamma correction, which is to say the intensity of every pixel in an image is put through a power function. Specifically, gamma is the name given to the power applied to the image.</p></blockquote><p><a href="https://en.wikipedia.org/wiki/Gamma_correction" target="_blank" rel="noopener">Wikipedia-Gamma correction</a>中谈到：</p><blockquote><p>Although gamma encoding was developed originally to compensate for the input–output characteristic of cathode ray tube (CRT) displays, that is not its main purpose or advantage in modern systems.</p></blockquote><p>由此基本可以明确：CRT显示器的历史原因是Gamma Correction的起源，与人眼感知能力等相关的其他因素是Gamma Correction一直延续下来的原因之一。 因此，不能绝对地主张其中一种原因而排斥其他说法。以下是笔者搜集和理解到的对两种原因的解释。</p><h3 id="CRT显示器特性的原因"><a href="#CRT显示器特性的原因" class="headerlink" title="CRT显示器特性的原因"></a>CRT显示器特性的原因</h3><p>此处主要借鉴冯乐乐女神的文章。<br>在早期，CRT几乎是唯一的显示设备。但CRT有个特性，它的输入电压和显示出来的亮度关系不是线性的，而是一个类似幂律（power-law）曲线的关系。也就是说，使用一个电压轰击CRT Monitor屏幕上的一种图层，这个图层就可以发亮，我们就可以看到图像了。但是，人们发现，咦，如果把电压调高两倍，屏幕亮度并没有提高两倍啊！<br>典型的CRT显示器的伽马曲线大致是一个伽马值为2.5的幂律曲线。显示器的这类伽马也称为<strong>display gamma</strong>。</p><p>这个幂律曲线的公式可以简单表述为下式：</p><p>$ \gamma(u) = Au^{\gamma } (u\in \left [  0, 1\right ],\gamma(u) \in \left [  0, 1\right ] )$      <strong>where u is R, G, or B</strong></p><p>一般情况下取A=1，那么，输入一个颜色值(0.5, 0.5, 0.5)，由该公式得到的输出为(0.177, 0.177, 0.177)。也就是说，显示器的Gamma转换会使输入的像素颜色的亮度变低（Darker）。</p><p>由于这个问题的存在，那么图像捕捉设备就需要进行一个<strong>伽马校正(Gamma Correction)</strong>，对显示器的伽玛变换进行<strong>反向补偿</strong>(变亮)。校正使用的伽马叫做<strong>encoding gamma</strong>。<br>所以，一个完整的图像系统需要2个伽马值：</p><ul><li>encoding gamma：它描述了encoding transfer function，即图像设备捕捉到的场景亮度值（scene radiance values）和编码的像素值（encoded pixel values）之间的关系。</li><li>display gamma：它描述了display transfer function，即编码的像素值和显示的亮度（displayed radiance）之间的关系。</li></ul><p>显示系统的处理流程如下图所示：<br><img src="./DiaplaySys.png" alt="Alt text"></p><p><a href="https://zhuanlan.zhihu.com/p/66558476" target="_blank" rel="noopener">PZZZB</a>的图较好地诠释了对应不同Gamma值的幂律曲线之间的关系：<br><img src="./power-law.jpg" alt="Alt text"></p><p>encoding gamma和display gamma的乘积就是真个图像系统的end-to-end gamma。如果这个乘积是1，那么显示出来的亮度就是和捕捉到的真实场景的亮度是成比例的。如果我们没有用一个encoding gamma对shader的输出进行校正，而是直接显示在屏幕上，那么由于display gamma的存在就会使画面失真。<br>虽然现在CRT设备很少见了，但为了保证这种感知一致性（这是它一直沿用至今的很重要的一点），同时也为了对已有图像的兼容性（之前很多图像使用了encoding gamma对图像进行了编码），所以仍在使用这种伽马编码。</p><p>至此可以大致理解对于显示器的Gamma校正的原理。然而，实际问题往往更复杂一些，此处做一个简要提示，感兴趣的同学可以深究。<br>encoding gamma和display gamma的乘积为1的话，可以让显示器精确重现原始场景的视觉条件。但是，原始场景的观察条件和显示的版本之间存在两个差异我们需要乘积不是1的end-to-end gamma，来保证显示的亮度结果在感知上和原始场景是一致的。根据《Real-time Rendering》一书中，推荐的值在电影院这种漆黑的环境中为1.5，在明亮的室内这个值为1.125。</p><blockquote><p>个人电脑使用的一个标准叫sRGB，它使用的encoding gamma大约是0.45（也就是1/2.2）。这个值就是为了配合display gamma为2.5的设备工作的。这样，end-to-end gamma就是0.45 * 2.5 = 1.125了。</p></blockquote><h3 id="人眼感知能力的原因"><a href="#人眼感知能力的原因" class="headerlink" title="人眼感知能力的原因"></a>人眼感知能力的原因</h3><p>人眼对亮度的感知是非线性的。换句话说，<strong>亮度上的线性变化在人眼看来是非均匀的</strong>。从0亮度变到0.01亮度，人眼是可以察觉到的，但从0.99变到1.0，人眼可能就根本差别不出来，觉得它们是一个颜色。人眼对暗部的变化更加敏感，而对亮部变化其实不是很敏感。<br>通过知乎上韩世麟答主分享的<a href="https://www.zhihu.com/question/27467127#answer-10413243" target="_blank" rel="noopener">视频</a>可以对这个问题有一个直观的理解。</p><p><img src="./灰阶关系0.5.jpg" alt="Alt text"></p><p>以下两比较通俗的句话可以帮助读者对这个问题进行理解：</p><ul><li>人心目中（美术中的）看起来中灰的色块，其物理亮度值大约在白色块的20%左右。</li><li>自然界的0.2，在心目中的地位是0.5。</li></ul><p>现实生活中的例子如下图所示：<br><img src="./颜色卡.jpg" alt="Alt text"></p><p>而如果将纯白色块与纯黑色块进行1比1混合，得到的结果在人眼看来是浅灰色。</p><p>符合人的直觉的灰度(或者理解为亮度)均匀变化的情况如下图：<br><img src="./人眼感知.png" alt="Alt text"><br>们看到这张图，会自然而然的认为中间的地方即灰度为0.5的地方。事实上，在线性颜色空间下，也就是实际人看到的中间部分的灰度值约为0.218。</p><p>那么，美术中使用的中间<strong>灰色</strong>应该设置像素值为多少呢？计算机中图片上的值与最终人们看到颜色是如何对应的呢？ 这也是曾一度困扰笔者的一个问题。<br>在Photoshop中作图，利用颜色取样工具，会发现上图的中间灰色对应的像素颜色值就是(127, 127, 127)，换算成0到1区间的表示方式即约为(0.5, 0.5, 0.5)。由此可见，美术要绘制出直觉上介于黑白中间的灰色，把灰度值设置为0.5就可以了。<br>上文中已经阐述过，显示器会对输入的颜色值进行display gamma转换。也就是说，输入给显示器的灰度值0.5，经过显示器的转换之后，会变为0.218，而这个0.218的灰度，又刚好符合人眼对于中等灰度（0.5）的直觉。这是一个有趣的巧合。这也可能是显示器的Gamma转换一直延续的原因。</p><h2 id="Gamma的定义"><a href="#Gamma的定义" class="headerlink" title="Gamma的定义"></a>Gamma的定义</h2><p><a href="https://en.wikipedia.org/wiki/Gamma_correction" target="_blank" rel="noopener">wikipedia - Gamma correction</a>对Gamma校正的相关概念进行了清楚的定义。<br><strong>Gamma correction</strong>, or often simply <strong>gamma</strong>, is a nonlinear operation used to encode and decode luminance or tristimulus values in video or still image systems.<br>Gamma correction is, in the simplest cases, defined by the following power-law expression:<br>${\displaystyle V<em>{\text{out}}=A{V</em>{\text{in}}^{\gamma }}}$</p><p>不同的文献资料对颜色空间相关转换的称呼不统一，这也是这块知识不容易理解清楚的原因之一。为此，笔者对同一过程的不同表述方式进行了整理，以便读者进行理解。</p><p>$\gamma &lt;1$时(即一些资料所说的1/2.2)，该值称为<strong>encoding gamma</strong>，该幂律函数进行的非线性转换称为<strong>gamma compression</strong>，或<strong>gamma encoding</strong>。该转换会把颜色的亮度变大，因此，这个过程也叫做<strong>补偿</strong>，狭义上的<strong>伽马校正</strong>。</p><p>$\gamma &gt; 1$时(典型的范围在2.0到2.4之间)，该值称为<strong>decoding gamma</strong>，该幂律函数进行的非线性转换称为<strong>gamma expansion</strong>，或<strong>gamma decoding</strong>。该转换会把导致颜色的亮度变低(Darker)，显示器的<strong>伽马转换</strong>就是这样一个过程。</p><h1 id="颜色空间-sRGB-amp-Linear-RGB"><a href="#颜色空间-sRGB-amp-Linear-RGB" class="headerlink" title="颜色空间(sRGB &amp; Linear RGB)"></a>颜色空间(sRGB &amp; Linear RGB)</h1><blockquote><p>Unity中的Color Space可以设置为Linear和Gamma，但这一说法会有争议。有人会说不存在Gamma Color Space的定义，Wikipedia上对Color Space的介绍中也确实没有提到Gamma Color Space。Gamma Color Space可能算是Unity自己提出的一个概念，指的是将图片的像素经过伽马校正后的颜色空间。<br>Unity文档中提到：<strong>The accepted standard for gamma space is called sRGB</strong>。准确地说，sRGB才是一种Color Space。为了方便理解，读者可以认为gamma space就是sRGB color space。</p></blockquote><h2 id="sRGB"><a href="#sRGB" class="headerlink" title="sRGB"></a>sRGB</h2><p><a href="https://en.wikipedia.org/wiki/SRGB" target="_blank" rel="noopener">Wikipedia</a>上定义：<br>sRGB (standard Red Green Blue) is an RGB color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web.</p><p>我们可以粗浅地理解为：<br><strong>sRGB格式相当于对物理空间的颜色做了一次伽马校正(Gamma Correction)</strong>。sRGB空间下的颜色即为经过伽马校正后的颜色。将sRGB格式的Texture输入给显示器，显示器经过自身的Gamma变换之后，输出的值就是准确的、线性空间下的颜色值，这样人从显示器看到的图像就和人眼直接观察物理世界一样了。</p><blockquote><p>笔者认为，由此我们很容易理解为什么Gamma校正和转换的过程被称为<strong>Encoding</strong>和<strong>Decoding</strong>——sRGB是一种格式，转换成这种格式我们可以叫做：<strong>编码成sRGB格式</strong>，那么其逆运算的过程就是<strong>解码</strong>。</p></blockquote><p>wikipedia中介绍了不同颜色空间(CIE XYZ to sRGB)的转换过程。我们只需要理解<strong>线性空间</strong>到<strong>sRGB空间</strong>的计算公式即可。<br>The following formula transforms <strong>the linear RGB values</strong> into <strong>sRGB</strong> :</p><p><img src="./1599332150051.png" alt="Alt text"></p><ul><li>where u is R, G, or B.</li></ul><h1 id="Unity对Color-Space的处理"><a href="#Unity对Color-Space的处理" class="headerlink" title="Unity对Color Space的处理"></a>Unity对Color Space的处理</h1><p>前面已经阐述过，显示器在显示的时候，会用display gamma把显示的像素进行display transfer之后输出实际显示的亮度值。所以，我们要在这之前，对图像先进行gamma encoding(或Gamma校正)。也就是说，我们输出给显示器的颜色值，应当是sRGB空间下的值，这样，显示器输出给人眼的值，才是我们期望人眼看到的值（和人眼直接观察物理世界一样）。</p><p>Unity官方文档解释到：<br>The reason both gamma and linear color spaces exist is because <strong>lighting calculations should be done in linear space in order to be mathematically correct</strong>, but the <strong>result should be presented in gamma space to look correct to our eyes</strong>.<br>如果要确保计算机渲染的效果最大程度接近真实世界，我们应当在线性空间下进行光照计算，因为这符合真实世界的规律（使用贴图中颜色的Linear RGB值进行计算）；应当输出给显示器Gamma空间的颜色值（输出给屏幕sRGB格式的像素）。</p><blockquote><p>Unity文档中的以下表述可以帮助读者更好地理解颜色空间的问题：<br>Even though <strong>monitors</strong> today are digital, they still take a <strong>gamma-encoded signal as input</strong>. Image <strong>files</strong> and video files are explicitly encoded to be in gamma space (meaning they <strong>carry gamma-encoded values</strong>, not linear intensities). This is the standard; everything is in gamma space.</p></blockquote><p>接下来我们看看Unity对Color Space的两种workflow：Gamma和Linear。</p><blockquote><p>该设置在Unity的Edit -&gt; Project Settings -&gt; Player -&gt; Other Settings中。</p></blockquote><p>其实说将Color Space设置成Gamma和Linear容易造成误解，因为这个设置并不是说输出的值是Gamma空间还是Linear空间。该设置只是选择两套处理颜色空间的方案(Workflow, or Pipeline)。<br><img src="./An+image+comparing+gamma+and+linear+pipelines.png" alt="Alt text"></p><h2 id="Gamma-workflow"><a href="#Gamma-workflow" class="headerlink" title="Gamma workflow"></a>Gamma workflow</h2><p> 当选择Gamma Space时，实际上就是“放任模式”，不会对shader的输入进行任何处理，即使输入可能是非线性的；也不会对输出像素进行任何处理，这意味着输出的像素会经过显示器的display gamma转换后得到非预期的亮度，通常表现为整个场景会比较昏暗。</p><p>我们使用Photoshop创建两张颜色为(127, 127, 127)纯色图片（映射到0到1的数值为0.498）。在Unity中将图片设置为UGUI的Image，并在屏幕上显示。在Import Settings当中，将其中一张图片勾选为sRGB(Color Texture)，另一张图片不勾选该项。<br>由下图可见，两张图片在显示上并没有区别，输出给显示器的颜色值都为0.498。</p><p><img src="./1.png" alt="Alt text"><br>整个gamma workflow的过程中不会进行gamma校正。</p><h2 id="Linear-workflow"><a href="#Linear-workflow" class="headerlink" title="Linear workflow"></a>Linear workflow</h2><p>选择Color Space为Linear的含义，并不是输出给屏幕的颜色为Linear RPG值，而是说，进行的光照计算的处理，是在Linear Space下进行的。下段文字为kinematicsoup介绍的Linear Pipeline的过程:<br>The input colors and textures have their gamma correction removed before shading, putting them into linear space. When shaded, the result is physically correct because the shading process and inputs are all in the same space. After, any post effects should be computed while the frame is still in linear space, as post effects are typically linear, much like shading. Finally the image is then gamma corrected so it will have the proper intensity after the display’s gamma adjustments.<br>在Linear workflow下，Unity会对sRGB格式的Texture进行decoding，将sRGB空间的颜色值转换为线性空间，然后在Linear Space下进行着色（光照计算等）。在最后输出阶段，进行的伽马校正（gamma correction），将Linear空间的像素转换为sRGB空间，输出给显示器。经过显示器的转换之后，输出给人眼的颜色就是更接近真实的颜色（亮度）。</p><p>在Linear workflow下，做前文相同的操作，可以发现，没有勾选sRGB的Texture（右边）会更亮一些。<br><img src="./QQ截图20200906041147.png" alt="Alt text"><br>初始状态下，两张图片的亮度都为0.498。</p><p>左边的Texture勾选了sRGB，那么Unity会把这张图片当作sRGB空间下的图片，在进行着色前，先将图片进行Decoding(Remove Gamma Correction)，转换成Linear Space下的图片，在输出给显示器之前，再进行Encoding，编码成sRGB格式。此时，输出给显示器的亮度值经过互为逆运算的两个步骤，仍然为0.498。经过显示器的转换，即为我们看到的左边的方块。</p><p>右边的Texture没有勾选sRGB，Unity会把这张图片当作Linear Space下的图片，也就不进行Decoding。在着色之后，进行Encoding(Gamma Correction)，输出给显示器的亮度值为0.733。经显示器转换处理之后，看到的就是右边的方块。</p><p>经过笔者计算验证，Unity进行Encoding的时候，使用的公式就是上文提到的公式（可能存在少量误差）：</p><p><img src="./1599332150051.png" alt="Alt text"></p><ul><li>where u is R, G, or B.</li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>促使笔者对本文的知识点进行整理的原因，主要是本公司（UWA）初始版本的的特效检测工具在Linear Color Space下存在计算得到的OverdrawRate偏高的小BUG。详情请看UWA问答：<a href="https://answer.uwa4d.com/question/5f51b8ba9424416784ef20d7" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5f51b8ba9424416784ef20d7</a></p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://blog.csdn.net/candycat1992/article/details/46228771" target="_blank" rel="noopener">https://blog.csdn.net/candycat1992/article/details/46228771</a><br><a href="https://www.zhihu.com/question/27467127#answer-10413243" target="_blank" rel="noopener">https://www.zhihu.com/question/27467127#answer-10413243</a><br><a href="https://docs.unity3d.com/Manual/index.html" target="_blank" rel="noopener">Unity Manual</a><br><a href="https://www.jianshu.com/p/e15932c40bea" target="_blank" rel="noopener">https://www.jianshu.com/p/e15932c40bea</a><br><a href="https://en.wikipedia.org/wiki/SRGB" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/SRGB</a><br><a href="https://en.wikipedia.org/wiki/Gamma_correction" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gamma_correction</a><br><a href="https://unity.cn/projects/unite-2018-qian-tan-jia-ma-he-xian-xing-yan-se-kong-jian" target="_blank" rel="noopener">https://unity.cn/projects/unite-2018-qian-tan-jia-ma-he-xian-xing-yan-se-kong-jian</a><br><a href="https://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ" target="_blank" rel="noopener">https://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ</a><br><a href="https://zhuanlan.zhihu.com/p/66558476" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66558476</a></p>]]></content>
      
      
      <categories>
          
          <category> CG&amp;Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
