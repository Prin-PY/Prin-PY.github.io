<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【基础】纹理(Texture)知识知多少</title>
      <link href="2020/11/06/Basic-About-Texture/"/>
      <url>2020/11/06/Basic-About-Texture/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><strong>纹理</strong>最初的目的就是使用一张图片来控制模型的外观。使用<strong>纹理映射（texture mapping）</strong>技术，我们可以把一张图“黏”在模型表面，逐<strong>纹素（texel）</strong>（纹素的名字是为了和像素进行区分）地控制模型的颜色。</p><h2 id="UV坐标"><a href="#UV坐标" class="headerlink" title="UV坐标"></a>UV坐标</h2><p><strong>纹理映射坐标（texture-mapping coordinates） / UV坐标：</strong> 存储在每个顶点上，定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个二维变量(u，v)来表示，其中u是横向坐标，而v是纵向坐标。</p><blockquote><p>顶点UV坐标的范围通常都被归一化到[0，1]范围内。<br>在OpenGL里，纹理空间的原点位于左下角，而在DirectX中，原点位于左上角。Unity使用的纹理空间是符合OpenGL的传统的</p></blockquote><h3 id="uv-uv2-uv3-uv4"><a href="#uv-uv2-uv3-uv4" class="headerlink" title="uv, uv2, uv3, uv4"></a>uv, uv2, uv3, uv4</h3><p><img src="./UV.png" alt="Alt text"><br>unity一共支持4套uv，在shader编程中，分别叫UV0, UV1, UV2, UV3，而在c＃编程中分别叫uv, uv2, uv3, uv4。<br>通常来说(使用c# API中的命名)，uv用于主纹理, uv2用于光照贴图(Lightmap)的采样, uv3用于实时动态光照, uv4可进行自定义。<br>uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。如果在建模软件中只做了一套uv，将模型导入unity的时候，在导入设置中勾选Generate Lightmap UVs, unity会自动为我们生成用于光照贴图的uv2。uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p><blockquote><p>3DMax和maya等软件都能对模型加多套uv<br>注意模型在fbx里可以保留多套uv，但是obj里只能保留默认的第一套<br>另外unity里现在貌似支持最多四套</p></blockquote><h3 id="清除不必要的UV通道"><a href="#清除不必要的UV通道" class="headerlink" title="清除不必要的UV通道"></a>清除不必要的UV通道</h3><p>某些时候，因为美术的一些意外操作，会引入多个我们不需要的UV通道。<br>由于unity的光照贴图会自动占用uv2通道，如果你的项目中又使用的是动态加载光照贴图的方式的话，最好不要在导入模型的时候把UV2设置为null，如果你这样做了有可能会导致光照贴图显示不出来的问题。<br>如果物体不需要烘培，你自己也不使用uv2，则可以删除该通道。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除color和uv</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClearModelUV</span>:<span class="title">AssetPostprocessor</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnPostprocessModel</span>(<span class="params">GameObject rImaportModel</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ClearMeshUVAndColorChannel(rImaportModel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ClearMeshUVAndColorChannel</span>(<span class="params">GameObject rImportModel</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">List&lt;Vector2&gt; rNewUV = <span class="literal">null</span>;</span><br><span class="line">List&lt;Color32&gt; rNewColor = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> rFilters= rImportModel.GetComponentsInChildren&lt;MeshFilter&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> filter_index = <span class="number">0</span>; filter_index &lt; rFilters.Length; filter_index++)</span><br><span class="line">&#123;</span><br><span class="line">rFilters[filter_index].sharedMesh.SetColors(rNewColor);</span><br><span class="line">rFilters[filter_index].sharedMesh.SetUVs(<span class="number">1</span>, rNewUV);</span><br><span class="line">rFilters[filter_index].sharedMesh.SetUVs(<span class="number">2</span>, rNewUV);</span><br><span class="line">rFilters[filter_index].sharedMesh.SetUVs(<span class="number">3</span>, rNewUV);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Texture-Type"><a href="#Texture-Type" class="headerlink" title="Texture Type"></a>Texture Type</h3><p>Default 默认的纹理类型，普通的图片<br>Normal map 法线贴图</p><blockquote><p>【关于法线贴图：就是看起来与3D效果无异的2D贴图】<br>游戏场景中譬如雕刻这种3D细节，如果做3D模型的话，就会浪费显示芯片，使游戏性能下降，便会用法线贴图，既不影响玩家体验游戏又不影响游戏性能</p></blockquote><p>Editor GUI and Legacy GUI  GUI编辑器用到的UI贴图<br>Sprite(2D and UI)  图片精灵，主要用于2D游戏中，把一张大的图分割成一张张小图，大的图叫图集atlas,<br>小的图叫精灵sprite,可以通过精灵名字来使用精灵.<br>Cursor 鼠标或者叫光标的贴图<br>Cubemap 立方体的纹理<br>Cookie  遮罩贴图 聚光灯贴图<br>Lightmap 光照或者叫烘焙贴图<br>Advanced 高级(可自定义一些贴图属性)</p><h3 id="Alpha-Source-α通道来源"><a href="#Alpha-Source-α通道来源" class="headerlink" title="Alpha Source (α通道来源)"></a>Alpha Source (α通道来源)</h3><ol><li>None：强制无α通道。</li><li>Input Texture Alpha：使用纹理自带的α通道。</li><li>From Gray Scale：使用纹理RGB通道的均值来生成α通道。</li></ol><h3 id="Alpha-Is-Transparen"><a href="#Alpha-Is-Transparen" class="headerlink" title="Alpha Is Transparen"></a>Alpha Is Transparen</h3><p>当alpha用于透明处理时，我们要勾上该选项，可以防止不透明边缘锯齿现象</p><p>性”alpha is transparency”，原理是在压缩之前对贴图进行颜色放大处理来搞定边缘锯齿问题，这个颜色放大处理等同于ps里的最小值滤镜操作，对图片边缘做强化处理。</p><p>一个坑：（<a href="http://blog.coolcoding.cn/?p=198）" target="_blank" rel="noopener">http://blog.coolcoding.cn/?p=198）</a><br>如果有一张PNG图片, 95%的地方是全透明的,而在全透明的地方,RGB值是有意义的;<br>如果设置了alphaIsTransparency属性,则全透明的地方,Unity会将RGB值全部丢失!!!<br>如果要使用此纹理的4个通道做数据存储时(比如地型的4通道混合)<br>千万不能勾选alphaIsTransparency属性<br>除非此PNG图片仅仅用于UI显示。</p><h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><p>Non Power of 2：NPOT的处理方式。<br>Read/Write Enabled：读写开关，非必要不开启，否则会增加一倍的 内存。<br>Generate Mip Maps：生成Mip Maps，会增加33%的内存。一般用 于模型纹理，UI、天空盒等纹理不需要开启。<br>Border Mip Maps：防止低阶的Mip Map的色彩值溢出边界，一般用 于光照Cookie。<br>Mip Map Filtering：过滤算法，Box和Kaiser。<br>Fadeout Mip Maps：根据层阶使Mip Map慢慢变灰，一般用于细节 贴图（DetailMaps）。</p><h3 id="Wrap-Mode"><a href="#Wrap-Mode" class="headerlink" title="Wrap Mode"></a>Wrap Mode</h3><p>Wrap mode determines how texture is sampled when texture coordinates are outside of the typical 0..1 range.<br>这由纹理的映射函数来决定。在OpenGL中，这类映射函数称为“Texture Wrapping Mode”；在D3D中，称为“Texture Addressing Mode”。</p><h4 id="Repeat-重复"><a href="#Repeat-重复" class="headerlink" title="Repeat   重复"></a>Repeat   重复</h4><p>Tiles the texture, creating a repeating pattern.<br>When UVs are outside of the 0…1 range, the integer part will be ignored, thus creating a repeating pattern.<br>在算法上，忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上。对于大多数复制纹理的使用，在纹理顶部的纹理单元应与底部的纹理单元相匹配，在纹理左侧的纹理单元也应与右侧的纹理单元相匹配。这样才能做到无缝连接。</p><h4 id="Clamp-拉伸"><a href="#Clamp-拉伸" class="headerlink" title="Clamp    拉伸"></a>Clamp    拉伸</h4><p>makes the texture edge pixels be stretched when outside of of 0..1 range.<br>This is useful for preventing wrapping artifacts when mapping an image onto an object and you don’t want the texture to tile. UV coordinates will be clamped to the range 0…1. When UVs are larger than 1 or smaller than 0, the last pixel at the border will be used.<br>将大于1.0的数值设置为1.0，将小于0.0的数值设置为0.0，即将超出[0.0,1.0]范围的数值截取到[0.0,1.0]范围内，这样会导致纹理边缘的重复。</p><h4 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h4><p>Tiles the texture, creating a repeating pattern by mirroring it at every integer boundary.</p><h4 id="Mirror-Once"><a href="#Mirror-Once" class="headerlink" title="Mirror Once"></a>Mirror Once</h4><p>Mirrors the texture once, then clamps to edge pixels.<br>This effectively mirrors the texture around zero UV coordinates, and repeats edge pixel values when outside of [-1..1] range.</p><blockquote><p>This mode is called “mirror and clamp to edge” in graphics APIs like Vulkan, Metal and OpenGL. This feature is not always supported when using OpenGL ES and Vulkan graphics APIs, specifically on ARM and Qualcomm GPUs platforms. Check SystemInfo.supportsTextureWrapMirrorOnce to figure out whether the system is capable..</p></blockquote><h4 id="Per-axis"><a href="#Per-axis" class="headerlink" title="Per-axis"></a>Per-axis</h4><p>Choose this to individually control how Unity wraps Textures at the U axis and V axis.</p><h3 id="Filter-Mode"><a href="#Filter-Mode" class="headerlink" title="Filter Mode"></a>Filter Mode</h3><p>控制纹理通过三维变换拉伸的计算(过滤)方式</p><p>Point：最近点采样，当纹理坐标没有刚好对应Texture上的一个采样点时，它会选择最近的一个采样点作为该坐标的采样值，</p><p>当纹理没有拉伸变形时，这样还不错，因为速度是最快的，但如果拉伸变形了，会出现马赛克现象。</p><p>Bilinear：双线性过滤，以像素对应的纹理坐标为中心，采样它周围4个texel（纹素）的像素，取平均值作为该坐标采样值。这是Unity默认的模式，过渡效果相对平滑，当然速度会比最近点采样有一定下降。会有模糊化现象。</p><p>Trilinear：三线性过滤，会对像素大小和纹素大小最接近的两层Mipmap level分别进行双线性过滤，再对结果进行线性插值。由于使用了两次双线性过滤，也就是计算2x4=8个像素的值，速度会更加下降，当然滤波效果更好。同上也会有模糊化现象。</p><h3 id="Aniso-Level"><a href="#Aniso-Level" class="headerlink" title="Aniso Level"></a>Aniso Level</h3><p>各向异性级别。当以一个过小的角度观察纹理时，此数值越高观察的纹理质量就越高，该参数对于提高地面等纹理的显示效果非常明显。</p><blockquote><p>Default  点了没效果不能重置所有设置，还是得手动选择.废弃的按钮</p></blockquote><h3 id="对不同平台的压缩设置"><a href="#对不同平台的压缩设置" class="headerlink" title="对不同平台的压缩设置"></a>对不同平台的压缩设置</h3><ul><li>Max Size：最大尺寸。</li><li>Compression：压缩质量。</li><li>Format：压缩格式。<br>格化式存储该纹理的类型，纹理的精度越高，占用的内存越大，得到的效果也越好</li><li>Compressed    默认压缩方式,PVRTC图片格式，压缩选项将会针对你的目标平台来选择最合适的压缩算法替换原来的我们给的图片格式(比如我们给的是PNG格式)。<br>  16 bits            无压缩16位格式，比32位节省一半的空间和内存。<br>  Truecolor       无压缩32位以上真彩色,适合对色彩要求较高的情况下使用，比较占空间和内存。</li><li>Compressor Quality：压缩质量</li><li>Use Crunch Compression：紧凑压缩<blockquote><p>Crunched  这种类型将会根据显卡的GPU来选择合适的压缩格式进行压缩然后会选用一种CPU上就能处理的压缩格式再压缩一遍。如果在制作供人下载的资源包的时候这种类型非常的合适。这个类型的压缩需要很长时间，但在运行时解压是非常快的。</p></blockquote></li></ul><h3 id="其他纹理类型设置"><a href="#其他纹理类型设置" class="headerlink" title="其他纹理类型设置"></a>其他纹理类型设置</h3><h3 id="Normal-Map"><a href="#Normal-Map" class="headerlink" title="Normal Map"></a>Normal Map</h3><p>与Default相比增加了一下设置：<br>Create from Grayscale：从灰度高度图（Heightmap）创建。<br>Bumpiness：崎岖度。<br>Filtering：滤波算法。</p><ol><li>Smooth：平滑，标准前向差分算法。 2. Sharp：尖锐，Sobel滤波器。</li></ol><h4 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h4><p>与Default相比增加了一下设置：<br>Sprite Mode：精灵模式。</p><ol><li>Single：单图。</li><li>Multiple：多图。</li><li>Polygon：多边形，在SpriteEditor里使用多边形裁剪精灵。<br>PackingTag：指定图集。<br>PixelsPer Unit：每单位像素数，在世界场景中，每单位距离有多少个 像素。</li></ol><p>Mesh Type：网格类型（Polygon模式无此属性）。</p><ol><li>FullRect：矩形。 2. Tight：紧凑的，根据Alpha通道生成Mesh。（2DObject）<br>ExtrudeEdge：拉伸边缘。</li></ol><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie类型的纹理设置<br>与Default相比增加了一下设置：<br>Light Type：光照类型。</p><ol><li>Spotlight：聚光灯，形状必须为2D。</li><li>Directional：平行光，形状必须为2D。</li><li>Point：点光源，形状必须为立方体。</li></ol><h2 id="Sprite及图集的使用"><a href="#Sprite及图集的使用" class="headerlink" title="Sprite及图集的使用"></a>Sprite及图集的使用</h2><blockquote><p>只有Sprite模式的图片才可以打包成图集</p></blockquote><p>旧版：<br>Sprite Mode 设置为 Muitiple 设置Packing Tag<br>Window-&gt;Sprite Packer –&gt;点击 Pack 即可</p><p>新版：<br>Project Setting -&gt; Editor  -&gt; Sprite Packer -&gt; Mode = Always Enabled<br>新建 Sprite Atlas<br>选择打包图集的文件夹或者依次添加单独图片，点击Pack Preview后自动打包成一个图集</p><p>代码获取图集并动态选择Sprite：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.U2D;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpriteAtlasExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SpriteAtlas atlas = AssetDatabase.LoadAssetAtPath&lt;SpriteAtlas&gt;(<span class="string">"Assets/TestAtlas.spriteatlas"</span>);</span><br><span class="line">        Sprite sprite = atlas.GetSprite(<span class="string">"Icon2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (sprite != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetComponent&lt;Image&gt;().sprite = sprite;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="压缩格式相关"><a href="#压缩格式相关" class="headerlink" title="压缩格式相关"></a>压缩格式相关</h2><h3 id="图像文件格式"><a href="#图像文件格式" class="headerlink" title="图像文件格式"></a>图像文件格式</h3><p>文件格式是图像为了存储信息而使用的对信息的特殊编码方式，它存储在磁盘中，或者内存中，但是并不能被GPU所识别，因为以向量计算见长的GPU对于这些 复杂的计算无能为力。这些文件格式当被游戏读入后，还是需要经过CPU转换成图形硬件支持的格式，再传送到GPU端进行使用。<br>常用的图片格式及特点如下：</p><ul><li>JPG 有损压缩 文件小 不支持透明</li><li>PNG 无损压缩 文件小 支持透明</li><li>TAG 无损压缩 文件大 支持透明</li><li>DDS 无损压缩 文件最小 支持透明</li></ul><p>不同格式的本质区别在于压缩算法不一样，结果图片大小，还原度也各不相同。</p><blockquote><p>TIFF（Tag Image File Format）文件是由Aldus和Microsoft公司为扫描仪和桌上出版系统研制开发的一种较为通用的图像文件格式。TIFF格式灵活易变，同时定义了四类不同的格式：TIFF－B适用于二值图像；TIFF－G适用黑白灰度图像；TIFF－P适用于带调色板的彩色图像；TIFF－R适用于RGB真彩图像。TIFF支持多种编码方法，其中包括RGB无损压缩、RLE压缩以及JPEG压缩等。</p><p>GIF（Graphics Interchange Format ）是CompuServe公司在1987年开发的图像文件格式。GIF文件的数据是经过压缩的，它采用了可变长度的压缩算法。GIF的图像深度从1 bit到8 bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。</p></blockquote><h3 id="3D-图形硬件支持的压缩格式"><a href="#3D-图形硬件支持的压缩格式" class="headerlink" title="3D 图形硬件支持的压缩格式"></a>3D 图形硬件支持的压缩格式</h3><p>JPG, PNG, PSD are  not used <strong>during realtime rendering by 3D graphics hardware</strong>  such as a graphics card or mobile device. 3D graphics hardware requires Textures to be compressed in specialized formats which are <strong>optimised for fast Texture sampling</strong> . The various different platforms and devices available each have their own different proprietary formats.</p><p>By default, the Unity Editor automatically converts Textures to the most appropriate format to match the build target you have selected. Only the converted Textures are included in your build; your source Asset<br> files are left in their original format, in your project’s Assets folder.</p><blockquote><p>如果发现GPU不支持当前压缩格式，Unity就会将纹理转换成RGB（A），首先是解压过程的消耗，其次是内存中会保存两个纹理。</p></blockquote><h4 id="简单纹理格式"><a href="#简单纹理格式" class="headerlink" title="简单纹理格式"></a>简单纹理格式</h4><p>RGBA8888 每个像素4字节，RGBA通道各占用8位<br>RGBA4444 每个像素2字节，RGBA通道各占用4位<br>RGB888 每个像素3字节，RGB通道各占用8位，无透明通道<br>RGB565 每个像素2字节，RGB通道各占用5/6/5位，无透明通道<br>RGBA5551 每个像素2字节，RGB通道各占用5位，透明通道1位，所以要么完全透明要么不透明</p><blockquote><p>所有设备对RGB 16BITS/ARGB 16BITS/RGB A16BITS/RGB 24BITS/ARGB 32BITS等支持都很好，只是这些格式算是非压缩格式，对内存消耗和渲染消耗非常不友好。</p></blockquote><h4 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h4><ul><li>DXT - 有损压缩方式</li><li>ETC - （Ericsson Texture Compression），在移动平台中广泛采用。它是一种为感知质量设计的有损算法，其依据是人眼对亮度改变的反应要高于色度改变。<ul><li>ETC1：安卓原生支持，在各种Android设备上非透明纹理都可以采用ETC1格式。ETC1不支持透明，对于透明纹理，在Android设备上，可以把RGB和Alpha拆到2张ETC1纹理上，游戏中再合成使用。</li><li>ETC2是ETC1的扩张，向后兼容ETC1，对RGB的压缩质量更好，并且支持透明通道。ETC2比ETC1压缩质量更高，而且支持透明，在Android设备上再也不需要打不同纹理格式的包了。不过需要OpenGL ES 3.0以上才可以，目前很多设备只支持OpenGL ES 2.0。</li></ul></li><li>PVRTC（PowerVR Texture Compression） - 压缩比高，也是有损压缩。iOS只支持PVRTC的压缩格式。</li></ul><p>关于压缩后的在储存上的大小，假设高清(ARGB32)大小为1，那么大概数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RGB PVRTC 4BITS:0.25</span><br><span class="line">ARGB PVRTC 4BITS:0.25</span><br><span class="line">RGB PVRTC 2BITS:0.13</span><br><span class="line">ARGB PVRTC 2BITS:0.13</span><br><span class="line">RGBA ETC2 4BITS:0.25</span><br><span class="line">RGBA ETC2 8BITS:0.25</span><br><span class="line">RGB + 1-bit ALPHA ETC2 8BITS:0.2</span><br><span class="line">DXT1 :0.3</span><br><span class="line">DXT5 : 0.6</span><br><span class="line">ARGB 16BITS:0.33</span><br><span class="line">RGB 16BITS:0.5</span><br><span class="line">RGB 24BITS:0.85</span><br><span class="line">ARGB 32BITS:1</span><br></pre></td></tr></table></figure><br>内存中的大小，假设高清(ARGB32)大小为1，那么大概数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RGB PVRTC 2BITS:0.0625</span><br><span class="line">ARGB PVRTC 2BITS:0.0625</span><br><span class="line">RGB PVRTC 4BITS:0.125</span><br><span class="line">ARGB PVRTC 4BITS:0.125</span><br><span class="line">RGBA ETC2 4BITS:0.125</span><br><span class="line">RGBA ETC2 8BITS:0.25</span><br><span class="line">RGB + 1-bit ALPHA ETC2 8BITS:0.125</span><br><span class="line">DXT1 : 0.125</span><br><span class="line">DXT5 : 0.25</span><br><span class="line">ARGB 16BITS:0.5</span><br><span class="line">RGB 16BITS:0.5</span><br><span class="line">RGB 24BITS:0.8</span><br><span class="line">ARGB 32BITS:1</span><br></pre></td></tr></table></figure></p><h4 id="格式选择"><a href="#格式选择" class="headerlink" title="格式选择"></a>格式选择</h4><p>一般方案：ETC1+Alpha/PVRTC4 和 RGB16/RGBA16 搭配使用。</p><hr><h5 id="高清无压缩"><a href="#高清无压缩" class="headerlink" title="高清无压缩"></a>高清无压缩</h5><p>RGBA32 （等同于原图了，效果最好，效率最差。）</p><hr><h5 id="中清晰中压缩"><a href="#中清晰中压缩" class="headerlink" title="中清晰中压缩"></a>中清晰中压缩</h5><ul><li>不透明贴图 ：RGB 16BITS</li><li>透明贴图：RGBA 16BITS + Dithering<blockquote><p>RGBA16在遇到渐变的时候表现很差，可能需要做抖动（Dithering）处理。<br>16位压缩会带来颜色损失，但如果本来美术就是按16BITS画的话，就不会损失，日本好些手游都是按16BITS来画的。这样的游戏一般少渐变艳度高比较容易看出来。</p></blockquote></li></ul><hr><h5 id="低清晰高压缩"><a href="#低清晰高压缩" class="headerlink" title="低清晰高压缩"></a>低清晰高压缩</h5><p>ETC1+Alpha/PVRTC4（能直接被GPU使用，占用少，效率高。）</p><p>IOS下</p><ul><li>普通不透明：RGB PVRTC 4BITS</li><li>普通透明：RGBA PVRTC 4BITS</li></ul><blockquote><p>PVRTC 要求方形的图集贴图<br>非方形的贴图会被转成16位RGB(A)的压缩格式。</p></blockquote><p>Android下：</p><ul><li>普通不透明：RGB ETC 4BITS</li><li>普通透明：<ul><li>RGBA 16BIT</li><li>有针对性的选择DXT5/ATC8 BITS/ETC2 8BITS</li><li>如果有技术支持，可以采用RGB ETC 4BITS加一张ALPHA 8的贴图来实现透明效果。</li></ul></li></ul><p><strong>对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16</strong></p><blockquote><p>Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；<br>iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。<br>另外，针对Android 上的带Alpha通道的图片，还有一种常见的做法，即把Alpha通道独立出来作为另一张纹理，从而将 RGB 部分和 Alpha 部分分别采用 ETC1来压缩，但渲染时就需要自定义的 Shader来处理。</p></blockquote><p>windows：<br>使用Compressed格式。会压缩为DXT5（带透明通道），DXT1 格式。</p><h4 id="关于POT-Power-Of-Two"><a href="#关于POT-Power-Of-Two" class="headerlink" title="关于POT(Power Of Two)"></a>关于POT(Power Of Two)</h4><p>Only textures with width/height being multiple of 4 can be compressed to ETC1 format.（ 只有宽/高的尺寸是4的倍数才能被压缩成ETC1格式。)<br>Only POT textures can be compressed to ETC1 format. ( 只有POT(Power of two,2的幂次方)的贴图才能被压缩成ETC1格式。)</p><p>如果纹理的原始尺寸不是2的幂次方的话，则可在Unity中可以通过导入设置来进行更正。<br><img src="./1604336979482.png" alt="Alt text"></p><ul><li>None不做处理</li><li>ToNearest（选择最接近的幂次方）</li><li>ToLarger（选择最大尺寸的幂次方）</li><li>ToSmaller（选择最小尺寸的幂次方）</li></ul><p>以一张513x1023尺寸的图片来举例：</p><ul><li>None：513x1023</li><li>ToNearest：512x1024</li><li>ToLarger：1024x1024</li><li>ToSmaller：512x512</li></ul><h2 id="实用的小工具"><a href="#实用的小工具" class="headerlink" title="实用的小工具"></a>实用的小工具</h2><h3 id="Texture转换成Texture2D"><a href="#Texture转换成Texture2D" class="headerlink" title="Texture转换成Texture2D"></a>Texture转换成Texture2D</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Texture转换成Texture2D...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="texture"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">Texture2D <span class="title">TextureToTexture2D</span>(<span class="params">Texture texture</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Texture2D texture2D = <span class="keyword">new</span> Texture2D(texture.width, texture.height, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    RenderTexture currentRT = RenderTexture.active;</span><br><span class="line"></span><br><span class="line">    RenderTexture renderTexture = RenderTexture.GetTemporary(texture.width, texture.height, <span class="number">32</span>);</span><br><span class="line">    Graphics.Blit(texture, renderTexture);</span><br><span class="line"></span><br><span class="line">    RenderTexture.active = renderTexture;</span><br><span class="line">    texture2D.ReadPixels(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, renderTexture.width, renderTexture.height), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    texture2D.Apply();</span><br><span class="line"></span><br><span class="line">    RenderTexture.active = currentRT;</span><br><span class="line">    RenderTexture.ReleaseTemporary(renderTexture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> texture2D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Texture2D形式截图"><a href="#Texture2D形式截图" class="headerlink" title="Texture2D形式截图"></a>Texture2D形式截图</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 截图...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="rect"&gt;</span>截图的区域<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">Texture2D <span class="title">CaptureScreenshot</span>(<span class="params">Rect rect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先创建一个的空纹理，大小可根据实现需要来设置</span></span><br><span class="line">Texture2D screenShot = <span class="keyword">new</span> Texture2D((<span class="keyword">int</span>)rect.width, (<span class="keyword">int</span>)rect.height, TextureFormat.RGB24,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取屏幕像素信息并存储为纹理数据，</span></span><br><span class="line">screenShot.ReadPixels(rect, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">screenShot.Apply();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将这些纹理数据，成一个png图片文件</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = screenShot.EncodeToPNG();</span><br><span class="line"><span class="keyword">string</span> filename = Application.dataPath + <span class="string">"/Screenshot.png"</span>;</span><br><span class="line">System.IO.File.WriteAllBytes(filename, bytes);</span><br><span class="line">Debug.Log(<span class="keyword">string</span>.Format(<span class="string">"截屏了一张图片: &#123;0&#125;"</span>, filename));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，我返回这个Texture2d对象，这样我们直接，所这个截图图示在游戏中，当然这个根据自己的需求的。</span></span><br><span class="line"><span class="keyword">return</span> screenShot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Texture保存到本地"><a href="#Texture保存到本地" class="headerlink" title="Texture保存到本地"></a>Texture保存到本地</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将Texture转为本地PNG...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filePath"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="teture"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">saveMainTextureToPng</span>(<span class="params"><span class="keyword">string</span> filePath, Texture teture</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (teture.GetType() != <span class="keyword">typeof</span>(Texture2D))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Texture2D savedTexture = (Texture2D)teture;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Texture2D newTexture = <span class="keyword">new</span> Texture2D(savedTexture.width, savedTexture.height, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">        newTexture.SetPixels(<span class="number">0</span>, <span class="number">0</span>, savedTexture.width, savedTexture.height, savedTexture.GetPixels());</span><br><span class="line">        newTexture.Apply();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = newTexture.EncodeToPNG();</span><br><span class="line">        <span class="keyword">if</span> (bytes != <span class="literal">null</span> &amp;&amp; bytes.Length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (File.Exists(filePath))</span><br><span class="line">            &#123;</span><br><span class="line">                File.Delete(filePath);</span><br><span class="line">            &#125;</span><br><span class="line">            System.IO.File.WriteAllBytes(filePath, bytes);                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将图片转换为byte数组"><a href="#将图片转换为byte数组" class="headerlink" title="将图片转换为byte数组"></a>将图片转换为byte数组</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 将图片转换为byte数组...</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filePath"&gt;</span>图片路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">ReadTexture</span>(<span class="params"><span class="keyword">string</span> filePath</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      FileStream fileStream = <span class="keyword">new</span> FileStream(filePath, FileMode.Open, System.IO.FileAccess.Read);</span><br><span class="line">      fileStream.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line"><span class="comment">//创建byte数组 ...  </span></span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[fileStream.Length];  </span><br><span class="line">      fileStream.Read(buffer, <span class="number">0</span>, (<span class="keyword">int</span>)fileStream.Length);</span><br><span class="line"></span><br><span class="line">      fileStream.Close();</span><br><span class="line">      fileStream.Dispose();</span><br><span class="line">      fileStream = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h2><p><a href="https://www.cnblogs.com/suogasus/p/5311264.html" target="_blank" rel="noopener">https://www.cnblogs.com/suogasus/p/5311264.html</a></p><p>Alpha通道是计算机图形学中的术语，指的是特别的通道，意思是“非彩色”通道，主要是用来保存选区和编辑选区</p><ul><li>Alpha 没有透明度的意思，不代表透明度。opacity 和 transparency 才和透明度有关，前者是不透明度，后者是透明度。比如 css 中的「opacity: 0.5」就是设定元素有 50% 的不透明度。</li><li>一个图像的每个像素都有 RGB 三个通道，后来 Alvy Ray Smith 提出每个像素再增加一个 Alpha 通道，取值为0到1，用来储存这个像素是否对图片有「贡献」，0代表透明、1代表不透明。也就是说，「Alpha 通道」储存一个值，其外在表现是「透明度」，Alpha 和透明度没啥关系。</li><li>为什么取名为 Alpha 通道，我觉得是因为这是除RGB以外「第一个通道」的意思，没有别的更深刻的含义。</li><li>Alpha 通道」是图片内在的一个属性，用 css 或者其他外部方法设定透明度，并没有改变图片的 Alpha 通道的值。</li></ul><p>真正让图片变透明的不是Alpha 实际是Alpha所代表的数值和其他数值做了一次运算<br>比如你有一张图片你想抠出图片中间的一部分 在PS里你会建立一个蒙板 然后在蒙板里把不需要的地方填充成黑色 需要的留成白色 这个时候实际上是是做了一次乘法<br>用黑色所代表的数值0去乘以你所填充的地方 那么这个地方就变透明了</p><p>设Alpha值[0，255]区间映射为[0，1]区间相对应的值表示，即Alpha值为0—1之间的数值。则图形文件中各个像素点可表示为：<br>Graphx（Redx，Greenx，Bulex，Alphax）<br>屏幕上相应像素点的显示值就转换为：<br>Dispx（Redx<em>Alphax，Greenx</em>Alphax，Bluex*Alphax）</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>Alpha通道<br>颜色通道<br>复合通道<br>专色通道<br>矢量通道</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>《Unity Shader入门精要》 冯乐乐<br><a href="https://zhuanlan.zhihu.com/p/126752791" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126752791</a><br><a href="https://www.jianshu.com/p/bec1a7514b08" target="_blank" rel="noopener">https://www.jianshu.com/p/bec1a7514b08</a><br><a href="https://blog.csdn.net/ynnmnm/article/details/44983545" target="_blank" rel="noopener">https://blog.csdn.net/ynnmnm/article/details/44983545</a><br><a href="https://www.jianshu.com/p/832e242523a4" target="_blank" rel="noopener">https://www.jianshu.com/p/832e242523a4</a><br><a href="https://blog.csdn.net/skymanwu/article/details/295121" target="_blank" rel="noopener">https://blog.csdn.net/skymanwu/article/details/295121</a><br><a href="https://blog.csdn.net/qq_29266497/article/details/81515326" target="_blank" rel="noopener">https://blog.csdn.net/qq_29266497/article/details/81515326</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Texture </tag>
            
            <tag> Asset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渲染】纹理滤波(Texture Filtering)相关知识整理</title>
      <link href="2020/10/28/CG-About-Texture-Filtering/"/>
      <url>2020/10/28/CG-About-Texture-Filtering/</url>
      
        <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="纹理映射-与-纹理采样"><a href="#纹理映射-与-纹理采样" class="headerlink" title="纹理映射 与 纹理采样"></a>纹理映射 与 纹理采样</h3><p>纹理映射：使用uv坐标将纹理像素(texel)映射到屏幕像素(pixel)的过程。</p><p>纹理采样（Texture Sample）：既然纹理是一张图片，那么自然就有分辨率的存在，纹理采样便是从纹理图片中采集一个像素颜色的操作。</p><h3 id="插值-Interpolation-的概念"><a href="#插值-Interpolation-的概念" class="headerlink" title="插值(Interpolation)的概念"></a>插值(Interpolation)的概念</h3><p>在数学的数值分析领域中，内插或称插值（英语：interpolation）是一种通过已知的、离散的数据点，在范围内推求新数据点的过程或方法。求解科学和工程的问题时，通常有许多数据点借由采样、实验等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。而根据这些数据，我们往往希望得到一个连续的函数（也就是曲线）；或者更密集的离散方程与已知数据互相吻合，这个过程叫做拟合。</p><p>常用的插值方法有：最近邻插值（Nearest-neighbor interpolation）、线性插值（线性插值）、多项式插值（Polynomial interpolation）、样条曲线插值（Spline interpolation）等。</p><p>高维度空间的计算中，需要用到多元插值（Multivariate interpolation）。方法有：</p><ul><li>双线性插值(bilinear interpolation) 和 双三次插值(bicubic interpolation) in two dimensions</li><li>trilinear interpolation in three dimensions.</li></ul><h4 id="线性插值-Linear-interpolation"><a href="#线性插值-Linear-interpolation" class="headerlink" title="线性插值(Linear interpolation)"></a>线性插值(Linear interpolation)</h4><p>In mathematics, linear interpolation is a method of curve fitting using linear polynomials to construct new data points within the range of a discrete set of known data points.<br><img src="./1603809936492.png" alt="Alt text"></p><h2 id="纹理滤波（Texture-Filtering）"><a href="#纹理滤波（Texture-Filtering）" class="headerlink" title="纹理滤波（Texture Filtering）"></a>纹理滤波（Texture Filtering）</h2><p><strong>纹理滤波（Texture Filtering）</strong>又称为<strong>纹理平滑（texture smoothing ）</strong> - the method used to determine the texture color for a texture mapped pixel, using the colors of nearby texels (pixels of the texture).</p><blockquote><p>当三维空间里面的多边形经过坐标变换、投影、光栅化等过程，变成二维屏幕上的一组象素的时候，对每个象素需要到相应纹理图像中进行采样，<strong>纹理过滤</strong>或者说<strong>纹理平滑</strong>是在纹理采样中使采样结果更加合理，以减少各种人为产生的穿帮现象的技术。</p></blockquote><p>纹理滤波主要分为两类：</p><ul><li><p><strong>放大过滤（magnification filtering）</strong>: reconstruction filter where sparse data is interpolated to fill gaps. （填充缺口）。一个纹理单元对应着多个像素。需要进行插值，平滑，防止马赛克现象。</p></li><li><p><strong>缩小过滤（minification filtering）</strong>: anti-aliasing (AA), where texture samples exist at a higher frequency than required for the sample frequency needed for texture fill. （抗锯齿）。一个像素对应着多个纹理单元。</p></li></ul><blockquote><p>There are many methods of texture filtering, which make different trade-offs between computational complexity, memory bandwidth and image quality.</p></blockquote><h3 id="为什么需要纹理滤波"><a href="#为什么需要纹理滤波" class="headerlink" title="为什么需要纹理滤波"></a>为什么需要纹理滤波</h3><p>对于任意的3D表面在纹理映射过程中，需要进行纹理查找来找到屏幕上的一个像素对应于纹理上的哪个位置，而在纹理采样过程中，可能出现如下问题：</p><ol><li>三维图形上的pixel中心和纹理上的texel中心并不一至。屏幕上像素的纹理映射坐标可能不会完美地落到像素格上。</li><li>取决于观察者，textured surface可能在任意的距离和方向，一个像素（pixel）通常不会直接对应一个纹素（texel），可能一个像素被映射到许多纹理像素，或者许多个像素都映射到相同纹素。<br>因此，需要执行一些形式的滤波来决定屏幕像素的最佳颜色。滤波不足或不正确将在图像中表现为伪像（图像中的错误），例如“块状”，锯齿状或闪烁。</li></ol><hr><ul><li><p>纹理放大(Texture Magnification)：the texels are larger than screen pixels, and need to be scaled up appropriately - a process known as texture magnification.<br>当最后呈现到屏幕中的尺寸比纹理实际尺寸大的时候，许多个像素都映射到同一纹素。纹理放大如果不进行过滤，会造成马赛克现象。此时需要对纹理进行放大过滤（magnification filtering），使用插值方法，进行平滑。</p></li><li><p>纹理缩小(Texture Minification)：each texel is smaller than a pixel, and so one pixel covers multiple texels. In this case an appropriate color has to be picked based on the covered texels, via texture minification.<br>当最后呈现到屏幕中的尺寸比纹理实际尺寸小的时候，一个像素被映射到许多纹理像素上。此时需要对纹理进行缩小过滤（minification filtering）。纹理缩小会由于精度损失造成贴图的扭曲。</p></li></ul><p>如图所示，过度的纹理缩小会造成高频走样问题，贴图出现扭曲（波纹）。<br><img src="./1605006132395.png" alt="Alt text"></p><h3 id="为什么称为滤波-Filter"><a href="#为什么称为滤波-Filter" class="headerlink" title="为什么称为滤波(Filter)"></a>为什么称为滤波(Filter)</h3><p><strong>图像其实是一种波，可以用波的算法处理图像</strong></p><h4 id="图像是波"><a href="#图像是波" class="headerlink" title="图像是波"></a>图像是波</h4><p>每个像素的颜色，可以用红、绿、蓝、透明度四个值描述，大小范围都是0 ～ 255，比如黑色是[0, 0, 0, 255]，白色是[255, 255, 255, 255]。<br><img src="./bg2017121302.png" alt="Alt text"><br>每条曲线都在不停的上下波动。有些区域的波动比较小，有些区域突然出现了大幅波动（比如 54 和 324 这两点）。曲线波动较大的地方，也是图像出现突变的地方。这说明波动与图像是紧密关联的。图像本质上就是各种色彩波的叠加。</p><h4 id="频率（frequency）"><a href="#频率（frequency）" class="headerlink" title="频率（frequency）"></a>频率（frequency）</h4><p>图像就是色彩的波动：波动大，就是色彩急剧变化；波动小，就是色彩平滑过渡。因此，波的各种指标可以用来描述图像。<br>频率（frequency）是波动快慢的指标，单位时间内波动次数越多，频率越高，反之越低。<br><strong>色彩剧烈变化的地方，就是图像的高频区域；色彩稳定平滑的地方，就是低频区域。</strong></p><h4 id="滤波器（filter）及在图像中的应用"><a href="#滤波器（filter）及在图像中的应用" class="headerlink" title="滤波器（filter）及在图像中的应用"></a>滤波器（filter）及在图像中的应用</h4><p>物理学对波的研究已经非常深入，提出了很多处理波的方法，其中就有滤波器（filter）：过滤掉某些波，保留另一些波。物理中两种常见的滤波器：</p><ul><li>低通滤波器（lowpass）：减弱或阻隔高频信号，保留低频信号</li><li>高通滤波器（highpass）：减弱或阻隔低频信号，保留高频信号</li></ul><p>应用在图像中：<br><strong>lowpass</strong>使得图像的高频区域变成低频，即色彩变化剧烈的区域变得平滑，也就是出现<strong>模糊效果</strong>。<br><img src="./1603787295513.png" alt="Alt text"></p><p><strong>highpass</strong>正好相反，过滤了低频，只保留那些变化最快速最剧烈的区域，也就是图像里面的物体边缘，所以常用于<strong>边缘识别</strong>。<br><img src="./1603787306380.png" alt="Alt text"></p><h3 id="Mipmapping"><a href="#Mipmapping" class="headerlink" title="Mipmapping"></a>Mipmapping</h3><p>Mipmapping is a standard technique used to <strong>save some of the filtering work</strong> needed during <strong>texture minification</strong>.<br>为了加快渲染速度和减少纹理锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为Mipmap。</p><h4 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h4><p>背景：Textured objects can be viewed at different distances from the viewpoint</p><p>Problem：Which level of detail (Resolution) should one use for the texture image?</p><ul><li>Too high resolution: Aliasing effects</li><li>Too small resolution: Too few details visible</li></ul><p>Solution: Use different levels of detail according to the distance between object and viewpoint → <strong>mipmaps</strong></p><blockquote><p>名称由来：mip = “multum in parvo”，拉丁语。</p></blockquote><p>在纹理缩小过程中，被贴上纹理的多边形距离很远时，纹理的多个纹素可能只落在一个屏幕像素中。需要读取多个纹素并通过合并他们的值的方式来决定屏幕像素的颜色，这样计算开销很大。Mipmapping会对纹理进行预过滤，并以较小的分辨率进行存储，从而避免运行时进行如此计算的开销。</p><blockquote><p>在3D场景中，由于距离问题，物体的纹理需要经常被缩放、拉伸，使用Mipmap会减小运行过程中的计算量，提升GPU效率。而在UI中，一般不需要繁缩放图片（特殊需求除外），因此不建议开启Mipmap，否则会造成内存浪费。</p></blockquote><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>Solves LOD problem by generating a pyramid of textures：</p><ul><li>Highest texture resolution at pyramid level 0</li><li>Halfed Resolution at each subsequent level</li></ul><p>预先生成一系列以2为倍数缩小（长宽）的纹理序列，在采样纹理时根据图形的大小自动选择相近等级的Mipmap进行采样。</p><blockquote><p>As the textured surface moves farther away, the texture being applied switches to the prefiltered smaller size. Different sizes of the mipmap are referred to as ‘levels’, with Level 0 being the largest size (used closest to the viewer), and increasing levels used at increasing distances.</p></blockquote><p>所需空间：(1 + 1/3) times the space<br><img src="./MemoryOfMipmap.png" alt="Alt text"></p><p>OpenGL automatically determines the mipmap level to use based on the projected size of the object.</p><blockquote><p>Mipmap通过下采样（downsampling）原始纹理生成。具体算法有：Nearest Neighbour, Boxfilter, Gaussian filter等</p></blockquote><h4 id="如何选择Mipmap-Level"><a href="#如何选择Mipmap-Level" class="headerlink" title="如何选择Mipmap Level"></a>如何选择Mipmap Level</h4><p>像素着色器是以像素为单位运行的，采样时该如何得知图形的大小呢？<br>现在的GPU在光栅化后不是逐像素单个渲染，而是分成2x2=4个的像素分块，每个线程处理4个。之所以这样处理是为了保存像素的偏导数信息，在计算mipmap等级和面法线等时候很有用。OpenGL提供了（唯一）一组获取相邻像素信息的函数——偏导函数dFdx和dFdy。偏导数代表了函数在某一方向的变化率，那么如果相邻两个像素间纹理坐标变化很大，则说明绘制的图形很小。<br>如下，计算出纹理坐标在纵向和横向的偏导数（并取最大值）来计算Mipmap级别：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MipmapLevel</span><span class="params">(vec2 texCoord)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The OpenGL Graphics System: A Specification 4.2</span></span><br><span class="line">    <span class="comment">//  - chapter 3.9.11, equation 3.21</span></span><br><span class="line">    vec2 dx = dFdx(texCoord);</span><br><span class="line">    vec2 dy = dFdy(texCoord);</span><br><span class="line">    <span class="keyword">float</span> delta = max(dot(dx, dx), dot(dy, dy));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * log2(delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MipmapLOD计算详解可见：<a href="http://warmcat.org/chai/blog/?p=1183" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1183</a></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>Mipmap除了能消除采样率过低带来的失真问题，还有一个重要的优点是<strong>节约显存带宽</strong>，注意是带宽而不是容量。Mipmap实际消耗的显存大约增加了1/3，但每次仅从需要的mipmap级别进行读取，而不必每次都访问原始大小的纹理，因此可以节约带宽。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>Mipmap贴图文件占用更多硬盘空间     — 解决方法：使用dds进行压缩存储</li><li>Mipmap纹理占用更多内存、显存空间</li></ol><h2 id="常用滤波方法（插值算法）"><a href="#常用滤波方法（插值算法）" class="headerlink" title="常用滤波方法（插值算法）"></a>常用滤波方法（插值算法）</h2><p>不同的过滤模式，计算复杂度不一样，会得到不同的效果。</p><h3 id="最近邻插值采样-Nearest-neighbor-interpolation"><a href="#最近邻插值采样-Nearest-neighbor-interpolation" class="headerlink" title="最近邻插值采样(Nearest-neighbor interpolation)"></a>最近邻插值采样(Nearest-neighbor interpolation)</h3><blockquote><p>OpenGL中对应的滤波方式为GL_NEAREST，Unity中对应的为Point。<br>Unity官方文档描述: Point 单点插值，纹理将变得块状化（blocky up close）</p></blockquote><p><strong>Nearest-neighbor interpolation</strong> (also known as <strong>proximal interpolation</strong> or, <strong>point sampling</strong>)<br>临近返回采样点所落在的像素内，即中心距离采样点曼哈顿距离最近的texel。</p><p>The nearest neighbor algorithm selects the value of the nearest point and does not consider the values of neighboring points at all, yielding a piecewise-constant interpolant.</p><p><img src="./1603790161075.png" alt="Alt text"></p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>临近采样的结果始终是纹理中的颜色，在做一些像素风格游戏的时候采用临近。临近通常带来锋利的结果（不是锯齿），颜色之间没有过渡。</p><p>当纹理的大小与贴图的三维图形的大小差不多时，这种方法非常有效和快捷。</p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><h5 id="块状（blocky-）"><a href="#块状（blocky-）" class="headerlink" title="块状（blocky ）"></a>块状（blocky ）</h5><p>不同的UV可能会得到相同的颜色，在放大观察时(Magify状态)会有明显色块(马赛克）。当一个texel对应多个pixel时，所有落在这个texel的pixel都会得到同样的颜色值，在屏幕上就会产生明显的像素锯齿，如果是3D游戏的话，就会显得很假。</p><blockquote><p>双线性插值解决了texel magnify时像素锯齿的问题，能根据采样点得到不同的颜色值，增加像素细节，只要不是一个uv，就会根据插值得到不同的结果。</p></blockquote><h5 id="高频走样（波纹和闪烁现象）"><a href="#高频走样（波纹和闪烁现象）" class="headerlink" title="高频走样（波纹和闪烁现象）"></a>高频走样（波纹和闪烁现象）</h5><p>当minify时，一个pixel”覆盖”多个texel，相邻的两个pixel取的texel太远，在纹理图上可能是两个完全不相邻、完全没有关系的像素。对于高频图像，大量信息被压缩在相对比较小的空间中，则像素变化微小时，色彩变化会剧烈，这个问题在物理上叫做高频走样。在绘制地板和远处物体时会由于这个原因，导致<strong>波纹（扭曲）和闪烁（sparkling）</strong>。</p><p>在看向地板远端的时候，会发现采样的结果并不连续，而是扭曲的波纹，移动摄像机后，会出现闪烁的问题，看起来非常糟糕。这是由于纹理在远处采样时pixel和它相邻的pixel跨越的texel太长，使在纹理中不相邻的两个texel（或者它们双线性插值的结果）被绘制在了一起。</p><ul><li>波纹是由于屏幕像素有限，原本不相邻的像素被绘制在一起导致的</li><li>闪烁是由于图像的高频，采样的低频，轻微偏移就会产生巨大变化导致的。</li></ul><h5 id="性能上"><a href="#性能上" class="headerlink" title="性能上"></a>性能上</h5><p>放大的情况下非常快，但是在缩小时开销却极高，因为屏幕上相邻的像素点，可能对应于纹理上距离很远的两个点，而这会破坏纹理采样时的内存连续性，导致L1或者L2缓存的命中率极低，使得纹理采样性能大大降低。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="./1603854909317.png" alt="Alt text"><br>如图所示，近处纹理放大过滤，造成了明显的马赛克现象。远处出现闪烁。</p><h3 id="最近点插值-mipmap的方式"><a href="#最近点插值-mipmap的方式" class="headerlink" title="最近点插值+mipmap的方式"></a>最近点插值+mipmap的方式</h3><p>这种方式在最近点插值的基础上，引入了mipmap，当距离相机很近时，使用miplevel0，此时和最近点插值完全一样。当距离下相机很远时，使用更高的miplevel等级，此时使用最近点插值采样更小尺寸的纹理。因此可以缓解缩小时的闪烁和锯齿现象，并且能够充分利用纹理采样时的内存连续性，使得纹理采样性能提高。但是在纹理放大时，不能解决产生的色块现象。<br><img src="./1603855058444.png" alt="Alt text"><br>加了mipmap之后可以看到噪点消失，但是远处纹理明显模糊，而且不同mipmap过渡处有明显分界，而近处的纹理仍然有色块现象。</p><h3 id="双线性插值-Bilinear-interpolation"><a href="#双线性插值-Bilinear-interpolation" class="headerlink" title="双线性插值 (Bilinear interpolation)"></a>双线性插值 (Bilinear interpolation)</h3><blockquote><p>OpenGL对应的设置为GL_LINEAR，unity对应的设置为bilinear。<br>Unity 官方文档描述：Bilinear 双线性插值，纹理将变得模糊（blurry up close）；</p></blockquote><p><strong>Bilinear interpolation</strong> is also called <strong>bilinear filtering</strong> or <strong>bilinear texture mapping</strong>.<br>在数学上，双线性插值是对线性插值在二维直角网格上的扩展<br>Bilinear interpolation is performed using linear interpolation first in one direction, and then again in the other direction. Although each step is linear in the sampled values and in the position, the interpolation as a whole is not linear but rather quadratic in the sample location.<br>首先在 X 轴方向插值两次，对得到的两个插值结果再在 Y 轴方向上进行一次插值。</p><p><img src="./1603810157411.png" alt="Alt text"></p><p><img src="./1603857020919.png" alt="Alt text"></p><p><img src="./1603857053404.png" alt="Alt text"><br>图像的双线性插值放大算法中，目标图像中新创造的象素值，是由源图像位置在它附近的2*2区域4个邻近象素的值通过加权平均计算得出的。</p><p>双线性过滤对于锯齿问题会有一个很明显的提升。该方法中，采样目标点附近的4个纹素，并且根据权重(距离中心点的距离)进行加权平均。这种方法使得放大纹理时的色块现象得以消失，因为此时两个相邻像素之间是平滑过度的。当缩小纹理时可以结合mipmap进行使用，尽管当缩小很多时，依然会有和最近点过滤方法一样的锯齿和闪烁现象，但是对于大部分合理的缩小比例，可以作为一种开销较少的有硬件加速的纹理超采样方案。<br><img src="./1603855288637.png" alt="Alt text"><br>近处纹理放大导致的马赛克现象明显消失，但是不同mipmap等级间的分界依然明显</p><h3 id="三线性插值-Trilinear-interpolation"><a href="#三线性插值-Trilinear-interpolation" class="headerlink" title="三线性插值 (Trilinear interpolation)"></a>三线性插值 (Trilinear interpolation)</h3><p>Trilinear interpolation is a method of multivariate interpolation on a 3-dimensional regular grid.<br>对两个相邻的mipmap等级的纹理进行双线性过滤采样，并对两个采样结果线性插值得到最终的颜色。<br>三线性过滤是对双线性过滤中当纹理距离相机的距离刚好处于两个mipmap等级的交界处时的明显的一个过渡现象的解决方案。<br>通过对两个相邻的mipmap等级的纹理进行双线性过滤采样，并对两个采样结果线性插值得到最终的颜色。这样当纹理到相机的距离逐渐增加时，可以得到平滑的一个过渡，而不是突兀的变化。当然，对于足够近的纹理，因为使用miplevel0这个等级，因此和双线性过滤完全一致。</p><p>经过mipmap+三线性插值，解决了</p><ul><li>点采样法引起的像素值不连续</li><li>远景的高频走样</li><li>不同lod level区域的明显分界</li><li>切换lod level的突变</li></ul><p><img src="./1603855360374.png" alt="Alt text"></p><h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4><p>然而mipmap自身定义上就导致严重的问题。为了解决高频走样，引入了mipmap，强行将高频区域变为低频区域，减少信息量。这样的后果就是随着lod越来越远，采样结果就越模糊。在游戏中，往往表现为感觉越往远看，地面上就越感觉蒙着一层雾，像眼睛近视了一样。</p><p>为了增强远景的清晰度，显卡厂商增加了一个新的过程，即各向异性过滤。这个效果对GPU的要求较高，所以在游戏中属于“最高画质”的选项。</p><h3 id="各向异性过滤-Anisotropic-filtering"><a href="#各向异性过滤-Anisotropic-filtering" class="headerlink" title="各向异性过滤(Anisotropic filtering)"></a>各向异性过滤(Anisotropic filtering)</h3><p>当一个物体的表面和相机有很大的夹角时，纹理在屏幕上的对应填充区域就不是方形的。例如一个地板，距离相机远的地方，填充区域的宽高是不对等的，此时方形的纹理贴图就不是很合适了，此时就会导致模糊或者闪烁或者两者皆有。各向异性过滤通过采样一个非方形纹理解决了这个问题。</p><p>在Unity中通过Aniso Level设置该过滤效果。</p><blockquote><p>Texture.anisoLevel - Anisotropic filtering level of the texture. Anisotropic filtering makes textures look better when viewed at a shallow angle, but comes at a performance cost in the graphics hardware. Usually you use it on floor, ground or road textures to make them look better.<br>The value range of this variable goes from 1 to 9, where 1 equals no filtering applied and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at shallow angles. Lower values mean the texture will be more blurry at shallow angles.</p></blockquote><p>Aniso Level == 0<br><img src="./1603855799619.png" alt="Alt text"><br>Aniso Level == 9<br><img src="./1603855820036.png" alt="Alt text"></p><h2 id="OpenGL对Minification-Magnification-Filter的选择"><a href="#OpenGL对Minification-Magnification-Filter的选择" class="headerlink" title="OpenGL对Minification/Magnification Filter的选择"></a>OpenGL对Minification/Magnification Filter的选择</h2><p>此处摘录自CHAI’S BLOG：<a href="http://warmcat.org/chai/blog/?p=1222" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1222</a><br>OpenGL允许设置纹理的过滤，分为GL_TEXTURE_MIN_FILTER和GL_TEXTURE_MAG_FILTER两种。<br>如果采样点的像素被认为是Minify了的，则用GL_TEXTURE_MIN_FILTER，如果是为认为是Magnify了的，用GL_TEXTURE_MAG_FILTER，决定用哪一个和mipmap无关，mipmap的三线性过滤通过_MIPMAP_NEAREAST和_MIPMAP_LINEAR决定。<br>默认情况下，GL_TEXTURE_MAG_FILTER 的过滤方式是GL_LINEAR，GL_TEXTURE_MIN_FILTER 的过滤方式是GL_NEAREST_MIPMAP_LINEAR。</p><p>opengl提供了dfdx,dfdy两个函数对片段的属性做屏幕空间的偏微分，如果对uv做偏微分的话就是:</p><script type="math/tex; mode=display">dfdx(uv)=(\frac{\partial u}{\partial x}, \frac{\partial v}{\partial x})</script><script type="math/tex; mode=display">dfdy(uv)=(\frac{\partial u}{\partial y}, \frac{\partial v}{\partial y})</script><p><img src="./1603865152983.png" alt="Alt text"><br>∂u/∂x和∂v/∂x是左下角的像素和它水平方向的邻居的差，∂u/∂y和∂v/∂y是左下角的像素和它上面的邻居的差，由于∂x=1，∂y=1，则<br>dfdx(uv) = P1.uv - P0.uv<br>dfdy(uv) = P3.uv - P0.uv</p><p>使用以下公式判断此纹素是min还是mag<br><img src="./1603864791127.png" alt="Alt text"><br>如果ρ&lt;=1，此纹素被放大了，即mag<br>如果ρ&gt;1，此纹素被缩小了，即min</p><h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="纹理环绕（Texture-Wrap）"><a href="#纹理环绕（Texture-Wrap）" class="headerlink" title="纹理环绕（Texture Wrap）"></a>纹理环绕（Texture Wrap）</h3><p>纹理环绕的作用是为了处理超出0.0~1.0范围的纹理坐标，例如采用重复（REPEAT）的环绕方式，采样（4.5,-4.5）的纹理坐标，实际采样的纹理坐标应是（0.5，0.5）。对于负数纹理坐标，采样的实际位置应是1-uv，例如（-0.2,-0.6）应该采样（0.8,0.4）</p><h3 id="上-下采样"><a href="#上-下采样" class="headerlink" title="上/下采样"></a>上/下采样</h3><h4 id="downsampled（下采样）"><a href="#downsampled（下采样）" class="headerlink" title="downsampled（下采样）"></a>downsampled（下采样）</h4><p>目的：</p><ul><li>使得图像符合显示区域的大小；</li><li>生成对应图像的缩略图；</li></ul><p>方法：对于一幅图像尺寸为M<em>N，对其进行s倍的下采样，即得到（M/s）</em>（N/s）尺寸的分辨率图像，当然，s应该是M和N的公约数才可以，如果考虑是矩阵形式的图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点就是窗口内所有像素的均值 Pk = (∑ Xi)/ S^2</p><h4 id="upsampling（上采样）"><a href="#upsampling（上采样）" class="headerlink" title="upsampling（上采样）"></a>upsampling（上采样）</h4><p>放大图像（或称为上采样（upsampling）或图像插值（interpolating））的主要目的是放大原图像，从而可以显示在更高分辨率的显示设备上。</p><p>上采样的原理：图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。插值算法还包括了传统插值，基于边缘图像的插值，还有基于区域的图像插值。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.sohu.com/a/397647922_468740" target="_blank" rel="noopener">https://www.sohu.com/a/397647922_468740</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC</a><br><a href="https://en.wikipedia.org/wiki/Texture_filtering" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Texture_filtering</a><br><a href="https://en.wikipedia.org/wiki/Linear_interpolation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Linear_interpolation</a><br><a href="http://warmcat.org/chai/blog/?p=1077" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1077</a><br><a href="http://warmcat.org/chai/blog/?p=1222" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1222</a></p>]]></content>
      
      
      <categories>
          
          <category> CG&amp;Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Texture </tag>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础】U3D中的Mesh</title>
      <link href="2020/10/25/Basic-Mesh-in-Unity3D/"/>
      <url>2020/10/25/Basic-Mesh-in-Unity3D/</url>
      
        <content type="html"><![CDATA[<p>Unity3D中的 <strong>Mesh(网格)</strong> 事实上就是我们所说的 <strong>三角网格</strong> 。<br>三角网格就是由一系列三角形组成的多边形网格，主要用于模拟复杂物体的表面。</p><h2 id="数据结构——索引三角网格"><a href="#数据结构——索引三角网格" class="headerlink" title="数据结构——索引三角网格"></a>数据结构——索引三角网格</h2><p>用c++语言模拟Unity3D中Mesh数据的存储结构。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点表</span></span><br><span class="line"><span class="comment">//-----------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span>   <span class="comment">//由于存储三角形顶点级信息</span></span><br><span class="line">Vector3 p;</span><br><span class="line">.......    <span class="comment">//其他信息 纹理映射坐标 法向量 光照信息</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形表</span></span><br><span class="line"><span class="comment">//-----------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triangle</span>&#123;</span>  <span class="comment">//保存三角形级信息</span></span><br><span class="line"><span class="keyword">int</span> vertex[<span class="number">3</span>];  <span class="comment">//三个顶点在顶点列表的索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//存放三角网格的结构 维护两个表 定点表和三角形表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriangleMesh</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> vertexCount; <span class="comment">//顶点数</span></span><br><span class="line">Vertex *vertexList; <span class="comment">//顶点存放链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *uv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> triangleCount; <span class="comment">//三角形数量</span></span><br><span class="line">Triangle *triangleCount; <span class="comment">//存放三角形的链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">........</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="vertices"><a href="#vertices" class="headerlink" title="vertices"></a>vertices</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3[] vertices; <span class="comment">//所有的顶点。</span></span><br></pre></td></tr></table></figure><p>每个三角形面三个顶点，面与面之间不一定共用顶点。<br>法向量相同的两个面可以公用顶点，法向量不同的两个面，在同一个位置会分别有两个顶点数据，坐标相同，法向量不同。</p><p>每个顶点包含一个3D位置，一般也会包括<strong>纹理映射坐标(UV坐标)</strong>，表面<strong>法向量</strong>，<strong>光照值</strong>等附加信息</p><h4 id="为何有冗余顶点"><a href="#为何有冗余顶点" class="headerlink" title="为何有冗余顶点"></a>为何有冗余顶点</h4><p>正方体6个面，每个面由2个三角形组成，所以共需要36个三角形顶点索引。但是正方体只有8个顶点，为什么需要24个顶点坐标数据呢？</p><p>答案是：Unity3D的Mesh.triangles是<strong>三角形索引数组</strong>，不仅依靠这个索引值<strong>索引三角形顶点坐标</strong>，而且<strong>索引纹理坐标</strong>，<strong>索引法线向量</strong>。即正方体的<strong>每个顶点都参与了3个平面，而这3个平面的法线向量是不同的</strong>，该顶点在渲染这3个平面的时候需要索引到不同的法线向量。而由于顶点坐标和法线向量是由同一个索引值triangles[Index]取得的，例如，根据triangles[0],triangles[14],triangles[17]在vertices中索引到的顶点都为（0.5，－0.5，0.5），但是在normals中索引到的法向量值各不相同。这就决定了在正方体中一个顶点，需要有<strong>3份存储</strong>。（如果你需要创建其它模型，需要根据实际情况决定顶点坐标的冗余度。实质上顶点坐标的冗余正是方便了法线坐标、纹理坐标的存取。）</p><h3 id="triangles"><a href="#triangles" class="headerlink" title="triangles"></a>triangles</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] triangles <span class="comment">// a list of triangles that contains indices into the vertex array</span></span><br></pre></td></tr></table></figure><p>三角形的哪一面可见是由顶点序号的方向来确定的。如果顶点顺序是顺时针方向的话那么三角形是正面可见。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.vertices = <span class="keyword">new</span> Vector3[] &#123;<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)&#125;;</span><br><span class="line">mesh.uv = <span class="keyword">new</span> Vector2[] &#123;<span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>)&#125;;</span><br><span class="line">mesh.triangles =  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="normals"><a href="#normals" class="headerlink" title="normals"></a>normals</h3><p>每个顶点对应一个法线，即顶点所在平面的法线</p><ul><li>法线是垂直于面的向量。我们通常使用单位长度的法向量，并向量指向面的外部，而不是内部。</li><li>法线可以用于确定光线与顶点的夹角。这个细节的使用取决于Shader。<blockquote><p>作为三角面它永远是平的，因此它不应该需要被提供一个单独的法线信息。然而，我们需要造假。在现实中，顶点是不存在法线的，三角面才有。通过附加自定义顶点法线和三角面插着，我们可以奖状我们有一个平滑的曲面代替一堆平的三角面。这个错觉是令人信服的，只要你不去注意网格锋利的轮廓（锯齿）。</p></blockquote></li></ul><p>法线用于规定每个顶点，所以我们必须填充另一个向量数组。另一种选择，我们可以依据网格的三角面来计算出法线。</p><h3 id="Tangent"><a href="#Tangent" class="headerlink" title="Tangent"></a>Tangent</h3><blockquote><p>tangent: 切线，切面，正切</p></blockquote><p>法线贴图在切线空间中定义。<br>所以切线是一个三维向量，但是在Unity中它是使用四维向量定义的。第四个值通常是1或者-1，用于控制第三切线空间唯独方向-朝前或朝后,这有助于展示法线贴图，通常用于左右对称的3D模型，像人一样。Untiy的shader执行此计算要求我们使用-1。</p><h4 id="法线贴图-Normal-Map"><a href="#法线贴图-Normal-Map" class="headerlink" title="法线贴图(Normal Map)"></a>法线贴图(Normal Map)</h4><p>使用颜色值记录了法相向量</p><h3 id="UV坐标-纹理坐标"><a href="#UV坐标-纹理坐标" class="headerlink" title="UV坐标(纹理坐标)"></a>UV坐标(纹理坐标)</h3><p>UV mapping is the 3D modeling process of projecting a 2D image to a 3D model’s surface for <strong>texture mapping</strong>.</p><blockquote><p>The letters “U” and “V” denote the axes of the 2D texture because “X”, “Y”, and “Z” are already used to denote the axes of the 3D object in model space, while “W” (in addition to XYZ) is used in calculating quaternion rotations, a common operation in computer graphics.</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>U3D中的<strong>纹理贴图的原理</strong>应该是你的模型坐标进过顶点变化到投影坐标系，然后在接下来的片段着色的时候通过传递过来的UV值用<code>tex2D(_texName, UV)</code>来获取颜色值，然后渲染到屏幕上。</p></blockquote><p>UV坐标通常在(0,0)到(1,1)之间，它覆盖了整个纹理。超出范围的坐标将造成<strong>clamped</strong>或者<strong>Tiling</strong>平铺的效果，这去取决于纹理设置。</p><h4 id="uv、uv2、uv3、uv4"><a href="#uv、uv2、uv3、uv4" class="headerlink" title="uv、uv2、uv3、uv4"></a>uv、uv2、uv3、uv4</h4><p>如果在模型导入时就存在 uv2，uv3，uv4，那么这是因为在建模软件中添加了这些顶点属性。<br>uv2通常被用于Lightmap，uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。<br>一般来说uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p><h3 id="colors属性"><a href="#colors属性" class="headerlink" title="colors属性"></a>colors属性</h3><p>在一些建模软件中导出的网格模型(Mesh)可能会带有colors属性，描述每个顶点的颜色。有些Shader可以使用这个属性进行运算与着色。然而很多时候colors属性是用不到的，<strong>如Unity标准着色器就不使用这个属性</strong>。</p><blockquote><p>Most shaders choose to ignore vertex color, with exception of sprites shader.<br>大多数着色器选择忽略顶点颜色，但精灵着色器除外<br><a href="https://stackoverflow.com/questions/34460587/unity-changing-only-certain-part-of-3d-models-color" target="_blank" rel="noopener">https://stackoverflow.com/questions/34460587/unity-changing-only-certain-part-of-3d-models-color</a></p></blockquote><p>colors属性与tangents属性一样，如果网格顶点拥有该属性，同样会对内存、物理体积和加载性能造成影响。</p><p>默认情况下，在3d建模软件中并不会导出Color属性。以3ds max为例，Color通常是通过modifier添加的，因此只需要在导出前将其删除即可。<br>去除方法：<a href="https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf</a></p><blockquote><p>注意：切忌将不同属性的网格模型拼合在一起。举个例子 ，100个网格模型进行Static Batching，如果99个模型只有Position和UV两种属性，而剩下1个模型函数有Position、UV、Normal、Tangent和Color五种属性。那么引擎在进行拼合时，会将前99个模型的顶点属性补齐，然后再进行拼合。这样无形中会增加大量的内存占用，从而造成不必要的内存浪费。</p></blockquote><h3 id="无用属性的去除方法"><a href="#无用属性的去除方法" class="headerlink" title="无用属性的去除方法"></a>无用属性的去除方法</h3><p>1.如果有3dmax的源文件，可以直接在3dmax里操作，在那个channelinfo—清掉那个vc<br>2.如果只有fbx，或者这类文件太多，可以直接下载一个fbx的sdk，拿里面的例子改一下，生成一个exe。然后在unity里直接调用就行了。<br>其实从外包回来的fbx，一般都有问题，要么顶点色，要么会出现uv3、uv4。我这里附上工具和c++、及在unity调用的代码，你可以试一下。如果运行不了，缺dll，你就到网上找一下，多半可以用。 clear_fbx_clr_uv_tool.rar<br>注意这个工具会清掉顶点色和uv3、uv4！！<br>3.印象中在unity里也可以直接清顶点色，好像是meshfiter那里把colors直接置空，再重新保存回去。</p><h2 id="Unity中Mesh重要属性和方法"><a href="#Unity中Mesh重要属性和方法" class="headerlink" title="Unity中Mesh重要属性和方法"></a>Unity中Mesh重要属性和方法</h2><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>(1) vertices 网格顶点数组;<br>(2) normals 网格的法线数组;<br>(3) tangents 网格的切线数组;<br>(4) uv 网格的基础纹理坐标;<br>(5) uv2 网格设定的第二个纹理坐标;<br>(6) bounds 网格的包围盒;<br>(7) Colors 网格的顶点颜色数组;<br>(8) triangles 包含所有三角形的顶点索引数组;<br>(9) vectexCount 网格中的顶点数量(只读的);<br>(10) subMeshCount 子网格的数量，每个材质都有一个独立的网格列表;<br>(11) bonesWeights: 每个顶点的骨骼权重;<br>(12) bindposes: 绑定姿势，每个索引绑定的姿势使用具有相同的索引骨骼;</p><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>(1) Clear 清空所有的顶点数据和所有的三角形索引;<br>(2) RecalculateBounds 重新计算网格的包围盒;<br>(3) RecalculateNormals 重新计算网格的法线;<br>(4) Optimze 显示优化的网格;<br>(5) GetTriangles 返回网格的三角形列表;<br>(6) SetTriangles 为网格设定三角形列表;<br>(7) CominMeshes组合多个网格到同一个网格;</p><h2 id="Import-Settings"><a href="#Import-Settings" class="headerlink" title="Import Settings"></a>Import Settings</h2><h3 id="Mesh-Compression（通常禁用，优化渲染和发布文件大小时启用）"><a href="#Mesh-Compression（通常禁用，优化渲染和发布文件大小时启用）" class="headerlink" title="Mesh Compression（通常禁用，优化渲染和发布文件大小时启用）"></a>Mesh Compression（通常禁用，优化渲染和发布文件大小时启用）</h3><p>启用网格压缩，unity会按照一定的级别来压缩网格数据，压缩级别越高，网格的精度越低，这对于渲染优化和发布时游戏文件大小的降低很有用，但可能会导致失真。官方的想法是，尽可能的压缩网格，只要模型看起来不至于太奇怪。</p><h3 id="Optimize-Mesh"><a href="#Optimize-Mesh" class="headerlink" title="Optimize Mesh"></a>Optimize Mesh</h3><p>优化网格，如果开启，网格的定点和三角形会按照U3D既定的一套规则重新排序用以提高GPU性能。<br>The Optimize Meshes option in a mesh’s import settings will reorganize the vertex data for quicker readability, and sometimes regenerate the low-level rendering style (down to the level of points versus tris versus strips) to optimize the rendering speed of the mesh.</p><p>该优化方法也可以在代码中调用：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mesh mesh = gameObject.GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line">mesh.Optimize();</span><br></pre></td></tr></table></figure><br>This function causes the geometry and vertices of the mesh to be reordered internally in an attempt to improve vertex cache utilisation on the graphics hardware and thus rendering performance.<br>This operation can take a few seconds or more for complex meshes and should only be used where <strong>the ordering of the geometry and vertices is not significant</strong> as both will change.<br>理论上如果模型对顶点和面片顺序没有要求的话，不会导致显示问题。</p><h2 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h2><h3 id="MeshFiler组件"><a href="#MeshFiler组件" class="headerlink" title="MeshFiler组件"></a>MeshFiler组件</h3><p>MeshFilter 这个组件记录了你想要展示的网格数据</p><h3 id="MeshRender组件"><a href="#MeshRender组件" class="headerlink" title="MeshRender组件"></a>MeshRender组件</h3><p>MeshRenderer 使用这个组件告诉网格如何渲染，比如使用哪个材质球，是否接受阴影和其他设置。</p><h2 id="Mesh编程"><a href="#Mesh编程" class="headerlink" title="Mesh编程"></a>Mesh编程</h2><h3 id="画面片"><a href="#画面片" class="headerlink" title="画面片"></a>画面片</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenMesh</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"MeshEditor/GenMesh"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenMeshM</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Mesh m1 = CreateRect();</span><br><span class="line">        AssetDatabase.CreateAsset(m1, <span class="string">"Assets/models/m1.asset"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mesh <span class="title">CreateRect</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Mesh mesh = <span class="keyword">new</span> Mesh();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> particleNum = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//顶点坐标</span></span><br><span class="line">        Vector3[] verts = <span class="keyword">new</span> Vector3[<span class="number">4</span> * particleNum];</span><br><span class="line">        <span class="comment">//uv坐标</span></span><br><span class="line">        Vector2[] uvs = <span class="keyword">new</span> Vector2[<span class="number">4</span> * particleNum];</span><br><span class="line">        <span class="comment">//三角形索引</span></span><br><span class="line">        <span class="keyword">int</span>[] tris = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * <span class="number">3</span> * particleNum];</span><br><span class="line"></span><br><span class="line">        Vector3 position;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; particleNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i4 = i * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">int</span> i6 = i * <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">            position.x = <span class="number">5</span> * i;</span><br><span class="line">            position.y = <span class="number">5</span> * i;</span><br><span class="line">            position.z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点坐标</span></span><br><span class="line">            verts[i4 + <span class="number">0</span>] = position;</span><br><span class="line">            verts[i4 + <span class="number">1</span>] = position + <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            verts[i4 + <span class="number">2</span>] = position + <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            verts[i4 + <span class="number">3</span>] = position + <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//四个顶点在UV坐标系中的位置</span></span><br><span class="line">            uvs[i4 + <span class="number">0</span>] = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">            uvs[i4 + <span class="number">1</span>] = <span class="keyword">new</span> Vector2(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">            uvs[i4 + <span class="number">2</span>] = <span class="keyword">new</span> Vector2(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            uvs[i4 + <span class="number">3</span>] = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顺时针绘制三角形0 1 2 / 0 2 3</span></span><br><span class="line">            tris[i6 + <span class="number">0</span>] = i4 + <span class="number">0</span>;</span><br><span class="line">            tris[i6 + <span class="number">1</span>] = i4 + <span class="number">1</span>;</span><br><span class="line">            tris[i6 + <span class="number">2</span>] = i4 + <span class="number">2</span>;</span><br><span class="line">            tris[i6 + <span class="number">3</span>] = i4 + <span class="number">0</span>;</span><br><span class="line">            tris[i6 + <span class="number">4</span>] = i4 + <span class="number">2</span>;</span><br><span class="line">            tris[i6 + <span class="number">5</span>] = i4 + <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mesh.vertices = verts;</span><br><span class="line">        mesh.triangles = tris;</span><br><span class="line">        mesh.uv = uvs;</span><br><span class="line">        mesh.RecalculateBounds();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mesh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">region</span> 画圆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 画圆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="radius"&gt;</span>圆的半径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="segments"&gt;</span>圆的分割数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="centerCircle"&gt;</span>圆心得位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawCircle</span>(<span class="params"><span class="keyword">float</span> radius, <span class="keyword">int</span> segments, Vector3 centerCircle</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">        gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        gameObject.GetComponent&lt;MeshRenderer&gt;().material = mat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顶点</span></span><br><span class="line">        Vector3[] vertices = <span class="keyword">new</span> Vector3[segments + <span class="number">1</span>];</span><br><span class="line">        vertices[<span class="number">0</span>] = centerCircle;</span><br><span class="line">        <span class="keyword">float</span> deltaAngle = Mathf.Deg2Rad * <span class="number">360f</span> / segments;</span><br><span class="line">        <span class="keyword">float</span> currentAngle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> cosA = Mathf.Cos(currentAngle);</span><br><span class="line">            <span class="keyword">float</span> sinA = Mathf.Sin(currentAngle);</span><br><span class="line">            vertices[i] = <span class="keyword">new</span> Vector3(cosA * radius + centerCircle.x, sinA * radius + centerCircle.y, <span class="number">0</span>);</span><br><span class="line">            currentAngle += deltaAngle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三角形</span></span><br><span class="line">        <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[segments * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; segments * <span class="number">3</span> - <span class="number">3</span>; i += <span class="number">3</span>, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            triangles[i] = <span class="number">0</span>;</span><br><span class="line">            triangles[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            triangles[i + <span class="number">2</span>] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">1</span>] = segments;</span><br><span class="line"></span><br><span class="line">        Vector2[] uvs = <span class="keyword">new</span> Vector2[vertices.Length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            uvs[i] = <span class="keyword">new</span> Vector2(vertices[i].x / radius / <span class="number">2</span> + <span class="number">0.5f</span>, vertices[i].y / radius / <span class="number">2</span> + <span class="number">0.5f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line">        mesh.Clear();</span><br><span class="line"></span><br><span class="line">        mesh.vertices = vertices;</span><br><span class="line">        mesh.triangles = triangles;</span><br><span class="line">        mesh.uv = uvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h3 id="画圆环"><a href="#画圆环" class="headerlink" title="画圆环"></a>画圆环</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">region</span> 画圆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 画圆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="radius"&gt;</span>圆的半径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="segments"&gt;</span>圆的分割数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="centerCircle"&gt;</span>圆心得位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawCircle</span>(<span class="params"><span class="keyword">float</span> radius, <span class="keyword">int</span> segments, Vector3 centerCircle</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">        gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        gameObject.GetComponent&lt;MeshRenderer&gt;().material = mat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顶点</span></span><br><span class="line">        Vector3[] vertices = <span class="keyword">new</span> Vector3[segments + <span class="number">1</span>];</span><br><span class="line">        vertices[<span class="number">0</span>] = centerCircle;</span><br><span class="line">        <span class="keyword">float</span> deltaAngle = Mathf.Deg2Rad * <span class="number">360f</span> / segments;</span><br><span class="line">        <span class="keyword">float</span> currentAngle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> cosA = Mathf.Cos(currentAngle);</span><br><span class="line">            <span class="keyword">float</span> sinA = Mathf.Sin(currentAngle);</span><br><span class="line">            vertices[i] = <span class="keyword">new</span> Vector3(cosA * radius + centerCircle.x, sinA * radius + centerCircle.y, <span class="number">0</span>);</span><br><span class="line">            currentAngle += deltaAngle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三角形</span></span><br><span class="line">        <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[segments * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; segments * <span class="number">3</span> - <span class="number">3</span>; i += <span class="number">3</span>, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            triangles[i] = <span class="number">0</span>;</span><br><span class="line">            triangles[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            triangles[i + <span class="number">2</span>] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        triangles[segments * <span class="number">3</span> - <span class="number">1</span>] = segments;</span><br><span class="line"></span><br><span class="line">        Vector2[] uvs = <span class="keyword">new</span> Vector2[vertices.Length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            uvs[i] = <span class="keyword">new</span> Vector2(vertices[i].x / radius / <span class="number">2</span> + <span class="number">0.5f</span>, vertices[i].y / radius / <span class="number">2</span> + <span class="number">0.5f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line">        mesh.Clear();</span><br><span class="line"></span><br><span class="line">        mesh.vertices = vertices;</span><br><span class="line">        mesh.triangles = triangles;</span><br><span class="line">        mesh.uv = uvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h3 id="Mesh顶点编辑器"><a href="#Mesh顶点编辑器" class="headerlink" title="Mesh顶点编辑器"></a>Mesh顶点编辑器</h3><p>摘自：<a href="https://gameinstitute.qq.com/community/detail/129174" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/129174</a><br>思路：获取mesh上的所有顶点，然后在每个顶点位置创建一个控制点，控制点可以是任意你喜欢的物体，通过判断控制点的位置信息来修改mesh的顶点位置。<br>把每个顶点的坐标转为字符串，使用该坐标的字符串作为<strong>key</strong>来把<strong>控制点</strong>与<strong>顶点数据</strong>联系起来。</p><hr><p>控制点：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">public class MeshEditorPoint : MonoBehaviour ｛</span><br><span class="line">    <span class="comment">//顶点id，（顶点初始位置转字符串）</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>] <span class="keyword">public</span> <span class="keyword">string</span> pointid;</span><br><span class="line">    <span class="comment">//记录坐标点上一次移动的位置，用于判断控制点是否移动</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>] <span class="keyword">private</span> Vector3 lastPosition;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MoveDelegate</span>(<span class="params"><span class="keyword">string</span> pid,Vector3 pos</span>)</span>;</span><br><span class="line">    <span class="comment">//控制点移动时的回调</span></span><br><span class="line">    <span class="keyword">public</span> MoveDelegate onMove = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Use this for initialization</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) ｛</span></span><br><span class="line"><span class="function">        lastPosition</span> = transform.position;</span><br><span class="line">｝</span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) ｛</span></span><br><span class="line"><span class="function">        <span class="title">if</span>(<span class="params">transform.position != lastPosition</span>)｛</span></span><br><span class="line"><span class="function">            <span class="title">if</span>(<span class="params">onMove != <span class="literal">null</span></span>) <span class="title">onMove</span>(<span class="params">pointid, transform.localPosition</span>)</span>;</span><br><span class="line">            lastPosition = transform.position;</span><br><span class="line">        ｝</span><br><span class="line">｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><hr><p>顶点编辑器<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line">public class ModelMeshEditor : MonoBehaviour ｛</span><br><span class="line">    <span class="comment">//控制点的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> pointScale = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastPointScale = <span class="number">1.0f</span>;</span><br><span class="line">    Mesh mesh;</span><br><span class="line">    <span class="comment">//顶点列表</span></span><br><span class="line">    List&lt;Vector3&gt; positionList = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line">    <span class="comment">//顶点控制物体列表</span></span><br><span class="line">    List&lt;GameObject&gt; positionObjList = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> key:顶点字符串</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> value:顶点在列表中的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt; pointmap = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"><span class="comment">// Use this for initialization</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) ｛</span></span><br><span class="line"><span class="function">        lastPointScale</span> = pointScale;</span><br><span class="line">        mesh = GetComponent&lt;MeshFilter&gt;().sharedMesh;</span><br><span class="line">        CreateEditorPoint();</span><br><span class="line">｝</span><br><span class="line">    <span class="comment">//创建控制点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateEditorPoint</span>(<span class="params"></span>)｛</span></span><br><span class="line"><span class="function">        positionList</span> = <span class="keyword">new</span> List&lt;Vector3&gt;(mesh.vertices);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh.vertices.Length; i++)</span><br><span class="line">        ｛</span><br><span class="line">            <span class="keyword">string</span> vstr = Vector2String(mesh.vertices[i]);</span><br><span class="line">            <span class="keyword">if</span>(!pointmap.ContainsKey(vstr))｛</span><br><span class="line">                pointmap.Add(vstr,<span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            ｝</span><br><span class="line">            pointmap[vstr].Add(i);</span><br><span class="line">        ｝</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> key <span class="keyword">in</span> pointmap.Keys)</span><br><span class="line">        ｛</span><br><span class="line">            GameObject editorpoint = (GameObject)Resources.Load(<span class="string">"Prefabs/MeshEditor/MeshEditorPoint"</span>);</span><br><span class="line">            editorpoint = Instantiate(editorpoint);</span><br><span class="line">            editorpoint.transform.parent = transform;</span><br><span class="line">            editorpoint.transform.localPosition = String2Vector(key);</span><br><span class="line">            editorpoint.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">1f</span>);</span><br><span class="line">            MeshEditorPoint editorPoint = editorpoint.GetComponent&lt;MeshEditorPoint&gt;();</span><br><span class="line">            editorPoint.onMove = PointMove;</span><br><span class="line">            editorPoint.pointid = key;</span><br><span class="line">            positionObjList.Add(editorpoint);</span><br><span class="line">        ｝</span><br><span class="line">    ｝</span><br><span class="line">    <span class="comment">//顶点物体被移动时调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PointMove</span>(<span class="params"><span class="keyword">string</span> pointid,Vector3 position</span>)｛</span></span><br><span class="line"><span class="function">        <span class="title">if</span>(<span class="params">!pointmap.ContainsKey(pointid</span>))｛</span></span><br><span class="line"><span class="function">            return</span>;</span><br><span class="line">        ｝</span><br><span class="line">        List&lt;<span class="keyword">int</span>&gt; _list = pointmap[pointid];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _list.Count; i ++)｛</span><br><span class="line">            positionList[_list[i]] = position;</span><br><span class="line">        ｝</span><br><span class="line">        mesh.vertices = positionList.ToArray();</span><br><span class="line">        mesh.RecalculateNormals();</span><br><span class="line">    ｝</span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) ｛</span></span><br><span class="line"><span class="function">        <span class="comment">//检测控制点尺寸是否改变</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> (<span class="params">Math.Abs(lastPointScale - pointScale</span>) &gt; 0.1f)｛</span></span><br><span class="line"><span class="function">            lastPointScale</span> = pointScale;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; positionObjList.Count; i ++)｛</span><br><span class="line">                positionObjList[i].transform.localScale = <span class="keyword">new</span> Vector3(pointScale, pointScale, pointScale);</span><br><span class="line">            ｝</span><br><span class="line">        ｝</span><br><span class="line">｝</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">Vector2String</span>(<span class="params">Vector3 v</span>)｛</span></span><br><span class="line"><span class="function">        StringBuilder str</span> = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        str.Append(v.x).Append(<span class="string">","</span>).Append(v.y).Append(<span class="string">","</span>).Append(v.z);</span><br><span class="line">        <span class="keyword">return</span> str.ToString();</span><br><span class="line">    ｝</span><br><span class="line">    <span class="function">Vector3 <span class="title">String2Vector</span>(<span class="params"><span class="keyword">string</span> vstr</span>)</span></span><br><span class="line"><span class="function">    ｛</span></span><br><span class="line"><span class="function">        <span class="keyword">try</span>｛</span></span><br><span class="line"><span class="function">            <span class="keyword">string</span>[] strings</span> = vstr.Split(<span class="string">','</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Vector3(<span class="keyword">float</span>.Parse(strings[<span class="number">0</span>]), <span class="keyword">float</span>.Parse(strings[<span class="number">1</span>]), <span class="keyword">float</span>.Parse(strings[<span class="number">2</span>]));</span><br><span class="line">        ｝<span class="keyword">catch</span>(Exception e)｛</span><br><span class="line">            Debug.LogError(e.ToString());</span><br><span class="line">            <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">        ｝</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="关于锯齿"><a href="#关于锯齿" class="headerlink" title="关于锯齿"></a>关于锯齿</h3><p>曲面的或者是圆的面只能被大量小的三角形来接近组成。如果三角面显示足够的小（不大于一个像素），那么你就不会感觉曲面或者是圆是由三角面组成的。从实时性能角度来讲通常这种情况是不可能的，所以我们总能够在面的某个程度上发现锯齿。</p><h3 id="Texture相关"><a href="#Texture相关" class="headerlink" title="Texture相关"></a>Texture相关</h3><p>Wrap Mode（包装方式）: Repeat(重复), Clamp(固定，贴不上的部分，会按照边缘进行延伸，而不会拉伸图片)</p><h3 id="3D建模软件"><a href="#3D建模软件" class="headerlink" title="3D建模软件"></a>3D建模软件</h3><p>1:Autodesk 3D Studio Max 支持mac os windows;<br>2: Autodesk 3D Maya 支持windows<br>3: Cinema4D 支持mac os windows<br>4: Blender 开源跨平台的全能三维制作软件, 支持mac os windows, linux;<br>5: Cheetah3D: 支持mac os<br>6: Unity与建模软件的单位比例:</p><div class="table-container"><table><thead><tr><th style="text-align:center">软件</th><th style="text-align:center">内部米</th><th style="text-align:center">导入unity后的尺寸/m</th><th style="text-align:center">与Unity单位的比例关系</th></tr></thead><tbody><tr><td style="text-align:center">3Dmax</td><td style="text-align:center">1</td><td style="text-align:center">0.01</td><td style="text-align:center">100:1</td></tr><tr><td style="text-align:center">Maya</td><td style="text-align:center">1</td><td style="text-align:center">0.01</td><td style="text-align:center">1:100</td></tr><tr><td style="text-align:center">Cinema 4D</td><td style="text-align:center">1</td><td style="text-align:center">0.01</td><td style="text-align:center">1:100</td></tr><tr><td style="text-align:center">Light Wave</td><td style="text-align:center">1</td><td style="text-align:center">0.01</td><td style="text-align:center">100:1</td></tr></tbody></table></div><p>　　　　　　　</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs:"></a>Refs:</h2><p><a href="https://www.cnblogs.com/zhanghaipeng-Unity3D/p/4714973.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhanghaipeng-Unity3D/p/4714973.html</a><br><a href="https://blog.csdn.net/qq_29579137/article/details/77369734" target="_blank" rel="noopener">https://blog.csdn.net/qq_29579137/article/details/77369734</a><br><a href="https://www.bbsmax.com/A/QV5ZQvObJy/" target="_blank" rel="noopener">https://www.bbsmax.com/A/QV5ZQvObJy/</a><br><a href="https://blog.csdn.net/nanggong/article/details/54728823" target="_blank" rel="noopener">https://blog.csdn.net/nanggong/article/details/54728823</a><br><a href="https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asset </tag>
            
            <tag> rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渲染】基础——渲染管线(Rendering Pipeline)</title>
      <link href="2020/10/25/Basic-Render-pipeline/"/>
      <url>2020/10/25/Basic-Render-pipeline/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染管线概览"><a href="#渲染管线概览" class="headerlink" title="渲染管线概览"></a>渲染管线概览</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="渲染管线（流水线）"><a href="#渲染管线（流水线）" class="headerlink" title="渲染管线（流水线）"></a>渲染管线（流水线）</h4><p>《Render-Time Rendering Third Edition》一书中将计算机图形渲染的流程划分为3个阶段<br><img src="./RenderingPipeline.png" alt="Alt text"><br>定义：也称渲染流水线，是显示芯片内部处理图形信号<strong>相互独立</strong>的<strong>并行</strong>的处理单位。</p><blockquote><p>一个<strong>流水线</strong>是一序列可以<strong>并行</strong>和<strong>按固定顺序进行</strong>的阶段。也就是说每个阶段都是从它的前一阶段输入，然后输出发给随后的阶段。</p></blockquote><p>渲染机理：将图像所具备的图形信息（顶点、纹理、材质、摄像机位置等）经过一系列阶段的处理，最终转换成屏幕上的图像。<br>实质是输入3D模型，输出2D图片显示出来的过程</p><p><strong>渲染过程中的坐标转换：物体空间-&gt;世界空间-&gt;观察空间-&gt;裁剪空间-&gt;屏幕空间</strong></p><h4 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h4><p>此处的Shader区别于Unity Shader文件<br>Shader（着色器），是一种较为短小的程序片段，用于告诉图形硬件如何加速输出图像，过去是有汇编语言来编写。<br>总而来说，Shader是<strong>可编程图形管线的算法片段</strong><br>分类:</p><ul><li>Vertex Shader</li><li>Fragment Shader</li></ul><p><img src="./20171201155916085.jpg" alt="Alt text"><br>物体空间-&gt;世界空间-&gt;观察空间-&gt;裁剪空间-&gt;屏幕空间<br><strong>Shader和材质、贴图的关系：</strong><br>Shader将顶点数据以指定的方式和贴图或者颜色组合起来，将输出数据绘制到屏幕上。<br><strong>材质</strong>就是将<strong>Shader</strong>以及<strong>输入参数（包括贴图）</strong>打包存储起来，将材质赋予到三维物体上进行渲染<br>这样就是说材质就是引擎最终使用的商品（每个渲染的物体都需要一个材质）<br>Shader就是生产这种商品的加工过程或方法，贴图就是商品材料之一。</p><h3 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h3><p><img src="./1603770851323.png" alt="Alt text"><br>绿色表示完全可编程控制，黄色表示可配置，蓝色表示由GPU固定实现，不可修改。实线表示必须由开发者编程实现，虚线表示该Shader是可选的。</p><h4 id="应用阶段-Application-Stage-CPU"><a href="#应用阶段-Application-Stage-CPU" class="headerlink" title="应用阶段 Application Stage ( CPU )"></a>应用阶段 Application Stage ( CPU )</h4><p><strong>目标：</strong> 准备好场景数据，设置好渲染状态，然后输出渲染图元（rendering primitives），即为下一阶段提供所需的几何信息。</p><blockquote><p><strong>图元</strong>是指渲染的基本图形，通俗来讲图元可以是顶点，线段，三角面等，复杂的图形可以通过渲染多个三角形来实现。</p></blockquote><p>可细分为3个子阶段</p><h5 id="加载数据到显存"><a href="#加载数据到显存" class="headerlink" title="加载数据到显存"></a>加载数据到显存</h5><p>所有渲染所需的数据都需要从硬盘加载到系统内存中（RAM），然后网格和纹理等数据又被加载到显存（VRAM）。这是因为显卡对于显存的访问速度更快，而且大多数显卡对于RAM没有直接的访问权利。</p><h5 id="设置渲染状态"><a href="#设置渲染状态" class="headerlink" title="设置渲染状态"></a>设置渲染状态</h5><p>比如设置使用的着色器，材质，纹理，光源属性等。</p><h5 id="调用DrawCall"><a href="#调用DrawCall" class="headerlink" title="调用DrawCall"></a>调用DrawCall</h5><p>Draw Call就是一个命令，它的发起方是CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元列表，而不会再包含任何材质信息，这是因为我们已经在上一个阶段设置过了。当给定了一个Draw Call时，GPU就会根据渲染状态和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。</p><h4 id="几何阶段-Geometry-Stage-GPU"><a href="#几何阶段-Geometry-Stage-GPU" class="headerlink" title="几何阶段 Geometry Stage ( GPU )"></a>几何阶段 Geometry Stage ( GPU )</h4><p><strong>接受数据：</strong> 应用阶段所准备好的<strong>渲染图源</strong>信息，也就是顶点数据（模型自身坐标系、顶点颜色、纹理UV等）<br><strong>目标：</strong> 与每个渲染图元打交道，进行逐顶点，逐多边形的操作。把顶点坐标变换到屏幕空间中，输出屏幕空间的顶点信息（绘制方法、绘制坐标），再交给光栅化器进行处理。<br><strong>基本流程：</strong></p><h5 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器(Vertex Shader)"></a>顶点着色器(Vertex Shader)</h5><p>对每个顶点均调用一次。<br>通过一系列的<strong>坐标转换</strong>，将模型的顶点在摄像机前进行位移，并最终投影到摄像机的投影屏幕上<br><strong>本地坐标系-&gt;世界坐标系-&gt;观察坐标系-&gt;投影坐标系</strong></p><p>顶点处理这个阶段包括顶点的<strong>坐标变换</strong>、<strong>逐顶点雾化</strong>、<strong>材质属性</strong>、<strong>光照属性</strong>处理</p><p>坐标变换：把顶点坐标从模型空间转换到齐次裁剪空间，接着通常再由硬件做透视除法，最终得到归一化的设备坐标（NDC）。</p><blockquote><p>顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点和顶点之间的关系，例如我们无法得知两个顶点是否属于同一个三角网格。但正因为这样的相互独立性，GPU可以利用本身的特性并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。</p></blockquote><h5 id="曲面细分着色器-Tessellation-Shader"><a href="#曲面细分着色器-Tessellation-Shader" class="headerlink" title="曲面细分着色器(Tessellation Shader)"></a>曲面细分着色器(Tessellation Shader)</h5><p>细分图元，例如将三角面细分成更小的三角面来添加几何细节。</p><blockquote><p>In Direct3D 11 pipeline (a part of DirectX 11), the graphics primitive is the patch.[4] The tessellator generates a triangle-based tessellation of the patch according to tessellation parameters such as the TessFactor, which controls the degree of fineness of the mesh.<br>Tessellation: 棋盘型布置，密铺，曲面细分</p></blockquote><h5 id="几何着色器-Geometry-Shader"><a href="#几何着色器-Geometry-Shader" class="headerlink" title="几何着色器(Geometry Shader)"></a>几何着色器(Geometry Shader)</h5><p>逐图元着色操作或是生成新的图元(减少CPU负担)。可决定输出的图元类型和个数，当输出的图元减少时，实际上起到了裁剪的作用，当输出的图元增多或类型改变时，起到了产生或改变图元的作用</p><h5 id="裁剪-Clipping"><a href="#裁剪-Clipping" class="headerlink" title="裁剪(Clipping)"></a>裁剪(Clipping)</h5><p>将那些不在摄像机视野内的顶点裁减掉，并剔除某些三角图元的面片（面片通常是由一个一个更小的图元来构成的）。</p><blockquote><p> 一个图元和摄像机视野的关系有3种：完全在视野内，部分在视野内，完全在视野外。完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会继续向下传递，因为它们不需要被渲染。而那些部分在视野内的图元需要被裁剪。<br><img src="./1603771738881.png" alt="Alt text"></p></blockquote><h5 id="屏幕映射-Screen-Mapping"><a href="#屏幕映射-Screen-Mapping" class="headerlink" title="屏幕映射(Screen Mapping)"></a>屏幕映射(Screen Mapping)</h5><p>把每个图元的x和y坐标转换到屏幕坐标系下，这实际上是一个缩放的过程。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。<br><img src="./1603771941717.png" alt="Alt text"></p><p>屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远。 屏幕映射不会对输入的z坐标做任何处理。实际上，屏幕坐标系和z坐标一起构成了<strong>窗口坐标系</strong>。这些值会被一起传递到光栅化阶段。</p><h4 id="光栅化阶段-Rasterizer-Stage-GPU"><a href="#光栅化阶段-Rasterizer-Stage-GPU" class="headerlink" title="光栅化阶段 Rasterizer Stage ( GPU )"></a>光栅化阶段 Rasterizer Stage ( GPU )</h4><blockquote><p>光栅化：是把顶点数据转换为片元的过程，具有将图转化为一个个栅格组成的图象的作用，特点是每个元素对应帧缓冲区中的一像素。（将以向量为基本结构的面转换为一个个点阵形式的像素。）</p></blockquote><p><strong>接受数据：</strong> 几何阶段准备好的顶点信息<br><strong>目标：</strong> 对几何阶段传递过来的<strong>屏幕空间的顶点信息</strong>进行处理,最终生成<strong>屏幕像素,</strong>渲染出图像</p><p>需要对上一个阶段得到的逐顶点数据（例如纹理坐标，顶点颜色等）进行插值，然后再进行逐像素处理。<br>例如对于三角形图元，得到的就是三个顶点的坐标和颜色信息等。而光栅化阶段要做的就是根据这三个顶点，计算出这个三角形<strong>覆盖了哪些像素</strong>，并为这些像素通过<strong>插值</strong>计算出它们的颜色。</p><h5 id="三角形设置-Triangle-Setup"><a href="#三角形设置-Triangle-Setup" class="headerlink" title="三角形设置(Triangle Setup)"></a>三角形设置(Triangle Setup)</h5><p>计算光栅化一个三角网格所需的信息。具体来说，上一个阶段输出的都是三角网格的顶点，但如果要得到整个三角网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个计算三角网格表示数据的过程就叫做三角形设置。</p><h5 id="三角形遍历-Triangle-Traversal"><a href="#三角形遍历-Triangle-Traversal" class="headerlink" title="三角形遍历(Triangle Traversal)"></a>三角形遍历(Triangle Traversal)</h5><p>检查每个像素是否被一个三角网格所覆盖。如果被覆盖的话，就会生成一个片元。而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换。<br>三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行<strong>插值</strong>。<strong>像素</strong>和<strong>片元</strong>是一一对应的，每个像素都会生成一个片元，<strong>片元中的状态记录了对应像素的信息</strong>，是对三个顶点的信息进行插值得到的。<br><img src="./1603772117005.png" alt="Alt text"></p><blockquote><p>片元包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括了但不限于它的屏幕坐标，深度信息，以及其他从几何阶段输出的顶点信息，例如法线，纹理坐标等。</p></blockquote><h5 id="片元着色器-Fragment-Shader"><a href="#片元着色器-Fragment-Shader" class="headerlink" title="片元着色器(Fragment Shader)"></a>片元着色器(Fragment Shader)</h5><p>又称<strong>像素着色器(Pixel Shader)</strong>。逐片元的着色操作(Per-Fragment Operations)，输出是一个或者多个颜色值（即计算该片元对应像素的颜色，但不是最终颜色）。</p><ol><li>纹理采样<br>这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是<strong>纹理采样</strong>。为了在片元着色器中进行纹理采样，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行插值后，就可以得到其覆盖的片元的纹理坐标了。</li><li>计算光照(阴影、明暗…)</li></ol><p>根据上一步插值后的片元信息，片元着色器计算该片元的输出颜色 虽然片元着色器可以完成很多重要效果，但它的局限在于，它<strong>仅可以影响单个片元</strong>。也就是说，当执行片元着色器时，它不可以将自己的任何结果直接发送给它的邻居们。当然导数信息例外。</p><h5 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h5><ol><li>决定每个片元的可见性。这涉及了很多测试工作，例如深度测试，模板<strong>测试</strong>等。</li><li>如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者所是<strong>混合</strong>。</li></ol><p>片元-&gt; 模板测试-&gt;深度测试-&gt;混合-&gt;颜色缓冲区</p><blockquote><p>模板测试<br>模板测试，可以作为一种丢弃片元的辅助方法，与之相关的是模板缓冲。如果开启了模板测试，GPU会首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取到（使用读取掩码）的参考值进行比较，这个比较函数可以是由开发者指定的，例如小于时舍弃该片元，或者大于等于时舍弃。如果这个片元没有通过这个测试，该片元就会被舍弃。不管一个片元有没有通过模板测试，我们都可以根据模板测试和下面的深度测试结果来修改模板缓冲区，这个修改操作也是由开发者指定的。开发者可以设置不同结果下的修改操作，例如，在失败时模板缓冲区保持不变，通过时将模板缓冲区中对应位置的值加1等。模板测试通常用于限制渲染的区域。另外模板测试还有一些更高级的用法，如渲染阴影，轮廓渲染等。</p><p>深度测试<br>如果开启了深度测试，GPU会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。这个比较函数也是由开发者设置的。通常如果这个片元的深度值大于等于当前深度缓冲区中的值，那么就会舍弃它。因为我们总想只显示出离摄像机最近的物体，而那些被其他物体遮挡的就不需要出现在屏幕上。如果这个片元没有通过这个测试，该片元就会被舍弃。和模板测试不同的是，如果一个片元没有通过深度测试，它就没有权利更改深度缓冲区中的值。而如果它通过了测试，开发者还可以指定是否要用这个片元的深度值覆盖掉原有的深度值，这是通过开启/关闭<strong>深度写入</strong>来做到的。</p><p>混合<br>为什么需要混合？渲染过程是一个物体接着一个物体画到屏幕上的。而每个像素的颜色信息被存储在一个名为颜色缓冲的地方。因此，当我们执行这次渲染时，颜色缓冲中往往已经有了上次渲染之后的颜色结果，那么我们是使用这次渲染得到的颜色完全覆盖掉之前的结果，还是进行其他处理？这就是混合需要解决的问题。对于不透明物体，开发者可以关闭混合操作。但对于不透明物体，我们就需要使用混合操作来让这个物体看起来是透明的。</p></blockquote><h3 id="CPU与GPU"><a href="#CPU与GPU" class="headerlink" title="CPU与GPU"></a>CPU与GPU</h3><p>CPU在内存中建立以下资源</p><ul><li>顶点定义</li><li>顶点缓存</li><li>索引缓存</li><li>贴图</li><li>摄像机</li><li>投影</li></ul><p>CPU从内存中发送以下资源到显存中供GPU使用</p><ul><li>顶点定义</li><li>顶点缓存</li><li>索引缓存</li><li>贴图</li><li>坐标系变换矩阵</li><li>渲染状态</li><li>贴图采样方式</li></ul><h4 id="GPU渲染管线理解"><a href="#GPU渲染管线理解" class="headerlink" title="GPU渲染管线理解"></a>GPU渲染管线理解</h4><p><img src="./o4YBAFtVNLGART11AADOMqy6xRY961.jpg" alt="Alt text"></p><p><a href="https://www.cnblogs.com/timlly/p/11471507.html" target="_blank" rel="noopener">深入GPU硬件架构及运行机制</a></p><h2 id="数学相关具体处理过程"><a href="#数学相关具体处理过程" class="headerlink" title="数学相关具体处理过程"></a>数学相关具体处理过程</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>视锥体（view frustum）<br>frustum(截头锥体)</p><h3 id="坐标转换过程"><a href="#坐标转换过程" class="headerlink" title="坐标转换过程"></a>坐标转换过程</h3><p>物体空间(object space)-&gt;世界空间(World Space)-&gt;观察空间(View Space)-&gt;裁剪空间(clip space)-&gt;屏幕空间(Screen Space)</p><h4 id="NDC-Normalized-Device-Coordinate-归一化设备坐标"><a href="#NDC-Normalized-Device-Coordinate-归一化设备坐标" class="headerlink" title="NDC(Normalized Device Coordinate)归一化设备坐标"></a>NDC(Normalized Device Coordinate)归一化设备坐标</h4><p>在这一步会进行一个叫齐次除法的步骤，说白了就是各个点（x,y,z,w）会除以w的值（注：计算机图形学中经常使用四元数代表一个点，叫齐次空间，齐次点等 ）<br><img src="./20180524234721665.jpg" alt="Alt text"><br><img src="./2018052423464776.jpg" alt="Alt text"></p><h4 id="屏幕空间（Screen-Space）"><a href="#屏幕空间（Screen-Space）" class="headerlink" title="屏幕空间（Screen Space）"></a>屏幕空间（Screen Space）</h4><p>pixelWidth:屏幕横向分辨率<br>pixelHeight:屏幕纵向分辨率<br>OpenGL规范<br><img src="./20180525000554600.jpg" alt="OpenGL规范"><br>DirectX规范<br><img src="./20180525000613422.jpg" alt="DirectX规范"></p><p>screenx={clipx<em>pixelWidth/(2</em>clipw)}+pixelWidth/2<br>screeny={clipy<em>pixelHeight/(2</em>clipw)}+pixelHeight/2</p><h3 id="Vertex-Shader-amp-Fragment-Shader"><a href="#Vertex-Shader-amp-Fragment-Shader" class="headerlink" title="Vertex Shader &amp; Fragment Shader"></a>Vertex Shader &amp; Fragment Shader</h3><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>将物体从<strong>物体空间</strong>-&gt;<strong>世界空间</strong>-&gt;<strong>观察空间</strong>-&gt;<strong>裁剪空间</strong>就是顶点着色器的工作。</p><blockquote><ol><li>将物体空间的数据（点）作为顶点着色器的输入</li><li>将所有在自己范围中的点全部遍历一遍，就是每个点都会算进行加工</li><li>高度可编程配置！</li></ol></blockquote><h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><p> 将裁剪空间中的点从<strong>裁剪空间</strong>-&gt;<strong>屏幕空间</strong>就是片元着色器的工作。<br>片元着色器会返回一个四元数-（r,g,b,a）-&gt;分别为（red&lt;红&gt;，green&lt;绿&gt;，blue&lt;蓝&gt;，alpha&lt;透明度&gt;）</p><blockquote><ol><li>将裁减空间的数据（点）作为片元着色器的输入</li><li>将所有在自己范围中的像素全部遍历一遍（三角遍历Rasterizer—-Triangle Traversal），就是每个片元（像素）都会运算进行加工。</li><li>高度可编程配置！</li></ol></blockquote><h2 id="Shader-1"><a href="#Shader-1" class="headerlink" title="Shader"></a>Shader</h2><h3 id="简单的Shader-Demo"><a href="#简单的Shader-Demo" class="headerlink" title="简单的Shader Demo"></a>简单的Shader Demo</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Test/Shader"</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</span><br><span class="line">LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vertex vert//告诉编译器 顶点着色器叫什么名字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> fragment frag//告诉编译器 片元着色器叫什么名字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include "UnityCG.cginc"//包含内置文件，方便写代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> appdata</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex : POSITION;<span class="comment">//物体坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> v2f</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex : SV_POSITION;<span class="comment">//裁剪空间坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)<span class="comment">//顶点着色器，以物体坐标为输入（appdata下的vertex）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.vertex = UnityObjectToClipPos(v.vertex);<span class="comment">//将物体坐标变换到裁剪空间</span></span><br><span class="line"><span class="keyword">return</span> o;<span class="comment">//返回裁剪空间的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target<span class="comment">//片元着色器，以裁剪空间数据作为输入（上面顶点着色器的输出）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fixed4 col = fixed4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//定义一个白色</span></span><br><span class="line"><span class="keyword">return</span> col;<span class="comment">//返回白色</span></span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h3><p>UnityObjectToClipPos()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> float4 <span class="title">UnityObjectToClipPos</span><span class="params">(in float3 pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// More efficient than computing M*VP matrix product</span></span><br><span class="line">   <span class="keyword">return</span> mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, float4(pos, <span class="number">1.0</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> float4 <span class="title">UnityObjectToClipPos</span><span class="params">(float4 pos)</span> <span class="comment">// overload for float4; avoids "implicit truncation" warning for existing shaders</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UnityObjectToClipPos(pos.xyz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unity_ObjectToWorld是物体空间到世界空间的转换矩阵mul()矩阵乘法内置函数。<br>UNITY_MATRIX_VP（观察空间和裁剪空间合一起了），乘完后将从世界空间变换到裁剪空间。</p><p>完全手动自定义计算的话，这么写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float4 <span class="title">UnityObjectToClipPos</span><span class="params">(in float3 pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">float4 objectSpaceData = float4(pos, <span class="number">1.0f</span>);</span><br><span class="line">float4 worldSpaceData = mul(unity_ObjectToWorld, objectSpaceData);</span><br><span class="line">float4 viewSpaceData = mul(UNITY_MATRIX_V, worldSpaceData);</span><br><span class="line">float4 clipSpaceData = mul(UNITY_MATRIX_P，viewSpaceData );</span><br><span class="line"><span class="keyword">return</span> clipSpaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/SouthBegonia/p/11564407.html" target="_blank" rel="noopener">https://www.cnblogs.com/SouthBegonia/p/11564407.html</a><br><a href="https://blog.csdn.net/AvatarForTest/article/details/80438344" target="_blank" rel="noopener">https://blog.csdn.net/AvatarForTest/article/details/80438344</a><br><a href="http://m.elecfans.com/article/713834.html" target="_blank" rel="noopener">http://m.elecfans.com/article/713834.html</a><br><a href="https://juejin.im/post/6844903975712489485" target="_blank" rel="noopener">https://juejin.im/post/6844903975712489485</a><br>《Unity Shader入门精要》</p>]]></content>
      
      
      <categories>
          
          <category> CG&amp;Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【加载】Asset bundle</title>
      <link href="2020/10/25/Load-AssetBundle/"/>
      <url>2020/10/25/Load-AssetBundle/</url>
      
        <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h4 id="从资源的角度"><a href="#从资源的角度" class="headerlink" title="从资源的角度"></a>从资源的角度</h4><p>它是一个<strong>存在于硬盘上的文件</strong>。可以称之为<strong>压缩包</strong>。这个压缩包可以认为是一个文件夹，里面包含了多个文件。这些文件可以分为两类：serialized file 和 resource files。（序列化文件和源文件）</p><ul><li>serialized files：资源被打碎放在一个对象中，最后统一被写进一个单独的文件（只有一个）。相当于是一个头文件，里面记录了关于这个AB的相关信息，当我们调用<strong>LoadFromFile</strong>接口加载AB的时候实际上就是去加载的这一部分信息。这部分信息在Profiler里面的SerilizeField选项里。</li><li>resource files：某些二进制资源（图片、声音）被单独保存，方便快速加载</li></ul><h4 id="从API的角度"><a href="#从API的角度" class="headerlink" title="从API的角度"></a>从API的角度</h4><p>它是一个AssetBundle对象，我们可以通过代码从一个特定的压缩包加载出来的对象。这个对象包含了所有我们当初添加到这个压缩包里面的内容，我们可以通过这个对象加载出来使用。</p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ol><li>AssetBundle是一个压缩包包含模型、贴图、预制体、声音、甚至整个场景，可以在游戏运行的时候被加载；</li><li>AssetBundle自身保存着互相的依赖关系；</li><li>压缩包可以使用LZMA和LZ4压缩算法，减少包大小，更快的进行网络传输；</li><li>把一些可以下载内容放在AssetBundle里面，可以减少安装包的大小；</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);</span><br><span class="line"></span><br><span class="line">AssetBundle ab = AssetBundle.LoadFromFile(<span class="string">"AssetBundles/scene/wall.unity3d"</span>);</span><br><span class="line">GameObject wallPrefab = ab.LoadAsset&lt;GameObject&gt;(<span class="string">"CubeWall"</span>);</span><br><span class="line">Instantiate(wallPrefab);</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle.LoadFromMemoryAsync</span><br><span class="line">AssetBundle.LoadFromFile</span><br><span class="line">WWW.LoadFromCacheOrDownload</span><br><span class="line">UnityWebRequest</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一般</span><br><span class="line">T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</span><br><span class="line">GameObject</span><br><span class="line">GameObject gameObject =</span><br><span class="line">loadedAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);</span><br><span class="line">所有资源</span><br><span class="line">Unity.Object[] objectArray =</span><br><span class="line">loadedAssetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure><h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><h3 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h3><ol><li>把经常更新的资源放在一个单独的包里面，跟不经常更新的包分离</li><li>把需要同时加载的资源放在一个包里面</li><li>可以把其他包共享的资源放在一个单独的包里面</li><li>把一些需要同时加载的小资源打包成一个包</li><li>如果对于一个同一个资源有两个版本，可以考虑通过后缀来区分  v1  v2  v3  unity3dv1 unity3dv2</li></ol><h4 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h4><p>a. 一个UI界面或者所有UI界面一个包（这个界面里面的贴图和布局信息一个包）<br>b. 一个角色或者所有角色一个包（这个角色里面的模型和动画一个包）<br>c. 所有的场景所共享的部分一个包（包括贴图和模型）</p><h4 id="按照类型分组"><a href="#按照类型分组" class="headerlink" title="按照类型分组"></a>按照类型分组</h4><p>所有<strong>声音</strong>资源打成一个包，所有<strong>shader</strong>打成一个包，所有<strong>模型</strong>打成一个包，所有材质打成一个包</p><h4 id="按照使用分组"><a href="#按照使用分组" class="headerlink" title="按照使用分组"></a>按照使用分组</h4><p>把在某一时间内使用的所有资源打成一个包。可以按照关卡分，一个关卡所需要的所有资源包括角色、贴图、声音等打成一个包。也可以按照场景分，一个场景所需要的资源一个包</p><h3 id="依赖打包"><a href="#依赖打包" class="headerlink" title="依赖打包"></a>依赖打包</h3><p>(Mat + Cube1) (Mat + Cube2)<br>(Mat) (Cube1) (Cube2)<br>Unity会自动识别，共享的依赖如果已经单独打包，则不会重复打包</p><h3 id="Build-AssetBundles"><a href="#Build-AssetBundles" class="headerlink" title="Build AssetBundles"></a>Build AssetBundles</h3><ol><li>Build的路径（随意只要是在硬盘上都可以的）</li><li>BuildAssetBundleOptions<br>BuildAssetBundleOptions.None：使用LZMA算法压缩，压缩的包更小，但是加载时间更长。使用之前需要整体解压。一旦被解压，这个包会使用LZ4重新压缩。使用资源的时候不需要整体解压。在下载的时候可以使用LZMA算法，一旦它被下载了之后，它会使用LZ4算法保存到本地上。<br>BuildAssetBundleOptions.UncompressedAssetBundle：不压缩，包大，加载快<br>BuildAssetBundleOptions.ChunkBasedCompression：使用LZ4压缩，压缩率没有LZMA高，但是我们可以加载指定资源而不用解压全部。</li></ol><blockquote><p> 注意使用LZ4压缩，可以获得可以跟不压缩想媲美的加载速度，而且比不压缩文件要小。</p></blockquote><h2 id="LoadAssetBundles"><a href="#LoadAssetBundles" class="headerlink" title="LoadAssetBundles"></a>LoadAssetBundles</h2><h3 id="LoadFromMemoryAsync"><a href="#LoadFromMemoryAsync" class="headerlink" title="LoadFromMemoryAsync"></a>LoadFromMemoryAsync</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">LoadFromMemoryAsync</span>(<span class="params"><span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> createRequest;</span><br><span class="line">        AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">        <span class="keyword">var</span> prefab = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LoadFromFile"><a href="#LoadFromFile" class="headerlink" title="LoadFromFile"></a>LoadFromFile</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function">function <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle</span><br><span class="line">            = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">"myassetBundle"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (myLoadedAssetBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Failed to load AssetBundle!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LoadFromCacheOrDownload"><a href="#LoadFromCacheOrDownload" class="headerlink" title="LoadFromCacheOrDownload"></a>LoadFromCacheOrDownload</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromCacheOrDownloadExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Caching.ready)</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> www = WWW.LoadFromCacheOrDownload(<span class="string">"http://myserver.com/myassetBundle"</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> www;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">string</span>.IsNullOrEmpty(www.error))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(www.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = www.assetBundle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> asset = myLoadedAssetBundle.mainAsset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> uri = <span class="string">"file:///"</span> + Application.dataPath + <span class="string">"/AssetBundles/"</span> + assetBundleName;</span><br><span class="line">    UnityEngine.Networking.UnityWebRequest request</span><br><span class="line">        = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.Send();</span><br><span class="line">    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"Cube"</span>);</span><br><span class="line">    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"Sprite"</span>);</span><br><span class="line">    Instantiate(cube);</span><br><span class="line">    Instantiate(sprite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FromFileABLoader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AssetBundle cubeAB;</span><br><span class="line">    <span class="keyword">string</span> abPath = <span class="string">"Assets/AssetBundles/waterobjs/"</span>;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> ABPath = Application.dataPath + <span class="string">"/AssetBundles"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LoadABFromFile();</span></span><br><span class="line">        <span class="comment">//StartCoroutine(LoadABFromMemoryAsync());</span></span><br><span class="line">        LoadABFromMemory();</span><br><span class="line">        <span class="comment">//AssetBundle matAB = AssetBundle.LoadFromFile("Assets/AssetBundles/watermat.asbd");</span></span><br><span class="line">        <span class="keyword">if</span> (cubeAB != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject cubePrefab = cubeAB.LoadAsset&lt;GameObject&gt;(<span class="string">"cube"</span>);</span><br><span class="line">            Instantiate(cubePrefab);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object[] objABs = cubeAB1.LoadAllAssets();</span></span><br><span class="line">        <span class="comment">//Debug.Log(objABs[0]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.M))</span><br><span class="line">        &#123;</span><br><span class="line">            AssetBundle.LoadFromFile(<span class="string">"Assets/AssetBundles/watermat.asbd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadABFromFile</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        cubeAB = AssetBundle.LoadFromFile(abPath + <span class="string">"cube.asbd"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">LoadABFromMemoryAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AssetBundleCreateRequest cubeRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(abPath + <span class="string">"cube.asbd"</span>));</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> cubeRequest;</span><br><span class="line">        cubeAB = cubeRequest.assetBundle;</span><br><span class="line">        GameObject cubePrefab = cubeAB.LoadAsset&lt;GameObject&gt;(<span class="string">"cube"</span>);</span><br><span class="line">        Instantiate(cubePrefab);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadABFromMemory</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AssetBundleCreateRequest cubeRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(abPath + <span class="string">"cube.asbd"</span>));</span><br><span class="line">        cubeAB = cubeRequest.assetBundle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h3><blockquote><p><strong>若把Start()函数声明成返回IEnumrator，编译器会自动将Start的调用处理成协程的模式</strong></p><h3 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h3><h3 id="WWW-LoadFromCacheOrDownload"><a href="#WWW-LoadFromCacheOrDownload" class="headerlink" title="WWW.LoadFromCacheOrDownload"></a>WWW.LoadFromCacheOrDownload</h3><p>Loading an AB from a remote location will automatically cache the AssetBundles. If the AssetBundle is compressed, a worker thread will spin up to decompress the bundle and write it to the cache. Once a bundle has been decompressed and cached, it will load exactly like AssetBundle.LoadFromFile .</p><h3 id="UnityWebRequest-1"><a href="#UnityWebRequest-1" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h3><p>从服务器下载</p><ol><li>NetBox可以在本地启动服务器，把当前目录作为服务器端的网站</li></ol></blockquote><h3 id="同步和异步的优缺点"><a href="#同步和异步的优缺点" class="headerlink" title="同步和异步的优缺点"></a>同步和异步的优缺点</h3><p>Ref: <a href="https://blog.csdn.net/qq_40093529/article/details/85290686" target="_blank" rel="noopener">https://blog.csdn.net/qq_40093529/article/details/85290686</a><br>异步<br>优点：速度快，与主线程无关，<br>缺点：调用比较麻烦，因为你不知道啥时候你的资源准备好了，最好的做法也是使用回调，这样回调就会很多，很乱个人感觉管理起来很不舒服。</p><p>同步<br>优点：管理起来方便，而且资源准备好了是可以及时返回的，<br>缺点：是没有异步快<br>综合上诉，最终我选择了 同步，因为我不希望代码不整洁，也不希望写太多的回调函数来通知调用者，资源准备妥当了。那么问题来了，如何解决同步的缺点呢。也就是卡主线程。之前一直以为corotine这玩意可以帮到我们。但是当我深入理解了coroutine以后发现他其实也是在主线程中的。最终我选择了使用c# 的多线程机制来解决这个问题。</p><h2 id="加载Manifests"><a href="#加载Manifests" class="headerlink" title="加载Manifests"></a>加载Manifests</h2><p>加载Manifests文件可以处理资源的依赖<br>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);<br>AssetBundleManifest manifest =<br>assetBundle.LoadAsset<AssetBundleManifest>(“AssetBundleManifest”);<br>string[] dependencies = manifest.GetAllDependencies(“assetBundle”); //Pass the name of the bundle you want the dependencies for.<br>foreach(string dependency in dependencies)<br>{<br>    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));<br>}</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>卸载有两个方面</p><ol><li>减少内存使用</li><li>有可能导致丢失<br>所以什么时候去卸载资源<h4 id="AssetBundle-Unload-true"><a href="#AssetBundle-Unload-true" class="headerlink" title="AssetBundle.Unload(true)"></a>AssetBundle.Unload(true)</h4></li></ol><p>When unloadAllLoadedObjects is true, all objects that were loaded from this bundle will be destroyed as well. If there are GameObjects in your Scene referencing those assets, the references to them will become missing.</p><p>卸载所有资源，即使有资源被使用着</p><pre><code>1. 在关卡切换、场景切换2. 资源没被用的时候调用</code></pre><h4 id="AssetBundle-Unload-false"><a href="#AssetBundle-Unload-false" class="headerlink" title="AssetBundle.Unload(false)"></a>AssetBundle.Unload(false)</h4><p>When unloadAllLoadedObjects is false, compressed file data inside the bundle itself will be freed, but any instances of objects loaded from this bundle will remain intact.</p><p>If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways:</p><ol><li>先去除对不想要的Objects的引用（包括场景和代码当中），然后调用 Resources.UnloadUnusedAssets.</li><li>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.</li></ol><h2 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h2><p>CRC MD5 SHA1<br>相同点：<br>CRC、MD5、SHA1都是通过对数据进行计算，来生成一个校验值，该校验值用来校验数据的完整性。<br>不同点：</p><ol><li>算法不同。CRC采用多项式除法，MD5和SHA1使用的是替换、轮转等方法；</li><li>校验值的长度不同。CRC校验位的长度跟其多项式有关系，一般为16位或32位；MD5是16个字节（128位）；SHA1是20个字节（160位）；</li><li>校验值的称呼不同。CRC一般叫做CRC值；MD5和SHA1一般叫做哈希值（Hash）或散列值；</li><li>安全性不同。这里的安全性是指检错的能力，即数据的错误能通过校验位检测出来。CRC的安全性跟多项式有很大关系，相对于MD5和SHA1要弱很多；MD5的安全性很高，不过大概在04年的时候被山东大学的王小云破解了；SHA1的安全性最高。</li><li>效率不同，CRC的计算效率很高；MD5和SHA1比较慢。</li><li>用途不同。CRC一般用作通信数据的校验；MD5和SHA1用于安全（Security）领域，比如文件校验、数字签名等。</li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>依赖包重复问题<br>a. 把需要共享的资源打包到一起<br>b. 分割包，这些包不是在同一时间使用的<br>c. 把共享部分打包成一个单独的包</li><li>图集重复问题<br>在Unity当中，Sprite2D会被打包到一个图集当中（由Packing Tag决定）。如果不指定PackingTag，Sprite会打包到同一个图集当中。一个Sprite打包到AssetBundle中时，它所在的整个图集都会被打包进去。<br>解决方法：确保同一个图集当中的图片打包到同一个AssetBundle当中去。</li><li>Android贴图问题</li><li>iOS文件处理重复fixed in Unity 5.3.2p2.</li></ol><h2 id="UnityAssetBundleBrowserTool"><a href="#UnityAssetBundleBrowserTool" class="headerlink" title="UnityAssetBundleBrowserTool"></a>UnityAssetBundleBrowserTool</h2><h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><p>Build的时候，该文件夹下的所有东西会被原封不动地打包到我们的安装包当中。<br>一般放一些二进制文件、 AssetBundles。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asset </tag>
            
            <tag> 加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渲染】Draw Call与Batching(合批)</title>
      <link href="2020/10/25/U3D-Draw-Call-Batching/"/>
      <url>2020/10/25/U3D-Draw-Call-Batching/</url>
      
        <content type="html"><![CDATA[<h2 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>To draw a GameObject on the screen, the engine has to issue a draw call to the graphics API (such as OpenGL or Direct3D).<br><strong>每次引擎准备数据并通知GPU的过程称为一次Draw Call</strong>。<br><strong>The command that tells the GPU to render a certain set of vertices as triangles with a certain state (shaders, blend state and so on)</strong></p><h3 id="耗时原因"><a href="#耗时原因" class="headerlink" title="耗时原因"></a>耗时原因</h3><p>在没有进行拼合的情况下，引擎准备数据并通知GPU的过程是逐个物体进行的，对于每个物体，不只GPU的渲染，CPU重新<strong>设置材质/Shader</strong>也是一项非常耗时的操作。</p><p><strong>Draw Call耗时主要是CPU端的耗时——</strong><br>Unity3d官方 - Draw calls are often resource-intensive(资源密集型的，大量占用资源的), with the graphics API doing significant work for every draw call, causing <strong>performance overhead(开销)on the CPU side</strong>. This is mostly caused <strong>by the state changes done between the draw calls</strong> (such as switching to a different Material), which causes resource-intensive validation and translation steps in the graphics driver.</p><p>There are some real costs with making draw calls, it requires <strong>setting up a bunch of state</strong> (<strong>which set of vertices to use, what shader to use and so on</strong>), and state changes have a cost both on the hardware side (updating a bunch of registers) and on the driver side (validating and translating your calls that set state).</p><p>为何要减少DrawCall？<br><strong>The main reason to make fewer draw calls is that graphics hardware can transform and render triangles much faster than you can submit them.</strong> If you submit few triangles with each call, you will be completely bound by the CPU and the GPU will be mostly idle. The CPU won’t be able to feed the GPU fast enough.</p><p> <strong>The main cost of draw calls only apply if each call submits too little data</strong>, since this will cause you to be CPU-bound, and stop you from utilizing the hardware fully.</p><blockquote><p>Making a single draw call with two triangles is cheap, but if you submit too little data with each call, you won’t have enough CPU time to submit as much geometry to the GPU as you could have.</p><p>(我还不太懂的)draw calls can also cause the command buffer to be flushed, but in my experience that usually happens when you call SwapBuffers, not when submitting geometry. Video drivers generally try to buffer as much as they can get away with (several frames sometimes!) to squeeze out as much parallelism from the GPU as possible.</p></blockquote><h3 id="方法与建议"><a href="#方法与建议" class="headerlink" title="方法与建议"></a>方法与建议</h3><p>目前，我们建议DrawCall的主体范围(5%~95%) 控制在[0,150]范围内。</p><p>方法：减少所渲染物体的材质种类，并通过Draw Call Batching 来减少其数量。</p><h3 id="Note：游戏性能并非Draw-Call越小越好。"><a href="#Note：游戏性能并非Draw-Call越小越好。" class="headerlink" title="Note：游戏性能并非Draw Call越小越好。"></a>Note：游戏性能并非Draw Call越小越好。</h3><p>决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的<strong>总线带宽</strong>。当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。</p><h2 id="Draw-call-batching"><a href="#Draw-call-batching" class="headerlink" title="Draw call batching"></a>Draw call batching</h2><blockquote><p>You can enable or disable Dynamic and Static batching through Unity’s Player settings under Other Settings.</p><p>Built-in Batching的优劣：<br>Built-in batching has several <strong>benefits</strong> compared to manually merging GameObjects together; most notably, GameObjects <strong>can still be culled individually</strong>.<br>However, it also has some <strong>downsides</strong>; <strong>static</strong> batching incurs <strong>memory and storage overhead</strong>, and <strong>dynamic</strong> batching incurs some <strong>CPU overhead</strong>.</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="Dynamic-batching-Meshes"><a href="#Dynamic-batching-Meshes" class="headerlink" title="Dynamic batching (Meshes)"></a>Dynamic batching (Meshes)</h4><p>条件:</p><ol><li>share the same Material(共享相同的材质<strong>实例</strong>)</li><li>fulfill other criteria<ul><li>Batching dynamic GameObjects has certain overhead per vertex, so batching is applied only to Meshes containing no more than 900 vertex attributes, and no more than 300 vertices.</li><li>GameObjects are not batched if they contain mirroring on the transform</li><li>Using different <strong>Material instances</strong> causes GameObjects not to batch together, even if they are essentially the same. The exception is shadow caster rendering.</li><li>GameObjects with lightmaps have additional renderer parameters: lightmap index and offset/scale into the lightmap. Generally, dynamic lightmapped GameObjects should point to exactly the same lightmap location to be batched.</li><li>Multi-pass Shaders break batching.</li></ul></li></ol><blockquote><p>如果Draw Call的开销比合批要低, 那么合批就没有意义了. Dynamic batching works by transforming all GameObject vertices into world space on the CPU, so it is only an advantage if that work is smaller than doing a draw call. The resource requirements of a draw call depends on many factors, primarily the graphics API used. For example, on consoles or modern APIs like Apple Metal, the draw call overhead is generally much lower, and often dynamic batching cannot be an advantage at all.</p></blockquote><h4 id="Dynamic-batching-Particle-Systems-Line-Renderers-Trail-Renderers"><a href="#Dynamic-batching-Particle-Systems-Line-Renderers-Trail-Renderers" class="headerlink" title="Dynamic batching (Particle Systems, Line Renderers, Trail Renderers)"></a>Dynamic batching (Particle Systems, Line Renderers, Trail Renderers)</h4><p>ParticleSystem等属于<strong>Components with geometry that Unity generates dynamically(带有动态生成的几何图形的组件)</strong></p><p>具体处理方式:</p><ul><li>For each compatible renderer type, Unity builds all batchable content into 1 large Vertex Buffer.</li><li>The renderer sets up the Material state for the batch.</li><li>Unity binds the Vertex Buffer to the Graphics Device.</li><li>For each Renderer in the batch, Unity updates the offset into the Vertex Buffer, and then submits a new draw call.</li></ul><p>When measuring the cost of the Graphics Device calls, the slowest part of rendering a Component is the set-up of the Material state. Submitting draw calls at different offsets into a shared Vertex Buffer is very fast by comparison.</p><h4 id="Static-batching"><a href="#Static-batching" class="headerlink" title="Static batching"></a>Static batching</h4><p><strong>本质上是用空间换时间,要在渲染耗时与内存占用之间做权衡.</strong></p><p>Static batching allows the engine to reduce draw calls for geometry of any size provided it <strong>shares the same material</strong>, and <strong>does not move</strong>.</p><ul><li>优点：more efficient than dynamic batching (it does not transform vertices on the CPU)</li><li>缺点：uses more memory.</li></ul><blockquote><p>Using static batching requires <strong>additional memory for storing the combined geometry</strong>. If several GameObjects shared the same geometry before static batching, then a copy of geometry is created for each GameObject, either in the Editor or at runtime. This might not always be a good idea; sometimes you have to sacrifice rendering performance by avoiding static batching for some GameObjects to keep a smaller memory footprint. For example, marking trees as static in a dense forest level can have serious memory impact.</p></blockquote><p>内部实现: Internally, static batching works by transforming the static GameObjects into world space and building one shared vertex and index buffer for them.</p><h3 id="怎样才能合批——Material-set-up-for-batching"><a href="#怎样才能合批——Material-set-up-for-batching" class="headerlink" title="怎样才能合批——Material set-up for batching"></a>怎样才能合批——Material set-up for batching</h3><p>Only GameObjects sharing the same Material can be batched together. Therefore, if you want to achieve good batching, you should aim to share Materials among as many different GameObjects as possible.</p><p>使用图集合并Material<br>If you have two identical Materials which differ only in Texture, you can combine those Textures into a single big Texture. This process is often called Texture atlasing (see the Wikipedia page on Texture atlases for more information). Once Textures are in the same atlas, you can use a single Material instead.</p><blockquote><p>If you need to access shared Material properties from the scripts, then it is important to note that <strong>modifying Renderer.material creates a copy of the Material</strong>. Instead, use Renderer.sharedMaterial to keep Materials shared.</p><p>Shadow casters can often be batched together while rendering, even if their Materials are different. Shadow casters in Unity can use dynamic batching even with different Materials, as long as the values in the Materials needed by the shadow pass are the same. For example, many crates could use Materials with different Textures on them, but for the shadow caster rendering the textures are not relevant, so in this case they can be batched together.</p></blockquote><h4 id="Texture-altas概念"><a href="#Texture-altas概念" class="headerlink" title="Texture altas概念"></a>Texture altas概念</h4><p>In computer graphics, a texture atlas (also called a sprite sheet or an image sprite) is an image containing multiple smaller images, usually packed together to reduce overall dimensions.<br><strong>Benefits</strong><br>In an application where many small textures are used frequently, it is often more efficient to store the textures in a texture atlas which is treated as a single unit by the graphics hardware. This reduces the overhead of a context switch by increasing memory locality.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.uwa4d.com/archives/Simple_PA_Rendering.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Simple_PA_Rendering.html</a><br><a href="https://blog.uwa4d.com/archives/optimzation_cpu.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/optimzation_cpu.html</a><br><a href="https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive" target="_blank" rel="noopener">https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive</a><br><a href="https://docs.unity3d.com/Manual/DrawCallBatching.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br><a href="https://en.wikipedia.org/wiki/Texture_atlas" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Texture_atlas</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Draw Call </tag>
            
            <tag> Batching </tag>
            
            <tag> 渲染 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OS】Shell on UNIX-like systems</title>
      <link href="2020/10/25/OS-Shell-on-UNIX-like-systems/"/>
      <url>2020/10/25/OS-Shell-on-UNIX-like-systems/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-overview"><a href="#Shell-overview" class="headerlink" title="Shell overview"></a>Shell overview</h1><p>shell即“壳”，是用户和操作系统（系统内核）之间的接口程序，是个命令解释程序，拥有自己内建的 shell 命令集。提示符下输入的每个命令都由shell先解释然后传给操作系统内核。</p><p>Linux下有Bash、Zsh等，Windows下有CMD、PowerShell等，都是Shell。</p><h2 id="Linux中Shell的类型"><a href="#Linux中Shell的类型" class="headerlink" title="Linux中Shell的类型"></a>Linux中Shell的类型</h2><p>Linux 中的 shell 有很多类型，其中最常用的几种是: Bourne shell (sh)、C shell (csh) 和 Korn shell (ksh), 各有优缺点。Bourne shell 是 UNIX 最初使用的 shell，并且在每种 UNIX 上都可以使用, 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。Linux 操作系统缺省的 shell 是Bourne Again shell，它是 Bourne shell 的扩展，简称 Bash，与 Bourne shell 完全向后兼容，并且在Bourne shell 的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p><a href="https://blog.csdn.net/MonMama/article/details/53390610" target="_blank" rel="noopener">https://blog.csdn.net/MonMama/article/details/53390610</a><br><a href="https://blog.csdn.net/wenlifu71022/article/details/4069929" target="_blank" rel="noopener">https://blog.csdn.net/wenlifu71022/article/details/4069929</a></p><h1 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h1><p><a href="http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html</a></p><h1 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h1><h1 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h1><h2 id="管理者权限"><a href="#管理者权限" class="headerlink" title="管理者权限"></a>管理者权限</h2><p><strong>sudo命令</strong> - 以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。<br>使用权限：在 /etc/sudoers 中有出现的使用者。</p><p><strong>su</strong>命令为切换用户的命令。</p><p>切换为root用户执行命令：<br> <code>sudo su root</code>或·<code>sudo su</code>: 切换到root用户，不改变当前变量<br> <code>sudo su - root</code>或·<code>sudo su -</code>: 切换到root用户，并获得root的环境变量及执行权限<br>只要当前用户为管理员用户，即可使用sudo切换到root用户，此时输入的密码为当前管理员用户的密码。</p><p>若直接使用命令<code>su root</code>，则需要输入的密码为root用户的密码。输入当前管理员用户的密码会返回 su: Sorry。<br>可以使用管理员权限修改root用户的密码后，再执行<code>su root</code>命令，这样输入刚刚修改好的root密码即可切换到root用户如下图：</p><p><img src="./su_root.png" alt="Alt text"></p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l 文件夹</span><br></pre></td></tr></table></figure><p>权限说明一共10位: drwxrwxrwx<br>第一位 - 文件类型，” + “代表目录，” - “代表非目录。<br>2-4位 - 所有者user的权限说明<br>5-7位 - 组群group的权限说明<br>8-10位 - 其他人other的权限说明</p><p>r代表可读权限，w代表可写权限，x代表可执行权限。</p><blockquote><p>MacOS上，权限说明后可能有 + 或 @<br>‘+’ 表示扩展属性(extended attributes)<br>‘@’ 表示扩展安全信息(extended security information)<br>详情可通过命令 ls -le 或 ls -l@ 查看</p></blockquote><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod o w xxx.xxx</span><br></pre></td></tr></table></figure><p>授予其他人写xxx.xxx这个文件的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod go-rw xxx.xxx</span><br></pre></td></tr></table></figure><p>删除xxx.xxx中组群和其他人的读和写的权限</p><blockquote><p>u 代表所有者（user）<br>g 代表所有者所在的组群（group）<br>o 代表其他人，但不是u和g （other）<br>a 代表全部的人，也就是包括u，g和o</p></blockquote><p>r w x可以换成数字表示：<br>r 对应 4， w 对应 2， x 对应 1<br>rwx 或 - 的任意组合对应的数字是唯一的，所以可用一个数字表示一组rwx权限。<br>如 7 = 4+2+1 表示赋予目录可读可写可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod  -R 777 /var/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h1 id="环境变量相关"><a href="#环境变量相关" class="headerlink" title="环境变量相关"></a>环境变量相关</h1><p>环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或多个应用程序将使用到的信息。Linux是一个多用户的操作系统，每个用户登录系统时都会有一个专用的运行环境。这个默认环境就是一组环境变量的定义。每个用户都可以通过修改环境变量的方式对自己的运行环境进行配置。</p><h2 id="环境变量分类"><a href="#环境变量分类" class="headerlink" title="环境变量分类"></a>环境变量分类</h2><h3 id="对所有用户生效的永久性变量（系统级）"><a href="#对所有用户生效的永久性变量（系统级）" class="headerlink" title="对所有用户生效的永久性变量（系统级）"></a>对所有用户生效的永久性变量（系统级）</h3><p>位置：/etc/profile<br>添加方式：vim打开/etc/ profile文件，用export指令添加环境变量。<br>调用<code>source /etc/profile</code>才能立即生效，否则下次进入此用户生效。</p><h3 id="对单一用户生效的永久性变量（用户级）"><a href="#对单一用户生效的永久性变量（用户级）" class="headerlink" title="对单一用户生效的永久性变量（用户级）"></a>对单一用户生效的永久性变量（用户级）</h3><p>设置方法：在用户主目录”~”下的隐藏文件 “.bashrc”中添加自己想要的环境变量。<br>同样调用<code>source ./.bashrc</code>该文件才会生效。否则只能在下次重进此用户时才能生效。</p><blockquote><ul><li>~/.bash_profile是交互式login方式进入bash shell运行，只会在用户登录的时候读取一次。</li><li>~/ .bashrc是交互式non-login方式进入bash shell运行，在每次打开终端进行一次新的会话时都会读取。<h3 id="临时有效的环境变量（只对当前shell有效）"><a href="#临时有效的环境变量（只对当前shell有效）" class="headerlink" title="临时有效的环境变量（只对当前shell有效）"></a>临时有效的环境变量（只对当前shell有效）</h3>此类环境变量只对当前的shell有效。当我们退出登录或者关闭终端再重新打开时，这个环境变量就会消失。是临时的。<br>设置方法：直接使用export指令添加。 如<code>export PATH=/usr/local/bin:$PATH</code></li></ul></blockquote><h2 id="常用环境变量"><a href="#常用环境变量" class="headerlink" title="常用环境变量"></a>常用环境变量</h2><ul><li>PPID: 是当前进程的父进程的PID</li><li>PWD: 当前工作目录。命令pwd的输出该变量值。</li><li>RANDOM: 随机数变量。每次引用这个变量会得到一个0~32767的随机数。</li><li>SECONDS: 脚本已经运行的时间（以秒为单位）</li><li><p>PATH 指定命令的搜索路径。通过设置环境变量PATH可以让我们运行程序或指令更加方便。</p><blockquote><p>每一个冒号都是一个路径，这些搜索路径都是一些可以找到可执行程序的目录列表。当我们输入一个指令时，shell会先检查命令是否是内部命令，不是的话会再检查这个命令是否是一个应用程序。然后shell会试着从搜索路径，即PATH中寻找这些应用程序。如果shell在这些路径目录里没有找到可执行文件。则会报错。若找到，shell内部命令或应用程序将被分解为系统调用并传给Linux内核。</p></blockquote></li><li><p>SHELL  指当前用户用的是哪种shell</p></li></ul><h2 id="设置环境变量常用的几个指令"><a href="#设置环境变量常用的几个指令" class="headerlink" title="设置环境变量常用的几个指令"></a>设置环境变量常用的几个指令</h2><ul><li>echo - 查看显示环境变量，变量使用时要加上符号“$”<br>  <code>echo $PATH</code></li><li>export - 设置新的环境变量<br><code>export PATH=/usr/local/bin:$PATH</code></li><li>修改环境变量 - 修改环境变量没有指令，可以直接使用环境变量名进行修改。<br><code>MYNAME=&quot;Prin&quot;</code></li><li>env  查看所有环境变量</li><li>set  查看本地定义的所有shell变量</li><li>unset 删除一个环境变量</li><li>readonly 设置只读环境变量<br><code>readonly MYNAME</code></li></ul><h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$variable</span></span><br><span class="line"><span class="variable">$&#123;variable&#125;</span></span><br><span class="line"><span class="string">"<span class="variable">$variable</span>"</span></span><br><span class="line"><span class="string">"<span class="variable">$&#123;variable&#125;</span>"</span></span><br></pre></td></tr></table></figure><h3 id="命令替换：-command"><a href="#命令替换：-command" class="headerlink" title="命令替换：$(command)"></a>命令替换：$(command)</h3><p>命令替换的目的是获取命令的输出、为变量赋值，或对命令的输出做进一步的处理。</p><h1 id="进程相关技巧"><a href="#进程相关技巧" class="headerlink" title="进程相关技巧"></a>进程相关技巧</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A | grep name</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-grep.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-grep.html</a><br>grep 命令用于查找文件里符合条件的字符串。上条命令可用于查找包含特定字符串的进程</p><p>如果出现进程未响应的状况，则查找到进程的PID后，可调用<code>kill -9 PID</code>强制终止进程</p><h1 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>.tar<br>解包：tar xvf FileName.tar<br>打包：tar cvf FileName.tar DirName<br>（注：tar是打包，不是压缩！）</p><p>.gz<br>解压1：gunzip FileName.gz<br>解压2：gzip -d FileName.gz<br>压缩：gzip FileName<br>.tar.gz 和 .tgz<br>解压：tar zxvf FileName.tar.gz<br>压缩：tar zcvf FileName.tar.gz DirName</p><p>.bz2<br>解压1：bzip2 -d FileName.bz2<br>解压2：bunzip2 FileName.bz2<br>压缩： bzip2 -z FileName<br>.tar.bz2<br>解压：tar jxvf FileName.tar.bz2<br>压缩：tar jcvf FileName.tar.bz2 DirName</p><p>.bz<br>解压1：bzip2 -d FileName.bz<br>解压2：bunzip2 FileName.bz<br>压缩： 未知<br>.tar.bz<br>解压：tar jxvf FileName.tar.bz<br>压缩： 未知</p><p>.Z<br>解压：uncompress FileName.Z<br>压缩：compress FileName<br>.tar.Z<br>解压：tar Zxvf FileName.tar.Z<br>压缩：tar Zcvf FileName.tar.Z DirName</p><p>.zip<br>解压：unzip FileName.zip<br>压缩：zip FileName.zip DirName</p><p>.rar<br>解压：rar x FileName.rar<br>压缩：rar a FileName.rar DirName</p><h2 id="zip-unzip-命令"><a href="#zip-unzip-命令" class="headerlink" title="zip / unzip 命令"></a>zip / unzip 命令</h2><p>unzip指令 格式如下：</p><p>//待更</p><p>-d 目录名    将压缩文件解压到指定目录下</p><h1 id="拓展延伸-Console-TTY等"><a href="#拓展延伸-Console-TTY等" class="headerlink" title="拓展延伸 Console, TTY等"></a>拓展延伸 Console, TTY等</h1><p><a href="https://www.zhihu.com/question/26860370" target="_blank" rel="noopener">https://www.zhihu.com/question/26860370</a></p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.iteye.com/blog/henry-cong-1060014" target="_blank" rel="noopener">https://www.iteye.com/blog/henry-cong-1060014</a><br><a href="https://www.jianshu.com/p/09f521c60c30" target="_blank" rel="noopener">https://www.jianshu.com/p/09f521c60c30</a><br><a href="https://blog.csdn.net/Axela30W/article/details/78981749" target="_blank" rel="noopener">https://blog.csdn.net/Axela30W/article/details/78981749</a><br><a href="https://blog.csdn.net/huayangshiboqi/article/details/80150842" target="_blank" rel="noopener">https://blog.csdn.net/huayangshiboqi/article/details/80150842</a></p>]]></content>
      
      
      <categories>
          
          <category> 从硬件到OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> OS </tag>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统下Lua及Luacheck环境配置</title>
      <link href="2020/10/03/Lua-installation-of-luacheck/"/>
      <url>2020/10/03/Lua-installation-of-luacheck/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>说明: 本文描述了windows系统上从Lua环境安装配置到使用luarocks安装luacheck的详细步骤。笔者参考网上的博客进行配置时踩了不少坑，最终整理出一套尽可能简洁且可行的步骤，希望帮到各位伙伴</strong><br><strong>另，笔者后来发现Luacheck在windows上的安装有更简洁的方法，一步即可，甚至不需要配置lua环境，详见文末。</strong></p></blockquote><h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><ul><li>Windows 10 专业版</li><li>Visual Studio 2017 community</li><li>Lua for Windows v5.1.5-52 Released</li><li>Luarocks 2.2.2<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-安装配置Lua环境"><a href="#1-安装配置Lua环境" class="headerlink" title="1. 安装配置Lua环境"></a>1. 安装配置Lua环境</h2>(1) Lua for Windows下载地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases" target="_blank" rel="noopener">https://github.com/rjpcomputing/luaforwindows/releases</a><br>(2) 直接下载<code>LuaForWindows_v5.1.5-52.exe</code>,双击安装(路径等设置按照默认即可)</li></ul><p><img src="./1.png" alt="1"></p><hr><p>(3) 安装好后，环境变量会自动配置好，命令行输入lua，显示结果如下，则配置成功<br><img src="./2.png" alt="Alt text"></p><hr><h2 id="2-安装并升级luarocks"><a href="#2-安装并升级luarocks" class="headerlink" title="2. 安装并升级luarocks"></a>2. 安装并升级luarocks</h2><p>(1) 在下载Lua for windows的网页中往下拉，可以看到LuaRocks updater，分别下载红框中的两个文件，得到<code>luarocks-2.2.2-win32.zip</code>和<code>lfw_luarocks-2.2.2-win32.7z</code><br><img src="./3.png" alt="Alt text"></p><hr><p>(2) 分别解压两个压缩文件，并将<code>lfw_luarocks-2.2.2-win32</code>中的文件全部拷贝到<code>luarocks-2.2.2-win32</code>中，如下图<br><img src="./4.png" alt="Alt text"></p><hr><p>(3) 将文件夹<code>luarocks-2.2.2-win32</code>移动到lua目录下。(若按照本文步骤1安装lua，则目录为C:\Program Files (x86)\Lua)<br>(4) 使用管理员身份运行windows命令提示符（方法：在Windows10系统的搜索框中直接输入命令CMD，在命令提示符上单击右键，选择管理员身份运行）<br><img src="./5.png" alt="Alt text"></p><hr><p>(5) 进入luarocks目录<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Program Files (x86)\Lua\luarocks-<span class="number">2</span>.<span class="number">2</span>.<span class="number">2</span>-win32</span><br></pre></td></tr></table></figure></p><hr><p>(6) 执行<code>install.bat</code>， 显示以下内容表明安装成功<br><img src="./6.png" alt="Alt text"></p><hr><p>(7) 执行<code>lfw_install.bat</code>。（若非管理员身份运行cmd，本步骤会出错）<br>此时，输入luarocks，可看到版本信息为2.2.2，</p><hr><h2 id="3-使用luarocks安装luacheck"><a href="#3-使用luarocks安装luacheck" class="headerlink" title="3. 使用luarocks安装luacheck"></a>3. 使用luarocks安装luacheck</h2><blockquote><p><strong>Note:</strong> luacheck的安装涉及到一些依赖，需要先安装一些其他的模块，包括：argparse, lanes, luafilesystem。（luacheck对所依赖的模块的版本也有一些要求）。</p></blockquote><p>(1) 继续在命令提示符中输入<code>luarocks install argparse</code>示如下信息，表明安装成功。<br><img src="./7.png" alt="Alt text"></p><hr><p>(2) 紧接着 <code>luarocks install luafilesystem</code>（在此之前，其实已经有安装好的luafilesystem模块，因其版本过低，需要重新安装）。<br>此处在编译时报错，信息如下：<br><img src="./8.png" alt="Alt text"><br>这是因为缺乏VC++编译的环境。根据luarocks的readme文档中的说明：</p><blockquote><p>if you want to install rocks, make it a “Visual Studio Command Prompt”</p></blockquote><p>我们需要在Visual Studio Command Prompt下使用luarocks进行相应模块的安装。<br>使用搜索功能搜索相应的快捷方式：<strong>VS 2017的开发人员命令提示符</strong> 或者<strong>Command Prompt for VS 2017</strong>，笔者计算机中其所在位置如下：<br><img src="./10.png" alt="Alt text"><br>同样右键，以管理员方式运行，执行命令<code>luarocks install luafilesystem</code>，则可安装成功。<br><img src="./11.png" alt="Alt text"></p><hr><p>(3) 直接安装luacheck：<code>luarocks install luacheck</code>，此时，luacheck安装成功<br><img src="./12.png" alt="Alt text"></p><hr><h2 id="4-使用测试"><a href="#4-使用测试" class="headerlink" title="4. 使用测试"></a>4. 使用测试</h2><p>将任意lua文件放置在任意位置，使用cmd进入相应目录，输入命令<code>luacheck XXX.lua</code>，即可使用luacheck对lua文件进行检测。<br><img src="./13.png" alt="Alt text"></p><h1 id="最简单的Luacheck配置方法-只需一步"><a href="#最简单的Luacheck配置方法-只需一步" class="headerlink" title="最简单的Luacheck配置方法(只需一步)"></a>最简单的Luacheck配置方法(只需一步)</h1><p>Luacheck的<a href="https://github.com/mpeterv/luacheck" target="_blank" rel="noopener">开源库</a>上提供了Windows 二进制Luacheck.exe文件的<a href="https://github.com/mpeterv/luacheck/releases/download/0.23.0/luacheck.exe" target="_blank" rel="noopener">下载链接</a>，该可执行文件将Luacheck所依赖的Lua，LuaFileSystem，Lualanes程序绑定在一起。因此，直接用命令行调用Luacheck.exe即可使用，甚至不需要配置Lua环境。</p><hr><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p> <a href="https://blog.csdn.net/Stupid_kidofObj/article/details/105043561" target="_blank" rel="noopener">https://blog.csdn.net/Stupid_kidofObj/article/details/105043561</a><br> <a href="https://github.com/mpeterv/luacheck" target="_blank" rel="noopener">https://github.com/mpeterv/luacheck</a></p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渲染】理解伽马校正(Gamma Correction)与Unity的Gamma or Linear workflow</title>
      <link href="2020/09/14/CG-gamma-correction-in-unity/"/>
      <url>2020/09/14/CG-gamma-correction-in-unity/</url>
      
        <content type="html"><![CDATA[<p>By Prin@UWA</p><p>笔者搜集阅读了一些与Gamma校正(Gamma Correction)、sRGB颜色空间等概念相关的资料，在学习相关知识时，由于理解的错误踩了很多坑。本文结合自己的理解，对相关理论以及在Unity中的处理方式进行了整理，希望能帮助刚接触这个知识的同学有一个粗浅的理解。</p><h1 id="伽马校正（Gamma-Correction）"><a href="#伽马校正（Gamma-Correction）" class="headerlink" title="伽马校正（Gamma Correction）"></a>伽马校正（Gamma Correction）</h1><h2 id="存在的原因"><a href="#存在的原因" class="headerlink" title="存在的原因"></a>存在的原因</h2><p>对于Gamma校正存在的原因，在网络上略有争议。汇总各种资料，主要存在以下两种观点：</p><ol><li>历史原因：去的CRT显示器屏幕上显示的颜色对于传递而来的原始值并不是线性的</li><li>人眼对自然亮度感知是非线性的</li></ol><p>笔者认为，以上两种因素是同时存在且不冲突的，都是Gamma校正产生的原因。以下来自<a href="https://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ" target="_blank" rel="noopener">kinematicsoup官网</a>的说法笔者比较认同：</p><blockquote><p>The need for gamma arises for two main reasons: The first is that screens have a non-linear response to intensity. The other is that the human eye can tell the difference between darker shades better than lighter shades. This means that when images are compressed to save space, we want to have greater accuracy for dark intensities at the expense of lighter intensities. Both of these problems are resolved using gamma correction, which is to say the intensity of every pixel in an image is put through a power function. Specifically, gamma is the name given to the power applied to the image.</p></blockquote><p><a href="https://en.wikipedia.org/wiki/Gamma_correction" target="_blank" rel="noopener">Wikipedia-Gamma correction</a>中谈到：</p><blockquote><p>Although gamma encoding was developed originally to compensate for the input–output characteristic of cathode ray tube (CRT) displays, that is not its main purpose or advantage in modern systems.</p></blockquote><p>由此基本可以明确：CRT显示器的历史原因是Gamma Correction的起源，与人眼感知能力等相关的其他因素是Gamma Correction一直延续下来的原因之一。 因此，不能绝对地主张其中一种原因而排斥其他说法。以下是笔者搜集和理解到的对两种原因的解释。</p><h3 id="CRT显示器特性的原因"><a href="#CRT显示器特性的原因" class="headerlink" title="CRT显示器特性的原因"></a>CRT显示器特性的原因</h3><p>此处主要借鉴冯乐乐女神的文章。<br>在早期，CRT几乎是唯一的显示设备。但CRT有个特性，它的输入电压和显示出来的亮度关系不是线性的，而是一个类似幂律（power-law）曲线的关系。也就是说，使用一个电压轰击CRT Monitor屏幕上的一种图层，这个图层就可以发亮，我们就可以看到图像了。但是，人们发现，咦，如果把电压调高两倍，屏幕亮度并没有提高两倍啊！<br>典型的CRT显示器的伽马曲线大致是一个伽马值为2.5的幂律曲线。显示器的这类伽马也称为<strong>display gamma</strong>。</p><p>这个幂律曲线的公式可以简单表述为下式：</p><p>$ \gamma(u) = Au^{\gamma } (u\in \left [  0, 1\right ],\gamma(u) \in \left [  0, 1\right ] )$      <strong>where u is R, G, or B</strong></p><p>一般情况下取A=1，那么，输入一个颜色值(0.5, 0.5, 0.5)，由该公式得到的输出为(0.177, 0.177, 0.177)。也就是说，显示器的Gamma转换会使输入的像素颜色的亮度变低（Darker）。</p><p>由于这个问题的存在，那么图像捕捉设备就需要进行一个<strong>伽马校正(Gamma Correction)</strong>，对显示器的伽玛变换进行<strong>反向补偿</strong>(变亮)。校正使用的伽马叫做<strong>encoding gamma</strong>。<br>所以，一个完整的图像系统需要2个伽马值：</p><ul><li>encoding gamma：它描述了encoding transfer function，即图像设备捕捉到的场景亮度值（scene radiance values）和编码的像素值（encoded pixel values）之间的关系。</li><li>display gamma：它描述了display transfer function，即编码的像素值和显示的亮度（displayed radiance）之间的关系。</li></ul><p>显示系统的处理流程如下图所示：<br><img src="./DiaplaySys.png" alt="Alt text"></p><p><a href="https://zhuanlan.zhihu.com/p/66558476" target="_blank" rel="noopener">PZZZB</a>的图较好地诠释了对应不同Gamma值的幂律曲线之间的关系：<br><img src="./power-law.jpg" alt="Alt text"></p><p>encoding gamma和display gamma的乘积就是真个图像系统的end-to-end gamma。如果这个乘积是1，那么显示出来的亮度就是和捕捉到的真实场景的亮度是成比例的。如果我们没有用一个encoding gamma对shader的输出进行校正，而是直接显示在屏幕上，那么由于display gamma的存在就会使画面失真。<br>虽然现在CRT设备很少见了，但为了保证这种感知一致性（这是它一直沿用至今的很重要的一点），同时也为了对已有图像的兼容性（之前很多图像使用了encoding gamma对图像进行了编码），所以仍在使用这种伽马编码。</p><p>至此可以大致理解对于显示器的Gamma校正的原理。然而，实际问题往往更复杂一些，此处做一个简要提示，感兴趣的同学可以深究。<br>encoding gamma和display gamma的乘积为1的话，可以让显示器精确重现原始场景的视觉条件。但是，原始场景的观察条件和显示的版本之间存在两个差异我们需要乘积不是1的end-to-end gamma，来保证显示的亮度结果在感知上和原始场景是一致的。根据《Real-time Rendering》一书中，推荐的值在电影院这种漆黑的环境中为1.5，在明亮的室内这个值为1.125。</p><blockquote><p>个人电脑使用的一个标准叫sRGB，它使用的encoding gamma大约是0.45（也就是1/2.2）。这个值就是为了配合display gamma为2.5的设备工作的。这样，end-to-end gamma就是0.45 * 2.5 = 1.125了。</p></blockquote><h3 id="人眼感知能力的原因"><a href="#人眼感知能力的原因" class="headerlink" title="人眼感知能力的原因"></a>人眼感知能力的原因</h3><p>人眼对亮度的感知是非线性的。换句话说，<strong>亮度上的线性变化在人眼看来是非均匀的</strong>。从0亮度变到0.01亮度，人眼是可以察觉到的，但从0.99变到1.0，人眼可能就根本差别不出来，觉得它们是一个颜色。人眼对暗部的变化更加敏感，而对亮部变化其实不是很敏感。<br>通过知乎上韩世麟答主分享的<a href="https://www.zhihu.com/question/27467127#answer-10413243" target="_blank" rel="noopener">视频</a>可以对这个问题有一个直观的理解。</p><p><img src="./灰阶关系0.5.jpg" alt="Alt text"></p><p>以下两比较通俗的句话可以帮助读者对这个问题进行理解：</p><ul><li>人心目中（美术中的）看起来中灰的色块，其物理亮度值大约在白色块的20%左右。</li><li>自然界的0.2，在心目中的地位是0.5。</li></ul><p>现实生活中的例子如下图所示：<br><img src="./颜色卡.jpg" alt="Alt text"></p><p>而如果将纯白色块与纯黑色块进行1比1混合，得到的结果在人眼看来是浅灰色。</p><p>符合人的直觉的灰度(或者理解为亮度)均匀变化的情况如下图：<br><img src="./人眼感知.png" alt="Alt text"><br>们看到这张图，会自然而然的认为中间的地方即灰度为0.5的地方。事实上，在线性颜色空间下，也就是实际人看到的中间部分的灰度值约为0.218。</p><p>那么，美术中使用的中间<strong>灰色</strong>应该设置像素值为多少呢？计算机中图片上的值与最终人们看到颜色是如何对应的呢？ 这也是曾一度困扰笔者的一个问题。<br>在Photoshop中作图，利用颜色取样工具，会发现上图的中间灰色对应的像素颜色值就是(127, 127, 127)，换算成0到1区间的表示方式即约为(0.5, 0.5, 0.5)。由此可见，美术要绘制出直觉上介于黑白中间的灰色，把灰度值设置为0.5就可以了。<br>上文中已经阐述过，显示器会对输入的颜色值进行display gamma转换。也就是说，输入给显示器的灰度值0.5，经过显示器的转换之后，会变为0.218，而这个0.218的灰度，又刚好符合人眼对于中等灰度（0.5）的直觉。这是一个有趣的巧合。这也可能是显示器的Gamma转换一直延续的原因。</p><h2 id="Gamma的定义"><a href="#Gamma的定义" class="headerlink" title="Gamma的定义"></a>Gamma的定义</h2><p><a href="https://en.wikipedia.org/wiki/Gamma_correction" target="_blank" rel="noopener">wikipedia - Gamma correction</a>对Gamma校正的相关概念进行了清楚的定义。<br><strong>Gamma correction</strong>, or often simply <strong>gamma</strong>, is a nonlinear operation used to encode and decode luminance or tristimulus values in video or still image systems.<br>Gamma correction is, in the simplest cases, defined by the following power-law expression:<br>${\displaystyle V<em>{\text{out}}=A{V</em>{\text{in}}^{\gamma }}}$</p><p>不同的文献资料对颜色空间相关转换的称呼不统一，这也是这块知识不容易理解清楚的原因之一。为此，笔者对同一过程的不同表述方式进行了整理，以便读者进行理解。</p><p>$\gamma &lt;1$时(即一些资料所说的1/2.2)，该值称为<strong>encoding gamma</strong>，该幂律函数进行的非线性转换称为<strong>gamma compression</strong>，或<strong>gamma encoding</strong>。该转换会把颜色的亮度变大，因此，这个过程也叫做<strong>补偿</strong>，狭义上的<strong>伽马校正</strong>。</p><p>$\gamma &gt; 1$时(典型的范围在2.0到2.4之间)，该值称为<strong>decoding gamma</strong>，该幂律函数进行的非线性转换称为<strong>gamma expansion</strong>，或<strong>gamma decoding</strong>。该转换会把导致颜色的亮度变低(Darker)，显示器的<strong>伽马转换</strong>就是这样一个过程。</p><h1 id="颜色空间-sRGB-amp-Linear-RGB"><a href="#颜色空间-sRGB-amp-Linear-RGB" class="headerlink" title="颜色空间(sRGB &amp; Linear RGB)"></a>颜色空间(sRGB &amp; Linear RGB)</h1><blockquote><p>Unity中的Color Space可以设置为Linear和Gamma，但这一说法会有争议。有人会说不存在Gamma Color Space的定义，Wikipedia上对Color Space的介绍中也确实没有提到Gamma Color Space。Gamma Color Space可能算是Unity自己提出的一个概念，指的是将图片的像素经过伽马校正后的颜色空间。<br>Unity文档中提到：<strong>The accepted standard for gamma space is called sRGB</strong>。准确地说，sRGB才是一种Color Space。为了方便理解，读者可以认为gamma space就是sRGB color space。</p></blockquote><h2 id="sRGB"><a href="#sRGB" class="headerlink" title="sRGB"></a>sRGB</h2><p><a href="https://en.wikipedia.org/wiki/SRGB" target="_blank" rel="noopener">Wikipedia</a>上定义：<br>sRGB (standard Red Green Blue) is an RGB color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web.</p><p>我们可以粗浅地理解为：<br><strong>sRGB格式相当于对物理空间的颜色做了一次伽马校正(Gamma Correction)</strong>。sRGB空间下的颜色即为经过伽马校正后的颜色。将sRGB格式的Texture输入给显示器，显示器经过自身的Gamma变换之后，输出的值就是准确的、线性空间下的颜色值，这样人从显示器看到的图像就和人眼直接观察物理世界一样了。</p><blockquote><p>笔者认为，由此我们很容易理解为什么Gamma校正和转换的过程被称为<strong>Encoding</strong>和<strong>Decoding</strong>——sRGB是一种格式，转换成这种格式我们可以叫做：<strong>编码成sRGB格式</strong>，那么其逆运算的过程就是<strong>解码</strong>。</p></blockquote><p>wikipedia中介绍了不同颜色空间(CIE XYZ to sRGB)的转换过程。我们只需要理解<strong>线性空间</strong>到<strong>sRGB空间</strong>的计算公式即可。<br>The following formula transforms <strong>the linear RGB values</strong> into <strong>sRGB</strong> :</p><p><img src="./1599332150051.png" alt="Alt text"></p><ul><li>where u is R, G, or B.</li></ul><h1 id="Unity对Color-Space的处理"><a href="#Unity对Color-Space的处理" class="headerlink" title="Unity对Color Space的处理"></a>Unity对Color Space的处理</h1><p>前面已经阐述过，显示器在显示的时候，会用display gamma把显示的像素进行display transfer之后输出实际显示的亮度值。所以，我们要在这之前，对图像先进行gamma encoding(或Gamma校正)。也就是说，我们输出给显示器的颜色值，应当是sRGB空间下的值，这样，显示器输出给人眼的值，才是我们期望人眼看到的值（和人眼直接观察物理世界一样）。</p><p>Unity官方文档解释到：<br>The reason both gamma and linear color spaces exist is because <strong>lighting calculations should be done in linear space in order to be mathematically correct</strong>, but the <strong>result should be presented in gamma space to look correct to our eyes</strong>.<br>如果要确保计算机渲染的效果最大程度接近真实世界，我们应当在线性空间下进行光照计算，因为这符合真实世界的规律（使用贴图中颜色的Linear RGB值进行计算）；应当输出给显示器Gamma空间的颜色值（输出给屏幕sRGB格式的像素）。</p><blockquote><p>Unity文档中的以下表述可以帮助读者更好地理解颜色空间的问题：<br>Even though <strong>monitors</strong> today are digital, they still take a <strong>gamma-encoded signal as input</strong>. Image <strong>files</strong> and video files are explicitly encoded to be in gamma space (meaning they <strong>carry gamma-encoded values</strong>, not linear intensities). This is the standard; everything is in gamma space.</p></blockquote><p>接下来我们看看Unity对Color Space的两种workflow：Gamma和Linear。</p><blockquote><p>该设置在Unity的Edit -&gt; Project Settings -&gt; Player -&gt; Other Settings中。</p></blockquote><p>其实说将Color Space设置成Gamma和Linear容易造成误解，因为这个设置并不是说输出的值是Gamma空间还是Linear空间。该设置只是选择两套处理颜色空间的方案(Workflow, or Pipeline)。<br><img src="./An+image+comparing+gamma+and+linear+pipelines.png" alt="Alt text"></p><h2 id="Gamma-workflow"><a href="#Gamma-workflow" class="headerlink" title="Gamma workflow"></a>Gamma workflow</h2><p> 当选择Gamma Space时，实际上就是“放任模式”，不会对shader的输入进行任何处理，即使输入可能是非线性的；也不会对输出像素进行任何处理，这意味着输出的像素会经过显示器的display gamma转换后得到非预期的亮度，通常表现为整个场景会比较昏暗。</p><p>我们使用Photoshop创建两张颜色为(127, 127, 127)纯色图片（映射到0到1的数值为0.498）。在Unity中将图片设置为UGUI的Image，并在屏幕上显示。在Import Settings当中，将其中一张图片勾选为sRGB(Color Texture)，另一张图片不勾选该项。<br>由下图可见，两张图片在显示上并没有区别，输出给显示器的颜色值都为0.498。</p><p><img src="./1.png" alt="Alt text"><br>整个gamma workflow的过程中不会进行gamma校正。</p><h2 id="Linear-workflow"><a href="#Linear-workflow" class="headerlink" title="Linear workflow"></a>Linear workflow</h2><p>选择Color Space为Linear的含义，并不是输出给屏幕的颜色为Linear RPG值，而是说，进行的光照计算的处理，是在Linear Space下进行的。下段文字为kinematicsoup介绍的Linear Pipeline的过程:<br>The input colors and textures have their gamma correction removed before shading, putting them into linear space. When shaded, the result is physically correct because the shading process and inputs are all in the same space. After, any post effects should be computed while the frame is still in linear space, as post effects are typically linear, much like shading. Finally the image is then gamma corrected so it will have the proper intensity after the display’s gamma adjustments.<br>在Linear workflow下，Unity会对sRGB格式的Texture进行decoding，将sRGB空间的颜色值转换为线性空间，然后在Linear Space下进行着色（光照计算等）。在最后输出阶段，进行的伽马校正（gamma correction），将Linear空间的像素转换为sRGB空间，输出给显示器。经过显示器的转换之后，输出给人眼的颜色就是更接近真实的颜色（亮度）。</p><p>在Linear workflow下，做前文相同的操作，可以发现，没有勾选sRGB的Texture（右边）会更亮一些。<br><img src="./QQ截图20200906041147.png" alt="Alt text"><br>初始状态下，两张图片的亮度都为0.498。</p><p>左边的Texture勾选了sRGB，那么Unity会把这张图片当作sRGB空间下的图片，在进行着色前，先将图片进行Decoding(Remove Gamma Correction)，转换成Linear Space下的图片，在输出给显示器之前，再进行Encoding，编码成sRGB格式。此时，输出给显示器的亮度值经过互为逆运算的两个步骤，仍然为0.498。经过显示器的转换，即为我们看到的左边的方块。</p><p>右边的Texture没有勾选sRGB，Unity会把这张图片当作Linear Space下的图片，也就不进行Decoding。在着色之后，进行Encoding(Gamma Correction)，输出给显示器的亮度值为0.733。经显示器转换处理之后，看到的就是右边的方块。</p><p>经过笔者计算验证，Unity进行Encoding的时候，使用的公式就是上文提到的公式（可能存在少量误差）：</p><p><img src="./1599332150051.png" alt="Alt text"></p><ul><li>where u is R, G, or B.</li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>促使笔者对本文的知识点进行整理的原因，主要是本公司（UWA）初始版本的的特效检测工具在Linear Color Space下存在计算得到的OverdrawRate偏高的小BUG。详情请看UWA问答：<a href="https://answer.uwa4d.com/question/5f51b8ba9424416784ef20d7" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5f51b8ba9424416784ef20d7</a></p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://blog.csdn.net/candycat1992/article/details/46228771" target="_blank" rel="noopener">https://blog.csdn.net/candycat1992/article/details/46228771</a><br><a href="https://www.zhihu.com/question/27467127#answer-10413243" target="_blank" rel="noopener">https://www.zhihu.com/question/27467127#answer-10413243</a><br><a href="https://docs.unity3d.com/Manual/index.html" target="_blank" rel="noopener">Unity Manual</a><br><a href="https://www.jianshu.com/p/e15932c40bea" target="_blank" rel="noopener">https://www.jianshu.com/p/e15932c40bea</a><br><a href="https://en.wikipedia.org/wiki/SRGB" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/SRGB</a><br><a href="https://en.wikipedia.org/wiki/Gamma_correction" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gamma_correction</a><br><a href="https://unity.cn/projects/unite-2018-qian-tan-jia-ma-he-xian-xing-yan-se-kong-jian" target="_blank" rel="noopener">https://unity.cn/projects/unite-2018-qian-tan-jia-ma-he-xian-xing-yan-se-kong-jian</a><br><a href="https://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ" target="_blank" rel="noopener">https://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ</a><br><a href="https://zhuanlan.zhihu.com/p/66558476" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66558476</a></p>]]></content>
      
      
      <categories>
          
          <category> CG&amp;Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
