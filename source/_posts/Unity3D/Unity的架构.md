---
title: Unity的架构
date: 2020-5-21 20-24
categories:
- Unity3D
tags:
- Unity3D
catalog: true
---

## Unity

Unity当中渲染的部分是用C++执行的   
Mono是Unity运行过程中的一部分，负责在特定的时间编译C#脚本，运行C#程序集。   
所以，操作系统之上是基于C++的Unity程序，在Unity当中的一部分是Mono，Mono负责Unity当中与C#相关的部分。

整个Unity程序的运行是基于一帧一帧的刷新来进行的。   
如果在一帧当中，调用了一个耗时比较长的函数，整个程序就会卡在这一帧，直到这个函数调用结束。   
在编辑器模式下，通过MenuItem调用一个函数，就是在一帧里面进行函数调用，这个函数耗时比较长，这一帧就会等待这个函数调用完再刷新。

Unity当中有些程序是支持多线程的，比如烘培操作，烘培的时候，会在右下角开一个进度条，但是Game界面的程序还是会不断地一帧一帧刷新，不会阻塞，就是在多个线程下运行的结果。

在Mono之上是整个C#环境，Unity在运行时，C#环境就一直在内存当中运行的。

## 关于异常

在脚本运行的时候，抛出异常，会一层一层往上抛。   
异常被try catch时，如果catch到，那么try当中的代码就会跳过。也就是说，被try的函数就会在异常出终止，进而从catch语句块之后的代码开始继续运行。

如果自己写的程序不catch这个异常，那么这个异常会最终被Unity catch到，那么，Unity调用的我写的整个函数，就会终止掉。而实际上，整个C#的程序是没有终止的，Unity的C#程序还在内存当中，与我自己catch到异常没有本质的区别。而且，出异常的函数所分配的资源，如果不写代码释放掉，就没有其他好办法来释放了。因为这部分资源是在Unity的C#环境中的，只有重启整个Unity，才能强制释放。

如果某个脚本索引了一个文件流，由于文件流没有被释放而造成文件被锁、无法重新打开，可以对这个脚本进行reimport，Why？

