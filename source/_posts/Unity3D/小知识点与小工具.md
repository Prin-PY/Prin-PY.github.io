---
title: 小知识点与小工具
date: 2020-7-17 18-41
categories:
- Unity3D
tags:
- Unity3D
catalog: true
---

## Gizmos

**Gizmos** 在编辑模式下Gizmos可以提供可视化的提示。它们只在Scene场景中显示不在Play模式下显示，但是你可以通过工具栏调整它们。

**Gizmos公共类** 允许你绘制图标，线条，和其他的东西。Gizmos在`OnDrawGizmos`方法中执行绘制，它被Unity编辑器自动调用。另一个可选的方法是`OnDrawGizmosSelected`，它只能被可选的对象调用。

Demo: 绘制顶点的位置，利用OnDrawGizmos在每个顶点绘制一个小球。

```csharp private void OnDrawGizmos () { Gizmos.color = Color.black; for (int i = 0; i < vertices.Length; i++) { Gizmos.DrawSphere(vertices[i], 0.1f); } } ``` 

## OnValidate

调用时机:

  * 脚本被加载时
  * Inspector 中的任何值被修改时

Cases：  
设置循环值

```csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { public float objectRotation; void OnValidate() { // objectRotation objectRotation = objectRotation % 360; } } ``` 

需要设计人员输入 16 到 4096 之间 2的整数次幂时。  
Unity提供了ClosestPowerOfTwo函数，方便我们取得最接近的值。同时我们使用RangeAttribute 属性来限定一下输入数值的区间，同时能更好的看出来处理后的值跟原始输入值的区别。

```csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { [RangeAttribute(16, 4096)] public int textureSize; void OnValidate() { // textureSize textureSize = Mathf.ClosestPowerOfTwo(textureSize); } } ``` 

使用场景 -需要“Nitro”车的速度比其他车的速度大至少20mph.

```csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { [RangeAttribute(10, 300)] [Tooltip("mph")] public int maxCarSpeed; [RangeAttribute(10, 300)] [Tooltip("mph")] public int maxNitroSpeed; const int minNitroSpeedExtra = 20; void OnValidate() { // speed check if (maxNitroSpeed < maxCarSpeed + minNitroSpeedExtra) maxNitroSpeed = maxCarSpeed + minNitroSpeedExtra; } } ``` 

## 动态添加tag

```csharp #region 动态添加tag static void AddTag(string tag, GameObject obj) { if (!isHasTag(tag)) { SerializedObject tagManager = new SerializedObject(obj);//序列化物体 SerializedProperty it = tagManager.GetIterator();//序列化属性 while (it.NextVisible(true))//下一属性的可见性 { if (it.name == "m_TagString") { Debug.Log(it.stringValue); it.stringValue = tag; tagManager.ApplyModifiedProperties(); } } } } static bool isHasTag(string tag) { for (int i = 0; i < UnityEditorInternal.InternalEditorUtility.tags.Length; i++) { if (UnityEditorInternal.InternalEditorUtility.tags[i].Equals(tag)) return true; } return false; } #endregion ``` 

## 关于enable=false

When a Behaviour is disabled, it will still be on the object and you can even change its properties and call its methods, but the engine will no longer call its Update method.  
When a Renderer is disabled, the object turns invisible.  
When a Collider is disabled, it won't cause any collision events to happen.  
When an UI component is disabled, the player can't interact with it anymore, but it will still be rendered, unless you also deactivate its renderer.
