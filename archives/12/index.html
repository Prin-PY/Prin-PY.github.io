<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-00-实用插件、工具、网站整理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-00-%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/"
    >00_实用插件、工具、网站整理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-00-%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2023-07-20T15:00:27.083Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ol>
<li><p>网格变换与优化：</p>
<ol>
<li><p>Low Poly Mesh Generator 将场景网格变为低多边形风格 <a href="https://www.assetstore.unity3d.com/en/#!/content/59295" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/59295</a></p>
</li>
<li><p>Per-Vertex Ambient Occlusion And Indirect Lighting Generator 快速逐顶点生成环境光遮蔽与间接光照 <a href="https://www.assetstore.unity3d.com/en/#!/content/46880" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/46880</a></p>
</li>
<li><p>Mesh Materializer 改变场景风格的工具 Flat Mesh Generator及Ambient Occlusion And Indirect Lighting工具，另外还带有用于将地形转换为网格的Terrain To Mesh、调整顶点颜色的Vertex Color Adjustments、网格资源优化器以及计算网格厚度的烘焙工具。以上所有工具都同时支持编辑器模式及运行模式。<a href="https://www.assetstore.unity3d.com/en/#!/content/28583" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/28583</a></p>
</li>
<li><p><a href="https://blog.csdn.net/hebirechenai/category_6673178.html" target="_blank" rel="noopener">https://blog.csdn.net/hebirechenai/category_6673178.html</a> Mesh编程专栏</p>
</li>
<li><p><a href="https://blog.csdn.net/nanggong/article/details/85050343" target="_blank" rel="noopener">https://blog.csdn.net/nanggong/article/details/85050343</a> Mesh绘制点云</p>
</li>
</ol>
</li>
<li></li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-2-IL2CPP，-IL2CPP-VM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-0-2-IL2CPP%EF%BC%8C-IL2CPP-VM/"
    >0.2_IL2CPP， IL2CPP VM</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-0-2-IL2CPP%EF%BC%8C-IL2CPP-VM/" class="article-date">
  <time datetime="2023-07-20T15:00:27.078Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="0-2IL2CPP，-IL2CPP-VM"><a href="#0-2IL2CPP，-IL2CPP-VM" class="headerlink" title="0.2IL2CPP， IL2CPP VM"></a>0.2IL2CPP， IL2CPP VM</h1><p>IL to CPP : 把IL中间语言转换成CPP文件</p>
<h2 id="IL2CPP的出现意义"><a href="#IL2CPP的出现意义" class="headerlink" title="IL2CPP的出现意义"></a>IL2CPP的出现意义</h2><ol>
<li><p>Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成<br>Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，像Unity这样支持多平台的引擎，Mono官方的VM肯定是不能满足需求的。所以针对不同的新平台，Unity的项目组就要把VM给移植一遍，同时解决VM里面发现的bug。这非常耗时耗力。这些能移植的平台还好说，还有比如WebGL这样基于浏览器的平台。要让WebGL支持Mono的VM几乎是不可能的。</p>
</li>
<li><p>Mono版本授权受限<br>大家有没有意识到Mono的版本已经更新到3.X了，但是在Unity中，C#的运行时版本一直停留在2.8，这也是Unity社区开发者抱怨的最多一 条：很多C#的新特性无法使用。这是因为Mono授权受限，导致Unity无法升级Mono。如果换做是IL2CPP，IL2CPP VM这套完全自己开发的组件，就解决了这个问题。</p>
</li>
<li><p>提高运行效率<br>根据官方的实验数据，换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p>
</li>
<li><p>可以利用现成的在各个平台的C++编译器对代码执行编译期优化，这样可以进一步减小最终游戏的尺寸并提高游戏运行速度。</p>
</li>
</ol>
<h2 id="IL2CPP与Mono"><a href="#IL2CPP与Mono" class="headerlink" title="IL2CPP与Mono"></a>IL2CPP与Mono</h2><p>Mono</p>
<p><img src="assets/0.2_IL2CPP，%20IL2CPP%20VM/1591264208473.png" alt="Mono编译运行结构"></p>
<p>IL2CPP</p>
<p><img src="assets/0.2_IL2CPP，%20IL2CPP%20VM/1591264524127.png" alt="Alt text"></p>
<p>在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</p>
<h2 id="IL2CPP-VM"><a href="#IL2CPP-VM" class="headerlink" title="IL2CPP VM"></a>IL2CPP VM</h2><p>通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 IL2CPP VM的原因：它负责提供诸如 <strong>GC管理</strong> ， <strong>线程创建</strong> 这类的服务性工作。但是由于去除了IL加载和动态解析的工作，使得IL2CPP VM可以做的很小，并且使得 <strong>游戏载入时间缩短</strong> 。</p>
<h2 id="AOT方式"><a href="#AOT方式" class="headerlink" title="AOT方式"></a>AOT方式</h2><p>由于C++是一门静态语言，这就意味着我们不能使用动态语言的那些酷炫特性。运行时生 成代码并执行肯定是不可能了。这就是Unity里面提到的所谓AOT（Ahead Of Time，运行前编译）编译而非JIT（Just In Time）编译。其实很多平台出于安全的考虑是不允许JIT的，大家最熟悉的有iOS平台，在Console游戏机上，不管是微软的Xbox360， XboxOne，还是Sony的PS3，PS4，PSV，没有一个是允许JIT的。使用了IL2CPP，就完全是AOT方式了，如果原来使用了动态特性的 代码肯定会编译失败。这些代码在编译iOS平台的时候天生也会失败，所以如果你是为iOS开发的游戏代码，就不用担心了。因此就这点而言，我们开发上几乎 不会感到什么问题。</p>
<h3 id="JIT优点："><a href="#JIT优点：" class="headerlink" title="JIT优点："></a>JIT优点：</h3><p>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）<br>可以根据当前程序的运行情况生成最优的机器指令序列<br>当程序需要支持动态链接时，只能使用JIT<br>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</p>
<h3 id="JIT缺点："><a href="#JIT缺点：" class="headerlink" title="JIT缺点："></a>JIT缺点：</h3><p>编译需要占用运行时资源，会导致进程卡顿<br>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡<br>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</p>
<h3 id="AOT优点："><a href="#AOT优点：" class="headerlink" title="AOT优点："></a>AOT优点：</h3><p>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗<br>可以在程序运行初期就达到最高性能<br>可以显著的加快程序的启动</p>
<h3 id="AOT缺点："><a href="#AOT缺点：" class="headerlink" title="AOT缺点："></a>AOT缺点：</h3><p>在程序运行前编译会使程序安装的时间增加<br>牺牲Java的一致性<br>将提前编译的内容保存会占用更多的外</p>
<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://zhuanlan.zhihu.com/indieace" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/indieace</a><br>IL2CPP怎么用：<a href="https://zhuanlan.zhihu.com/p/19972666" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19972666</a><br>IL2CPP深入讲解：<br><a href="https://zhuanlan.zhihu.com/p/20063880" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20063880</a><br><a href="https://zhuanlan.zhihu.com/p/20207712" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20207712</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/19972689" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19972689</a><br>via IndieACE</p>
<p><a href="https://www.cnblogs.com/linghu-java/p/10577515.html" target="_blank" rel="noopener">https://www.cnblogs.com/linghu-java/p/10577515.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-2-IL2CPP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-0-2-IL2CPP/"
    >0.2_IL2CPP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-0-2-IL2CPP/" class="article-date">
  <time datetime="2023-07-20T15:00:27.066Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IL2CPP 是 Unity 自 4.6.1p5版本 提出的一种新的 scripting backend 方式，为Unity提供了更加高效、更加便携的虚拟机。<br>IL2CPP (Intermediate Language To C++) is a Unity-developed scripting backend<br>which you can use as an alternative to Mono when building projects for various platforms. When building a project using IL2CPP, Unity converts IL code from scripts<br>and assemblies to C++, before creating a native binary file (.exe, apk, .xap, for example) for your chosen platform.</p>
<ul>
<li><p>increasing the performance</p>
<ul>
<li><p>security</p>
</li>
<li><p>platform compatibility</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Scripting backend is a framework that powers scripting in Unity( 支持脚本的框架 ). </p>
</blockquote>
<p>IL2CPP分为两个独立的部分：</p>
<ul>
<li><p>AOT编译器<br>AOT编译器将 IL（由.Net编译器输出的中间语言）转换为C++源码</p>
</li>
<li><p>运行时库<br>运行时库则会提供诸如 <strong>垃圾回收</strong> 、 <strong>线程/文件获取</strong> （独立于平台，与平台无关）、 <strong>内部调用直接修改托管数据结构的原生代码</strong> 的服务与抽象。</p>
</li>
</ul>
<h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><p>AOT(Ahead Of Time)(运行前编译，静态编译)<br>所谓AOT编辑器即 <strong>il2cpp.exe</strong><br>在 Windows 系统中你可以在 Editor\Data\il2cpp 目录中找到它，在 OSX 系统中你可以在 Contents/Frameworks/il2cpp/build，即Unity的安装目录中找到它。<br>il2cpp.exe 是由C#编写的 <strong>受托管的可执行程序</strong> ，它 <strong>接受我们在Unity中通过Mono编译器生成的托管程序集，并生成指定平台下的C++代码</strong> 。</p>
<p><img src="0.2_IL2CPP/IL2CPP_WorkFlow.png" alt="Alt text"></p>
<h2 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h2><p><strong>运行时库（libil2cpp）</strong> 的存在是为了支持 <strong>IL2CPP虚拟机</strong> 的运行，几乎完全由C++代码编写，并作为一个静态库与最终的可执行程序链接。（值得一提的是，IL2CPP技术十分得益于使用了libil2cpp这一更轻便的运行时库）</p>
<p>你可以通过查看 libil2cpp 的头文件了解其的代码构成，例如你可以在 codegen/il2cpp-codegen.h 文件中看到 il2cpp.exe 生成C++代码的接口以及 运行时库 的接口。</p>
<p>运行时库的另一关键功能是提供了垃圾回收。</p>
<h2 id="AOT编译器是如何运行的"><a href="#AOT编译器是如何运行的" class="headerlink" title="AOT编译器是如何运行的"></a>AOT编译器是如何运行的</h2><p>看一个例子（该例子运行在 Windows 系统下 Unity 5.0.1版本中）<br>发布一个WebGL平台下的程序，并使用 Process Explorer 工具查看命令行调用过程</p>
<p>首先，Unity启动 mono.exe</p>
<p><code>&quot;C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe&quot;</code><br>接着启动 il2cpp.exe<br><code>&quot;C:\Program Files\Unity\Editor\Data\il2cpp/il2cpp.exe</code></p>
<pre><code class="lang-csharp">
&quot;C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe&quot;

&quot;C:\Program Files\Unity\Editor\Data\il2cpp/il2cpp.exe&quot;

rem 传递给 il2cpp.exe ，而非传递给 mono.exe的参数(5个标识符)

rem 告诉 il2cpp.exe 不要复制生成的C++代码.

\--copy-level=None 

rem IL2CPP将会共享泛型以此来减少最终包体的大小。

\--enable-generic-sharing 

rem 支持通过反射获取的Unity事件，保证代码能够正确生成。

\--enable-unity-event-support 

rem 在生成的C++代码中，为类与方法使用更少的字符数来命名，这样会使得代码更难以调试，因为IL代码的命名将会发生改变（笔者注：应该类似于代码混淆），但是却能够被编译器更快编译，因为编译器所需要解析的字符数变少了。

\--output-format=Compact

rem 使用默认的额外类型文件 ，这个文件会被加入到你的Unity工程里，并告知 il2cpp.exe 哪些泛型类型或者数组类型没有在IL代码中出现，却会在运行时被创建。

\--extra-types.file=&quot;C:\Program Files\Unity\Editor\Data\il2cpp\il2cpp_default_extra_types.txt&quot;

``` ```csharp 

&quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\Assembly-CSharp.dll&quot;

&quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\UnityEngine.UI.dll&quot;
</code></pre>
<p>il2cpp.exe 接受所有应该被转换的 IL 程序集，在这里例子中它应该包含我的 MonoBehaviour脚本、 Assembly-CSharp.dll 以及 GUI assembly 和 UnityEngine.UI.dll。<br>我的脚本引用了 UnityEngine.dll 和 mscorlib.dll，但是它们却没有被包含在上述的命令行中。事实上，il2cpp.exe 在内部对这些程序集进行了处理，因此在上述的命令行中它们不是必须的，Unity只显式地需要 <strong>根程序集</strong> （不被任何程序集引用的程序集）在命令行中被提及。</p>
<pre><code class="lang-csharp">
&quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\il2cppOutput&quot;
</code></pre>
<p>最后的一个参数表示 il2cpp.exe 的输出目录，即 il2cpp.exe 生成代码的输出位置，如果你对此感兴趣的话，可以看一看生成目录下的C++文件，而这一块内容我们也会在后续的文章中对其进行详解。此外，如果你希望浏览生成目录下的代码的话，推荐在出包的时候选择 <strong>Development Player</strong> 模式，这样一来将会移除 –output-format=Compact 命令行，使得你的代码更具可读性。</p>
<blockquote>
<p>PS:你可以通过改变 Player Settings 中的设置来观察 Unity 传递给 il2cpp.exe 的命令行的差异，例如将<br> Enable Exceptions 设置为 Full，那么命令行中就会增加 –emit-null-checks、–enable-stacktrace 、 –enable-array-bounds-check 三项.</p>
</blockquote>
<h2 id="IL2CPP没有做的工作"><a href="#IL2CPP没有做的工作" class="headerlink" title="IL2CPP没有做的工作"></a>IL2CPP没有做的工作</h2><p>Unity官方并没有重写C#的标准库，因此当你发布一个Unity工程的时候，即使你选择了 IL2CPP 的方式来生成你的代码，所有在 mscorlib.dll、System.dll 等标准库中的代码都将使用Mono2X的方式来生成。</p>
<p>Ref: <a href="https://www.jianshu.com/p/7cfcb7b0cfe7" target="_blank" rel="noopener">https://www.jianshu.com/p/7cfcb7b0cfe7</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-1-Unity-Profiler"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-0-1-Unity-Profiler/"
    >0.1_Unity  Profiler</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-0-1-Unity-Profiler/" class="article-date">
  <time datetime="2023-07-20T15:00:27.063Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="0-1-Unity-Profiler"><a href="#0-1-Unity-Profiler" class="headerlink" title="0.1_Unity Profiler"></a>0.1_Unity Profiler</h1><h1 id="0-1-Unity-Profiler-1"><a href="#0-1-Unity-Profiler-1" class="headerlink" title="0.1_Unity Profiler"></a>0.1_Unity Profiler</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Profiler 中看到的内存是通过 unity 自身引擎看到的内存分配,凡是 <strong>引擎创建和销毁的内存</strong> ,引擎有记录,可以给出准确的引用内存占用信息。第三方库的内存分配无法进行统计,以及一些其他的内存分配是无法进行统计的。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="真实环境内存"><a href="#真实环境内存" class="headerlink" title="真实环境内存"></a>真实环境内存</h4><p>在真实环境上面,(例如移动设备上面,Xcode的 instrument,Android 的 USS)内存都比 profiler 上要多<br>因为这些内存包括2部分</p>
<ul>
<li><p>真实的 used 的物理内存</p>
</li>
<li><p>缓存的(cached)的物理内存,这是不同平台决定的.Android 和 iOS 系统在资源不使用的时候均不会立即将其进行回收,而是将其放在缓存的物理内存中,以便下次再使用时,可以快速的加载.</p>
</li>
</ul>
<p>unity 的 profiler 只记录目前真实使用的物理内存,即上述所说的 A 部分内存.</p>
<p>当系统发现 APP 的内存不够用时,才会在底层调用一个 memory killer 线程来轮询缓存物理内存,为 APP 清理内存.</p>
<h4 id="PersistentManager-Remapper"><a href="#PersistentManager-Remapper" class="headerlink" title="PersistentManager.Remapper"></a>PersistentManager.Remapper</h4><p>主要提供文件的持久化存储,包括各种序列化的 asset,项目的 setting 文件,维护文件系统中的文件与内存中数据的对应关系.如果项目中大量适用 AssetBundle ,在对 AsserBundle 进行 Unload 之前都会需要占用 Remapper 的内存的,而 Remapper 本身的实现适用内存池,其数值只会增大,那么为了使 Remapper 占用的内存保持稳定,则在加载一定数量的 AssetBundle 之后需要进行 Unload 操作,而不要一次性把所有的 AssetBundle 进行 Unload.(这样的操作对维持整个 mono heap 的大小也是重要的,mono heap 本身也是只增大不减小的)</p>
<h2 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h2><p>Unity 在本机联合代码中分配的内存数量<br>Mono 托管代码所使用的堆大小和堆大小。这个内存是垃圾收集的<br>GfxDriver 驱动程序在纹理上使用的估计内存数量，呈现目标、着色器和网格数据。<br>FMOD 音频驱动程序的内存使用情况<br>Profiler 用于分析器数据的内存</p>
<p>内存统计信息显示在一些最常见的asset/object类型中。这些统计数据包括计数和使用的内存：<br>Textures<br>Meshes<br>Materials<br>Animations<br>Audio<br>Object Count</p>
<p>游戏对象在内存中常见的原因包括:<br>Assets:从用户或本机代码引用的资产<br>Built-in Resources:统一编辑器资源或统一缺省资源<br>Not Saved:标记为DontSave的GameObjects<br>Scene Memory: GameObject和附加组件<br>Other: 在上面的类别中没有标记的配子</p>
<h2 id="Profiler-UI显示数据"><a href="#Profiler-UI显示数据" class="headerlink" title="Profiler UI显示数据"></a>Profiler UI显示数据</h2><p>Uesd Total :<br>当前帧的Unity内存，Mono内存，GfxDriver内存，Profiler内存以及额外内存的总和。<br>Used total = Unity + Mono + GfxDriver + Profiler + additionalUsedMemory.</p>
<blockquote>
<p>additionalUsedMemory在profiler 中没有显示,因为在大多数平台下都为 0(PC/Android/iOS 都为 0),一般情况下 Used Total 的值就是除 FMOD 之外各项的总和了.Reserved Total 同样适用的.</p>
</blockquote>
<p>Reserved Total：<br>系统在当前帧申请的总体物理内存</p>
<p>Total System Memory Usage：<br>当前帧的虚拟内存使用量</p>
<p>GameObjects in Scene：<br>当前帧场景中的GameObject数量</p>
<p>Total Objects in Scene：<br>当前帧场景中的Object数量（除GameObject外，还有各种Component）</p>
<p>Total Object Count：<br>所有Object数量</p>
<h2 id="API-UnityEngine-Profiling-Profiler"><a href="#API-UnityEngine-Profiling-Profiler" class="headerlink" title="API UnityEngine.Profiling.Profiler"></a>API UnityEngine.Profiling.Profiler</h2><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><h4 id="in-your-built-app"><a href="#in-your-built-app" class="headerlink" title="in your built app"></a>in your built app</h4><p>most of the Profiler API functionality is only available when “Development Build” is enabled. This means you must enable “Developer Build” if you want to use profiler API methods in your built app.</p>
<p>Disabling “Development Build” makes your app run faster, but prevents you from using most of the Profiler API methods.</p>
<p>The exception to this are the Profiler API methods relating to memory usage. Because Unity manages most of its system memory at run-time, it can provide that information with no performance penalty, therefore those methods are available even if “Development Build” is not enabled. </p>
<h3 id="Static-Properties"><a href="#Static-Properties" class="headerlink" title="Static Properties"></a>Static Properties</h3><h4 id="usedHeapSizeLong"><a href="#usedHeapSizeLong" class="headerlink" title="usedHeapSizeLong"></a>usedHeapSizeLong</h4><p>Returns the number of bytes that Unity has allocated. This does not include bytes allocated by external libraries or drivers.</p>
<h3 id="Static-Methods"><a href="#Static-Methods" class="headerlink" title="Static Methods"></a>Static Methods</h3><h4 id="GetAllocatedMemoryForGraphicsDriver"><a href="#GetAllocatedMemoryForGraphicsDriver" class="headerlink" title="GetAllocatedMemoryForGraphicsDriver"></a>GetAllocatedMemoryForGraphicsDriver</h4><p>Returns the amount of <strong>allocated memory for the graphics driver</strong> , in bytes.<br>Only available in development players and editor.</p>
<h4 id="GetMonoHeapSizeLong-Reserved-Mono"><a href="#GetMonoHeapSizeLong-Reserved-Mono" class="headerlink" title="GetMonoHeapSizeLong (Reserved Mono)"></a>GetMonoHeapSizeLong (Reserved Mono)</h4><p>Returns the size of the <strong>reserved space for managed-memory</strong>.</p>
<h4 id="GetMonoUsedSizeLong-Used-Mono"><a href="#GetMonoUsedSizeLong-Used-Mono" class="headerlink" title="GetMonoUsedSizeLong (Used Mono)"></a>GetMonoUsedSizeLong (Used Mono)</h4><p>The <strong>allocated managed-memory</strong> for live objects and non-collected objects.</p>
<h4 id="GetRuntimeMemorySizeLong-native-memory-by-Unity-Obj"><a href="#GetRuntimeMemorySizeLong-native-memory-by-Unity-Obj" class="headerlink" title="GetRuntimeMemorySizeLong (native-memory by Unity Obj)"></a>GetRuntimeMemorySizeLong (native-memory by Unity Obj)</h4><p>Gathers the <strong>native-memory used by a Unity object</strong>.</p>
<h4 id="GetTempAllocatorSize"><a href="#GetTempAllocatorSize" class="headerlink" title="GetTempAllocatorSize"></a>GetTempAllocatorSize</h4><p>Returns the size of the temp allocator.</p>
<h4 id="GetTotalAllocatedMemoryLong"><a href="#GetTotalAllocatedMemoryLong" class="headerlink" title="GetTotalAllocatedMemoryLong"></a>GetTotalAllocatedMemoryLong</h4><p>The total memory allocated by the internal allocators in Unity. </p>
<blockquote>
<p>Unity <strong>reserves large pools of memory</strong> from the system. This function returns <strong>the amount of used memory in those pools</strong>.</p>
</blockquote>
<h4 id="GetTotalReservedMemoryLong"><a href="#GetTotalReservedMemoryLong" class="headerlink" title="GetTotalReservedMemoryLong"></a>GetTotalReservedMemoryLong</h4><p>The total memory Unity has reserved.</p>
<h4 id="GetTotalUnusedReservedMemoryLong"><a href="#GetTotalUnusedReservedMemoryLong" class="headerlink" title="GetTotalUnusedReservedMemoryLong"></a>GetTotalUnusedReservedMemoryLong</h4><p>Unity allocates memory in pools for usage when unity needs to allocate memory. This function returns the amount of unused memory in these pools.</p>
<h3 id="API和UI界面数据对应关系Table"><a href="#API和UI界面数据对应关系Table" class="headerlink" title="API和UI界面数据对应关系Table"></a>API和UI界面数据对应关系Table</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Profiler UI界面</th>
<th>API  </th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved Unity</td>
<td>GetTotalReservedMemoryLong  </td>
</tr>
<tr>
<td>Used Unity</td>
<td>GetTotalAllocatedMemoryLong  </td>
</tr>
<tr>
<td>Reserved Mono</td>
<td>GetMonoHeapSizeLong  </td>
</tr>
<tr>
<td>Used Mono</td>
<td>GetMonoUsedSizeLong  </td>
</tr>
</tbody>
</table>
</div>
<h2 id="优化项目（对于选定帧）"><a href="#优化项目（对于选定帧）" class="headerlink" title="优化项目（对于选定帧）"></a>优化项目（对于选定帧）</h2><h3 id="显示的项"><a href="#显示的项" class="headerlink" title="显示的项"></a>显示的项</h3><p>选中后，unity会自动获取这一帧的内存占用数据项，主要分为：Other、Assets、BuiltinResources、Scene Memory、NotSaved这五大部分</p>
<h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><h5 id="System-ExecutableAndDlls"><a href="#System-ExecutableAndDlls" class="headerlink" title="System.ExecutableAndDlls"></a>System.ExecutableAndDlls</h5><p>统可执行程序和DLL，是只读的内存，用来执行所有的脚本和DLL引用。不同平台和不同硬件得到的值会不一样，可以通过修改Player Setting的Stripping Level来调节大小。<br>Ricky：我试着修改了一下Stripping Level似乎没什么改变，感觉虽占用内存大但不会影响游戏运行。我们暂时忽略它吧(- -)!</p>
<h5 id="GfxDeviceClient"><a href="#GfxDeviceClient" class="headerlink" title="GfxDeviceClient"></a>GfxDeviceClient</h5><p>GFX（图形加速\图形加速器\显卡 (GraphicsForce Express)）客户端设备。<br>Ricky：虽占用较大内存，但这也是必备项，没办法优化。继续忽略吧(- -)!!</p>
<h5 id="ManagedHeap-UsedSize"><a href="#ManagedHeap-UsedSize" class="headerlink" title="ManagedHeap.UsedSize"></a>ManagedHeap.UsedSize</h5><p>托管堆使用大小。<br>Ricky：重点监控对象，不要让它超过20MB，否则可能会有性能问题！</p>
<h5 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h5><p>Unity自带的着色器语言工具相关资源。<br>Ricky：这个东西大家都比较熟悉了，忽略它吧。</p>
<h5 id="SerializedFile"><a href="#SerializedFile" class="headerlink" title="SerializedFile"></a>SerializedFile</h5><p>序列化文件，把显示中的Prefab、Atlas和metadata等资源加载进内存。<br>Ricky：重点监控对象，这里就是你要监控的哪些预设在序列化中在内存中占用大小，根据需求进行优化。</p>
<h5 id="PersistentManager-Remapper-1"><a href="#PersistentManager-Remapper-1" class="headerlink" title="PersistentManager.Remapper"></a>PersistentManager.Remapper</h5><p>持久化数据重映射管理相关<br>Ricky：与持久化数据相关，比如AssetBundle之类的。注意监控相关的文件。</p>
<h5 id="ManagedHeap-ReservedUnusedSize"><a href="#ManagedHeap-ReservedUnusedSize" class="headerlink" title="ManagedHeap.ReservedUnusedSize"></a>ManagedHeap.ReservedUnusedSize</h5><p>托管堆预留不使用内存大小，只由Mono使用。<br>Ricky：无法优化。</p>
<h4 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h4><h5 id="Texture2D"><a href="#Texture2D" class="headerlink" title="Texture2D"></a>Texture2D</h5><p>2D贴图及纹理。<br>Ricky：重点优化对象，有以下几点可以优化：</p>
<ol>
<li><p>许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。</p>
</li>
<li><p>当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先 <strong>把物体制空(null)，然后调用Resources.UnloadUnusedAssets()</strong> ，才能真正释放内存。</p>
</li>
<li><p>有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。</p>
</li>
</ol>
<h5 id="AudioManager"><a href="#AudioManager" class="headerlink" title="AudioManager"></a>AudioManager</h5><p>音频管理器<br>Ricky：随着音频文件的增多而增大。</p>
<h5 id="AudioClip"><a href="#AudioClip" class="headerlink" title="AudioClip"></a>AudioClip</h5><p>音效及声音文件<br>Ricky：重点优化对象，播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。</p>
<h5 id="Cubemap"><a href="#Cubemap" class="headerlink" title="Cubemap"></a>Cubemap</h5><p>立方图纹理<br>Ricky：这个一般在天空盒中比较常见，我也不知道如何优化这个。。。</p>
<h5 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h5><p>模型网格<br>Ricky：主要检查是否有重复的资源，还有尽量减少点面数。</p>
<h4 id="Scene-Memory"><a href="#Scene-Memory" class="headerlink" title="Scene Memory"></a>Scene Memory</h4><h5 id="Mesh-1"><a href="#Mesh-1" class="headerlink" title="Mesh"></a>Mesh</h5><p>场景中使用的网格模型<br>Ricky：注意网格模型的点面数，能合并的mesh尽量合并。</p>
<h5 id="Builtin-Resources"><a href="#Builtin-Resources" class="headerlink" title="Builtin Resources"></a>Builtin Resources</h5><p>Ricky：这些都是Unity的一些内部资源，对于项目内存没有什么分析价值，所以我就暂时不对其进行分析了。</p>
<h3 id="Profiler内存重点关注优化项目"><a href="#Profiler内存重点关注优化项目" class="headerlink" title="Profiler内存重点关注优化项目"></a>Profiler内存重点关注优化项目</h3><ol>
<li><p>ManagedHeap.UsedSize: 移动游戏建议不要超过20MB.</p>
</li>
<li><p>SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.</p>
</li>
<li><p>WebStream: 通过异步WWW下载的资源文件在内存中的解压版本，比SerializedFile大几倍或几十倍，</p>
</li>
<li><p>Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等.</p>
</li>
<li><p>AnimationClip: 重点检查是否有重复资源.</p>
</li>
<li><p>Mesh： 重点检查是否有重复资源.</p>
</li>
</ol>
<h3 id="项目中可能遇到的问题"><a href="#项目中可能遇到的问题" class="headerlink" title="项目中可能遇到的问题"></a>项目中可能遇到的问题</h3><h4 id="1-Device-Present"><a href="#1-Device-Present" class="headerlink" title="1.Device.Present:"></a>1.Device.Present:</h4><p>1）GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader.<br>2）GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间.<br>3）同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.<br>4）Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片).<br>5）StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace(): 一般是由Debug.Log或类似API造成，游戏发布后需将Debug API进行屏蔽。</p>
<h4 id="2-Overhead"><a href="#2-Overhead" class="headerlink" title="2.Overhead:"></a>2.Overhead:</h4><p>1）一般情况为Vsync所致.<br>2）通常出现在Android设备上.</p>
<h4 id="3-GC-Collect"><a href="#3-GC-Collect" class="headerlink" title="3.GC.Collect:"></a>3.GC.Collect:</h4><p>原因：<br>1）代码分配内存过量(恶性的)<br>2）一定时间间隔由系统调用(良性的).<br>占用时间：<br>1）与现有Garbage size相关<br>2）与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排)</p>
<h4 id="4-GarbageCollectAssetsProfile"><a href="#4-GarbageCollectAssetsProfile" class="headerlink" title="4.GarbageCollectAssetsProfile:"></a>4.GarbageCollectAssetsProfile:</h4><p>1）引擎在执行UnloadUnusedAssets操作（该操作是比较耗时的,建议在切场景的时候进行）。<br>2）尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GCAllow.<br>3）if(other.tag == a.tag)改为other.CompareTag(a.tag).因为other.tag为产生180B的GC Allow.<br>4）少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for.<br>5）Lambda表达式，使用不当会产生内存泄漏.</p>
<h4 id="5-尽量少用LINQ："><a href="#5-尽量少用LINQ：" class="headerlink" title="5.尽量少用LINQ："></a>5.尽量少用LINQ：</h4><p>1）部分功能无法在某些平台使用.<br>2）会分配大量GC Allow.</p>
<h4 id="6-控制StartCoroutine的次数："><a href="#6-控制StartCoroutine的次数：" class="headerlink" title="6.控制StartCoroutine的次数："></a>6.控制StartCoroutine的次数：</h4><p>1）开启一个Coroutine(协程)，至少分配37B的内存.<br>2）Coroutine类的实例 -&gt; 21B.<br>3）Enumerator -&gt; 16B.</p>
<h4 id="7-使用StringBuilder替代字符串直接连接"><a href="#7-使用StringBuilder替代字符串直接连接" class="headerlink" title="7.使用StringBuilder替代字符串直接连接."></a>7.使用StringBuilder替代字符串直接连接.</h4><h4 id="8-缓存组件"><a href="#8-缓存组件" class="headerlink" title="8.缓存组件:"></a>8.缓存组件:</h4><p>1）每次GetComponent均会分配一定的GC Allow.<br>2）每次Object.name都会分配39B的堆内存.</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/yanghui0702/p/yanghui20181026.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanghui0702/p/yanghui20181026.html</a><br><a href="https://zhuanlan.zhihu.com/p/139235851" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/139235851</a><br><a href="https://www.jianshu.com/p/3c5540637525" target="_blank" rel="noopener">https://www.jianshu.com/p/3c5540637525</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-1-Android内存管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-0-1-Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
    >0.1_Android内存管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-0-1-Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2023-07-20T15:00:27.046Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Android 运行时 ( <strong>ART</strong> ) 和 <strong>Dalvik 虚拟机</strong> 使用 <strong>分页</strong> 和 <strong>内存映射</strong> 来管理内存。这意味着应用修改的任何内存，无论修改的方式是分配新对象还是轻触内存映射的页面，都会一直驻留在 RAM 中，并且无法换出。 <strong>要从应用中释放内存，只能释放应用保留的对象引用，使内存可供垃圾回收器回收。</strong> 这种情况有 <strong>一个例外</strong> ：对于任何未经修改的内存映射文件（如代码），如果系统想要在其他位置使用其内存，可将其从 RAM 中换出。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>Ref: <a href="https://blog.csdn.net/greedylin/article/details/103711555" target="_blank" rel="noopener">https://blog.csdn.net/greedylin/article/details/103711555</a><br>Android的内存大，但是管理不太好<br>基本单位: Page</p>
<ol>
<li><p>默认4K一个page（与linux相同），但并不意味是4K对齐的</p>
</li>
<li><p>回收和分配以page为单位</p>
</li>
<li><p>分为用户态和内核态，常见的一个问题是，用户态中的一个指针越界到内核态，该程序就会挂掉</p>
</li>
</ol>
<h3 id="LMK"><a href="#LMK" class="headerlink" title="LMK"></a>LMK</h3><p>内存管理工具-low memory killer（AKA lmk）<br>一些现象都和它有关，例如闪退 服务消失 手机重启等<br>当内存不足时，killer会从下往上杀应用，当杀到前台（Foreground）时，你的应用就会闪退，如果继续使用内存，会一致杀到System层，这时设备会重启</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>ART 或 Dalvik 虚拟机之类的 <strong>受管内存环境</strong> 会 <strong>跟踪每次内存分配</strong> 。一旦确定程序不再使用某块内存，它就会将该内存重新释放到堆中，无需程序员进行任何干预。这种 <strong>回收受管内存环境中的未使用内存的机制</strong> 称为“ <strong>垃圾回收”</strong> 。垃圾回收有两个目标： <strong>在程序中查找将来无法访问的数据对象</strong> ，并 <strong>回收这些对象使用的资源</strong> 。</p>
<h4 id="Android做法"><a href="#Android做法" class="headerlink" title="Android做法"></a>Android做法</h4><p>Android 的内存堆是分代的，这意味着它会根据分配对象的 <strong>预期寿命和大小</strong> 跟踪不同的 <strong>分配存储分区</strong> 。例如，最近分配的对象属于“ <strong>新生代</strong> ”。当某个对象保持活动状态达足够长的时间时，可将其提升为 <strong>较老代</strong> ，然后是 <strong>永久代</strong> 。<br>堆的每一代对相应对象可占用的内存量都有其自身的专用上限。 <strong>每当一代开始填满时，系统便会执行垃圾回收事件以释放内存。</strong></p>
<p>垃圾回收的 <strong>持续时间</strong> 取决于它 <strong>回收的是哪一代</strong> 对象以及 <strong>每一代有多少个活动对象</strong> 。</p>
<p>尽管垃圾回收速度非常快，但仍会影响应用的性能。系统有一套专门确定何时执行垃圾回收的标准。当条件满足时，系统会停止执行进程并开始垃圾回收。如果 <em>在动画或音乐播放等密集型处理循环过程中发生垃圾回收，则可能会增加处理时间</em> ，进而可能会导致应用中的代码执行超出建议的 16ms 阈值， <em>无法实现高效、流畅的帧渲染</em> 。</p>
<p>此外，您的代码流执行的各种工作可能迫使垃圾回收事件发生得更频繁或导致其持续时间超过正常范围。 例如， <em>如果您在 Alpha 混合动画的每一帧期间，在 for 循环的最内层分配多个对象，则可能会使内存堆受到大量对象的影响</em> 。在这种情况下，垃圾回收器会执行多个垃圾回收事件，并可能降低应用的性能。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>为了在 RAM 中容纳所需的一切，Android 会尝试跨进程共享 RAM 页面。<br>方式：</p>
<ul>
<li><p>每个应用进程都从一个 <strong>名为 Zygote 的现有进程分叉</strong> 。系统启动并加载通用框架代码和资源（如 Activity 主题背景）时，Zygote 进程随之启动。为启动新的应用进程，系统会分叉 Zygote 进程，然后在新进程中加载并运行应用代码。这种方法使为框架代码和资源分配的大多数 RAM 页面可在所有应用进程之间共享。</p>
</li>
<li><p>大多数 <strong>静态数据会内存映射到一个进程中</strong> 。这种方法使得数据不仅可以在进程之间共享，还可以在需要时换出。静态数据示例包括：Dalvik 代码（通过将其放入预先链接的 .odex 文件中进行直接内存映射）、应用资源（通过将资源表格设计为可内存映射的结构以及通过对齐 APK 的 zip 条目）和传统项目元素（如 .so 文件中的原生代码）。</p>
</li>
<li><p>在很多地方，Android 使用 <strong>明确分配的共享内存区域（通过 ashmem 或 gralloc）</strong> 在进程间共享同一 <strong>动态 RAM</strong> 。例如，窗口 surface 在应用和屏幕合成器之间使用共享内存，而光标缓冲区则在内容提供程序和客户端之间使用共享内存。</p>
</li>
</ul>
<h3 id="分配与回收应用内存"><a href="#分配与回收应用内存" class="headerlink" title="分配与回收应用内存"></a>分配与回收应用内存</h3><p><strong>Dalvik 堆</strong> 局限于 <strong>每个应用进程的单个虚拟内存范围</strong> 。这定义了 <strong>逻辑堆大小</strong> ，该大小可以根据需要增长，但不能超过系统为每个应用定义的上限。</p>
<p>堆的逻辑大小与 <strong>堆使用的物理内存量</strong> 不同。在检查应用堆时，Android 会 <strong>计算</strong> 按比例分摊的内存大小 <strong>(PSS) 值</strong> ，该值同时考虑与其他进程共享的脏页和干净页，但其数量与共享该 RAM 的应用数量成正比。此 (PSS) 总量是系统认为的 <strong>物理内存占用</strong> 量。有关 PSS 的详情，请参阅调查 RAM 使用量指南: <a href="https://developer.android.com/studio/profile/memory-profiler" target="_blank" rel="noopener">https://developer.android.com/studio/profile/memory-profiler</a>。</p>
<p>Dalvik 堆不压缩堆的逻辑大小，这意味着 Android 不会对堆进行碎片整理来缩减空间。只有当堆末尾存在未使用的空间时，Android 才能缩减逻辑堆大小。但是，系统仍然可以减少堆使用的物理内存。垃圾回收之后，Dalvik 遍历堆并查找未使用的页面，然后使用 madvise 将这些页面返回给内核。因此，大数据块的配对分配和解除分配应该使所有（或几乎所有）使用的物理内存被回收。但是，从较小分配量中回收内存的效率要低得多，因为用于较小分配量的页面可能仍在与其他尚未释放的数据块共享。</p>
<h4 id="PSS"><a href="#PSS" class="headerlink" title="PSS"></a>PSS</h4><p>PSS(Proportional Set Size)：按比例分摊的内存大小</p>
<blockquote>
<p>Proportional 比例的，成比例的<br> Proportional Set Size: 按照比例设置的大小，按比例分摊的内存大小，即 <strong>实际使用的物理内存</strong></p>
</blockquote>
<h3 id="限制应用内存"><a href="#限制应用内存" class="headerlink" title="限制应用内存"></a>限制应用内存</h3><p>为了维持多任务环境的正常运行，Android 会为每个应用的 <strong>堆大小</strong> 设置硬性 <strong>上限</strong> 。如果您的应用在达到堆容量上限后尝试分配更多内存，则可能会收到 <strong>OutOfMemoryError</strong> 。<br>在某些情况下，例如，为了确定在缓存中保存多少数据比较安全，您可能需要查询系统以确定 <strong>当前设备上确切可用的堆空间大小</strong> 。您可以通过调用 <strong>getMemoryClass()</strong> 向系统查询此数值。此方法返回一个整数，表示 <strong>应用堆的可用兆字节数</strong> 。</p>
<h3 id="切换应用"><a href="#切换应用" class="headerlink" title="切换应用"></a>切换应用</h3><p>当用户在应用之间切换时，Android 会在最近最少使用 (LRU) 缓存中保留 <strong>非前台应用</strong> ，即用户看不到或不在运行前台服务（如 <em>音乐播放</em> ）的应用。例如，当用户首次启动某个应用时，系统会为其创建一个进程；但是当用户离开此应用时，该进程不会退出。系统会将该进程保留在缓存中。如果用户稍后返回该应用，则系统会重复使用该进程，从而加快应用切换速度。</p>
<p>如果您的应用具有缓存进程且保留了目前不需要的内存，那么即使用户不在使用您的应用，它也会影响系统的整体性能。当系统 <strong>内存不足时</strong> ，它会从最近最少使用的进程开始， <strong>终止 LRU 缓存中的进程</strong> 。系统还会考虑终止占用最多内存的进程以释放 RAM。</p>
<h2 id="进程间内存分配"><a href="#进程间内存分配" class="headerlink" title="进程间内存分配"></a>进程间内存分配</h2><p>Android 平台在运行时不会浪费可用的内存。它会一直尝试利用所有可用内存。</p>
<h3 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h3><p>Android 设备包含三种不同类型的内存：RAM、zRAM 和存储器</p>
<p><img src="0.1_Android内存管理/1592449330748.png" alt="Alt text"></p>
<p>RAM 是最快的内存类型，但其大小通常有限。高端设备通常具有最大的 RAM 容量。</p>
<p>zRAM 是用于交换空间的 RAM 分区。所有数据在放入 zRAM 时都会进行压缩，然后在从 zRAM 向外复制时进行解压缩。这部分 RAM 会随着页面进出 zRAM 而增大或缩小。设备制造商可以设置 zRAM 大小上限。</p>
<p>存储器中包含所有持久性数据（例如文件系统等），以及为所有应用、库和平台添加的对象代码。存储器比另外两种内存的容量大得多。在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间，因为频繁写入会导致这种内存出现损坏，并缩短存储媒介的使用寿命。</p>
<h3 id="内存页面"><a href="#内存页面" class="headerlink" title="内存页面"></a>内存页面</h3><p>RAM 分为多个“页面”。通常，每个页面为 4KB 的内存。</p>
<p>系统会将页面视为“可用”或“已使用”。</p>
<h4 id="可用页面"><a href="#可用页面" class="headerlink" title="可用页面"></a>可用页面</h4><h4 id="已使用页面"><a href="#已使用页面" class="headerlink" title="已使用页面"></a>已使用页面</h4><h5 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h5><p>有存储器中的文件（例如代码或内存映射文件）支持的内存。缓存内存有两种类型：</p>
<ol>
<li><p>私有页：由一个进程拥有且未共享</p>
<ul>
<li><p>干净页：存储器中未经修改的文件副本，可由 kswapd 删除以增加可用内存</p>
</li>
<li><p>脏页：存储器中经过修改的文件副本；可由 kswapd 移动到 zRAM 或在 zRAM 中进行压缩以增加可用内存</p>
</li>
</ul>
</li>
<li><p>共享页：由多个进程使用</p>
<ul>
<li><p>干净页：存储器中未经修改的文件副本，可由 kswapd 删除以增加可用内存</p>
</li>
<li><p>脏页：存储器中经过修改的文件副本；允许通过 kswapd 或者通过明确使用 msync() 或 munmap() 将更改写回存储器中的文件，以增加可用空间</p>
</li>
</ul>
</li>
</ol>
<h5 id="匿名页："><a href="#匿名页：" class="headerlink" title="匿名页："></a>匿名页：</h5><p>没有存储器中的文件支持的内存（例如，由设置了 MAP_ANONYMOUS 标记的 mmap() 进行分配）<br>脏页：可由 kswapd 移动到 zRAM/在 zRAM 中进行压缩以增加可用内存</p>
<blockquote>
<p>注意：干净页包含存在于存储器中的文件（或文件一部分）的精确副本。如果干净页不再包含文件的精确副本（例如，因应用操作所致），则会变成脏页。干净页可以删除，因为始终可以使用存储器中的数据重新生成它们；脏页则不能删除，否则数据将会丢失。<br> 随着系统积极管理 RAM，可用和已使用页面的比例会不断变化。</p>
</blockquote>
<h3 id="内存不足管理"><a href="#内存不足管理" class="headerlink" title="内存不足管理"></a>内存不足管理</h3><p>Android 有两种处理内存不足情况的主要机制： <strong>内核交换守护进程</strong> 和 <strong>低内存终止守护进程</strong> 。</p>
<h4 id="内核交换守护进程"><a href="#内核交换守护进程" class="headerlink" title="内核交换守护进程"></a>内核交换守护进程</h4><p>内核交换守护进程 (kernel swap daemon, kswapd) 是 Linux 内核的一部分，用于将已使用内存转换为可用内存。当设备上的可用内存不足时，该守护进程将变为活动状态。Linux 内核设有可用内存上下限阈值。当可用内存降至下限阈值以下时，kswapd 开始回收内存。当可用内存达到上限阈值时，kswapd 停止回收内存。</p>
<p>kswapd 可以删除干净页来回收它们，因为这些页受到存储器的支持且未经修改。如果某个进程尝试处理已删除的干净页，则系统会将该页面从存储器复制到 RAM。此操作称为“请求分页”。</p>
<p>kswapd 可以将缓存的私有脏页和匿名脏页移动到 zRAM 进行压缩。这样可以释放 RAM 中的可用内存（可用页面）。如果某个进程尝试处理 zRAM 中的脏页，该页将被解压缩并移回到 RAM。如果与压缩页面关联的进程被终止，则该页面将从 zRAM 中删除。</p>
<p>如果可用内存量低于特定阈值，系统会开始终止进程。</p>
<h4 id="低内存终止守护进程"><a href="#低内存终止守护进程" class="headerlink" title="低内存终止守护进程"></a>低内存终止守护进程</h4><p>很多时候，kswapd 不能为系统释放足够的内存。在这种情况下，系统会使用 onTrimMemory() 通知应用内存不足，应该减少其分配量。如果这还不够，内核会开始终止进程以释放内存。它会使用低内存终止守护进程 ( low-memory killer, LMK) 来执行此操作。</p>
<p>LMK 使用一个名为 oom_adj_score 的“内存不足”分值来确定正在运行的进程的优先级，以此决定要终止的进程。最高得分的进程最先被终止。后台应用最先被终止，系统进程最后被终止。下表列出了从高到低的 LMK 评分类别。评分最高的类别，即第一行中的项目将最先被终止：</p>
<p><img src="0.1_Android内存管理/1592451159557.png" alt="Alt text"></p>
<ul>
<li><p>后台应用：之前运行过且当前不处于活动状态的应用。LMK 将首先从具有最高 oom_adj_score 的应用开始终止后台应用。</p>
</li>
<li><p>上一个应用：最近用过的后台应用。上一个应用比后台应用具有更高的优先级（得分更低），因为相比某个后台应用，用户更有可能切换到上一个应用。</p>
</li>
<li><p>主屏幕应用：这是启动器应用。终止该应用会使壁纸消失。</p>
</li>
<li><p>服务：服务由应用启动，可能包括同步或上传到云端。</p>
</li>
<li><p>可觉察的应用：用户可通过某种方式察觉到的非前台应用，例如运行一个显示小界面的搜索进程或听音乐。</p>
</li>
<li><p>前台应用：当前正在使用的应用。终止前台应用看起来就像是应用崩溃了，可能会向用户提示设备出了问题。</p>
</li>
<li><p>持久性（服务）：这些是设备的核心服务，例如电话和 WLAN。</p>
</li>
<li><p>系统：系统进程。这些进程被终止后，手机可能看起来即将重新启动。</p>
</li>
<li><p>原生：系统使用的极低级别的进程（例如，kswapd）。</p>
</li>
</ul>
<h3 id="计算内存占用量"><a href="#计算内存占用量" class="headerlink" title="计算内存占用量"></a>计算内存占用量</h3><blockquote>
<p>在确定应用使用的内存量时，系统必须考虑共享的页面。访问相同服务或库的应用将共享内存页面。<br> 如需确定应用的内存占用量，可以使用以下任一指标：</p>
</blockquote>
<ul>
<li><p>常驻内存大小 (Resident Set Size, RSS)：应用使用的共享和非共享页面的数量</p>
</li>
<li><p>按比例分摊的内存大小 (Proportional Set Size, PSS)：应用使用的非共享页面的数量加上共享页面的均匀分摊数量（例如，如果三个进程共享 3MB，则每个进程的 PSS 为 1MB）</p>
</li>
<li><p>独占内存大小 (Unique Set Size, USS)：应用使用的非共享页面数量（不包括共享页面）</p>
</li>
</ul>
<p>如果操作系统想要知道所有进程使用了多少内存，那么 <strong>PSS</strong> 非常有用，因为页面只会统计一次。计算 PSS 需要花很长时间，因为系统需要确定共享的页面以及共享页面的进程数量。RSS 不区分共享和非共享页面（因此计算起来更快），更适合跟踪内存分配量的变化。</p>
<h2 id="管理应用内存"><a href="#管理应用内存" class="headerlink" title="管理应用内存"></a>管理应用内存</h2><p>随机存取存储器 (RAM) 在任何软件开发环境中都是一项宝贵资源。虽然 Android 运行时 (ART) 和 Dalvik 虚拟机都执行例行的垃圾回收任务，但这并不意味着您可以忽略应用分配和释放内存的位置和时间。您仍然需要避免引入 <strong>内存泄漏</strong> 问题（ <strong>通常因在静态成员变量中保留对象引用而引起</strong> ），并在适当时间（如生命周期回调所定义）释放所有 Reference 对象。</p>
<h3 id="监控可用内存和内存使用量"><a href="#监控可用内存和内存使用量" class="headerlink" title="监控可用内存和内存使用量"></a>监控可用内存和内存使用量</h3><p>您需要 <strong>先找到应用中的内存使用问题，然后才能修复问题</strong> 。Android Studio 中的内存分析器可以通过以下方式帮助您查找和诊断内存问题：</p>
<ul>
<li><p>了解您的应用在一段时间内如何分配内存。内存分析器可以显示实时图表，说明应用的内存使用量、分配的 Java 对象数量以及垃圾回收事件发生的时间。</p>
</li>
<li><p>发起垃圾回收事件，并在应用运行时拍摄 Java 堆的快照。</p>
</li>
<li><p>记录应用的内存分配情况，然后检查所有分配的对象、查看每个分配的堆栈轨迹，并在 Android Studio 编辑器中跳转到相应代码。</p>
</li>
</ul>
<h4 id="释放内存以响应事件"><a href="#释放内存以响应事件" class="headerlink" title="释放内存以响应事件"></a>释放内存以响应事件</h4><p>如 Android 内存管理概览中所述，Android 可以通过多种方式从应用中回收内存，或在必要时完全终止应用，从而释放内存以执行关键任务。为了进一步帮助平衡系统内存并避免系统需要终止您的应用进程，您可以在 Activity 类中实现 ComponentCallbacks2 接口。借助所提供的 onTrimMemory() 回调方法，您的应用可以在处于前台或后台时监听与内存相关的事件，然后释放对象以响应指示系统需要回收内存的应用生命周期事件或系统事件。</p>
<h4 id="查看您应该使用多少内存"><a href="#查看您应该使用多少内存" class="headerlink" title="查看您应该使用多少内存"></a>查看您应该使用多少内存</h4><p>为了允许多个进程同时运行，Android 针对为每个应用分配的堆大小设置了硬性限制。设备的确切堆大小限制因设备总体可用的 RAM 多少而异。如果您的应用已达到堆容量上限并尝试分配更多内存，系统就会抛出 OutOfMemoryError。</p>
<p>为了避免用尽内存，您可以查询系统以确定当前设备上可用的堆空间。您可以通过调用 getMemoryInfo() 向系统查询此数值。它将返回一个 ActivityManager.MemoryInfo 对象，其中会提供与设备当前的内存状态有关的信息，包括可用内存、总内存和内存阈值（如果达到此内存级别，系统就会开始终止进程）。ActivityManager.MemoryInfo 对象还会提供一个简单的布尔值lowMemory，您可以根据此值确定设备是否内存不足。</p>
<p>以下代码段示例演示了如何在应用中使用 getMemoryInfo() 方法。</p>
<h3 id="使用内存效率更高的代码结构"><a href="#使用内存效率更高的代码结构" class="headerlink" title="使用内存效率更高的代码结构"></a>使用内存效率更高的代码结构</h3><p>某些 Android 功能、Java 类和代码结构所使用的内存往往多于其他功能、类和结构。您可以在代码中选择效率更高的替代方案，以尽可能降低应用的内存使用量。</p>
<h4 id="谨慎使用服务"><a href="#谨慎使用服务" class="headerlink" title="谨慎使用服务"></a>谨慎使用服务</h4><p>在不需要某项服务时让其保持运行状态，是 Android 应用可能犯下的最严重的内存管理错误之一。如果您的应用需要某项服务在后台执行工作，请不要让其保持运行状态，除非其需要运行作业。请注意在服务完成任务后使其停止运行。否则，您可能会在无意中导致内存泄漏。</p>
<p>在您启动某项服务后，系统更倾向于让此服务的进程始终保持运行状态。这种行为会导致服务进程代价十分高昂，因为一旦服务使用了某部分 RAM，那么这部分 RAM 就不再可供其他进程使用。这会减少系统可以在 LRU 缓存中保留的缓存进程数量，从而降低应用切换效率。当内存紧张，并且系统无法维护足够的进程以托管当前运行的所有服务时，这甚至可能导致系统出现颠簸。</p>
<p>您通常应该避免使用持久性服务，因为它们会对可用内存提出持续性的要求。我们建议您采用 JobSchedulerJobScheduler 等替代实现方式。要详细了解如何使用 JobScheduler 调度后台进程，请参阅后台优化。</p>
<p>如果您必须使用某项服务，则限制此服务的生命周期的最佳方式是使用 IntentService，它会在处理完启动它的 intent 后立即自行结束。有关详情，请参阅在后台服务中运行。</p>
<h4 id="使用经过优化的数据容器"><a href="#使用经过优化的数据容器" class="headerlink" title="使用经过优化的数据容器"></a>使用经过优化的数据容器</h4><p>编程语言所提供的部分类并未针对移动设备做出优化。例如，常规 HashMap 实现的内存效率可能十分低下，因为每个映射都需要分别对应一个单独的条目对象。</p>
<p>Android 框架包含几个经过优化的数据容器，包括 SparseArray、SparseBooleanArray 和 LongSparseArray。 例如，SparseArray 类的效率更高，因为它们可以避免系统需要对键（有时还对值）进行自动装箱（这会为每个条目分别再创建 1-2 个对象）。</p>
<p>如果需要，您可以随时切换到原始数组以获得非常精简的数据结构。</p>
<h4 id="谨慎对待代码抽象"><a href="#谨慎对待代码抽象" class="headerlink" title="谨慎对待代码抽象"></a>谨慎对待代码抽象</h4><p>开发者往往会将抽象简单地当做一种良好的编程做法，因为抽象可以提高代码灵活性和维护性。不过，抽象的代价很高：通常它们需要更多的代码才能执行，需要更多的时间和更多的 RAM 才能将代码映射到内存中。因此，如果抽象没有带来显著的好处，您就应该避免使用抽象。</p>
<h4 id="针对序列化数据使用精简版-Protobuf"><a href="#针对序列化数据使用精简版-Protobuf" class="headerlink" title="针对序列化数据使用精简版 Protobuf"></a>针对序列化数据使用精简版 Protobuf</h4><p>协议缓冲区是 Google 设计的一种无关乎语言和平台，并且可扩展的机制，用于对结构化数据进行序列化。该机制与 XML 类似，但更小、更快也更简单。如果您决定针对数据使用 Protobuf，则应始终在客户端代码中使用精简版 Protobuf。常规 Protobuf 会生成极其冗长的代码，这会导致应用出现多种问题，例如 RAM 使用量增多、APK 大小显著增加以及执行速度变慢。</p>
<p>有关详情，请参阅 Protobuf 自述文件中的“精简版”部分。</p>
<h4 id="避免内存抖动"><a href="#避免内存抖动" class="headerlink" title="避免内存抖动"></a>避免内存抖动</h4><p>如前所述，垃圾回收事件通常不会影响应用的性能。不过，如果在短时间内发生许多垃圾回收事件，就可能会快速耗尽帧时间。系统花在垃圾回收上的时间越多，能够花在呈现或流式传输音频等其他任务上的时间就越少。</p>
<p>通常，“内存抖动”可能会导致出现大量的垃圾回收事件。实际上，内存抖动可以说明在给定时间内出现的已分配临时对象的数量。</p>
<p>例如，您可以在 for 循环中分配多个临时对象。或者，您也可以在视图的 onDraw() 函数中创建新的 Paint 或 Bitmap 对象。在这两种情况下，应用都会快速创建大量对象。这些操作可以快速消耗新生代 (young generation) 区域中的所有可用内存，从而迫使垃圾回收事件发生。</p>
<p>当然，您必须先在代码中找到内存抖动较高的位置，然后才能进行修复。为此，您应该使用 Android Studio 中的内存分析器。</p>
<p>确定代码中的问题区域后，请尝试减少对性能至关重要的区域中的分配数量。您可以考虑将某些代码逻辑从内部循环中移出，或将其移到基于 Factory 的分配结构中。</p>
<h3 id="移除会占用大量内存的资源和库"><a href="#移除会占用大量内存的资源和库" class="headerlink" title="移除会占用大量内存的资源和库"></a>移除会占用大量内存的资源和库</h3><p>代码中的某些资源和库可能会在您不知情的情况下吞噬内存。APK 的总体大小（包括第三方库或嵌入式资源）可能会影响应用的内存消耗量。您可以通过从代码中移除任何冗余、不必要或臃肿的组件、资源或库，降低应用的内存消耗量。</p>
<h4 id="缩减总体-APK-大小"><a href="#缩减总体-APK-大小" class="headerlink" title="缩减总体 APK 大小"></a>缩减总体 APK 大小</h4><p>您可以通过缩减应用的总体大小来显著降低应用的内存使用量。位图大小、资源、动画帧数和第三方库都会影响 APK 的大小。Android Studio 和 Android SDK 提供了可帮助您缩减资源和外部依赖项大小的多种工具。这些工具支持现代代码收缩方法，例如 R8 编译。（Android Studio 3.3 及更低版本使用 ProGuard，而不是 R8 编译。）</p>
<p>要详细了解如何缩减 APK 的总体大小，请参阅有关如何缩减应用大小的指南。</p>
<h4 id="使用-Dagger-2-实现依赖注入"><a href="#使用-Dagger-2-实现依赖注入" class="headerlink" title="使用 Dagger 2 实现依赖注入"></a>使用 Dagger 2 实现依赖注入</h4><p>依赖注入框架可以简化您编写的代码，并提供一个可供您进行测试及其他配置更改的自适应环境。</p>
<p>如果您打算在应用中使用依赖注入框架，请考虑使用 Dagger 2。Dagger 不使用反射来扫描您应用的代码。Dagger 的静态编译时实现意味着它可以在 Android 应用中使用，而不会带来不必要的运行时代价或内存消耗量。</p>
<p>其他使用反射的依赖注入框架倾向于通过扫描代码中的注释来初始化进程。此过程可能需要更多的 CPU 周期和 RAM，并可能在应用启动时导致出现明显的延迟。</p>
<h4 id="谨慎使用外部库"><a href="#谨慎使用外部库" class="headerlink" title="谨慎使用外部库"></a>谨慎使用外部库</h4><p>外部库代码通常不是针对移动环境编写的，在移动客户端上运行时可能效率低下。如果您决定使用外部库，则可能需要针对移动设备优化该库。在决定是否使用该库之前，请提前规划，并在代码大小和 RAM 消耗量方面对库进行分析。</p>
<p>即使是一些针对移动设备进行了优化的库，也可能因实现方式不同而导致问题。例如，一个库可能使用的是精简版 Protobuf，而另一个库使用的是 Micro Protobuf，导致您的应用出现两种不同的 Protobuf 实现。日志记录、分析、图像加载框架和缓存以及许多您意料之外的其他功能的不同实现都可能导致这种情况。</p>
<p>虽然 ProGuard 可以使用适当的标记移除 API 和资源，但无法移除库的大型内部依赖项。您所需要的这些库中的功能可能需要较低级别的依赖项。如果存在以下情况，这就特别容易导致出现问题：您使用某个库中的 Activity 子类（往往会有大量的依赖项）、库使用反射（这很常见，意味着您需要花费大量的时间手动调整 ProGuard 以使其运行）等。</p>
<p>此外，请避免仅针对数十个功能中的一两个功能使用共享库。您一定不希望产生大量您甚至根本用不到的代码和开销。在考虑是否使用某个库时，请查找与您的需求十分契合的实现。否则，您可以决定自己去创建实现。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-0-Unity与Mono和-NET的关系"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-0-0-Unity%E4%B8%8EMono%E5%92%8C-NET%E7%9A%84%E5%85%B3%E7%B3%BB/"
    >0.0 Unity与Mono和.NET的关系</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-0-0-Unity%E4%B8%8EMono%E5%92%8C-NET%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time datetime="2023-07-20T15:00:27.045Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>&gt;</p>
<p><a href="https://www.cnblogs.com/u3ddjw/p/10909975.html" target="_blank" rel="noopener">https://www.cnblogs.com/u3ddjw/p/10909975.html</a></p>
<p><a href="https://www.cnblogs.com/u3ddjw/p/10909975.html" target="_blank" rel="noopener">https://www.cnblogs.com/u3ddjw/p/10909975.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unreal-TODO-解决困惑-Actor与component关系"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/11/Unreal-TODO-%E8%A7%A3%E5%86%B3%E5%9B%B0%E6%83%91-Actor%E4%B8%8Ecomponent%E5%85%B3%E7%B3%BB/"
    >解决困惑-Actor与component关系</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/11/Unreal-TODO-%E8%A7%A3%E5%86%B3%E5%9B%B0%E6%83%91-Actor%E4%B8%8Ecomponent%E5%85%B3%E7%B3%BB/" class="article-date">
  <time datetime="2022-04-10T17:42:00.000Z" itemprop="datePublished">2022-04-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unreal/">Unreal</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Actor不支持嵌套？</p>
<p>那GetComponents函数的“bIncludeFromChildActors”是什么意思？</p>
<p>Components是否支持嵌套？</p>
<p>如果不支持，为什么Details中的Components可有父子关系？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-CG-homogeneous-coordinates-and-transformation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/17/CG-homogeneous-coordinates-and-transformation/"
    >【CG】齐次坐标(homogeneous coordinates )与坐标变换(transformation)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/17/CG-homogeneous-coordinates-and-transformation/" class="article-date">
  <time datetime="2020-11-17T15:39:00.000Z" itemprop="datePublished">2020-11-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-Rendering/">CG&Rendering</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>同一个事物，从不同的视角去看，会有不同的理解。而任何一个视角看到的，都不是事物的全部，任何一种解释，都无法完全描述这个事物。单纯用一种方式去理解它，一定是片面的。只有从不同的层次、不同的角度去理解，我们的认知才能不断逼近这个事物的真相。<br>本文借鉴多位博主的研究成果，企图整理从不同的角度对齐次坐标的理解，帮助感兴趣的朋友更透彻地理解齐次坐标到底是什么，有什么意义，如何应用。</p>
<h2 id="齐次坐标引入"><a href="#齐次坐标引入" class="headerlink" title="齐次坐标引入"></a>齐次坐标引入</h2><h3 id="Problem-Two-parallel-lines-can-intersect"><a href="#Problem-Two-parallel-lines-can-intersect" class="headerlink" title="Problem: Two parallel lines can intersect."></a>Problem: Two parallel lines can intersect.</h3><ul>
<li><p>欧氏几何空间<br>In <strong>Euclidean space (geometry)</strong> - two parallel lines on the same plane cannot intersect, or cannot meet each other forever.</p>
</li>
<li><p>透视空间 - 无穷远处相交<br>In projective space - Finally, the two parallel rails meet at the horizon, which is a point at infinity.<br><img src="./1605592065160.png" alt="Alt text"></p>
</li>
</ul>
<blockquote>
<p>(Actually, Euclidean geometry is a subset of projective geometry</p>
</blockquote>
<p>The Cartesian coordinates of a 2D point can be expressed as (x, y).</p>
<p>What if this point goes far away to infinity? The point at infinity would be (∞,∞), and it becomes meaningless in Euclidean space. <strong>The parallel lines should meet at infinity in projective space, but cannot do in Euclidean space.</strong></p>
<h3 id="Solution-Homogeneous-Coordinates"><a href="#Solution-Homogeneous-Coordinates" class="headerlink" title="Solution: Homogeneous Coordinates"></a>Solution: Homogeneous Coordinates</h3><p>Homogeneous coordinates are a way of <strong>representing N-dimensional coordinates with N+1 numbers</strong>.</p>
<p>(1, 2) becomes (1, 2, 1) in Homogeneous<br>If (1, 2) moves toward infinity, it becomes (∞,∞) in Cartesian coordinates. And it becomes (1, 2, 0) in Homogeneous coordinates.</p>
<p><strong>We can express the point at infinity without using “∞”.</strong></p>
<h3 id="Why-is-it-called-“homogeneous”"><a href="#Why-is-it-called-“homogeneous”" class="headerlink" title="Why is it called “homogeneous”?"></a>Why is it called “homogeneous”?</h3><p>Homogeneous coordinates are scale invariant.<br>(1a, 2a, 3a) in Homogeneous coordinates is the same point as (1/3, 2/3) in Euclidean space.<br>These points are “homogeneous” because they represent the same point in Euclidean space (or Cartesian space).</p>
<h3 id="Proof-Two-parallel-lines-can-intersect"><a href="#Proof-Two-parallel-lines-can-intersect" class="headerlink" title="Proof: Two parallel lines can intersect."></a>Proof: Two parallel lines can intersect.</h3><p><img src="./1605593492210.png" alt="Alt text"></p>
<ul>
<li>if C ≠ D -&gt; there is no solution</li>
<li>if C = D -&gt; two lines are identical (overlapped)</li>
</ul>
<p>笛卡尔坐标系下，两平行线要么重叠，要么永不相交。</p>
<hr>
<p>Rewrite the equations for projective space：<br><img src="./1605593639293.png" alt="Alt text"><br>we have a solution, (x, y, 0)<br>two parallel lines meet at (x, y, 0), which is the point at infinity.</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>从数学的角度讲：</p>
<ul>
<li>区分向量和点</li>
<li>可以表示无穷远的点</li>
<li>易于进行 仿射变化（Affine Transformation）。提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法。</li>
</ul>
<p>从现实意义的角度讲：</p>
<ul>
<li>描述透视空间</li>
<li>区分不同位置的向量</li>
</ul>
<h3 id="区分向量和点"><a href="#区分向量和点" class="headerlink" title="区分向量和点"></a>区分向量和点</h3><p>问题：笛卡尔坐标系下，三维坐标既可以表示向量，也可以表示点，从坐标上无法区分。<br>而实质上，向量和点是有区别的，点的位置是对这个基的原点o所进行的一个位移。<br>当我们在坐标系 xOy 中</p>
<ul>
<li>用 (a,b) 定义一个向量 <strong>v</strong> 时，表示 <strong>v</strong> =a<strong>x</strong> +b<strong>y</strong></li>
<li>用 (a,b) 表示一个点 p 时，表示 p−o=a<strong>x</strong> +b<strong>y</strong></li>
</ul>
<p>假若写下 (2,1)，如无附加说明，不能区别出它是向量还是点。<br>将点的表示重写为：<br><img src="./1605605087117.png" alt="Alt text"></p>
<p>将向量的表示写为:<br><img src="./1605605093577.png" alt="Alt text"></p>
<p>这样能够清晰地区分向量和点。数学家使用这种方式表示坐标 - 在n维向量（或坐标点）后面增加一维，这便是齐次坐标的思想。</p>
<p>通过如下方式可将三维坐标转换成齐次坐标：</p>
<ul>
<li>把3D向量的第4个代数分量设置为0</li>
<li>把3D点的第4个代数分量设置为1</li>
</ul>
<p>对于一个普通坐标的点P=(Px, Py, Pz)，有对应的<strong>一族</strong>齐次坐标(wPx, wPy, wPz, w)，其中w不等于零。</p>
<blockquote>
<p>比如，P(1, 4, 7)的齐次坐标有(1, 4, 7, 1)、（2, 8, 14, 2）、（-0.1, -0.4, -0.7, -0.1）等等。</p>
</blockquote>
<p>最后一个代数分量w称为<strong>比例因子</strong><br>当w=0时，可解释为无穷远的“点”，其意义是描述方向（既然已经是“无穷远”了，其实际位置已经没有意义了，只有用于描述方向的意义）。因此，w=0时，该坐标表示一个向量。对该坐标进行平移变换，不会产生效果，计算过程如图：<br><img src="./1605606438308.png" alt="Alt text"><br>这也符合我们原先的认知：向量没有位置，只有大小和方向。</p>
<h3 id="描述投影几何（-projective-geometry）"><a href="#描述投影几何（-projective-geometry）" class="headerlink" title="描述投影几何（ projective geometry）"></a>描述投影几何（ projective geometry）</h3><p>用眼睛观察世界有一个特点，就是越远的物体看起来就越小，而且我们还能通过“越远越小”这种视觉效果估算距离。 这种现象被称为透视现象，同样的存在这种现象的空间被称为<strong>投影空间</strong>。<br>在笛卡尔空间中，两条平行线是永远不会相交的，但是在透视空间中，两条平行线会相交于一点，这是两种空间最大的区别。</p>
<p>Projective geometry has an extra dimension, called W, in addition to the X, Y, and Z dimensions. This four-dimensional space is called “projective space,” and coordinates in projective space are called “homogeneous coordinates.”<br>（x,y,z）在齐次空间中有无数多个点与之对应。所有点的形式是（wx,wy,wz,w），其轨迹是通过齐次空间原点的“直线”</p>
<h4 id="An-Analogy-In-2D"><a href="#An-Analogy-In-2D" class="headerlink" title="An Analogy In 2D"></a>An Analogy In 2D</h4><p><img src="./1605607149931.png" alt="Alt text"><br>The W dimension is the distance from the projector to the screen.<br>The value of W affects the size (a.k.a. scale) of the image.</p>
<h4 id="Applying-It-To-3D"><a href="#Applying-It-To-3D" class="headerlink" title="Applying It To 3D"></a>Applying It To 3D</h4><p> When W increases, the coordinate expands (scales up). When W decreases, the coordinate shrinks (scales down). The W is basically a scaling transformation for the 3D coordinate.</p>
<p>The usual advice for 3D programming beginners is to always set W=1 whenever converting a 3D coordinate to a 4D coordinate.<br>when you scale a coordinate by 1 it doesn’t shrink or grow, it just stays the same size.</p>
<p>When W=1 it has no effect on the X, Y or Z values.<br>For this reason, when it comes to 3D computer graphics, coordinates are said to be “<strong>correct</strong>” only when W=1.</p>
<ul>
<li>If you rendered coordinates with W&gt;1 then everything would look too small, and with W&lt;1 everything would look too big.</li>
<li>If you tried to render with W=0 your program would crash when it attempted to divide by zero.</li>
<li>With W&lt;0 everything would flip upside-down and back-to-front.</li>
</ul>
<blockquote>
<p>Mathematically speaking, there is no such thing as an “incorrect” homogeneous coordinate. Using coordinates with <strong>W=1</strong> is just <strong>a useful convention</strong> for 3D computer graphics.</p>
</blockquote>
<h4 id="Uses-Of-Homogeneous-Coordinates-In-Computer-Graphics"><a href="#Uses-Of-Homogeneous-Coordinates-In-Computer-Graphics" class="headerlink" title="Uses Of Homogeneous Coordinates In Computer Graphics"></a>Uses Of Homogeneous Coordinates In Computer Graphics</h4><h5 id="Translation-Matrices-For-3D-Coordinates"><a href="#Translation-Matrices-For-3D-Coordinates" class="headerlink" title="Translation Matrices For 3D Coordinates"></a>Translation Matrices For 3D Coordinates</h5><p>In order to do translation, the matrices need to have at least four columns.<br>A four-column matrix can only be multiplied with a four-element vector, which is why we often use homogeneous 4D vectors instead of 3D vectors.</p>
<blockquote>
<p>W的几何意义与投影有关，也只有投影变换矩阵影响到w的值。平移、旋转、缩放矩阵都不影响W。</p>
</blockquote>
<p>The 4th dimension W is usually unchanged, when using homogeneous coordinates in matrix transformation. <strong>W is set to 1 when converting a 3D coordinate into 4D, and it is usually still 1 after the transformation matrices are applied, at which point it can be converted back into a 3D coordinate by ignoring the W.</strong> This is true for all <strong>translation</strong>, <strong>rotation</strong>, and <strong>scaling</strong> transformations, which are by far the most common types of transformations. <strong>The notable exception is projection matrices, which do affect the W dimension</strong>.</p>
<h5 id="Perspective-Transformation"><a href="#Perspective-Transformation" class="headerlink" title="Perspective Transformation"></a>Perspective Transformation</h5><p>Perspective is implemented in 3D computer graphics by using a transformation matrix that changes the W element of each vertex.<br>After the the camera matrix is applied to each vertex, but before the projection matrix is applied, <strong>the Z element of each vertex represents the distance away from the camera</strong>. Therefore, the larger Z is, the more the vertex should be scaled down. The W dimension affects the scale, so <strong>the projection matrix just changes the W value based on the Z value</strong>.<br>投影矩阵根据深度（Z）计算W值，W值影响缩放。<br><img src="./1605610411957.png" alt="Alt text"></p>
<p>投影矩阵相乘之后，执行透视除法，把齐次坐标转换成W=1的形式。<br>After the perspective projection matrix is applied, each vertex undergoes “perspective division.” Perspective division is just a specific term for converting the homogeneous coordinate back to W=1, as explained earlier in the article.<br><img src="./1605610619279.png" alt="Alt text"><br>After perspective division, the W value is discarded, and we are left with a 3D coordinate that has been correctly scaled according to a 3D perspective projection.</p>
<blockquote>
<p> In OpenGL, <strong>perspective division happens automatically after the vertex shader runs on each vertex.</strong> This is one reason why gl_Position, the main output of the vertex shader, is a 4D vector, not a 3D vector.</p>
</blockquote>
<h5 id="Positioning-Directional-Lights"><a href="#Positioning-Directional-Lights" class="headerlink" title="Positioning Directional Lights"></a>Positioning Directional Lights</h5><p>Points at <strong>infinity</strong> occur when W=0. Coordinates with W=0 can not be converted into 3D coordinates.</p>
<p><strong>Directional lights</strong></p>
<ul>
<li>point lights that are infinitely far away.</li>
<li>the rays of light become parallel, and all of the light travels in a single direction.</li>
</ul>
<p>W=1, then it is a point light.<br>W=0, then it is a directional light.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lightPosition.w == <span class="number">0.0</span>)&#123;</span><br><span class="line">    <span class="comment">//directional light code here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//point light code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="仿射变换总结"><a href="#仿射变换总结" class="headerlink" title="仿射变换总结"></a>仿射变换总结</h2><h3 id="旋转、缩放到平移"><a href="#旋转、缩放到平移" class="headerlink" title="旋转、缩放到平移"></a>旋转、缩放到平移</h3><p>对于一个 2 维点 p=(x,y)，<strong>仿射变换</strong>（T）是线性变换（Ap）和平移变换（+t）的叠加:<br>T(p)=Ap+t</p>
<blockquote>
<p>计算机图形学中的图形变换，实际上是在仿射空间中进行的</p>
</blockquote>
<p>线性变换在欧式空间中可以表示为矩阵乘积形式，如旋转变换和缩放变换：<br><img src="./1605604356384.png" alt="Alt text"></p>
<p>而平移变换<br><img src="./1605604375076.png" alt="Alt text"><br>却不能用矩阵相乘的形式表达。</p>
<p>现在引入齐次坐标系表达 p~=(x,y,1)，（尺度不变性，实际上在高一维的空间映射到 w=1 平面, 这样计算后结果直接可导出到欧式空间）。可以将旋转变换和缩放变换表示为：<br><img src="./1605604526234.png" alt="Alt text"></p>
<p>以二维向量为例，平移变换则为：<br><img src="./1605604714025.png" alt="Alt text"></p>
<p>仿射变换的矩阵形式<br><img src="./1605604635107.png" alt="Alt text"></p>
<p>齐次坐标把各种变换都在统一了起来，不管怎样变换，变换多少次，都可以表示成一连串的矩阵相乘。任何三维坐标空间的转换，都可以用一个四维矩阵表示。</p>
<hr>
<p>三维向量平移运算：<br><img src="./1605624685160.png" alt="Alt text"></p>
<h3 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h3><h4 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h4><p>正交投影矩阵的视锥体是一个长方体[l,r][b,t][f,n]，我们要把这个长方体转换到一个正方体[-1,1][-1,1][-1,1]中，如图。<br><img src="./1605619846921.png" alt="Alt text"><br><img src="./1605619859591.png" alt="Alt text"><br>第一步平移，计算出长方体的中心点为[(l+r)/2,(b+t)/2,(f+n)/2]，然后将中心点移动到原点，矩阵为<br><img src="./1605619868421.png" alt="Alt text"><br>第二步缩放，例如从[l,r]缩放到[-1,1]，缩放系数为2/(r-l)，所以矩阵为<br><img src="./1605619877457.png" alt="Alt text"><br>所以正交投影矩阵Mortho = Mscale*Mtranslate</p>
<h4 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h4><p>透视投影的视锥体是一个四棱锥的一部分，其中近平面为z=n，远平面为z=f，我们要把这个视锥体转换到一个正方体[-1,1][-1,1][-1,1]中，可以先把远平面压缩，把视锥体压缩成一个长方体，然后再通过第二步中的正交投影矩阵就可以变换到正方体中，如图。<br><img src="./1605620068159.png" alt="Alt text"><br>三个原则：</p>
<ol>
<li>近平面的所有点坐标不变</li>
<li>远平面的所有点坐标z值不变 都是f</li>
<li>远平面的中心点坐标值不变 为(0,0,f)<br><img src="./1605620366905.png" alt="Alt text"><br>由三角形相似性，对于(x,y,z,1)一点，它在视锥体压缩以后坐标应该为(nx/z,ny/z,unknow,1)。<br><img src="./1605620393640.png" alt="Alt text"><br>也就是我们现在需要找到一个矩阵Mpersp-&gt;ortho，使得上面的转换成立。<br>(x,y,z,1)与(kx,ky,kz,k!=0)这两个点是完全等价的点<br><img src="./1605620546915.png" alt="Alt text"><br>需要找到矩阵Mpersp-&gt;ortho，使得上面的转换成立。</li>
</ol>
<p>Ax+By+Cz+D = nx，求出 A=n,B=C=D=0<br>Ex+Fy+Gz+H = ny，求出F=n,E=G=H=0<br>Mx+Ny+Oz+P = z，求出O=1,M=N=P=0。<br><img src="./1606293635777.png" alt="Alt text"></p>
<p>由（1）近平面的所有点坐标不变<br><img src="./1605621055364.png" alt="Alt text"><br>对于第一二四行，我们写出等式<br>nx+0y+0n+0<em>1=x<br>0x+ny+0n+0</em>1=y<br>0x+0y+1n+0<em>1=1<br>很明显这是有问题的，因为n应该是任意常数，但是现在只有在n等于1时，一二四行的运算才成立<br>所以我们根据前面的方法，再把(x,y,n,1)都乘以一个n等价变为(nx,ny,n</em>n,n)。<br><img src="./1605621104726.png" alt="Alt text"><br>对于第一二四行，我们写出等式<br>nx+0y+0n+0<em>1=nx,<br>0x+ny+0n+0</em>1=ny,<br>0x+0y+1n+0<em>1=n<br>完美成立。现在我们可以安心的求第三行了。<br>设第三行的四个数分别为ABCD<br>可以获得等式 Ax+By+Cn+D = n</em>n。<br>明显A=0,B=0<br>Cn+D = n*n (式1)</p>
<p>我们接下来考虑第三个原则，远平面的中心点坐标值不变 为(0,0,f)<br>同样为了保证之前求的矩阵一二四行成立，我们需要把(0,0,f,1)写成(0,0,f<em>f,f)<br><img src="./1605621167044.png" alt="Alt text"><br>Cf+D = f</em>f（式2）</p>
<p>联立式1式2，解得<br>C = n+f<br>D = -nf</p>
<p>终于，我们求得了Mpersp-&gt;ortho矩阵为<br><img src="./1605621187419.png" alt="Alt text"><br>也就是通过这个矩阵，我们可以把原来的透视投影的视锥体压缩为正交投影的视锥体(长方体)<br>最后我们再乘上一开始求出来正交投影矩阵Morth就得到了透视投影矩阵<br>Mpersp = Mortho*Mpersp-&gt;ortho<br><img src="./1605621299525.png" alt="Alt text"></p>
<p><img src="./1605621446770.png" alt="Alt text"></p>
<p>推导过程及代码：<br><a href="http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html" target="_blank" rel="noopener">http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html</a></p>
<p><strong>After multiplying the vertex position by the projection matrix the coordinates are said to be in Clip Space and after performing the perspective divide the coordinates are in NDC Space (Normalized Device Coordinates).</strong></p>
<h2 id="Prin对齐次坐标、透视投影的理解"><a href="#Prin对齐次坐标、透视投影的理解" class="headerlink" title="Prin对齐次坐标、透视投影的理解"></a>Prin对齐次坐标、透视投影的理解</h2><p>如何理解四维坐标，如何理解w分量？<br>本质问题是，将一个frustum(截头锥体)压缩成一个正方体，求frustum中的点的坐标到正方体空间中点的坐标的一个映射关系。并用矩阵、线性代数的语言描述这一变换，使得所有的点的变换可以用同一个矩阵乘法进行描述，从而可以让计算机对所有顶点批量处理这一变换。</p>
<p>关键点：这个变换不是线性变换，无法用三维矩阵乘法描述。这个变换对所有点不是统一的，还与点到摄像机的距离有关系，不能对所有的点进行统一的变换，意味着对每个点增加一个属性，来描述点到摄像机的距离属性，从而使得这个变换与距离有关，这个属性就是点的w分量。</p>
<p>引入w分量之后，点的坐标扩充到四维，变换矩阵是4x4的矩阵。使用四维矩阵进行投影变换本质上是使用四维空间下的线性变换描述三维空间下的非线性变换（将frustum“捏”成正方体的变换）。<br>引入w分量后，实际上将一个点映射成了无数个点。我们定义了三维空间中点(x, y, z)对应的齐次坐标为(wx, wy, wz, w),(w!=0)。</p>
<p>之前“捏”frustum的操作，用三维空间线性变换是无法描述的，用3x3矩阵乘法进行变换是无法达到要求的。我们发现，当扩充一个维度之后，看待这个问题，之前的一些”无理要求”是可以满足的。</p>
<p>按照把frustum“捏”成正方体的条件，建立方程，在齐次空间下求这个映射函数，求出了满足要求的变换矩阵。变换之后，点的坐标是下图右边这个样子：<br><img src="./1606297457393.png" alt="Alt text"><br>再映射到三维空间的点就是这个样子：<br><img src="./1606297509696.png" alt="Alt text"></p>
<p>这样一来，我们对所有的点都可以进行这个变换过程:</p>
<ol>
<li>映射到齐次坐标空间（增加一个w分量，变为四维坐标）</li>
<li>按照我们对视锥体进行形变的要求，求得4x4变换矩阵。</li>
<li>齐次空间下做统一的缩放、平移变换，这个变换过程中，点将到摄像机的距离体现在w分量上面。</li>
<li>变换后，再将点映射到三维空间，发现原视锥体经变换后成功映射为正方体，其他所有点也经过了相同的映射，结果是合理的。</li>
</ol>
<h2 id="渲染管线中坐标变换总结"><a href="#渲染管线中坐标变换总结" class="headerlink" title="渲染管线中坐标变换总结"></a>渲染管线中坐标变换总结</h2><h3 id="坐标变换过程"><a href="#坐标变换过程" class="headerlink" title="坐标变换过程"></a>坐标变换过程</h3><p>物体空间(object space)-&gt;世界空间(World Space)-&gt;观察空间(View Space)-&gt;裁剪空间(clip space)-&gt;屏幕空间(Screen Space)<br><img src="./1605627042134.png" alt="Alt text"></p>
<ul>
<li>Object Coordinate System: 也称作Local coordinate System，用来定义一个模型本身的坐标系。</li>
<li>World Coordinate System: 3d 虚拟世界中的绝对坐标系，定义好这个坐标系的原点就可以用来描述模型的实现的位置，Camera 的位置，光源的位置。</li>
<li>View Coordinate System: 一般使用用来计算光照效果。</li>
<li>Clip Coordinate System:  对3D场景使用投影变换裁剪视锥。</li>
<li>Normalized device coordinate System (NDC): 归一化设备坐标系</li>
<li>Windows Coordinate System: 最后屏幕显示的2D坐标系统，一般原点定义在屏幕左上角。<h3 id="MVP矩阵及使用"><a href="#MVP矩阵及使用" class="headerlink" title="MVP矩阵及使用"></a>MVP矩阵及使用</h3>模型（Model）、观察（View）和投影（Projection）矩阵</li>
</ul>
<p><img src="./1605625875848.png" alt="Alt text"></p>
<h4 id="The-Model-matrix"><a href="#The-Model-matrix" class="headerlink" title="The Model matrix"></a>The Model matrix</h4><p>We went from Model Space (all vertices defined relatively to the center of the model) to World Space (all vertices defined relatively to the center of the world).<br><img src="./1605625959705.png" alt="Alt text"></p>
<h4 id="The-View-matrix"><a href="#The-View-matrix" class="headerlink" title="The View matrix"></a>The View matrix</h4><p>We went from World Space (all vertices defined relatively to the center of the world, as we made so in the previous section) to Camera Space (all vertices defined relatively to the camera).</p>
<blockquote>
<p>Unity中</p>
<ul>
<li>模型空间 &amp; 世界空间: 左手坐标系.</li>
<li>观察空间: 右手坐标系 (+x轴指向右方, +y轴指向上方, +z轴指向相机的后方)</li>
</ul>
</blockquote>
<p><img src="./1605626040517.png" alt="Alt text"></p>
<blockquote>
<p>The engines don’t move the ship at all. The ship stays where it is and the engines move the universe around it.</p>
</blockquote>
<h4 id="The-Projection-matrix"><a href="#The-Projection-matrix" class="headerlink" title="The Projection matrix"></a>The Projection matrix</h4><p>We’re now in Camera Space. This means that after all theses transformations, a vertex that happens to have x==0 and y==0 should be rendered at the center of the screen. But we can’t use only the x and y coordinates to determine where an object should be put on the screen : its distance to the camera (z) counts, too ! <strong>For two vertices with similar x and y coordinates, the vertex with the biggest z coordinate will be more on the center of the screen than the other.</strong></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generates a really hard-to-read matrix, but a normal, standard 4x4 matrix nonetheless</span></span><br><span class="line">glm::<span class="type">mat4</span> projectionMatrix = glm::perspective(</span><br><span class="line">    glm::<span class="built_in">radians</span>(FoV), <span class="comment">// The vertical Field of View, in radians: the amount of "zoom". Think "camera lens". Usually between 90° (extra wide) and 30° (quite zoomed in)</span></span><br><span class="line">    <span class="number">4.0</span>f / <span class="number">3.0</span>f,       <span class="comment">// Aspect Ratio. Depends on the size of your window. Notice that 4/3 == 800/600 == 1280/960, sounds familiar ?</span></span><br><span class="line">    <span class="number">0.1</span>f,              <span class="comment">// Near clipping plane. Keep as big as possible, or you'll get precision issues.</span></span><br><span class="line">    <span class="number">100.0</span>f             <span class="comment">// Far clipping plane. Keep as little as possible.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>We went from Camera Space (all vertices defined relatively to the camera) to Homogeneous Space (all vertices defined in a small cube. Everything inside the cube is onscreen).</p>
<p>Before projection, we’ve got our blue objects, in Camera Space, and the red shape represents the <strong>frustum</strong> of the camera : the part of the scene that the camera is actually able to see.<br><img src="./1605626582117.png" alt="Alt text"><br>Multiplying everything by the Projection Matrix has the following effect :<br><img src="./1605626624387.png" alt="Alt text"><br>In this image, the frustum is now a perfect cube (between -1 and 1 on all axes, it’s a little bit hard to see it), and all blue objects have been deformed in the same way. Thus, the objects that are near the camera ( = near the face of the cube that we can’t see) are big, the others are smaller. Seems like real life !<br><img src="./1605626691338.png" alt="Alt text"></p>
<p>Another mathematical transformation is applied (this one is automatic, you don’t have to do it yourself in the shader) to fit this to the actual window size :<br><img src="./1605626743536.png" alt="Alt text"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://oncemore2020.github.io/blog/homogeneous/" target="_blank" rel="noopener">https://oncemore2020.github.io/blog/homogeneous/</a><br><a href="http://www.songho.ca/math/homogeneous/homogeneous.html" target="_blank" rel="noopener">http://www.songho.ca/math/homogeneous/homogeneous.html</a><br><a href="https://zhuanlan.zhihu.com/p/110503121" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110503121</a><br><a href="https://blog.csdn.net/yinhun2012/article/details/79566148" target="_blank" rel="noopener">https://blog.csdn.net/yinhun2012/article/details/79566148</a><br><a href="https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/" target="_blank" rel="noopener">https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/</a><br><a href="https://zhuanlan.zhihu.com/p/122411512" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/122411512</a><br><a href="http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-3-matrices/" target="_blank" rel="noopener">http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-3-matrices/</a><br><a href="http://www.guidebee.info/wordpress/?m=201106" target="_blank" rel="noopener">http://www.guidebee.info/wordpress/?m=201106</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rendering/" rel="tag">Rendering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math/" rel="tag">math</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Basic-About-Texture"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/06/Basic-About-Texture/"
    >【基础】纹理(Texture)知识知多少</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/06/Basic-About-Texture/" class="article-date">
  <time datetime="2020-11-06T09:36:00.000Z" itemprop="datePublished">2020-11-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><strong>纹理</strong>最初的目的就是使用一张图片来控制模型的外观。使用<strong>纹理映射（texture mapping）</strong>技术，我们可以把一张图“黏”在模型表面，逐<strong>纹素（texel）</strong>（纹素的名字是为了和像素进行区分）地控制模型的颜色。</p>
<h2 id="UV坐标"><a href="#UV坐标" class="headerlink" title="UV坐标"></a>UV坐标</h2><p><strong>纹理映射坐标（texture-mapping coordinates） / UV坐标：</strong> 存储在每个顶点上，定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个二维变量(u，v)来表示，其中u是横向坐标，而v是纵向坐标。</p>
<blockquote>
<p>顶点UV坐标的范围通常都被归一化到[0，1]范围内。<br>在OpenGL里，纹理空间的原点位于左下角，而在DirectX中，原点位于左上角。Unity使用的纹理空间是符合OpenGL的传统的</p>
</blockquote>
<h3 id="uv-uv2-uv3-uv4"><a href="#uv-uv2-uv3-uv4" class="headerlink" title="uv, uv2, uv3, uv4"></a>uv, uv2, uv3, uv4</h3><p><img src="./UV.png" alt="Alt text"><br>unity一共支持4套uv，在shader编程中，分别叫UV0, UV1, UV2, UV3，而在c＃编程中分别叫uv, uv2, uv3, uv4。<br>通常来说(使用c# API中的命名)，uv用于主纹理, uv2用于光照贴图(Lightmap)的采样, uv3用于实时动态光照, uv4可进行自定义。<br>uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。如果在建模软件中只做了一套uv，将模型导入unity的时候，在导入设置中勾选Generate Lightmap UVs, unity会自动为我们生成用于光照贴图的uv2。uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p>
<blockquote>
<p>3DMax和maya等软件都能对模型加多套uv<br>注意模型在fbx里可以保留多套uv，但是obj里只能保留默认的第一套<br>另外unity里现在貌似支持最多四套</p>
</blockquote>
<h3 id="清除不必要的UV通道"><a href="#清除不必要的UV通道" class="headerlink" title="清除不必要的UV通道"></a>清除不必要的UV通道</h3><p>某些时候，因为美术的一些意外操作，会引入多个我们不需要的UV通道。<br>由于unity的光照贴图会自动占用uv2通道，如果你的项目中又使用的是动态加载光照贴图的方式的话，最好不要在导入模型的时候把UV2设置为null，如果你这样做了有可能会导致光照贴图显示不出来的问题。<br>如果物体不需要烘培，你自己也不使用uv2，则可以删除该通道。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除color和uv</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClearModelUV</span>:<span class="title">AssetPostprocessor</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnPostprocessModel</span>(<span class="params">GameObject rImaportModel</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">this</span>.ClearMeshUVAndColorChannel(rImaportModel);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ClearMeshUVAndColorChannel</span>(<span class="params">GameObject rImportModel</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		List&lt;Vector2&gt; rNewUV = <span class="literal">null</span>;</span><br><span class="line">		List&lt;Color32&gt; rNewColor = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">var</span> rFilters= rImportModel.GetComponentsInChildren&lt;MeshFilter&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> filter_index = <span class="number">0</span>; filter_index &lt; rFilters.Length; filter_index++)</span><br><span class="line">		&#123;</span><br><span class="line">			rFilters[filter_index].sharedMesh.SetColors(rNewColor);</span><br><span class="line">			rFilters[filter_index].sharedMesh.SetUVs(<span class="number">1</span>, rNewUV);</span><br><span class="line">			rFilters[filter_index].sharedMesh.SetUVs(<span class="number">2</span>, rNewUV);</span><br><span class="line">			rFilters[filter_index].sharedMesh.SetUVs(<span class="number">3</span>, rNewUV);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Texture-Type"><a href="#Texture-Type" class="headerlink" title="Texture Type"></a>Texture Type</h3><p>Default 默认的纹理类型，普通的图片<br>Normal map 法线贴图</p>
<blockquote>
<p>【关于法线贴图：就是看起来与3D效果无异的2D贴图】<br>游戏场景中譬如雕刻这种3D细节，如果做3D模型的话，就会浪费显示芯片，使游戏性能下降，便会用法线贴图，既不影响玩家体验游戏又不影响游戏性能</p>
</blockquote>
<p>Editor GUI and Legacy GUI  GUI编辑器用到的UI贴图<br>Sprite(2D and UI)  图片精灵，主要用于2D游戏中，把一张大的图分割成一张张小图，大的图叫图集atlas,<br>小的图叫精灵sprite,可以通过精灵名字来使用精灵.<br>Cursor 鼠标或者叫光标的贴图<br>Cubemap 立方体的纹理<br>Cookie  遮罩贴图 聚光灯贴图<br>Lightmap 光照或者叫烘焙贴图<br>Advanced 高级(可自定义一些贴图属性)</p>
<h3 id="Alpha-Source-α通道来源"><a href="#Alpha-Source-α通道来源" class="headerlink" title="Alpha Source (α通道来源)"></a>Alpha Source (α通道来源)</h3><ol>
<li>None：强制无α通道。</li>
<li>Input Texture Alpha：使用纹理自带的α通道。</li>
<li>From Gray Scale：使用纹理RGB通道的均值来生成α通道。</li>
</ol>
<h3 id="Alpha-Is-Transparen"><a href="#Alpha-Is-Transparen" class="headerlink" title="Alpha Is Transparen"></a>Alpha Is Transparen</h3><p>当alpha用于透明处理时，我们要勾上该选项，可以防止不透明边缘锯齿现象</p>
<p>性”alpha is transparency”，原理是在压缩之前对贴图进行颜色放大处理来搞定边缘锯齿问题，这个颜色放大处理等同于ps里的最小值滤镜操作，对图片边缘做强化处理。</p>
<p>一个坑：（<a href="http://blog.coolcoding.cn/?p=198）" target="_blank" rel="noopener">http://blog.coolcoding.cn/?p=198）</a><br>如果有一张PNG图片, 95%的地方是全透明的,而在全透明的地方,RGB值是有意义的;<br>如果设置了alphaIsTransparency属性,则全透明的地方,Unity会将RGB值全部丢失!!!<br>如果要使用此纹理的4个通道做数据存储时(比如地型的4通道混合)<br>千万不能勾选alphaIsTransparency属性<br>除非此PNG图片仅仅用于UI显示。</p>
<h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><p>Non Power of 2：NPOT的处理方式。<br>Read/Write Enabled：读写开关，非必要不开启，否则会增加一倍的 内存。<br>Generate Mip Maps：生成Mip Maps，会增加33%的内存。一般用 于模型纹理，UI、天空盒等纹理不需要开启。<br>Border Mip Maps：防止低阶的Mip Map的色彩值溢出边界，一般用 于光照Cookie。<br>Mip Map Filtering：过滤算法，Box和Kaiser。<br>Fadeout Mip Maps：根据层阶使Mip Map慢慢变灰，一般用于细节 贴图（DetailMaps）。</p>
<h3 id="Wrap-Mode"><a href="#Wrap-Mode" class="headerlink" title="Wrap Mode"></a>Wrap Mode</h3><p>Wrap mode determines how texture is sampled when texture coordinates are outside of the typical 0..1 range.<br>这由纹理的映射函数来决定。在OpenGL中，这类映射函数称为“Texture Wrapping Mode”；在D3D中，称为“Texture Addressing Mode”。</p>
<h4 id="Repeat-重复"><a href="#Repeat-重复" class="headerlink" title="Repeat   重复"></a>Repeat   重复</h4><p>Tiles the texture, creating a repeating pattern.<br>When UVs are outside of the 0…1 range, the integer part will be ignored, thus creating a repeating pattern.<br>在算法上，忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上。对于大多数复制纹理的使用，在纹理顶部的纹理单元应与底部的纹理单元相匹配，在纹理左侧的纹理单元也应与右侧的纹理单元相匹配。这样才能做到无缝连接。</p>
<h4 id="Clamp-拉伸"><a href="#Clamp-拉伸" class="headerlink" title="Clamp    拉伸"></a>Clamp    拉伸</h4><p>makes the texture edge pixels be stretched when outside of of 0..1 range.<br>This is useful for preventing wrapping artifacts when mapping an image onto an object and you don’t want the texture to tile. UV coordinates will be clamped to the range 0…1. When UVs are larger than 1 or smaller than 0, the last pixel at the border will be used.<br>将大于1.0的数值设置为1.0，将小于0.0的数值设置为0.0，即将超出[0.0,1.0]范围的数值截取到[0.0,1.0]范围内，这样会导致纹理边缘的重复。</p>
<h4 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h4><p>Tiles the texture, creating a repeating pattern by mirroring it at every integer boundary.</p>
<h4 id="Mirror-Once"><a href="#Mirror-Once" class="headerlink" title="Mirror Once"></a>Mirror Once</h4><p>Mirrors the texture once, then clamps to edge pixels.<br>This effectively mirrors the texture around zero UV coordinates, and repeats edge pixel values when outside of [-1..1] range.</p>
<blockquote>
<p>This mode is called “mirror and clamp to edge” in graphics APIs like Vulkan, Metal and OpenGL. This feature is not always supported when using OpenGL ES and Vulkan graphics APIs, specifically on ARM and Qualcomm GPUs platforms. Check SystemInfo.supportsTextureWrapMirrorOnce to figure out whether the system is capable..</p>
</blockquote>
<h4 id="Per-axis"><a href="#Per-axis" class="headerlink" title="Per-axis"></a>Per-axis</h4><p>Choose this to individually control how Unity wraps Textures at the U axis and V axis.</p>
<h3 id="Filter-Mode"><a href="#Filter-Mode" class="headerlink" title="Filter Mode"></a>Filter Mode</h3><p>控制纹理通过三维变换拉伸的计算(过滤)方式</p>
<p>Point：最近点采样，当纹理坐标没有刚好对应Texture上的一个采样点时，它会选择最近的一个采样点作为该坐标的采样值，</p>
<p>当纹理没有拉伸变形时，这样还不错，因为速度是最快的，但如果拉伸变形了，会出现马赛克现象。</p>
<p>Bilinear：双线性过滤，以像素对应的纹理坐标为中心，采样它周围4个texel（纹素）的像素，取平均值作为该坐标采样值。这是Unity默认的模式，过渡效果相对平滑，当然速度会比最近点采样有一定下降。会有模糊化现象。</p>
<p>Trilinear：三线性过滤，会对像素大小和纹素大小最接近的两层Mipmap level分别进行双线性过滤，再对结果进行线性插值。由于使用了两次双线性过滤，也就是计算2x4=8个像素的值，速度会更加下降，当然滤波效果更好。同上也会有模糊化现象。</p>
<h3 id="Aniso-Level"><a href="#Aniso-Level" class="headerlink" title="Aniso Level"></a>Aniso Level</h3><p>各向异性级别。当以一个过小的角度观察纹理时，此数值越高观察的纹理质量就越高，该参数对于提高地面等纹理的显示效果非常明显。</p>
<blockquote>
<p>Default  点了没效果不能重置所有设置，还是得手动选择.废弃的按钮</p>
</blockquote>
<h3 id="对不同平台的压缩设置"><a href="#对不同平台的压缩设置" class="headerlink" title="对不同平台的压缩设置"></a>对不同平台的压缩设置</h3><ul>
<li>Max Size：最大尺寸。</li>
<li>Compression：压缩质量。</li>
<li>Format：压缩格式。<br>格化式存储该纹理的类型，纹理的精度越高，占用的内存越大，得到的效果也越好</li>
<li>Compressed    默认压缩方式,PVRTC图片格式，压缩选项将会针对你的目标平台来选择最合适的压缩算法替换原来的我们给的图片格式(比如我们给的是PNG格式)。<br>  16 bits            无压缩16位格式，比32位节省一半的空间和内存。<br>  Truecolor       无压缩32位以上真彩色,适合对色彩要求较高的情况下使用，比较占空间和内存。</li>
<li>Compressor Quality：压缩质量</li>
<li>Use Crunch Compression：紧凑压缩<blockquote>
<p>Crunched  这种类型将会根据显卡的GPU来选择合适的压缩格式进行压缩然后会选用一种CPU上就能处理的压缩格式再压缩一遍。如果在制作供人下载的资源包的时候这种类型非常的合适。这个类型的压缩需要很长时间，但在运行时解压是非常快的。</p>
</blockquote>
</li>
</ul>
<h3 id="其他纹理类型设置"><a href="#其他纹理类型设置" class="headerlink" title="其他纹理类型设置"></a>其他纹理类型设置</h3><h3 id="Normal-Map"><a href="#Normal-Map" class="headerlink" title="Normal Map"></a>Normal Map</h3><p>与Default相比增加了一下设置：<br>Create from Grayscale：从灰度高度图（Heightmap）创建。<br>Bumpiness：崎岖度。<br>Filtering：滤波算法。</p>
<ol>
<li>Smooth：平滑，标准前向差分算法。 2. Sharp：尖锐，Sobel滤波器。</li>
</ol>
<h4 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h4><p>与Default相比增加了一下设置：<br>Sprite Mode：精灵模式。</p>
<ol>
<li>Single：单图。</li>
<li>Multiple：多图。</li>
<li>Polygon：多边形，在SpriteEditor里使用多边形裁剪精灵。<br>PackingTag：指定图集。<br>PixelsPer Unit：每单位像素数，在世界场景中，每单位距离有多少个 像素。</li>
</ol>
<p>Mesh Type：网格类型（Polygon模式无此属性）。</p>
<ol>
<li>FullRect：矩形。 2. Tight：紧凑的，根据Alpha通道生成Mesh。（2DObject）<br>ExtrudeEdge：拉伸边缘。</li>
</ol>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie类型的纹理设置<br>与Default相比增加了一下设置：<br>Light Type：光照类型。</p>
<ol>
<li>Spotlight：聚光灯，形状必须为2D。</li>
<li>Directional：平行光，形状必须为2D。</li>
<li>Point：点光源，形状必须为立方体。</li>
</ol>
<h2 id="Sprite及图集的使用"><a href="#Sprite及图集的使用" class="headerlink" title="Sprite及图集的使用"></a>Sprite及图集的使用</h2><blockquote>
<p>只有Sprite模式的图片才可以打包成图集</p>
</blockquote>
<p>旧版：<br>Sprite Mode 设置为 Muitiple 设置Packing Tag<br>Window-&gt;Sprite Packer –&gt;点击 Pack 即可</p>
<p>新版：<br>Project Setting -&gt; Editor  -&gt; Sprite Packer -&gt; Mode = Always Enabled<br>新建 Sprite Atlas<br>选择打包图集的文件夹或者依次添加单独图片，点击Pack Preview后自动打包成一个图集</p>
<p>代码获取图集并动态选择Sprite：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.U2D;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpriteAtlasExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SpriteAtlas atlas = AssetDatabase.LoadAssetAtPath&lt;SpriteAtlas&gt;(<span class="string">"Assets/TestAtlas.spriteatlas"</span>);</span><br><span class="line">        Sprite sprite = atlas.GetSprite(<span class="string">"Icon2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (sprite != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetComponent&lt;Image&gt;().sprite = sprite;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="压缩格式相关"><a href="#压缩格式相关" class="headerlink" title="压缩格式相关"></a>压缩格式相关</h2><h3 id="图像文件格式"><a href="#图像文件格式" class="headerlink" title="图像文件格式"></a>图像文件格式</h3><p>文件格式是图像为了存储信息而使用的对信息的特殊编码方式，它存储在磁盘中，或者内存中，但是并不能被GPU所识别，因为以向量计算见长的GPU对于这些 复杂的计算无能为力。这些文件格式当被游戏读入后，还是需要经过CPU转换成图形硬件支持的格式，再传送到GPU端进行使用。<br>常用的图片格式及特点如下：</p>
<ul>
<li>JPG 有损压缩 文件小 不支持透明</li>
<li>PNG 无损压缩 文件小 支持透明</li>
<li>TAG 无损压缩 文件大 支持透明</li>
<li>DDS 无损压缩 文件最小 支持透明</li>
</ul>
<p>不同格式的本质区别在于压缩算法不一样，结果图片大小，还原度也各不相同。</p>
<blockquote>
<p>TIFF（Tag Image File Format）文件是由Aldus和Microsoft公司为扫描仪和桌上出版系统研制开发的一种较为通用的图像文件格式。TIFF格式灵活易变，同时定义了四类不同的格式：TIFF－B适用于二值图像；TIFF－G适用黑白灰度图像；TIFF－P适用于带调色板的彩色图像；TIFF－R适用于RGB真彩图像。TIFF支持多种编码方法，其中包括RGB无损压缩、RLE压缩以及JPEG压缩等。</p>
<p>GIF（Graphics Interchange Format ）是CompuServe公司在1987年开发的图像文件格式。GIF文件的数据是经过压缩的，它采用了可变长度的压缩算法。GIF的图像深度从1 bit到8 bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。</p>
</blockquote>
<h3 id="3D-图形硬件支持的压缩格式"><a href="#3D-图形硬件支持的压缩格式" class="headerlink" title="3D 图形硬件支持的压缩格式"></a>3D 图形硬件支持的压缩格式</h3><p>JPG, PNG, PSD are  not used <strong>during realtime rendering by 3D graphics hardware</strong>  such as a graphics card or mobile device. 3D graphics hardware requires Textures to be compressed in specialized formats which are <strong>optimised for fast Texture sampling</strong> . The various different platforms and devices available each have their own different proprietary formats.</p>
<p>By default, the Unity Editor automatically converts Textures to the most appropriate format to match the build target you have selected. Only the converted Textures are included in your build; your source Asset<br> files are left in their original format, in your project’s Assets folder.</p>
<blockquote>
<p>如果发现GPU不支持当前压缩格式，Unity就会将纹理转换成RGB（A），首先是解压过程的消耗，其次是内存中会保存两个纹理。</p>
</blockquote>
<h4 id="简单纹理格式"><a href="#简单纹理格式" class="headerlink" title="简单纹理格式"></a>简单纹理格式</h4><p>RGBA8888 每个像素4字节，RGBA通道各占用8位<br>RGBA4444 每个像素2字节，RGBA通道各占用4位<br>RGB888 每个像素3字节，RGB通道各占用8位，无透明通道<br>RGB565 每个像素2字节，RGB通道各占用5/6/5位，无透明通道<br>RGBA5551 每个像素2字节，RGB通道各占用5位，透明通道1位，所以要么完全透明要么不透明</p>
<blockquote>
<p>所有设备对RGB 16BITS/ARGB 16BITS/RGB A16BITS/RGB 24BITS/ARGB 32BITS等支持都很好，只是这些格式算是非压缩格式，对内存消耗和渲染消耗非常不友好。</p>
</blockquote>
<h4 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h4><ul>
<li>DXT - 有损压缩方式</li>
<li>ETC - （Ericsson Texture Compression），在移动平台中广泛采用。它是一种为感知质量设计的有损算法，其依据是人眼对亮度改变的反应要高于色度改变。<ul>
<li>ETC1：安卓原生支持，在各种Android设备上非透明纹理都可以采用ETC1格式。ETC1不支持透明，对于透明纹理，在Android设备上，可以把RGB和Alpha拆到2张ETC1纹理上，游戏中再合成使用。</li>
<li>ETC2是ETC1的扩张，向后兼容ETC1，对RGB的压缩质量更好，并且支持透明通道。ETC2比ETC1压缩质量更高，而且支持透明，在Android设备上再也不需要打不同纹理格式的包了。不过需要OpenGL ES 3.0以上才可以，目前很多设备只支持OpenGL ES 2.0。</li>
</ul>
</li>
<li>PVRTC（PowerVR Texture Compression） - 压缩比高，也是有损压缩。iOS只支持PVRTC的压缩格式。</li>
</ul>
<p>关于压缩后的在储存上的大小，假设高清(ARGB32)大小为1，那么大概数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RGB PVRTC 4BITS:0.25</span><br><span class="line">ARGB PVRTC 4BITS:0.25</span><br><span class="line">RGB PVRTC 2BITS:0.13</span><br><span class="line">ARGB PVRTC 2BITS:0.13</span><br><span class="line">RGBA ETC2 4BITS:0.25</span><br><span class="line">RGBA ETC2 8BITS:0.25</span><br><span class="line">RGB + 1-bit ALPHA ETC2 8BITS:0.2</span><br><span class="line">DXT1 :0.3</span><br><span class="line">DXT5 : 0.6</span><br><span class="line">ARGB 16BITS:0.33</span><br><span class="line">RGB 16BITS:0.5</span><br><span class="line">RGB 24BITS:0.85</span><br><span class="line">ARGB 32BITS:1</span><br></pre></td></tr></table></figure><br>内存中的大小，假设高清(ARGB32)大小为1，那么大概数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RGB PVRTC 2BITS:0.0625</span><br><span class="line">ARGB PVRTC 2BITS:0.0625</span><br><span class="line">RGB PVRTC 4BITS:0.125</span><br><span class="line">ARGB PVRTC 4BITS:0.125</span><br><span class="line">RGBA ETC2 4BITS:0.125</span><br><span class="line">RGBA ETC2 8BITS:0.25</span><br><span class="line">RGB + 1-bit ALPHA ETC2 8BITS:0.125</span><br><span class="line">DXT1 : 0.125</span><br><span class="line">DXT5 : 0.25</span><br><span class="line">ARGB 16BITS:0.5</span><br><span class="line">RGB 16BITS:0.5</span><br><span class="line">RGB 24BITS:0.8</span><br><span class="line">ARGB 32BITS:1</span><br></pre></td></tr></table></figure></p>
<h4 id="格式选择"><a href="#格式选择" class="headerlink" title="格式选择"></a>格式选择</h4><p>一般方案：ETC1+Alpha/PVRTC4 和 RGB16/RGBA16 搭配使用。</p>
<hr>
<h5 id="高清无压缩"><a href="#高清无压缩" class="headerlink" title="高清无压缩"></a>高清无压缩</h5><p>RGBA32 （等同于原图了，效果最好，效率最差。）</p>
<hr>
<h5 id="中清晰中压缩"><a href="#中清晰中压缩" class="headerlink" title="中清晰中压缩"></a>中清晰中压缩</h5><ul>
<li>不透明贴图 ：RGB 16BITS</li>
<li>透明贴图：RGBA 16BITS + Dithering<blockquote>
<p>RGBA16在遇到渐变的时候表现很差，可能需要做抖动（Dithering）处理。<br>16位压缩会带来颜色损失，但如果本来美术就是按16BITS画的话，就不会损失，日本好些手游都是按16BITS来画的。这样的游戏一般少渐变艳度高比较容易看出来。</p>
</blockquote>
</li>
</ul>
<hr>
<h5 id="低清晰高压缩"><a href="#低清晰高压缩" class="headerlink" title="低清晰高压缩"></a>低清晰高压缩</h5><p>ETC1+Alpha/PVRTC4（能直接被GPU使用，占用少，效率高。）</p>
<p>IOS下</p>
<ul>
<li>普通不透明：RGB PVRTC 4BITS</li>
<li>普通透明：RGBA PVRTC 4BITS</li>
</ul>
<blockquote>
<p>PVRTC 要求方形的图集贴图<br>非方形的贴图会被转成16位RGB(A)的压缩格式。</p>
</blockquote>
<p>Android下：</p>
<ul>
<li>普通不透明：RGB ETC 4BITS</li>
<li>普通透明：<ul>
<li>RGBA 16BIT</li>
<li>有针对性的选择DXT5/ATC8 BITS/ETC2 8BITS</li>
<li>如果有技术支持，可以采用RGB ETC 4BITS加一张ALPHA 8的贴图来实现透明效果。</li>
</ul>
</li>
</ul>
<p><strong>对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16</strong></p>
<blockquote>
<p>Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；<br>iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。<br>另外，针对Android 上的带Alpha通道的图片，还有一种常见的做法，即把Alpha通道独立出来作为另一张纹理，从而将 RGB 部分和 Alpha 部分分别采用 ETC1来压缩，但渲染时就需要自定义的 Shader来处理。</p>
</blockquote>
<p>windows：<br>使用Compressed格式。会压缩为DXT5（带透明通道），DXT1 格式。</p>
<h4 id="关于POT-Power-Of-Two"><a href="#关于POT-Power-Of-Two" class="headerlink" title="关于POT(Power Of Two)"></a>关于POT(Power Of Two)</h4><p>Only textures with width/height being multiple of 4 can be compressed to ETC1 format.（ 只有宽/高的尺寸是4的倍数才能被压缩成ETC1格式。)<br>Only POT textures can be compressed to ETC1 format. ( 只有POT(Power of two,2的幂次方)的贴图才能被压缩成ETC1格式。)</p>
<p>如果纹理的原始尺寸不是2的幂次方的话，则可在Unity中可以通过导入设置来进行更正。<br><img src="./1604336979482.png" alt="Alt text"></p>
<ul>
<li>None不做处理</li>
<li>ToNearest（选择最接近的幂次方）</li>
<li>ToLarger（选择最大尺寸的幂次方）</li>
<li>ToSmaller（选择最小尺寸的幂次方）</li>
</ul>
<p>以一张513x1023尺寸的图片来举例：</p>
<ul>
<li>None：513x1023</li>
<li>ToNearest：512x1024</li>
<li>ToLarger：1024x1024</li>
<li>ToSmaller：512x512</li>
</ul>
<h2 id="实用的小工具"><a href="#实用的小工具" class="headerlink" title="实用的小工具"></a>实用的小工具</h2><h3 id="Texture转换成Texture2D"><a href="#Texture转换成Texture2D" class="headerlink" title="Texture转换成Texture2D"></a>Texture转换成Texture2D</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Texture转换成Texture2D...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="texture"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">Texture2D <span class="title">TextureToTexture2D</span>(<span class="params">Texture texture</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Texture2D texture2D = <span class="keyword">new</span> Texture2D(texture.width, texture.height, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    RenderTexture currentRT = RenderTexture.active;</span><br><span class="line"></span><br><span class="line">    RenderTexture renderTexture = RenderTexture.GetTemporary(texture.width, texture.height, <span class="number">32</span>);</span><br><span class="line">    Graphics.Blit(texture, renderTexture);</span><br><span class="line"></span><br><span class="line">    RenderTexture.active = renderTexture;</span><br><span class="line">    texture2D.ReadPixels(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, renderTexture.width, renderTexture.height), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    texture2D.Apply();</span><br><span class="line"></span><br><span class="line">    RenderTexture.active = currentRT;</span><br><span class="line">    RenderTexture.ReleaseTemporary(renderTexture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> texture2D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Texture2D形式截图"><a href="#Texture2D形式截图" class="headerlink" title="Texture2D形式截图"></a>Texture2D形式截图</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 截图...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="rect"&gt;</span>截图的区域<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">Texture2D <span class="title">CaptureScreenshot</span>(<span class="params">Rect rect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 先创建一个的空纹理，大小可根据实现需要来设置</span></span><br><span class="line">	Texture2D screenShot = <span class="keyword">new</span> Texture2D((<span class="keyword">int</span>)rect.width, (<span class="keyword">int</span>)rect.height, TextureFormat.RGB24,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取屏幕像素信息并存储为纹理数据，</span></span><br><span class="line">	screenShot.ReadPixels(rect, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	screenShot.Apply();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后将这些纹理数据，成一个png图片文件</span></span><br><span class="line">	<span class="keyword">byte</span>[] bytes = screenShot.EncodeToPNG();</span><br><span class="line">	<span class="keyword">string</span> filename = Application.dataPath + <span class="string">"/Screenshot.png"</span>;</span><br><span class="line">	System.IO.File.WriteAllBytes(filename, bytes);</span><br><span class="line">	Debug.Log(<span class="keyword">string</span>.Format(<span class="string">"截屏了一张图片: &#123;0&#125;"</span>, filename));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后，我返回这个Texture2d对象，这样我们直接，所这个截图图示在游戏中，当然这个根据自己的需求的。</span></span><br><span class="line">	<span class="keyword">return</span> screenShot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Texture保存到本地"><a href="#Texture保存到本地" class="headerlink" title="Texture保存到本地"></a>Texture保存到本地</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将Texture转为本地PNG...</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filePath"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="teture"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">saveMainTextureToPng</span>(<span class="params"><span class="keyword">string</span> filePath, Texture teture</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (teture.GetType() != <span class="keyword">typeof</span>(Texture2D))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Texture2D savedTexture = (Texture2D)teture;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Texture2D newTexture = <span class="keyword">new</span> Texture2D(savedTexture.width, savedTexture.height, TextureFormat.RGBA32, <span class="literal">false</span>);</span><br><span class="line">        newTexture.SetPixels(<span class="number">0</span>, <span class="number">0</span>, savedTexture.width, savedTexture.height, savedTexture.GetPixels());</span><br><span class="line">        newTexture.Apply();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = newTexture.EncodeToPNG();</span><br><span class="line">        <span class="keyword">if</span> (bytes != <span class="literal">null</span> &amp;&amp; bytes.Length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (File.Exists(filePath))</span><br><span class="line">            &#123;</span><br><span class="line">                File.Delete(filePath);</span><br><span class="line">            &#125;</span><br><span class="line">            System.IO.File.WriteAllBytes(filePath, bytes);                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将图片转换为byte数组"><a href="#将图片转换为byte数组" class="headerlink" title="将图片转换为byte数组"></a>将图片转换为byte数组</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 将图片转换为byte数组...</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filePath"&gt;</span>图片路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">ReadTexture</span>(<span class="params"><span class="keyword">string</span> filePath</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      FileStream fileStream = <span class="keyword">new</span> FileStream(filePath, FileMode.Open, System.IO.FileAccess.Read);</span><br><span class="line">      fileStream.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line"><span class="comment">//创建byte数组 ...  </span></span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[fileStream.Length];  </span><br><span class="line">      fileStream.Read(buffer, <span class="number">0</span>, (<span class="keyword">int</span>)fileStream.Length);</span><br><span class="line"></span><br><span class="line">      fileStream.Close();</span><br><span class="line">      fileStream.Dispose();</span><br><span class="line">      fileStream = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h2><p><a href="https://www.cnblogs.com/suogasus/p/5311264.html" target="_blank" rel="noopener">https://www.cnblogs.com/suogasus/p/5311264.html</a></p>
<p>Alpha通道是计算机图形学中的术语，指的是特别的通道，意思是“非彩色”通道，主要是用来保存选区和编辑选区</p>
<ul>
<li>Alpha 没有透明度的意思，不代表透明度。opacity 和 transparency 才和透明度有关，前者是不透明度，后者是透明度。比如 css 中的「opacity: 0.5」就是设定元素有 50% 的不透明度。</li>
<li>一个图像的每个像素都有 RGB 三个通道，后来 Alvy Ray Smith 提出每个像素再增加一个 Alpha 通道，取值为0到1，用来储存这个像素是否对图片有「贡献」，0代表透明、1代表不透明。也就是说，「Alpha 通道」储存一个值，其外在表现是「透明度」，Alpha 和透明度没啥关系。</li>
<li>为什么取名为 Alpha 通道，我觉得是因为这是除RGB以外「第一个通道」的意思，没有别的更深刻的含义。</li>
<li>Alpha 通道」是图片内在的一个属性，用 css 或者其他外部方法设定透明度，并没有改变图片的 Alpha 通道的值。</li>
</ul>
<p>真正让图片变透明的不是Alpha 实际是Alpha所代表的数值和其他数值做了一次运算<br>比如你有一张图片你想抠出图片中间的一部分 在PS里你会建立一个蒙板 然后在蒙板里把不需要的地方填充成黑色 需要的留成白色 这个时候实际上是是做了一次乘法<br>用黑色所代表的数值0去乘以你所填充的地方 那么这个地方就变透明了</p>
<p>设Alpha值[0，255]区间映射为[0，1]区间相对应的值表示，即Alpha值为0—1之间的数值。则图形文件中各个像素点可表示为：<br>Graphx（Redx，Greenx，Bulex，Alphax）<br>屏幕上相应像素点的显示值就转换为：<br>Dispx（Redx<em>Alphax，Greenx</em>Alphax，Bluex*Alphax）</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>Alpha通道<br>颜色通道<br>复合通道<br>专色通道<br>矢量通道</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>《Unity Shader入门精要》 冯乐乐<br><a href="https://zhuanlan.zhihu.com/p/126752791" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126752791</a><br><a href="https://www.jianshu.com/p/bec1a7514b08" target="_blank" rel="noopener">https://www.jianshu.com/p/bec1a7514b08</a><br><a href="https://blog.csdn.net/ynnmnm/article/details/44983545" target="_blank" rel="noopener">https://blog.csdn.net/ynnmnm/article/details/44983545</a><br><a href="https://www.jianshu.com/p/832e242523a4" target="_blank" rel="noopener">https://www.jianshu.com/p/832e242523a4</a><br><a href="https://blog.csdn.net/skymanwu/article/details/295121" target="_blank" rel="noopener">https://blog.csdn.net/skymanwu/article/details/295121</a><br><a href="https://blog.csdn.net/qq_29266497/article/details/81515326" target="_blank" rel="noopener">https://blog.csdn.net/qq_29266497/article/details/81515326</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Asset/" rel="tag">Asset</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rendering/" rel="tag">Rendering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Texture/" rel="tag">Texture</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-CG-About-Texture-Filtering"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/28/CG-About-Texture-Filtering/"
    >【渲染】纹理滤波(Texture Filtering)相关知识整理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/28/CG-About-Texture-Filtering/" class="article-date">
  <time datetime="2020-10-28T06:29:00.000Z" itemprop="datePublished">2020-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-Rendering/">CG&Rendering</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="纹理映射-与-纹理采样"><a href="#纹理映射-与-纹理采样" class="headerlink" title="纹理映射 与 纹理采样"></a>纹理映射 与 纹理采样</h3><p>纹理映射：使用uv坐标将纹理像素(texel)映射到屏幕像素(pixel)的过程。</p>
<p>纹理采样（Texture Sample）：既然纹理是一张图片，那么自然就有分辨率的存在，纹理采样便是从纹理图片中采集一个像素颜色的操作。</p>
<h3 id="插值-Interpolation-的概念"><a href="#插值-Interpolation-的概念" class="headerlink" title="插值(Interpolation)的概念"></a>插值(Interpolation)的概念</h3><p>在数学的数值分析领域中，内插或称插值（英语：interpolation）是一种通过已知的、离散的数据点，在范围内推求新数据点的过程或方法。求解科学和工程的问题时，通常有许多数据点借由采样、实验等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。而根据这些数据，我们往往希望得到一个连续的函数（也就是曲线）；或者更密集的离散方程与已知数据互相吻合，这个过程叫做拟合。</p>
<p>常用的插值方法有：最近邻插值（Nearest-neighbor interpolation）、线性插值（线性插值）、多项式插值（Polynomial interpolation）、样条曲线插值（Spline interpolation）等。</p>
<p>高维度空间的计算中，需要用到多元插值（Multivariate interpolation）。方法有：</p>
<ul>
<li>双线性插值(bilinear interpolation) 和 双三次插值(bicubic interpolation) in two dimensions</li>
<li>trilinear interpolation in three dimensions.</li>
</ul>
<h4 id="线性插值-Linear-interpolation"><a href="#线性插值-Linear-interpolation" class="headerlink" title="线性插值(Linear interpolation)"></a>线性插值(Linear interpolation)</h4><p>In mathematics, linear interpolation is a method of curve fitting using linear polynomials to construct new data points within the range of a discrete set of known data points.<br><img src="./1603809936492.png" alt="Alt text"></p>
<h2 id="纹理滤波（Texture-Filtering）"><a href="#纹理滤波（Texture-Filtering）" class="headerlink" title="纹理滤波（Texture Filtering）"></a>纹理滤波（Texture Filtering）</h2><p><strong>纹理滤波（Texture Filtering）</strong>又称为<strong>纹理平滑（texture smoothing ）</strong> - the method used to determine the texture color for a texture mapped pixel, using the colors of nearby texels (pixels of the texture).</p>
<blockquote>
<p>当三维空间里面的多边形经过坐标变换、投影、光栅化等过程，变成二维屏幕上的一组象素的时候，对每个象素需要到相应纹理图像中进行采样，<strong>纹理过滤</strong>或者说<strong>纹理平滑</strong>是在纹理采样中使采样结果更加合理，以减少各种人为产生的穿帮现象的技术。</p>
</blockquote>
<p>纹理滤波主要分为两类：</p>
<ul>
<li><p><strong>放大过滤（magnification filtering）</strong>: reconstruction filter where sparse data is interpolated to fill gaps. （填充缺口）。一个纹理单元对应着多个像素。需要进行插值，平滑，防止马赛克现象。</p>
</li>
<li><p><strong>缩小过滤（minification filtering）</strong>: anti-aliasing (AA), where texture samples exist at a higher frequency than required for the sample frequency needed for texture fill. （抗锯齿）。一个像素对应着多个纹理单元。</p>
</li>
</ul>
<blockquote>
<p>There are many methods of texture filtering, which make different trade-offs between computational complexity, memory bandwidth and image quality.</p>
</blockquote>
<h3 id="为什么需要纹理滤波"><a href="#为什么需要纹理滤波" class="headerlink" title="为什么需要纹理滤波"></a>为什么需要纹理滤波</h3><p>对于任意的3D表面在纹理映射过程中，需要进行纹理查找来找到屏幕上的一个像素对应于纹理上的哪个位置，而在纹理采样过程中，可能出现如下问题：</p>
<ol>
<li>三维图形上的pixel中心和纹理上的texel中心并不一至。屏幕上像素的纹理映射坐标可能不会完美地落到像素格上。</li>
<li>取决于观察者，textured surface可能在任意的距离和方向，一个像素（pixel）通常不会直接对应一个纹素（texel），可能一个像素被映射到许多纹理像素，或者许多个像素都映射到相同纹素。<br>因此，需要执行一些形式的滤波来决定屏幕像素的最佳颜色。滤波不足或不正确将在图像中表现为伪像（图像中的错误），例如“块状”，锯齿状或闪烁。</li>
</ol>
<hr>
<ul>
<li><p>纹理放大(Texture Magnification)：the texels are larger than screen pixels, and need to be scaled up appropriately - a process known as texture magnification.<br>当最后呈现到屏幕中的尺寸比纹理实际尺寸大的时候，许多个像素都映射到同一纹素。纹理放大如果不进行过滤，会造成马赛克现象。此时需要对纹理进行放大过滤（magnification filtering），使用插值方法，进行平滑。</p>
</li>
<li><p>纹理缩小(Texture Minification)：each texel is smaller than a pixel, and so one pixel covers multiple texels. In this case an appropriate color has to be picked based on the covered texels, via texture minification.<br>当最后呈现到屏幕中的尺寸比纹理实际尺寸小的时候，一个像素被映射到许多纹理像素上。此时需要对纹理进行缩小过滤（minification filtering）。纹理缩小会由于精度损失造成贴图的扭曲。</p>
</li>
</ul>
<p>如图所示，过度的纹理缩小会造成高频走样问题，贴图出现扭曲（波纹）。<br><img src="./1605006132395.png" alt="Alt text"></p>
<h3 id="为什么称为滤波-Filter"><a href="#为什么称为滤波-Filter" class="headerlink" title="为什么称为滤波(Filter)"></a>为什么称为滤波(Filter)</h3><p><strong>图像其实是一种波，可以用波的算法处理图像</strong></p>
<h4 id="图像是波"><a href="#图像是波" class="headerlink" title="图像是波"></a>图像是波</h4><p>每个像素的颜色，可以用红、绿、蓝、透明度四个值描述，大小范围都是0 ～ 255，比如黑色是[0, 0, 0, 255]，白色是[255, 255, 255, 255]。<br><img src="./bg2017121302.png" alt="Alt text"><br>每条曲线都在不停的上下波动。有些区域的波动比较小，有些区域突然出现了大幅波动（比如 54 和 324 这两点）。曲线波动较大的地方，也是图像出现突变的地方。这说明波动与图像是紧密关联的。图像本质上就是各种色彩波的叠加。</p>
<h4 id="频率（frequency）"><a href="#频率（frequency）" class="headerlink" title="频率（frequency）"></a>频率（frequency）</h4><p>图像就是色彩的波动：波动大，就是色彩急剧变化；波动小，就是色彩平滑过渡。因此，波的各种指标可以用来描述图像。<br>频率（frequency）是波动快慢的指标，单位时间内波动次数越多，频率越高，反之越低。<br><strong>色彩剧烈变化的地方，就是图像的高频区域；色彩稳定平滑的地方，就是低频区域。</strong></p>
<h4 id="滤波器（filter）及在图像中的应用"><a href="#滤波器（filter）及在图像中的应用" class="headerlink" title="滤波器（filter）及在图像中的应用"></a>滤波器（filter）及在图像中的应用</h4><p>物理学对波的研究已经非常深入，提出了很多处理波的方法，其中就有滤波器（filter）：过滤掉某些波，保留另一些波。物理中两种常见的滤波器：</p>
<ul>
<li>低通滤波器（lowpass）：减弱或阻隔高频信号，保留低频信号</li>
<li>高通滤波器（highpass）：减弱或阻隔低频信号，保留高频信号</li>
</ul>
<p>应用在图像中：<br><strong>lowpass</strong>使得图像的高频区域变成低频，即色彩变化剧烈的区域变得平滑，也就是出现<strong>模糊效果</strong>。<br><img src="./1603787295513.png" alt="Alt text"></p>
<p><strong>highpass</strong>正好相反，过滤了低频，只保留那些变化最快速最剧烈的区域，也就是图像里面的物体边缘，所以常用于<strong>边缘识别</strong>。<br><img src="./1603787306380.png" alt="Alt text"></p>
<h3 id="Mipmapping"><a href="#Mipmapping" class="headerlink" title="Mipmapping"></a>Mipmapping</h3><p>Mipmapping is a standard technique used to <strong>save some of the filtering work</strong> needed during <strong>texture minification</strong>.<br>为了加快渲染速度和减少纹理锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为Mipmap。</p>
<h4 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h4><p>背景：Textured objects can be viewed at different distances from the viewpoint</p>
<p>Problem：Which level of detail (Resolution) should one use for the texture image?</p>
<ul>
<li>Too high resolution: Aliasing effects</li>
<li>Too small resolution: Too few details visible</li>
</ul>
<p>Solution: Use different levels of detail according to the distance between object and viewpoint → <strong>mipmaps</strong></p>
<blockquote>
<p>名称由来：mip = “multum in parvo”，拉丁语。</p>
</blockquote>
<p>在纹理缩小过程中，被贴上纹理的多边形距离很远时，纹理的多个纹素可能只落在一个屏幕像素中。需要读取多个纹素并通过合并他们的值的方式来决定屏幕像素的颜色，这样计算开销很大。Mipmapping会对纹理进行预过滤，并以较小的分辨率进行存储，从而避免运行时进行如此计算的开销。</p>
<blockquote>
<p>在3D场景中，由于距离问题，物体的纹理需要经常被缩放、拉伸，使用Mipmap会减小运行过程中的计算量，提升GPU效率。而在UI中，一般不需要繁缩放图片（特殊需求除外），因此不建议开启Mipmap，否则会造成内存浪费。</p>
</blockquote>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>Solves LOD problem by generating a pyramid of textures：</p>
<ul>
<li>Highest texture resolution at pyramid level 0</li>
<li>Halfed Resolution at each subsequent level</li>
</ul>
<p>预先生成一系列以2为倍数缩小（长宽）的纹理序列，在采样纹理时根据图形的大小自动选择相近等级的Mipmap进行采样。</p>
<blockquote>
<p>As the textured surface moves farther away, the texture being applied switches to the prefiltered smaller size. Different sizes of the mipmap are referred to as ‘levels’, with Level 0 being the largest size (used closest to the viewer), and increasing levels used at increasing distances.</p>
</blockquote>
<p>所需空间：(1 + 1/3) times the space<br><img src="./MemoryOfMipmap.png" alt="Alt text"></p>
<p>OpenGL automatically determines the mipmap level to use based on the projected size of the object.</p>
<blockquote>
<p>Mipmap通过下采样（downsampling）原始纹理生成。具体算法有：Nearest Neighbour, Boxfilter, Gaussian filter等</p>
</blockquote>
<h4 id="如何选择Mipmap-Level"><a href="#如何选择Mipmap-Level" class="headerlink" title="如何选择Mipmap Level"></a>如何选择Mipmap Level</h4><p>像素着色器是以像素为单位运行的，采样时该如何得知图形的大小呢？<br>现在的GPU在光栅化后不是逐像素单个渲染，而是分成2x2=4个的像素分块，每个线程处理4个。之所以这样处理是为了保存像素的偏导数信息，在计算mipmap等级和面法线等时候很有用。OpenGL提供了（唯一）一组获取相邻像素信息的函数——偏导函数dFdx和dFdy。偏导数代表了函数在某一方向的变化率，那么如果相邻两个像素间纹理坐标变化很大，则说明绘制的图形很小。<br>如下，计算出纹理坐标在纵向和横向的偏导数（并取最大值）来计算Mipmap级别：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MipmapLevel</span><span class="params">(vec2 texCoord)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The OpenGL Graphics System: A Specification 4.2</span></span><br><span class="line">    <span class="comment">//  - chapter 3.9.11, equation 3.21</span></span><br><span class="line">    vec2 dx = dFdx(texCoord);</span><br><span class="line">    vec2 dy = dFdy(texCoord);</span><br><span class="line">    <span class="keyword">float</span> delta = max(dot(dx, dx), dot(dy, dy));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * log2(delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MipmapLOD计算详解可见：<a href="http://warmcat.org/chai/blog/?p=1183" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1183</a></p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>Mipmap除了能消除采样率过低带来的失真问题，还有一个重要的优点是<strong>节约显存带宽</strong>，注意是带宽而不是容量。Mipmap实际消耗的显存大约增加了1/3，但每次仅从需要的mipmap级别进行读取，而不必每次都访问原始大小的纹理，因此可以节约带宽。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>Mipmap贴图文件占用更多硬盘空间     — 解决方法：使用dds进行压缩存储</li>
<li>Mipmap纹理占用更多内存、显存空间</li>
</ol>
<h2 id="常用滤波方法（插值算法）"><a href="#常用滤波方法（插值算法）" class="headerlink" title="常用滤波方法（插值算法）"></a>常用滤波方法（插值算法）</h2><p>不同的过滤模式，计算复杂度不一样，会得到不同的效果。</p>
<h3 id="最近邻插值采样-Nearest-neighbor-interpolation"><a href="#最近邻插值采样-Nearest-neighbor-interpolation" class="headerlink" title="最近邻插值采样(Nearest-neighbor interpolation)"></a>最近邻插值采样(Nearest-neighbor interpolation)</h3><blockquote>
<p>OpenGL中对应的滤波方式为GL_NEAREST，Unity中对应的为Point。<br>Unity官方文档描述: Point 单点插值，纹理将变得块状化（blocky up close）</p>
</blockquote>
<p><strong>Nearest-neighbor interpolation</strong> (also known as <strong>proximal interpolation</strong> or, <strong>point sampling</strong>)<br>临近返回采样点所落在的像素内，即中心距离采样点曼哈顿距离最近的texel。</p>
<p>The nearest neighbor algorithm selects the value of the nearest point and does not consider the values of neighboring points at all, yielding a piecewise-constant interpolant.</p>
<p><img src="./1603790161075.png" alt="Alt text"></p>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>临近采样的结果始终是纹理中的颜色，在做一些像素风格游戏的时候采用临近。临近通常带来锋利的结果（不是锯齿），颜色之间没有过渡。</p>
<p>当纹理的大小与贴图的三维图形的大小差不多时，这种方法非常有效和快捷。</p>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><h5 id="块状（blocky-）"><a href="#块状（blocky-）" class="headerlink" title="块状（blocky ）"></a>块状（blocky ）</h5><p>不同的UV可能会得到相同的颜色，在放大观察时(Magify状态)会有明显色块(马赛克）。当一个texel对应多个pixel时，所有落在这个texel的pixel都会得到同样的颜色值，在屏幕上就会产生明显的像素锯齿，如果是3D游戏的话，就会显得很假。</p>
<blockquote>
<p>双线性插值解决了texel magnify时像素锯齿的问题，能根据采样点得到不同的颜色值，增加像素细节，只要不是一个uv，就会根据插值得到不同的结果。</p>
</blockquote>
<h5 id="高频走样（波纹和闪烁现象）"><a href="#高频走样（波纹和闪烁现象）" class="headerlink" title="高频走样（波纹和闪烁现象）"></a>高频走样（波纹和闪烁现象）</h5><p>当minify时，一个pixel”覆盖”多个texel，相邻的两个pixel取的texel太远，在纹理图上可能是两个完全不相邻、完全没有关系的像素。对于高频图像，大量信息被压缩在相对比较小的空间中，则像素变化微小时，色彩变化会剧烈，这个问题在物理上叫做高频走样。在绘制地板和远处物体时会由于这个原因，导致<strong>波纹（扭曲）和闪烁（sparkling）</strong>。</p>
<p>在看向地板远端的时候，会发现采样的结果并不连续，而是扭曲的波纹，移动摄像机后，会出现闪烁的问题，看起来非常糟糕。这是由于纹理在远处采样时pixel和它相邻的pixel跨越的texel太长，使在纹理中不相邻的两个texel（或者它们双线性插值的结果）被绘制在了一起。</p>
<ul>
<li>波纹是由于屏幕像素有限，原本不相邻的像素被绘制在一起导致的</li>
<li>闪烁是由于图像的高频，采样的低频，轻微偏移就会产生巨大变化导致的。</li>
</ul>
<h5 id="性能上"><a href="#性能上" class="headerlink" title="性能上"></a>性能上</h5><p>放大的情况下非常快，但是在缩小时开销却极高，因为屏幕上相邻的像素点，可能对应于纹理上距离很远的两个点，而这会破坏纹理采样时的内存连续性，导致L1或者L2缓存的命中率极低，使得纹理采样性能大大降低。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="./1603854909317.png" alt="Alt text"><br>如图所示，近处纹理放大过滤，造成了明显的马赛克现象。远处出现闪烁。</p>
<h3 id="最近点插值-mipmap的方式"><a href="#最近点插值-mipmap的方式" class="headerlink" title="最近点插值+mipmap的方式"></a>最近点插值+mipmap的方式</h3><p>这种方式在最近点插值的基础上，引入了mipmap，当距离相机很近时，使用miplevel0，此时和最近点插值完全一样。当距离下相机很远时，使用更高的miplevel等级，此时使用最近点插值采样更小尺寸的纹理。因此可以缓解缩小时的闪烁和锯齿现象，并且能够充分利用纹理采样时的内存连续性，使得纹理采样性能提高。但是在纹理放大时，不能解决产生的色块现象。<br><img src="./1603855058444.png" alt="Alt text"><br>加了mipmap之后可以看到噪点消失，但是远处纹理明显模糊，而且不同mipmap过渡处有明显分界，而近处的纹理仍然有色块现象。</p>
<h3 id="双线性插值-Bilinear-interpolation"><a href="#双线性插值-Bilinear-interpolation" class="headerlink" title="双线性插值 (Bilinear interpolation)"></a>双线性插值 (Bilinear interpolation)</h3><blockquote>
<p>OpenGL对应的设置为GL_LINEAR，unity对应的设置为bilinear。<br>Unity 官方文档描述：Bilinear 双线性插值，纹理将变得模糊（blurry up close）；</p>
</blockquote>
<p><strong>Bilinear interpolation</strong> is also called <strong>bilinear filtering</strong> or <strong>bilinear texture mapping</strong>.<br>在数学上，双线性插值是对线性插值在二维直角网格上的扩展<br>Bilinear interpolation is performed using linear interpolation first in one direction, and then again in the other direction. Although each step is linear in the sampled values and in the position, the interpolation as a whole is not linear but rather quadratic in the sample location.<br>首先在 X 轴方向插值两次，对得到的两个插值结果再在 Y 轴方向上进行一次插值。</p>
<p><img src="./1603810157411.png" alt="Alt text"></p>
<p><img src="./1603857020919.png" alt="Alt text"></p>
<p><img src="./1603857053404.png" alt="Alt text"><br>图像的双线性插值放大算法中，目标图像中新创造的象素值，是由源图像位置在它附近的2*2区域4个邻近象素的值通过加权平均计算得出的。</p>
<p>双线性过滤对于锯齿问题会有一个很明显的提升。该方法中，采样目标点附近的4个纹素，并且根据权重(距离中心点的距离)进行加权平均。这种方法使得放大纹理时的色块现象得以消失，因为此时两个相邻像素之间是平滑过度的。当缩小纹理时可以结合mipmap进行使用，尽管当缩小很多时，依然会有和最近点过滤方法一样的锯齿和闪烁现象，但是对于大部分合理的缩小比例，可以作为一种开销较少的有硬件加速的纹理超采样方案。<br><img src="./1603855288637.png" alt="Alt text"><br>近处纹理放大导致的马赛克现象明显消失，但是不同mipmap等级间的分界依然明显</p>
<h3 id="三线性插值-Trilinear-interpolation"><a href="#三线性插值-Trilinear-interpolation" class="headerlink" title="三线性插值 (Trilinear interpolation)"></a>三线性插值 (Trilinear interpolation)</h3><p>Trilinear interpolation is a method of multivariate interpolation on a 3-dimensional regular grid.<br>对两个相邻的mipmap等级的纹理进行双线性过滤采样，并对两个采样结果线性插值得到最终的颜色。<br>三线性过滤是对双线性过滤中当纹理距离相机的距离刚好处于两个mipmap等级的交界处时的明显的一个过渡现象的解决方案。<br>通过对两个相邻的mipmap等级的纹理进行双线性过滤采样，并对两个采样结果线性插值得到最终的颜色。这样当纹理到相机的距离逐渐增加时，可以得到平滑的一个过渡，而不是突兀的变化。当然，对于足够近的纹理，因为使用miplevel0这个等级，因此和双线性过滤完全一致。</p>
<p>经过mipmap+三线性插值，解决了</p>
<ul>
<li>点采样法引起的像素值不连续</li>
<li>远景的高频走样</li>
<li>不同lod level区域的明显分界</li>
<li>切换lod level的突变</li>
</ul>
<p><img src="./1603855360374.png" alt="Alt text"></p>
<h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4><p>然而mipmap自身定义上就导致严重的问题。为了解决高频走样，引入了mipmap，强行将高频区域变为低频区域，减少信息量。这样的后果就是随着lod越来越远，采样结果就越模糊。在游戏中，往往表现为感觉越往远看，地面上就越感觉蒙着一层雾，像眼睛近视了一样。</p>
<p>为了增强远景的清晰度，显卡厂商增加了一个新的过程，即各向异性过滤。这个效果对GPU的要求较高，所以在游戏中属于“最高画质”的选项。</p>
<h3 id="各向异性过滤-Anisotropic-filtering"><a href="#各向异性过滤-Anisotropic-filtering" class="headerlink" title="各向异性过滤(Anisotropic filtering)"></a>各向异性过滤(Anisotropic filtering)</h3><p>当一个物体的表面和相机有很大的夹角时，纹理在屏幕上的对应填充区域就不是方形的。例如一个地板，距离相机远的地方，填充区域的宽高是不对等的，此时方形的纹理贴图就不是很合适了，此时就会导致模糊或者闪烁或者两者皆有。各向异性过滤通过采样一个非方形纹理解决了这个问题。</p>
<p>在Unity中通过Aniso Level设置该过滤效果。</p>
<blockquote>
<p>Texture.anisoLevel - Anisotropic filtering level of the texture. Anisotropic filtering makes textures look better when viewed at a shallow angle, but comes at a performance cost in the graphics hardware. Usually you use it on floor, ground or road textures to make them look better.<br>The value range of this variable goes from 1 to 9, where 1 equals no filtering applied and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at shallow angles. Lower values mean the texture will be more blurry at shallow angles.</p>
</blockquote>
<p>Aniso Level == 0<br><img src="./1603855799619.png" alt="Alt text"><br>Aniso Level == 9<br><img src="./1603855820036.png" alt="Alt text"></p>
<h2 id="OpenGL对Minification-Magnification-Filter的选择"><a href="#OpenGL对Minification-Magnification-Filter的选择" class="headerlink" title="OpenGL对Minification/Magnification Filter的选择"></a>OpenGL对Minification/Magnification Filter的选择</h2><p>此处摘录自CHAI’S BLOG：<a href="http://warmcat.org/chai/blog/?p=1222" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1222</a><br>OpenGL允许设置纹理的过滤，分为GL_TEXTURE_MIN_FILTER和GL_TEXTURE_MAG_FILTER两种。<br>如果采样点的像素被认为是Minify了的，则用GL_TEXTURE_MIN_FILTER，如果是为认为是Magnify了的，用GL_TEXTURE_MAG_FILTER，决定用哪一个和mipmap无关，mipmap的三线性过滤通过_MIPMAP_NEAREAST和_MIPMAP_LINEAR决定。<br>默认情况下，GL_TEXTURE_MAG_FILTER 的过滤方式是GL_LINEAR，GL_TEXTURE_MIN_FILTER 的过滤方式是GL_NEAREST_MIPMAP_LINEAR。</p>
<p>opengl提供了dfdx,dfdy两个函数对片段的属性做屏幕空间的偏微分，如果对uv做偏微分的话就是:</p>
<script type="math/tex; mode=display">dfdx(uv)=(\frac{\partial u}{\partial x}, \frac{\partial v}{\partial x})</script><script type="math/tex; mode=display">dfdy(uv)=(\frac{\partial u}{\partial y}, \frac{\partial v}{\partial y})</script><p><img src="./1603865152983.png" alt="Alt text"><br>∂u/∂x和∂v/∂x是左下角的像素和它水平方向的邻居的差，∂u/∂y和∂v/∂y是左下角的像素和它上面的邻居的差，由于∂x=1，∂y=1，则<br>dfdx(uv) = P1.uv - P0.uv<br>dfdy(uv) = P3.uv - P0.uv</p>
<p>使用以下公式判断此纹素是min还是mag<br><img src="./1603864791127.png" alt="Alt text"><br>如果ρ&lt;=1，此纹素被放大了，即mag<br>如果ρ&gt;1，此纹素被缩小了，即min</p>
<h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="纹理环绕（Texture-Wrap）"><a href="#纹理环绕（Texture-Wrap）" class="headerlink" title="纹理环绕（Texture Wrap）"></a>纹理环绕（Texture Wrap）</h3><p>纹理环绕的作用是为了处理超出0.0~1.0范围的纹理坐标，例如采用重复（REPEAT）的环绕方式，采样（4.5,-4.5）的纹理坐标，实际采样的纹理坐标应是（0.5，0.5）。对于负数纹理坐标，采样的实际位置应是1-uv，例如（-0.2,-0.6）应该采样（0.8,0.4）</p>
<h3 id="上-下采样"><a href="#上-下采样" class="headerlink" title="上/下采样"></a>上/下采样</h3><h4 id="downsampled（下采样）"><a href="#downsampled（下采样）" class="headerlink" title="downsampled（下采样）"></a>downsampled（下采样）</h4><p>目的：</p>
<ul>
<li>使得图像符合显示区域的大小；</li>
<li>生成对应图像的缩略图；</li>
</ul>
<p>方法：对于一幅图像尺寸为M<em>N，对其进行s倍的下采样，即得到（M/s）</em>（N/s）尺寸的分辨率图像，当然，s应该是M和N的公约数才可以，如果考虑是矩阵形式的图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点就是窗口内所有像素的均值 Pk = (∑ Xi)/ S^2</p>
<h4 id="upsampling（上采样）"><a href="#upsampling（上采样）" class="headerlink" title="upsampling（上采样）"></a>upsampling（上采样）</h4><p>放大图像（或称为上采样（upsampling）或图像插值（interpolating））的主要目的是放大原图像，从而可以显示在更高分辨率的显示设备上。</p>
<p>上采样的原理：图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。插值算法还包括了传统插值，基于边缘图像的插值，还有基于区域的图像插值。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.sohu.com/a/397647922_468740" target="_blank" rel="noopener">https://www.sohu.com/a/397647922_468740</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC</a><br><a href="https://en.wikipedia.org/wiki/Texture_filtering" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Texture_filtering</a><br><a href="https://en.wikipedia.org/wiki/Linear_interpolation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Linear_interpolation</a><br><a href="http://warmcat.org/chai/blog/?p=1077" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1077</a><br><a href="http://warmcat.org/chai/blog/?p=1222" target="_blank" rel="noopener">http://warmcat.org/chai/blog/?p=1222</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rendering/" rel="tag">Rendering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Texture/" rel="tag">Texture</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/11/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/10/">10</a><a class="page-number" href="/archives/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/13/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>