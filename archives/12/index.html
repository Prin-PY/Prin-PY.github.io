<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-Animation优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Animation%E4%BC%98%E5%8C%96/"
    >Animation优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Animation%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2023-07-25T12:56:23.212Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>标签：</strong>|  <em>优化</em>  </p>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><ol>
<li><p>Rig-&gt;Animation Type:改为Generic</p>
</li>
<li><p>Animations-&gt;Anim.Compression:Optimal</p>
</li>
<li><p>其他高级方式</p>
</li>
</ol>
<h2 id="曲线数据存储与压缩"><a href="#曲线数据存储与压缩" class="headerlink" title="曲线数据存储与压缩"></a>曲线数据存储与压缩</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><h4 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream(流)"></a>Stream(流)</h4><p>Use the “stream” method of storing data (values with time and tangent data for curved interpolation).<br>（保留时间和切线数据进行 <strong>曲线插值</strong> ）<br>This data occupies significantly <strong>more memory</strong> than the “dense” method.</p>
<blockquote>
<p>Streaming curves are very fast to decompress in the average use case.</p>
</blockquote>
<h4 id="Dense-密集的"><a href="#Dense-密集的" class="headerlink" title="Dense(密集的)"></a>Dense(密集的)</h4><p>Optimize animation curves using the “dense” method of storing data (discrete values which are interpolated between linearly).<br>（离散数值之间的 <strong>线性差值</strong> ）<br>不含有切线数据，使用较少内存<br>This method uses less significantly less memory than the “stream” method.<br>与“流”方法相比，此方法使用的内存要少得多。</p>
<h4 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h4><p>Curves are optimised as constant (unchanging) values.<br>Unity selects this automatically if your animation files contain curves with unchanging values.</p>
<h3 id="Compression方式"><a href="#Compression方式" class="headerlink" title="Compression方式"></a>Compression方式</h3><p>Unity引擎对导入的Clip提供三种压缩格式，Off、KeyframeReduction和Optimal。其中Off表示不压缩，Keyframe Reduction表示使用关键帧进行处理，Optimal则表示Unity引擎会根据动画曲线的特点来自动选择一个最优的压缩方式。</p>
<h4 id="Off"><a href="#Off" class="headerlink" title="Off"></a>Off</h4><p>存储方式：Stream</p>
<p>不压缩，官方不推荐</p>
<blockquote>
<p>Unity文档: This means that Unity doesn’t reduce keyframe count on import. Disabling animation compression leads to the highest precision animations, but slower performance and bigger file and runtime memory size. It is generally not advisable to use this option - if you need higher precision animation, you should enable keyframe reduction and lower allowed Animation Compression Error values instead.</p>
</blockquote>
<h4 id="Keyframe-Reduction"><a href="#Keyframe-Reduction" class="headerlink" title="Keyframe Reduction"></a>Keyframe Reduction</h4><p>存储方式：Stream<br>压缩方式：关键帧缩减算法</p>
<h5 id="Keyframe-Reduction算法"><a href="#Keyframe-Reduction算法" class="headerlink" title="Keyframe Reduction算法"></a>Keyframe Reduction算法</h5><p>Basically key frame reduction will simply <strong>go through all key frames in your animation, and evaluate the animation curves with and without that key, and if the difference is smaller then some defined delta, the key is removed.</strong></p>
<p><strong>error tolerance(误差宽容度，容错值)</strong> 或者称为 <strong>error threshold(误差阈值)</strong><br>值越小动画的精度越高，如果默认值的表现效果不过好，可以通过减小容错值来调。</p>
<ul>
<li><p>Rotation Error 角度值</p>
</li>
<li><p>Position Error 百分比值</p>
</li>
<li><p>Scale Error 百分比值</p>
</li>
</ul>
<p>Unity compares the original curve to what the curve looks like after removing a specific keyframe and applies this test：<br>OriginalValue - ReducedValue &gt; OriginalValue * percentageOfError<br>Unity removes a keyframe if the delta between the original value and the reduced value is less than the original value multiplied by the error tolerance percentage.</p>
<h4 id="Optimal"><a href="#Optimal" class="headerlink" title="Optimal"></a>Optimal</h4><p>存储方式：(Unity官方)Unity will use a heuristic algorithm to determine whether it is best to use the <strong>dense</strong> or <strong>stream</strong> method to store the data for each curve.<br>(笔者推测，可能对于unchanging的值做优化处理，使用constant方式存储)<br>压缩方式：Unity decide how to compress, either by <strong>keyframe reduction</strong> or by using <strong>dense format</strong>.</p>
<p>If a track is very short or very noisy (which could happen with motion capture clips or baked simulations), the key reduction algorithm might not give appreciable gains and it is possible that a dense curve might end up having a smaller memory footprint than a streaming curve. </p>
<blockquote>
<p>Unity官方：<br> If your animation clips are imported with “Anim Compression” set to “Optimal” in the Animation import reference, Unity will use a heuristic（启发式的） algorithm to determine whether it is best to use the <strong>dense</strong> or <strong>stream</strong> method to <strong>store the data for each curve</strong>.</p>
</blockquote>
<h3 id="UWA性能对比实验"><a href="#UWA性能对比实验" class="headerlink" title="UWA性能对比实验"></a>UWA性能对比实验</h3><p><a href="https://blog.uwa4d.com/archives/Loading_AnimationClip.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Loading_AnimationClip.html</a></p>
<ol>
<li><p>Optimal压缩方式确实可以提升资源的加载效率，无论是在高端机、中端机还是低端机上；</p>
</li>
<li><p>硬件设备性能越好，其加载效率越高。但随着设备的提升，Keyframe Reduction和Optimal的加载效率提升已不十分明显；</p>
</li>
<li><p>Optimal压缩方式可能会降低动画的视觉质量，因此，是否最终选择Optimal压缩模式，还需根据最终视觉效果的接受程度来决定。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从性能的角度来看，Optimal的方式内存占用是最低的，是我们最推荐的方案，但是可能会降低动画的视觉质量。Off是不压缩，Unity官方都不推荐的。Keyframe Reduction内存稍高于Optimal，在内存性能和效果上算是折中的方案，用户手动设置Keyframe Reduction问题不大。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="1-去掉AnimationClip中的无效曲线：例如ScaleCurve"><a href="#1-去掉AnimationClip中的无效曲线：例如ScaleCurve" class="headerlink" title="1. 去掉AnimationClip中的无效曲线：例如ScaleCurve"></a>1. 去掉AnimationClip中的无效曲线：例如ScaleCurve</h3><pre><code class="lang-csharp">
using UnityEngine; 

using UnityEditor; 

using System.Collections.Generic; 

public class RemoveCurve : AssetPostprocessor

{ 

void OnPostprocessModel(GameObject g)

{ 

Apply(g); 

} 

void Apply(GameObject g)

{ 

List&lt;AnimationClip&gt; animationClipList = new List&lt;AnimationClip&gt;(AnimationUtility.GetAnimationClips(g)); 

if (animationClipList.Count == 0) 

{ 

AnimationClip[] objectList = UnityEngine.Object.FindObjectsOfType(typeof(AnimationClip)) as AnimationClip[]; 

animationClipList.AddRange(objectList); 

} 

foreach (AnimationClip theAnimation in animationClipList) 

{ 

foreach (EditorCurveBinding theCurveBinding in AnimationUtility.GetCurveBindings(theAnimation)) 

{ 

string name = theCurveBinding.propertyName.ToLower(); 

if (name.Contains(&quot;scale&quot;)) 

{ 

AnimationUtility.SetEditorCurve(theAnimation, theCurveBinding, null); 

} 

} 

} 

} 

}
</code></pre>
<h3 id="2-压缩AnimationClip文件float的精度"><a href="#2-压缩AnimationClip文件float的精度" class="headerlink" title="2. 压缩AnimationClip文件float的精度"></a>2. 压缩AnimationClip文件float的精度</h3><pre><code class="lang-csharp">
public static bool CompressAnimationClip(Object o)

{ 

string animationPath = AssetDatabase.GetAssetPath(o); 

try

{ 

//AnimationClip clip = GameObject.Instantiate(o) as AnimationClip;

AnimationClip clip = o as AnimationClip; 

AnimationClipCurveData[] curves = null; 

curves = AnimationUtility.GetAllCurves(clip); 

Keyframe key; 

Keyframe[] keyFrames; 

for (int ii = 0; ii &lt; curves.Length; ++ii) 

{ 

AnimationClipCurveData curveDate = curves[ii]; 

if (curveDate.curve == null || curveDate.curve.keys == null) 

{ 

//Debug.LogWarning(string.Format(&quot;AnimationClipCurveData {0} don&#39;t have curve; Animation name {1} &quot;, curveDate, animationPath));

continue; 

} 

keyFrames = curveDate.curve.keys; 

for (int i = 0; i &lt; keyFrames.Length; i++) 

{ 

key = keyFrames[i]; 

key.value = float.Parse(key.value.ToString(&quot;f3&quot;)); 

key.inTangent = float.Parse(key.inTangent.ToString(&quot;f3&quot;)); 

key.outTangent = float.Parse(key.outTangent.ToString(&quot;f3&quot;)); 

keyFrames[i] = key; 

} 

curveDate.curve.keys = keyFrames; 

clip.SetCurve(curveDate.path, curveDate.type, curveDate.propertyName, curveDate.curve); 

} 

//AssetDatabase.CreateAsset(clip, animationPath);

Debug.Log(string.Format(&quot; CompressAnimationClip {0} Success !!!&quot;, animationPath)); 

return true; 

} 

catch(Exception e) 

{ 

Debug.LogError(string.Format(&quot;CompressAnimationClip Failed !!! animationPath : {0} error: {1}&quot;, animationPath, e)); 

return false; 

} 

}
</code></pre>
<h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><h3 id="optimize-gameobject"><a href="#optimize-gameobject" class="headerlink" title="optimize gameobject"></a>optimize gameobject</h3><p>针对Mecinam新版动画系统的优化选项，默认情况下会将动画网格下的所有骨骼结点隐藏，但是，你可以通过“Extra Transform to Expose”查看你想通过脚本获取的骨骼结点，这样既可以提升该角色的动画模块性能，又可以达到获取某个关键结点的需求。不过这种方式获得的骨骼节点是只读的，如果想要对其中的属性进行改变比如换装，就不可以开启这个选项。</p>
<h3 id="multithreaded-rendering"><a href="#multithreaded-rendering" class="headerlink" title="multithreaded rendering"></a>multithreaded rendering</h3><p>多线程渲染，将主线程的一部分渲染工作移到另一个线程里执行，Android平台下才有的优化渲染设置，但是对半透明物体支持不好，项目中需要进行测试来决定开不开启。</p>
<h3 id="Animation-Type"><a href="#Animation-Type" class="headerlink" title="Animation Type"></a>Animation Type</h3><p>Legacy Generic Humaniod<br>Legacy 老版动画系统<br>Generic 适合非人型动画<br>Humaniod 适合人型动画，可以动画重定向<br>cpu耗时 Generic &lt; Humanoid<br>Humanoid更省内存</p>
<h3 id="Apply-Root-Motion"><a href="#Apply-Root-Motion" class="headerlink" title="Apply Root Motion"></a>Apply Root Motion</h3><p>增加CPU计算量，不建议开启。如果要开启，建议勾上optimize gameobject。</p>
<h3 id="AnimationBlend"><a href="#AnimationBlend" class="headerlink" title="AnimationBlend"></a>AnimationBlend</h3><p>指的是混合树，多层动画，动画状态过渡三个方面。<br>会增加ProcessAnimations的开销<br>避免频繁blend<br>替换不必要的blend tree和layers</p>
<h3 id="Bake-Mesh"><a href="#Bake-Mesh" class="headerlink" title="Bake Mesh"></a>Bake Mesh</h3><p>将Skinned Mesh转换为普通的Mesh，运行时从网格中获取对应的网格数据进行渲染。<br>缺点：需要记录Mesh信息，占用大量内存。</p>
<h3 id="GPU-Skinning"><a href="#GPU-Skinning" class="headerlink" title="GPU Skinning"></a>GPU Skinning</h3><p>用GPU计算网格，<br>优点：<br>减少SkinnedMesh.Render的CPU耗时<br>骨骼结点信息通过纹理来存储，数据量较Bake Mesh会大幅降低<br>缺点：<br>增加GPU消耗，<br>要求DIrectX 11或者Opengl ES 3.0</p>
<h3 id="简化骨骼名字"><a href="#简化骨骼名字" class="headerlink" title="简化骨骼名字"></a>简化骨骼名字</h3><p>unity的动画数据存储的时候按每个骨骼节点的轨道拆分存储的，每个骨骼存储的是从根节点到这个骨骼节点的hierarchy路径，字符串的，骨骼多了之后这部分字符串不少。如果把所有骨骼名字都简化，这里可以省不少内存 </p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://nfrechette.github.io/2017/01/30/anim_compression_unity5/" target="_blank" rel="noopener">http://nfrechette.github.io/2017/01/30/anim_compression_unity5/</a><br><a href="http://www.manew.com/thread-103127-1-1.html" target="_blank" rel="noopener">http://www.manew.com/thread-103127-1-1.html</a><br><a href="https://blog.csdn.net/alexander_xfl/article/details/66975570" target="_blank" rel="noopener">https://blog.csdn.net/alexander_xfl/article/details/66975570</a><br><a href="https://blog.csdn.net/j756915370/article/details/79415841" target="_blank" rel="noopener">https://blog.csdn.net/j756915370/article/details/79415841</a><br><a href="https://blog.uwa4d.com/archives/Loading_AnimationClip.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Loading_AnimationClip.html</a><br><a href="http://www.360doc.com/content/17/0424/15/6432946_648246543.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/0424/15/6432946_648246543.shtml</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-00-实用插件、工具、网站整理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-00-%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/"
    >00_实用插件、工具、网站整理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-00-%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2023-07-25T12:56:23.211Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ol>
<li><p>网格变换与优化：</p>
<ol>
<li><p>Low Poly Mesh Generator 将场景网格变为低多边形风格 <a href="https://www.assetstore.unity3d.com/en/#!/content/59295" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/59295</a></p>
</li>
<li><p>Per-Vertex Ambient Occlusion And Indirect Lighting Generator 快速逐顶点生成环境光遮蔽与间接光照 <a href="https://www.assetstore.unity3d.com/en/#!/content/46880" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/46880</a></p>
</li>
<li><p>Mesh Materializer 改变场景风格的工具 Flat Mesh Generator及Ambient Occlusion And Indirect Lighting工具，另外还带有用于将地形转换为网格的Terrain To Mesh、调整顶点颜色的Vertex Color Adjustments、网格资源优化器以及计算网格厚度的烘焙工具。以上所有工具都同时支持编辑器模式及运行模式。<a href="https://www.assetstore.unity3d.com/en/#!/content/28583" target="_blank" rel="noopener">https://www.assetstore.unity3d.com/en/#!/content/28583</a></p>
</li>
<li><p><a href="https://blog.csdn.net/hebirechenai/category_6673178.html" target="_blank" rel="noopener">https://blog.csdn.net/hebirechenai/category_6673178.html</a> Mesh编程专栏</p>
</li>
<li><p><a href="https://blog.csdn.net/nanggong/article/details/85050343" target="_blank" rel="noopener">https://blog.csdn.net/nanggong/article/details/85050343</a> Mesh绘制点云</p>
</li>
</ol>
</li>
<li></li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-4-3-Unity3D-index"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-4-3-Unity3D-index/"
    >4-3  Unity3D_index</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-4-3-Unity3D-index/" class="article-date">
  <time datetime="2023-07-25T12:56:23.211Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="【内存】PSS内存组成.html">【内存】PSS内存组成</a></li>
<li><a href="优化知识点链接收藏.html">优化知识点链接收藏</a></li>
<li><a href="Mesh%20in%20U3D\(ToUpdate\">Mesh in U3D(ToUpdate)</a>.html)</li>
<li><a href="【资源】Asset%20Bundle\(2020-10-25%20022900\">【资源】Asset Bundle(2020-10-25 02:29:00)</a>.html)</li>
<li><a href="【疑难问题处理】异常捕获与处理.html">【疑难问题处理】异常捕获与处理</a></li>
<li><a href="UGUI.html">UGUI</a></li>
<li><a href="Unity%20Addressasble.html">Unity Addressasble</a></li>
<li><a href="NavMesh.html">NavMesh</a></li>
<li><a href="Draw%20Call与Batching\(TODO\">Draw Call与Batching(TODO)</a>.html)</li>
<li><a href="Unity中Culling相关技术.html">Unity中Culling相关技术</a></li>
<li><a href="Unity相关Culling知识.html">Unity相关Culling知识</a></li>
<li><a href="Unity的渲染顺序.html">Unity的渲染顺序</a></li>
<li><a href="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协.html">从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协程、异步执行究竟有什么关系？</a></li>
<li><a href="Unity渲染相关API.html">Unity渲染相关API</a></li>
<li><a href="Project%20Settings与优化相关知识点.html">Project Settings与优化相关知识点</a></li>
<li><a href="【动画】Unity动画系统.html">【动画】Unity动画系统</a></li>
<li><a href="【动画】Animator%20%26%20ApplyRootMotion.html">【动画】Animator &amp; ApplyRootMotion</a></li>
<li><a href="CubeMap%20%26%20Skybox.html">CubeMap &amp; Skybox</a></li>
<li><a href="Unity中的Texture相关知识\(To%20Update\">Unity中的Texture相关知识(To Update)</a>.html)</li>
<li><a href="【Editor%20Extension】IMGUI.html">【Editor Extension】IMGUI</a></li>
<li><a href="Windows与MacOS在U3D项目中的使用.html">Windows与MacOS在U3D项目中的使用</a></li>
<li><a href="CSharp调用Java%26与Android交互.html">CSharp调用Java&amp;与Android交互</a></li>
<li><a href="Graphics%20-%20Tier%20Settings%20%26%20Quality%20Level.html">Graphics - Tier Settings &amp; Quality Level</a></li>
<li><a href="UPM自定义资源包及相关规范.html">UPM自定义资源包及相关规范</a></li>
<li><a href="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题.html">实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题</a></li>
<li><a href="U3D资源优化（零碎）知识点汇总.html">U3D资源优化（零碎）知识点汇总</a></li>
<li><a href="Animation优化.html">Animation优化</a></li>
<li><a href="0.0%20Unity与Mono和.NET的关系.html">0.0 Unity与Mono和.NET的关系</a></li>
<li><a href="A计划.html">A计划</a></li>
<li><a href="研究Unity引擎的技巧.html">研究Unity引擎的技巧</a></li>
<li><a href="Unity场景管理和切换.html">Unity场景管理和切换</a></li>
<li><a href="Profiler使用技巧.html">Profiler使用技巧</a></li>
<li><a href="资源路径与文件加载.html">资源路径与文件加载</a></li>
<li><a href="资源与内存\(加载、卸载、Destroy\">资源与内存(加载、卸载、Destroy)</a>.html)</li>
<li><a href="Unity大气散射.html">Unity大气散射</a></li>
<li><a href="小知识点与小工具.html">小知识点与小工具</a></li>
<li><a href="编辑器扩展.html">编辑器扩展</a></li>
<li><a href="An%20introduction%20to%20IL2CPP%20internalsВведение%20в.html">An introduction to IL2CPP internalsВведение в IL2CPP - Unity Technologies Blog</a></li>
<li><a href="获取场景点数和面数.html">获取场景点数和面数</a></li>
<li><a href="Unity控制程序停止运行.html">Unity控制程序停止运行</a></li>
<li><a href="Unity%26C预处理指令.html">Unity&amp;C#预处理指令</a></li>
<li><a href="Unity中的路径获取.html">Unity中的路径获取</a></li>
<li><a href="GPU和CPU的区别.html">GPU和CPU的区别</a></li>
<li><a href="出错汇总.html">出错汇总</a></li>
<li><a href="【内存】内存底层深入.html">【内存】内存底层深入</a></li>
<li><a href="【内存】Unity内存组成.html">【内存】Unity内存组成</a></li>
<li><a href="Unity%20Native%20Programming（C与C++互相调用）.html">Unity Native Programming（C#与C++互相调用）</a></li>
<li><a href="Atlas\(图集\">Atlas(图集)</a>.html)</li>
<li><a href="资源管理工具.html">资源管理工具</a></li>
<li><a href="ScriptableObject.html">ScriptableObject</a></li>
<li><a href="强哥UI课.html">强哥UI课</a></li>
<li><a href="0.1_Unity%20%20Profiler.html">0.1_Unity Profiler</a></li>
<li><a href="关于脚本的生命周期、函数的执行顺序.html">关于脚本的生命周期、函数的执行顺序</a></li>
<li><a href="0.2_IL2CPP，%20IL2CPP%20VM.html">0.2_IL2CPP， IL2CPP VM</a></li>
<li><a href="00_实用插件、工具、网站整理.html">00_实用插件、工具、网站整理</a></li>
<li><a href="Assembly%20Definition%20File%20%26%20Package%20Manager.html">Assembly Definition File &amp; Package Manager</a></li>
<li><a href="LUA相关.html">LUA相关</a></li>
<li><a href="GPU%20Skinning.html">GPU Skinning</a></li>
<li><a href="0.2_IL2CPP.html">0.2_IL2CPP</a></li>
<li><a href="BatchMode.html">BatchMode</a></li>
<li><a href="Destroy.html">Destroy</a></li>
<li><a href="0.1_Android内存管理.html">0.1_Android内存管理</a></li>
<li><a href="一些属性.html">一些属性</a></li>
<li><a href="Overdraw.html">Overdraw</a></li>
<li><a href="DrawCall.html">DrawCall</a></li>
<li><a href="序列化与反序列化.html">序列化与反序列化</a></li>
<li><a href="Collider.html">Collider</a></li>
<li><a href="”游戏程序员核心竞争力“问题总结.html">”游戏程序员核心竞争力“问题总结</a></li>
<li><a href="Unity的架构.html">Unity的架构</a></li>
<li><a href="Assets,%20Resources%20and%20AssetBundles%20-%20Unity%20Le.html">Assets, Resources and AssetBundles - Unity Learn</a></li>
<li><a href="【转载】RenderTexture及其用途.html">【转载】RenderTexture及其用途</a></li>
<li><a href="Shader变体相关知识与优化.html">Shader变体相关知识与优化</a></li>
<li><a href="Skinned%20Mesh%20Renderer.html">Skinned Mesh Renderer</a></li>
<li><a href="Image%20%26%20Raw%20Image.html">Image &amp; Raw Image</a></li>
<li><a href="Unity线上技术大会.html">Unity线上技术大会</a></li>
<li><a href="Camera%20%26%20Screen.html">Camera &amp; Screen</a></li>
<li><a href="Map及其与Material、Texture的关系.html">Map及其与Material、Texture的关系</a></li>
<li><a href="Material.html">Material</a></li>
<li><a href="Audio.html">Audio</a></li>
<li><a href="U3D工具链积累.html">U3D工具链积累</a></li>
<li><a href="YAML.html">YAML</a></li>
<li><a href="Unity%20Crash%20与%20符号表.html">Unity Crash 与 符号表</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-2-IL2CPP，-IL2CPP-VM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-0-2-IL2CPP%EF%BC%8C-IL2CPP-VM/"
    >0.2_IL2CPP， IL2CPP VM</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-0-2-IL2CPP%EF%BC%8C-IL2CPP-VM/" class="article-date">
  <time datetime="2023-07-25T12:56:23.209Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="0-2IL2CPP，-IL2CPP-VM"><a href="#0-2IL2CPP，-IL2CPP-VM" class="headerlink" title="0.2IL2CPP， IL2CPP VM"></a>0.2IL2CPP， IL2CPP VM</h1><p>IL to CPP : 把IL中间语言转换成CPP文件</p>
<h2 id="IL2CPP的出现意义"><a href="#IL2CPP的出现意义" class="headerlink" title="IL2CPP的出现意义"></a>IL2CPP的出现意义</h2><ol>
<li><p>Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成<br>Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，像Unity这样支持多平台的引擎，Mono官方的VM肯定是不能满足需求的。所以针对不同的新平台，Unity的项目组就要把VM给移植一遍，同时解决VM里面发现的bug。这非常耗时耗力。这些能移植的平台还好说，还有比如WebGL这样基于浏览器的平台。要让WebGL支持Mono的VM几乎是不可能的。</p>
</li>
<li><p>Mono版本授权受限<br>大家有没有意识到Mono的版本已经更新到3.X了，但是在Unity中，C#的运行时版本一直停留在2.8，这也是Unity社区开发者抱怨的最多一 条：很多C#的新特性无法使用。这是因为Mono授权受限，导致Unity无法升级Mono。如果换做是IL2CPP，IL2CPP VM这套完全自己开发的组件，就解决了这个问题。</p>
</li>
<li><p>提高运行效率<br>根据官方的实验数据，换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p>
</li>
<li><p>可以利用现成的在各个平台的C++编译器对代码执行编译期优化，这样可以进一步减小最终游戏的尺寸并提高游戏运行速度。</p>
</li>
</ol>
<h2 id="IL2CPP与Mono"><a href="#IL2CPP与Mono" class="headerlink" title="IL2CPP与Mono"></a>IL2CPP与Mono</h2><p>Mono</p>
<p><img src="assets/0.2_IL2CPP，%20IL2CPP%20VM/1591264208473.png" alt="Mono编译运行结构"></p>
<p>IL2CPP</p>
<p><img src="assets/0.2_IL2CPP，%20IL2CPP%20VM/1591264524127.png" alt="Alt text"></p>
<p>在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</p>
<h2 id="IL2CPP-VM"><a href="#IL2CPP-VM" class="headerlink" title="IL2CPP VM"></a>IL2CPP VM</h2><p>通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 IL2CPP VM的原因：它负责提供诸如 <strong>GC管理</strong> ， <strong>线程创建</strong> 这类的服务性工作。但是由于去除了IL加载和动态解析的工作，使得IL2CPP VM可以做的很小，并且使得 <strong>游戏载入时间缩短</strong> 。</p>
<h2 id="AOT方式"><a href="#AOT方式" class="headerlink" title="AOT方式"></a>AOT方式</h2><p>由于C++是一门静态语言，这就意味着我们不能使用动态语言的那些酷炫特性。运行时生 成代码并执行肯定是不可能了。这就是Unity里面提到的所谓AOT（Ahead Of Time，运行前编译）编译而非JIT（Just In Time）编译。其实很多平台出于安全的考虑是不允许JIT的，大家最熟悉的有iOS平台，在Console游戏机上，不管是微软的Xbox360， XboxOne，还是Sony的PS3，PS4，PSV，没有一个是允许JIT的。使用了IL2CPP，就完全是AOT方式了，如果原来使用了动态特性的 代码肯定会编译失败。这些代码在编译iOS平台的时候天生也会失败，所以如果你是为iOS开发的游戏代码，就不用担心了。因此就这点而言，我们开发上几乎 不会感到什么问题。</p>
<h3 id="JIT优点："><a href="#JIT优点：" class="headerlink" title="JIT优点："></a>JIT优点：</h3><p>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）<br>可以根据当前程序的运行情况生成最优的机器指令序列<br>当程序需要支持动态链接时，只能使用JIT<br>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</p>
<h3 id="JIT缺点："><a href="#JIT缺点：" class="headerlink" title="JIT缺点："></a>JIT缺点：</h3><p>编译需要占用运行时资源，会导致进程卡顿<br>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡<br>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</p>
<h3 id="AOT优点："><a href="#AOT优点：" class="headerlink" title="AOT优点："></a>AOT优点：</h3><p>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗<br>可以在程序运行初期就达到最高性能<br>可以显著的加快程序的启动</p>
<h3 id="AOT缺点："><a href="#AOT缺点：" class="headerlink" title="AOT缺点："></a>AOT缺点：</h3><p>在程序运行前编译会使程序安装的时间增加<br>牺牲Java的一致性<br>将提前编译的内容保存会占用更多的外</p>
<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://zhuanlan.zhihu.com/indieace" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/indieace</a><br>IL2CPP怎么用：<a href="https://zhuanlan.zhihu.com/p/19972666" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19972666</a><br>IL2CPP深入讲解：<br><a href="https://zhuanlan.zhihu.com/p/20063880" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20063880</a><br><a href="https://zhuanlan.zhihu.com/p/20207712" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20207712</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/19972689" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19972689</a><br>via IndieACE</p>
<p><a href="https://www.cnblogs.com/linghu-java/p/10577515.html" target="_blank" rel="noopener">https://www.cnblogs.com/linghu-java/p/10577515.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-2-IL2CPP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-0-2-IL2CPP/"
    >0.2_IL2CPP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-0-2-IL2CPP/" class="article-date">
  <time datetime="2023-07-25T12:56:23.208Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IL2CPP 是 Unity 自 4.6.1p5版本 提出的一种新的 scripting backend 方式，为Unity提供了更加高效、更加便携的虚拟机。<br>IL2CPP (Intermediate Language To C++) is a Unity-developed scripting backend<br>which you can use as an alternative to Mono when building projects for various platforms. When building a project using IL2CPP, Unity converts IL code from scripts<br>and assemblies to C++, before creating a native binary file (.exe, apk, .xap, for example) for your chosen platform.</p>
<ul>
<li><p>increasing the performance</p>
<ul>
<li><p>security</p>
</li>
<li><p>platform compatibility</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Scripting backend is a framework that powers scripting in Unity( 支持脚本的框架 ). </p>
</blockquote>
<p>IL2CPP分为两个独立的部分：</p>
<ul>
<li><p>AOT编译器<br>AOT编译器将 IL（由.Net编译器输出的中间语言）转换为C++源码</p>
</li>
<li><p>运行时库<br>运行时库则会提供诸如 <strong>垃圾回收</strong> 、 <strong>线程/文件获取</strong> （独立于平台，与平台无关）、 <strong>内部调用直接修改托管数据结构的原生代码</strong> 的服务与抽象。</p>
</li>
</ul>
<h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><p>AOT(Ahead Of Time)(运行前编译，静态编译)<br>所谓AOT编辑器即 <strong>il2cpp.exe</strong><br>在 Windows 系统中你可以在 Editor\Data\il2cpp 目录中找到它，在 OSX 系统中你可以在 Contents/Frameworks/il2cpp/build，即Unity的安装目录中找到它。<br>il2cpp.exe 是由C#编写的 <strong>受托管的可执行程序</strong> ，它 <strong>接受我们在Unity中通过Mono编译器生成的托管程序集，并生成指定平台下的C++代码</strong> 。</p>
<p><img src="0.2_IL2CPP/IL2CPP_WorkFlow.png" alt="Alt text"></p>
<h2 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h2><p><strong>运行时库（libil2cpp）</strong> 的存在是为了支持 <strong>IL2CPP虚拟机</strong> 的运行，几乎完全由C++代码编写，并作为一个静态库与最终的可执行程序链接。（值得一提的是，IL2CPP技术十分得益于使用了libil2cpp这一更轻便的运行时库）</p>
<p>你可以通过查看 libil2cpp 的头文件了解其的代码构成，例如你可以在 codegen/il2cpp-codegen.h 文件中看到 il2cpp.exe 生成C++代码的接口以及 运行时库 的接口。</p>
<p>运行时库的另一关键功能是提供了垃圾回收。</p>
<h2 id="AOT编译器是如何运行的"><a href="#AOT编译器是如何运行的" class="headerlink" title="AOT编译器是如何运行的"></a>AOT编译器是如何运行的</h2><p>看一个例子（该例子运行在 Windows 系统下 Unity 5.0.1版本中）<br>发布一个WebGL平台下的程序，并使用 Process Explorer 工具查看命令行调用过程</p>
<p>首先，Unity启动 mono.exe</p>
<p><code>&quot;C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe&quot;</code><br>接着启动 il2cpp.exe<br><code>&quot;C:\Program Files\Unity\Editor\Data\il2cpp/il2cpp.exe</code></p>
<pre><code class="lang-csharp">
&quot;C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe&quot;

&quot;C:\Program Files\Unity\Editor\Data\il2cpp/il2cpp.exe&quot;

rem 传递给 il2cpp.exe ，而非传递给 mono.exe的参数(5个标识符)

rem 告诉 il2cpp.exe 不要复制生成的C++代码.

\--copy-level=None 

rem IL2CPP将会共享泛型以此来减少最终包体的大小。

\--enable-generic-sharing 

rem 支持通过反射获取的Unity事件，保证代码能够正确生成。

\--enable-unity-event-support 

rem 在生成的C++代码中，为类与方法使用更少的字符数来命名，这样会使得代码更难以调试，因为IL代码的命名将会发生改变（笔者注：应该类似于代码混淆），但是却能够被编译器更快编译，因为编译器所需要解析的字符数变少了。

\--output-format=Compact

rem 使用默认的额外类型文件 ，这个文件会被加入到你的Unity工程里，并告知 il2cpp.exe 哪些泛型类型或者数组类型没有在IL代码中出现，却会在运行时被创建。

\--extra-types.file=&quot;C:\Program Files\Unity\Editor\Data\il2cpp\il2cpp_default_extra_types.txt&quot;

``` ```csharp 

&quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\Assembly-CSharp.dll&quot;

&quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\UnityEngine.UI.dll&quot;
</code></pre>
<p>il2cpp.exe 接受所有应该被转换的 IL 程序集，在这里例子中它应该包含我的 MonoBehaviour脚本、 Assembly-CSharp.dll 以及 GUI assembly 和 UnityEngine.UI.dll。<br>我的脚本引用了 UnityEngine.dll 和 mscorlib.dll，但是它们却没有被包含在上述的命令行中。事实上，il2cpp.exe 在内部对这些程序集进行了处理，因此在上述的命令行中它们不是必须的，Unity只显式地需要 <strong>根程序集</strong> （不被任何程序集引用的程序集）在命令行中被提及。</p>
<pre><code class="lang-csharp">
&quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\il2cppOutput&quot;
</code></pre>
<p>最后的一个参数表示 il2cpp.exe 的输出目录，即 il2cpp.exe 生成代码的输出位置，如果你对此感兴趣的话，可以看一看生成目录下的C++文件，而这一块内容我们也会在后续的文章中对其进行详解。此外，如果你希望浏览生成目录下的代码的话，推荐在出包的时候选择 <strong>Development Player</strong> 模式，这样一来将会移除 –output-format=Compact 命令行，使得你的代码更具可读性。</p>
<blockquote>
<p>PS:你可以通过改变 Player Settings 中的设置来观察 Unity 传递给 il2cpp.exe 的命令行的差异，例如将<br> Enable Exceptions 设置为 Full，那么命令行中就会增加 –emit-null-checks、–enable-stacktrace 、 –enable-array-bounds-check 三项.</p>
</blockquote>
<h2 id="IL2CPP没有做的工作"><a href="#IL2CPP没有做的工作" class="headerlink" title="IL2CPP没有做的工作"></a>IL2CPP没有做的工作</h2><p>Unity官方并没有重写C#的标准库，因此当你发布一个Unity工程的时候，即使你选择了 IL2CPP 的方式来生成你的代码，所有在 mscorlib.dll、System.dll 等标准库中的代码都将使用Mono2X的方式来生成。</p>
<p>Ref: <a href="https://www.jianshu.com/p/7cfcb7b0cfe7" target="_blank" rel="noopener">https://www.jianshu.com/p/7cfcb7b0cfe7</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-1-Unity-Profiler"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-0-1-Unity-Profiler/"
    >0.1_Unity  Profiler</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-0-1-Unity-Profiler/" class="article-date">
  <time datetime="2023-07-25T12:56:23.208Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="0-1-Unity-Profiler"><a href="#0-1-Unity-Profiler" class="headerlink" title="0.1_Unity Profiler"></a>0.1_Unity Profiler</h1><h1 id="0-1-Unity-Profiler-1"><a href="#0-1-Unity-Profiler-1" class="headerlink" title="0.1_Unity Profiler"></a>0.1_Unity Profiler</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Profiler 中看到的内存是通过 unity 自身引擎看到的内存分配,凡是 <strong>引擎创建和销毁的内存</strong> ,引擎有记录,可以给出准确的引用内存占用信息。第三方库的内存分配无法进行统计,以及一些其他的内存分配是无法进行统计的。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="真实环境内存"><a href="#真实环境内存" class="headerlink" title="真实环境内存"></a>真实环境内存</h4><p>在真实环境上面,(例如移动设备上面,Xcode的 instrument,Android 的 USS)内存都比 profiler 上要多<br>因为这些内存包括2部分</p>
<ul>
<li><p>真实的 used 的物理内存</p>
</li>
<li><p>缓存的(cached)的物理内存,这是不同平台决定的.Android 和 iOS 系统在资源不使用的时候均不会立即将其进行回收,而是将其放在缓存的物理内存中,以便下次再使用时,可以快速的加载.</p>
</li>
</ul>
<p>unity 的 profiler 只记录目前真实使用的物理内存,即上述所说的 A 部分内存.</p>
<p>当系统发现 APP 的内存不够用时,才会在底层调用一个 memory killer 线程来轮询缓存物理内存,为 APP 清理内存.</p>
<h4 id="PersistentManager-Remapper"><a href="#PersistentManager-Remapper" class="headerlink" title="PersistentManager.Remapper"></a>PersistentManager.Remapper</h4><p>主要提供文件的持久化存储,包括各种序列化的 asset,项目的 setting 文件,维护文件系统中的文件与内存中数据的对应关系.如果项目中大量适用 AssetBundle ,在对 AsserBundle 进行 Unload 之前都会需要占用 Remapper 的内存的,而 Remapper 本身的实现适用内存池,其数值只会增大,那么为了使 Remapper 占用的内存保持稳定,则在加载一定数量的 AssetBundle 之后需要进行 Unload 操作,而不要一次性把所有的 AssetBundle 进行 Unload.(这样的操作对维持整个 mono heap 的大小也是重要的,mono heap 本身也是只增大不减小的)</p>
<h2 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h2><p>Unity 在本机联合代码中分配的内存数量<br>Mono 托管代码所使用的堆大小和堆大小。这个内存是垃圾收集的<br>GfxDriver 驱动程序在纹理上使用的估计内存数量，呈现目标、着色器和网格数据。<br>FMOD 音频驱动程序的内存使用情况<br>Profiler 用于分析器数据的内存</p>
<p>内存统计信息显示在一些最常见的asset/object类型中。这些统计数据包括计数和使用的内存：<br>Textures<br>Meshes<br>Materials<br>Animations<br>Audio<br>Object Count</p>
<p>游戏对象在内存中常见的原因包括:<br>Assets:从用户或本机代码引用的资产<br>Built-in Resources:统一编辑器资源或统一缺省资源<br>Not Saved:标记为DontSave的GameObjects<br>Scene Memory: GameObject和附加组件<br>Other: 在上面的类别中没有标记的配子</p>
<h2 id="Profiler-UI显示数据"><a href="#Profiler-UI显示数据" class="headerlink" title="Profiler UI显示数据"></a>Profiler UI显示数据</h2><p>Uesd Total :<br>当前帧的Unity内存，Mono内存，GfxDriver内存，Profiler内存以及额外内存的总和。<br>Used total = Unity + Mono + GfxDriver + Profiler + additionalUsedMemory.</p>
<blockquote>
<p>additionalUsedMemory在profiler 中没有显示,因为在大多数平台下都为 0(PC/Android/iOS 都为 0),一般情况下 Used Total 的值就是除 FMOD 之外各项的总和了.Reserved Total 同样适用的.</p>
</blockquote>
<p>Reserved Total：<br>系统在当前帧申请的总体物理内存</p>
<p>Total System Memory Usage：<br>当前帧的虚拟内存使用量</p>
<p>GameObjects in Scene：<br>当前帧场景中的GameObject数量</p>
<p>Total Objects in Scene：<br>当前帧场景中的Object数量（除GameObject外，还有各种Component）</p>
<p>Total Object Count：<br>所有Object数量</p>
<h2 id="API-UnityEngine-Profiling-Profiler"><a href="#API-UnityEngine-Profiling-Profiler" class="headerlink" title="API UnityEngine.Profiling.Profiler"></a>API UnityEngine.Profiling.Profiler</h2><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><h4 id="in-your-built-app"><a href="#in-your-built-app" class="headerlink" title="in your built app"></a>in your built app</h4><p>most of the Profiler API functionality is only available when “Development Build” is enabled. This means you must enable “Developer Build” if you want to use profiler API methods in your built app.</p>
<p>Disabling “Development Build” makes your app run faster, but prevents you from using most of the Profiler API methods.</p>
<p>The exception to this are the Profiler API methods relating to memory usage. Because Unity manages most of its system memory at run-time, it can provide that information with no performance penalty, therefore those methods are available even if “Development Build” is not enabled. </p>
<h3 id="Static-Properties"><a href="#Static-Properties" class="headerlink" title="Static Properties"></a>Static Properties</h3><h4 id="usedHeapSizeLong"><a href="#usedHeapSizeLong" class="headerlink" title="usedHeapSizeLong"></a>usedHeapSizeLong</h4><p>Returns the number of bytes that Unity has allocated. This does not include bytes allocated by external libraries or drivers.</p>
<h3 id="Static-Methods"><a href="#Static-Methods" class="headerlink" title="Static Methods"></a>Static Methods</h3><h4 id="GetAllocatedMemoryForGraphicsDriver"><a href="#GetAllocatedMemoryForGraphicsDriver" class="headerlink" title="GetAllocatedMemoryForGraphicsDriver"></a>GetAllocatedMemoryForGraphicsDriver</h4><p>Returns the amount of <strong>allocated memory for the graphics driver</strong> , in bytes.<br>Only available in development players and editor.</p>
<h4 id="GetMonoHeapSizeLong-Reserved-Mono"><a href="#GetMonoHeapSizeLong-Reserved-Mono" class="headerlink" title="GetMonoHeapSizeLong (Reserved Mono)"></a>GetMonoHeapSizeLong (Reserved Mono)</h4><p>Returns the size of the <strong>reserved space for managed-memory</strong>.</p>
<h4 id="GetMonoUsedSizeLong-Used-Mono"><a href="#GetMonoUsedSizeLong-Used-Mono" class="headerlink" title="GetMonoUsedSizeLong (Used Mono)"></a>GetMonoUsedSizeLong (Used Mono)</h4><p>The <strong>allocated managed-memory</strong> for live objects and non-collected objects.</p>
<h4 id="GetRuntimeMemorySizeLong-native-memory-by-Unity-Obj"><a href="#GetRuntimeMemorySizeLong-native-memory-by-Unity-Obj" class="headerlink" title="GetRuntimeMemorySizeLong (native-memory by Unity Obj)"></a>GetRuntimeMemorySizeLong (native-memory by Unity Obj)</h4><p>Gathers the <strong>native-memory used by a Unity object</strong>.</p>
<h4 id="GetTempAllocatorSize"><a href="#GetTempAllocatorSize" class="headerlink" title="GetTempAllocatorSize"></a>GetTempAllocatorSize</h4><p>Returns the size of the temp allocator.</p>
<h4 id="GetTotalAllocatedMemoryLong"><a href="#GetTotalAllocatedMemoryLong" class="headerlink" title="GetTotalAllocatedMemoryLong"></a>GetTotalAllocatedMemoryLong</h4><p>The total memory allocated by the internal allocators in Unity. </p>
<blockquote>
<p>Unity <strong>reserves large pools of memory</strong> from the system. This function returns <strong>the amount of used memory in those pools</strong>.</p>
</blockquote>
<h4 id="GetTotalReservedMemoryLong"><a href="#GetTotalReservedMemoryLong" class="headerlink" title="GetTotalReservedMemoryLong"></a>GetTotalReservedMemoryLong</h4><p>The total memory Unity has reserved.</p>
<h4 id="GetTotalUnusedReservedMemoryLong"><a href="#GetTotalUnusedReservedMemoryLong" class="headerlink" title="GetTotalUnusedReservedMemoryLong"></a>GetTotalUnusedReservedMemoryLong</h4><p>Unity allocates memory in pools for usage when unity needs to allocate memory. This function returns the amount of unused memory in these pools.</p>
<h3 id="API和UI界面数据对应关系Table"><a href="#API和UI界面数据对应关系Table" class="headerlink" title="API和UI界面数据对应关系Table"></a>API和UI界面数据对应关系Table</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Profiler UI界面</th>
<th>API  </th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved Unity</td>
<td>GetTotalReservedMemoryLong  </td>
</tr>
<tr>
<td>Used Unity</td>
<td>GetTotalAllocatedMemoryLong  </td>
</tr>
<tr>
<td>Reserved Mono</td>
<td>GetMonoHeapSizeLong  </td>
</tr>
<tr>
<td>Used Mono</td>
<td>GetMonoUsedSizeLong  </td>
</tr>
</tbody>
</table>
</div>
<h2 id="优化项目（对于选定帧）"><a href="#优化项目（对于选定帧）" class="headerlink" title="优化项目（对于选定帧）"></a>优化项目（对于选定帧）</h2><h3 id="显示的项"><a href="#显示的项" class="headerlink" title="显示的项"></a>显示的项</h3><p>选中后，unity会自动获取这一帧的内存占用数据项，主要分为：Other、Assets、BuiltinResources、Scene Memory、NotSaved这五大部分</p>
<h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><h5 id="System-ExecutableAndDlls"><a href="#System-ExecutableAndDlls" class="headerlink" title="System.ExecutableAndDlls"></a>System.ExecutableAndDlls</h5><p>统可执行程序和DLL，是只读的内存，用来执行所有的脚本和DLL引用。不同平台和不同硬件得到的值会不一样，可以通过修改Player Setting的Stripping Level来调节大小。<br>Ricky：我试着修改了一下Stripping Level似乎没什么改变，感觉虽占用内存大但不会影响游戏运行。我们暂时忽略它吧(- -)!</p>
<h5 id="GfxDeviceClient"><a href="#GfxDeviceClient" class="headerlink" title="GfxDeviceClient"></a>GfxDeviceClient</h5><p>GFX（图形加速\图形加速器\显卡 (GraphicsForce Express)）客户端设备。<br>Ricky：虽占用较大内存，但这也是必备项，没办法优化。继续忽略吧(- -)!!</p>
<h5 id="ManagedHeap-UsedSize"><a href="#ManagedHeap-UsedSize" class="headerlink" title="ManagedHeap.UsedSize"></a>ManagedHeap.UsedSize</h5><p>托管堆使用大小。<br>Ricky：重点监控对象，不要让它超过20MB，否则可能会有性能问题！</p>
<h5 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h5><p>Unity自带的着色器语言工具相关资源。<br>Ricky：这个东西大家都比较熟悉了，忽略它吧。</p>
<h5 id="SerializedFile"><a href="#SerializedFile" class="headerlink" title="SerializedFile"></a>SerializedFile</h5><p>序列化文件，把显示中的Prefab、Atlas和metadata等资源加载进内存。<br>Ricky：重点监控对象，这里就是你要监控的哪些预设在序列化中在内存中占用大小，根据需求进行优化。</p>
<h5 id="PersistentManager-Remapper-1"><a href="#PersistentManager-Remapper-1" class="headerlink" title="PersistentManager.Remapper"></a>PersistentManager.Remapper</h5><p>持久化数据重映射管理相关<br>Ricky：与持久化数据相关，比如AssetBundle之类的。注意监控相关的文件。</p>
<h5 id="ManagedHeap-ReservedUnusedSize"><a href="#ManagedHeap-ReservedUnusedSize" class="headerlink" title="ManagedHeap.ReservedUnusedSize"></a>ManagedHeap.ReservedUnusedSize</h5><p>托管堆预留不使用内存大小，只由Mono使用。<br>Ricky：无法优化。</p>
<h4 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h4><h5 id="Texture2D"><a href="#Texture2D" class="headerlink" title="Texture2D"></a>Texture2D</h5><p>2D贴图及纹理。<br>Ricky：重点优化对象，有以下几点可以优化：</p>
<ol>
<li><p>许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。</p>
</li>
<li><p>当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先 <strong>把物体制空(null)，然后调用Resources.UnloadUnusedAssets()</strong> ，才能真正释放内存。</p>
</li>
<li><p>有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。</p>
</li>
</ol>
<h5 id="AudioManager"><a href="#AudioManager" class="headerlink" title="AudioManager"></a>AudioManager</h5><p>音频管理器<br>Ricky：随着音频文件的增多而增大。</p>
<h5 id="AudioClip"><a href="#AudioClip" class="headerlink" title="AudioClip"></a>AudioClip</h5><p>音效及声音文件<br>Ricky：重点优化对象，播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。</p>
<h5 id="Cubemap"><a href="#Cubemap" class="headerlink" title="Cubemap"></a>Cubemap</h5><p>立方图纹理<br>Ricky：这个一般在天空盒中比较常见，我也不知道如何优化这个。。。</p>
<h5 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h5><p>模型网格<br>Ricky：主要检查是否有重复的资源，还有尽量减少点面数。</p>
<h4 id="Scene-Memory"><a href="#Scene-Memory" class="headerlink" title="Scene Memory"></a>Scene Memory</h4><h5 id="Mesh-1"><a href="#Mesh-1" class="headerlink" title="Mesh"></a>Mesh</h5><p>场景中使用的网格模型<br>Ricky：注意网格模型的点面数，能合并的mesh尽量合并。</p>
<h5 id="Builtin-Resources"><a href="#Builtin-Resources" class="headerlink" title="Builtin Resources"></a>Builtin Resources</h5><p>Ricky：这些都是Unity的一些内部资源，对于项目内存没有什么分析价值，所以我就暂时不对其进行分析了。</p>
<h3 id="Profiler内存重点关注优化项目"><a href="#Profiler内存重点关注优化项目" class="headerlink" title="Profiler内存重点关注优化项目"></a>Profiler内存重点关注优化项目</h3><ol>
<li><p>ManagedHeap.UsedSize: 移动游戏建议不要超过20MB.</p>
</li>
<li><p>SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.</p>
</li>
<li><p>WebStream: 通过异步WWW下载的资源文件在内存中的解压版本，比SerializedFile大几倍或几十倍，</p>
</li>
<li><p>Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等.</p>
</li>
<li><p>AnimationClip: 重点检查是否有重复资源.</p>
</li>
<li><p>Mesh： 重点检查是否有重复资源.</p>
</li>
</ol>
<h3 id="项目中可能遇到的问题"><a href="#项目中可能遇到的问题" class="headerlink" title="项目中可能遇到的问题"></a>项目中可能遇到的问题</h3><h4 id="1-Device-Present"><a href="#1-Device-Present" class="headerlink" title="1.Device.Present:"></a>1.Device.Present:</h4><p>1）GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader.<br>2）GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间.<br>3）同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.<br>4）Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片).<br>5）StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace(): 一般是由Debug.Log或类似API造成，游戏发布后需将Debug API进行屏蔽。</p>
<h4 id="2-Overhead"><a href="#2-Overhead" class="headerlink" title="2.Overhead:"></a>2.Overhead:</h4><p>1）一般情况为Vsync所致.<br>2）通常出现在Android设备上.</p>
<h4 id="3-GC-Collect"><a href="#3-GC-Collect" class="headerlink" title="3.GC.Collect:"></a>3.GC.Collect:</h4><p>原因：<br>1）代码分配内存过量(恶性的)<br>2）一定时间间隔由系统调用(良性的).<br>占用时间：<br>1）与现有Garbage size相关<br>2）与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排)</p>
<h4 id="4-GarbageCollectAssetsProfile"><a href="#4-GarbageCollectAssetsProfile" class="headerlink" title="4.GarbageCollectAssetsProfile:"></a>4.GarbageCollectAssetsProfile:</h4><p>1）引擎在执行UnloadUnusedAssets操作（该操作是比较耗时的,建议在切场景的时候进行）。<br>2）尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GCAllow.<br>3）if(other.tag == a.tag)改为other.CompareTag(a.tag).因为other.tag为产生180B的GC Allow.<br>4）少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for.<br>5）Lambda表达式，使用不当会产生内存泄漏.</p>
<h4 id="5-尽量少用LINQ："><a href="#5-尽量少用LINQ：" class="headerlink" title="5.尽量少用LINQ："></a>5.尽量少用LINQ：</h4><p>1）部分功能无法在某些平台使用.<br>2）会分配大量GC Allow.</p>
<h4 id="6-控制StartCoroutine的次数："><a href="#6-控制StartCoroutine的次数：" class="headerlink" title="6.控制StartCoroutine的次数："></a>6.控制StartCoroutine的次数：</h4><p>1）开启一个Coroutine(协程)，至少分配37B的内存.<br>2）Coroutine类的实例 -&gt; 21B.<br>3）Enumerator -&gt; 16B.</p>
<h4 id="7-使用StringBuilder替代字符串直接连接"><a href="#7-使用StringBuilder替代字符串直接连接" class="headerlink" title="7.使用StringBuilder替代字符串直接连接."></a>7.使用StringBuilder替代字符串直接连接.</h4><h4 id="8-缓存组件"><a href="#8-缓存组件" class="headerlink" title="8.缓存组件:"></a>8.缓存组件:</h4><p>1）每次GetComponent均会分配一定的GC Allow.<br>2）每次Object.name都会分配39B的堆内存.</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/yanghui0702/p/yanghui20181026.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanghui0702/p/yanghui20181026.html</a><br><a href="https://zhuanlan.zhihu.com/p/139235851" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/139235851</a><br><a href="https://www.jianshu.com/p/3c5540637525" target="_blank" rel="noopener">https://www.jianshu.com/p/3c5540637525</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-1-Android内存管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-0-1-Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
    >0.1_Android内存管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-0-1-Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2023-07-25T12:56:23.207Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Android 运行时 ( <strong>ART</strong> ) 和 <strong>Dalvik 虚拟机</strong> 使用 <strong>分页</strong> 和 <strong>内存映射</strong> 来管理内存。这意味着应用修改的任何内存，无论修改的方式是分配新对象还是轻触内存映射的页面，都会一直驻留在 RAM 中，并且无法换出。 <strong>要从应用中释放内存，只能释放应用保留的对象引用，使内存可供垃圾回收器回收。</strong> 这种情况有 <strong>一个例外</strong> ：对于任何未经修改的内存映射文件（如代码），如果系统想要在其他位置使用其内存，可将其从 RAM 中换出。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>Ref: <a href="https://blog.csdn.net/greedylin/article/details/103711555" target="_blank" rel="noopener">https://blog.csdn.net/greedylin/article/details/103711555</a><br>Android的内存大，但是管理不太好<br>基本单位: Page</p>
<ol>
<li><p>默认4K一个page（与linux相同），但并不意味是4K对齐的</p>
</li>
<li><p>回收和分配以page为单位</p>
</li>
<li><p>分为用户态和内核态，常见的一个问题是，用户态中的一个指针越界到内核态，该程序就会挂掉</p>
</li>
</ol>
<h3 id="LMK"><a href="#LMK" class="headerlink" title="LMK"></a>LMK</h3><p>内存管理工具-low memory killer（AKA lmk）<br>一些现象都和它有关，例如闪退 服务消失 手机重启等<br>当内存不足时，killer会从下往上杀应用，当杀到前台（Foreground）时，你的应用就会闪退，如果继续使用内存，会一致杀到System层，这时设备会重启</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>ART 或 Dalvik 虚拟机之类的 <strong>受管内存环境</strong> 会 <strong>跟踪每次内存分配</strong> 。一旦确定程序不再使用某块内存，它就会将该内存重新释放到堆中，无需程序员进行任何干预。这种 <strong>回收受管内存环境中的未使用内存的机制</strong> 称为“ <strong>垃圾回收”</strong> 。垃圾回收有两个目标： <strong>在程序中查找将来无法访问的数据对象</strong> ，并 <strong>回收这些对象使用的资源</strong> 。</p>
<h4 id="Android做法"><a href="#Android做法" class="headerlink" title="Android做法"></a>Android做法</h4><p>Android 的内存堆是分代的，这意味着它会根据分配对象的 <strong>预期寿命和大小</strong> 跟踪不同的 <strong>分配存储分区</strong> 。例如，最近分配的对象属于“ <strong>新生代</strong> ”。当某个对象保持活动状态达足够长的时间时，可将其提升为 <strong>较老代</strong> ，然后是 <strong>永久代</strong> 。<br>堆的每一代对相应对象可占用的内存量都有其自身的专用上限。 <strong>每当一代开始填满时，系统便会执行垃圾回收事件以释放内存。</strong></p>
<p>垃圾回收的 <strong>持续时间</strong> 取决于它 <strong>回收的是哪一代</strong> 对象以及 <strong>每一代有多少个活动对象</strong> 。</p>
<p>尽管垃圾回收速度非常快，但仍会影响应用的性能。系统有一套专门确定何时执行垃圾回收的标准。当条件满足时，系统会停止执行进程并开始垃圾回收。如果 <em>在动画或音乐播放等密集型处理循环过程中发生垃圾回收，则可能会增加处理时间</em> ，进而可能会导致应用中的代码执行超出建议的 16ms 阈值， <em>无法实现高效、流畅的帧渲染</em> 。</p>
<p>此外，您的代码流执行的各种工作可能迫使垃圾回收事件发生得更频繁或导致其持续时间超过正常范围。 例如， <em>如果您在 Alpha 混合动画的每一帧期间，在 for 循环的最内层分配多个对象，则可能会使内存堆受到大量对象的影响</em> 。在这种情况下，垃圾回收器会执行多个垃圾回收事件，并可能降低应用的性能。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>为了在 RAM 中容纳所需的一切，Android 会尝试跨进程共享 RAM 页面。<br>方式：</p>
<ul>
<li><p>每个应用进程都从一个 <strong>名为 Zygote 的现有进程分叉</strong> 。系统启动并加载通用框架代码和资源（如 Activity 主题背景）时，Zygote 进程随之启动。为启动新的应用进程，系统会分叉 Zygote 进程，然后在新进程中加载并运行应用代码。这种方法使为框架代码和资源分配的大多数 RAM 页面可在所有应用进程之间共享。</p>
</li>
<li><p>大多数 <strong>静态数据会内存映射到一个进程中</strong> 。这种方法使得数据不仅可以在进程之间共享，还可以在需要时换出。静态数据示例包括：Dalvik 代码（通过将其放入预先链接的 .odex 文件中进行直接内存映射）、应用资源（通过将资源表格设计为可内存映射的结构以及通过对齐 APK 的 zip 条目）和传统项目元素（如 .so 文件中的原生代码）。</p>
</li>
<li><p>在很多地方，Android 使用 <strong>明确分配的共享内存区域（通过 ashmem 或 gralloc）</strong> 在进程间共享同一 <strong>动态 RAM</strong> 。例如，窗口 surface 在应用和屏幕合成器之间使用共享内存，而光标缓冲区则在内容提供程序和客户端之间使用共享内存。</p>
</li>
</ul>
<h3 id="分配与回收应用内存"><a href="#分配与回收应用内存" class="headerlink" title="分配与回收应用内存"></a>分配与回收应用内存</h3><p><strong>Dalvik 堆</strong> 局限于 <strong>每个应用进程的单个虚拟内存范围</strong> 。这定义了 <strong>逻辑堆大小</strong> ，该大小可以根据需要增长，但不能超过系统为每个应用定义的上限。</p>
<p>堆的逻辑大小与 <strong>堆使用的物理内存量</strong> 不同。在检查应用堆时，Android 会 <strong>计算</strong> 按比例分摊的内存大小 <strong>(PSS) 值</strong> ，该值同时考虑与其他进程共享的脏页和干净页，但其数量与共享该 RAM 的应用数量成正比。此 (PSS) 总量是系统认为的 <strong>物理内存占用</strong> 量。有关 PSS 的详情，请参阅调查 RAM 使用量指南: <a href="https://developer.android.com/studio/profile/memory-profiler" target="_blank" rel="noopener">https://developer.android.com/studio/profile/memory-profiler</a>。</p>
<p>Dalvik 堆不压缩堆的逻辑大小，这意味着 Android 不会对堆进行碎片整理来缩减空间。只有当堆末尾存在未使用的空间时，Android 才能缩减逻辑堆大小。但是，系统仍然可以减少堆使用的物理内存。垃圾回收之后，Dalvik 遍历堆并查找未使用的页面，然后使用 madvise 将这些页面返回给内核。因此，大数据块的配对分配和解除分配应该使所有（或几乎所有）使用的物理内存被回收。但是，从较小分配量中回收内存的效率要低得多，因为用于较小分配量的页面可能仍在与其他尚未释放的数据块共享。</p>
<h4 id="PSS"><a href="#PSS" class="headerlink" title="PSS"></a>PSS</h4><p>PSS(Proportional Set Size)：按比例分摊的内存大小</p>
<blockquote>
<p>Proportional 比例的，成比例的<br> Proportional Set Size: 按照比例设置的大小，按比例分摊的内存大小，即 <strong>实际使用的物理内存</strong></p>
</blockquote>
<h3 id="限制应用内存"><a href="#限制应用内存" class="headerlink" title="限制应用内存"></a>限制应用内存</h3><p>为了维持多任务环境的正常运行，Android 会为每个应用的 <strong>堆大小</strong> 设置硬性 <strong>上限</strong> 。如果您的应用在达到堆容量上限后尝试分配更多内存，则可能会收到 <strong>OutOfMemoryError</strong> 。<br>在某些情况下，例如，为了确定在缓存中保存多少数据比较安全，您可能需要查询系统以确定 <strong>当前设备上确切可用的堆空间大小</strong> 。您可以通过调用 <strong>getMemoryClass()</strong> 向系统查询此数值。此方法返回一个整数，表示 <strong>应用堆的可用兆字节数</strong> 。</p>
<h3 id="切换应用"><a href="#切换应用" class="headerlink" title="切换应用"></a>切换应用</h3><p>当用户在应用之间切换时，Android 会在最近最少使用 (LRU) 缓存中保留 <strong>非前台应用</strong> ，即用户看不到或不在运行前台服务（如 <em>音乐播放</em> ）的应用。例如，当用户首次启动某个应用时，系统会为其创建一个进程；但是当用户离开此应用时，该进程不会退出。系统会将该进程保留在缓存中。如果用户稍后返回该应用，则系统会重复使用该进程，从而加快应用切换速度。</p>
<p>如果您的应用具有缓存进程且保留了目前不需要的内存，那么即使用户不在使用您的应用，它也会影响系统的整体性能。当系统 <strong>内存不足时</strong> ，它会从最近最少使用的进程开始， <strong>终止 LRU 缓存中的进程</strong> 。系统还会考虑终止占用最多内存的进程以释放 RAM。</p>
<h2 id="进程间内存分配"><a href="#进程间内存分配" class="headerlink" title="进程间内存分配"></a>进程间内存分配</h2><p>Android 平台在运行时不会浪费可用的内存。它会一直尝试利用所有可用内存。</p>
<h3 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h3><p>Android 设备包含三种不同类型的内存：RAM、zRAM 和存储器</p>
<p><img src="0.1_Android内存管理/1592449330748.png" alt="Alt text"></p>
<p>RAM 是最快的内存类型，但其大小通常有限。高端设备通常具有最大的 RAM 容量。</p>
<p>zRAM 是用于交换空间的 RAM 分区。所有数据在放入 zRAM 时都会进行压缩，然后在从 zRAM 向外复制时进行解压缩。这部分 RAM 会随着页面进出 zRAM 而增大或缩小。设备制造商可以设置 zRAM 大小上限。</p>
<p>存储器中包含所有持久性数据（例如文件系统等），以及为所有应用、库和平台添加的对象代码。存储器比另外两种内存的容量大得多。在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间，因为频繁写入会导致这种内存出现损坏，并缩短存储媒介的使用寿命。</p>
<h3 id="内存页面"><a href="#内存页面" class="headerlink" title="内存页面"></a>内存页面</h3><p>RAM 分为多个“页面”。通常，每个页面为 4KB 的内存。</p>
<p>系统会将页面视为“可用”或“已使用”。</p>
<h4 id="可用页面"><a href="#可用页面" class="headerlink" title="可用页面"></a>可用页面</h4><h4 id="已使用页面"><a href="#已使用页面" class="headerlink" title="已使用页面"></a>已使用页面</h4><h5 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h5><p>有存储器中的文件（例如代码或内存映射文件）支持的内存。缓存内存有两种类型：</p>
<ol>
<li><p>私有页：由一个进程拥有且未共享</p>
<ul>
<li><p>干净页：存储器中未经修改的文件副本，可由 kswapd 删除以增加可用内存</p>
</li>
<li><p>脏页：存储器中经过修改的文件副本；可由 kswapd 移动到 zRAM 或在 zRAM 中进行压缩以增加可用内存</p>
</li>
</ul>
</li>
<li><p>共享页：由多个进程使用</p>
<ul>
<li><p>干净页：存储器中未经修改的文件副本，可由 kswapd 删除以增加可用内存</p>
</li>
<li><p>脏页：存储器中经过修改的文件副本；允许通过 kswapd 或者通过明确使用 msync() 或 munmap() 将更改写回存储器中的文件，以增加可用空间</p>
</li>
</ul>
</li>
</ol>
<h5 id="匿名页："><a href="#匿名页：" class="headerlink" title="匿名页："></a>匿名页：</h5><p>没有存储器中的文件支持的内存（例如，由设置了 MAP_ANONYMOUS 标记的 mmap() 进行分配）<br>脏页：可由 kswapd 移动到 zRAM/在 zRAM 中进行压缩以增加可用内存</p>
<blockquote>
<p>注意：干净页包含存在于存储器中的文件（或文件一部分）的精确副本。如果干净页不再包含文件的精确副本（例如，因应用操作所致），则会变成脏页。干净页可以删除，因为始终可以使用存储器中的数据重新生成它们；脏页则不能删除，否则数据将会丢失。<br> 随着系统积极管理 RAM，可用和已使用页面的比例会不断变化。</p>
</blockquote>
<h3 id="内存不足管理"><a href="#内存不足管理" class="headerlink" title="内存不足管理"></a>内存不足管理</h3><p>Android 有两种处理内存不足情况的主要机制： <strong>内核交换守护进程</strong> 和 <strong>低内存终止守护进程</strong> 。</p>
<h4 id="内核交换守护进程"><a href="#内核交换守护进程" class="headerlink" title="内核交换守护进程"></a>内核交换守护进程</h4><p>内核交换守护进程 (kernel swap daemon, kswapd) 是 Linux 内核的一部分，用于将已使用内存转换为可用内存。当设备上的可用内存不足时，该守护进程将变为活动状态。Linux 内核设有可用内存上下限阈值。当可用内存降至下限阈值以下时，kswapd 开始回收内存。当可用内存达到上限阈值时，kswapd 停止回收内存。</p>
<p>kswapd 可以删除干净页来回收它们，因为这些页受到存储器的支持且未经修改。如果某个进程尝试处理已删除的干净页，则系统会将该页面从存储器复制到 RAM。此操作称为“请求分页”。</p>
<p>kswapd 可以将缓存的私有脏页和匿名脏页移动到 zRAM 进行压缩。这样可以释放 RAM 中的可用内存（可用页面）。如果某个进程尝试处理 zRAM 中的脏页，该页将被解压缩并移回到 RAM。如果与压缩页面关联的进程被终止，则该页面将从 zRAM 中删除。</p>
<p>如果可用内存量低于特定阈值，系统会开始终止进程。</p>
<h4 id="低内存终止守护进程"><a href="#低内存终止守护进程" class="headerlink" title="低内存终止守护进程"></a>低内存终止守护进程</h4><p>很多时候，kswapd 不能为系统释放足够的内存。在这种情况下，系统会使用 onTrimMemory() 通知应用内存不足，应该减少其分配量。如果这还不够，内核会开始终止进程以释放内存。它会使用低内存终止守护进程 ( low-memory killer, LMK) 来执行此操作。</p>
<p>LMK 使用一个名为 oom_adj_score 的“内存不足”分值来确定正在运行的进程的优先级，以此决定要终止的进程。最高得分的进程最先被终止。后台应用最先被终止，系统进程最后被终止。下表列出了从高到低的 LMK 评分类别。评分最高的类别，即第一行中的项目将最先被终止：</p>
<p><img src="0.1_Android内存管理/1592451159557.png" alt="Alt text"></p>
<ul>
<li><p>后台应用：之前运行过且当前不处于活动状态的应用。LMK 将首先从具有最高 oom_adj_score 的应用开始终止后台应用。</p>
</li>
<li><p>上一个应用：最近用过的后台应用。上一个应用比后台应用具有更高的优先级（得分更低），因为相比某个后台应用，用户更有可能切换到上一个应用。</p>
</li>
<li><p>主屏幕应用：这是启动器应用。终止该应用会使壁纸消失。</p>
</li>
<li><p>服务：服务由应用启动，可能包括同步或上传到云端。</p>
</li>
<li><p>可觉察的应用：用户可通过某种方式察觉到的非前台应用，例如运行一个显示小界面的搜索进程或听音乐。</p>
</li>
<li><p>前台应用：当前正在使用的应用。终止前台应用看起来就像是应用崩溃了，可能会向用户提示设备出了问题。</p>
</li>
<li><p>持久性（服务）：这些是设备的核心服务，例如电话和 WLAN。</p>
</li>
<li><p>系统：系统进程。这些进程被终止后，手机可能看起来即将重新启动。</p>
</li>
<li><p>原生：系统使用的极低级别的进程（例如，kswapd）。</p>
</li>
</ul>
<h3 id="计算内存占用量"><a href="#计算内存占用量" class="headerlink" title="计算内存占用量"></a>计算内存占用量</h3><blockquote>
<p>在确定应用使用的内存量时，系统必须考虑共享的页面。访问相同服务或库的应用将共享内存页面。<br> 如需确定应用的内存占用量，可以使用以下任一指标：</p>
</blockquote>
<ul>
<li><p>常驻内存大小 (Resident Set Size, RSS)：应用使用的共享和非共享页面的数量</p>
</li>
<li><p>按比例分摊的内存大小 (Proportional Set Size, PSS)：应用使用的非共享页面的数量加上共享页面的均匀分摊数量（例如，如果三个进程共享 3MB，则每个进程的 PSS 为 1MB）</p>
</li>
<li><p>独占内存大小 (Unique Set Size, USS)：应用使用的非共享页面数量（不包括共享页面）</p>
</li>
</ul>
<p>如果操作系统想要知道所有进程使用了多少内存，那么 <strong>PSS</strong> 非常有用，因为页面只会统计一次。计算 PSS 需要花很长时间，因为系统需要确定共享的页面以及共享页面的进程数量。RSS 不区分共享和非共享页面（因此计算起来更快），更适合跟踪内存分配量的变化。</p>
<h2 id="管理应用内存"><a href="#管理应用内存" class="headerlink" title="管理应用内存"></a>管理应用内存</h2><p>随机存取存储器 (RAM) 在任何软件开发环境中都是一项宝贵资源。虽然 Android 运行时 (ART) 和 Dalvik 虚拟机都执行例行的垃圾回收任务，但这并不意味着您可以忽略应用分配和释放内存的位置和时间。您仍然需要避免引入 <strong>内存泄漏</strong> 问题（ <strong>通常因在静态成员变量中保留对象引用而引起</strong> ），并在适当时间（如生命周期回调所定义）释放所有 Reference 对象。</p>
<h3 id="监控可用内存和内存使用量"><a href="#监控可用内存和内存使用量" class="headerlink" title="监控可用内存和内存使用量"></a>监控可用内存和内存使用量</h3><p>您需要 <strong>先找到应用中的内存使用问题，然后才能修复问题</strong> 。Android Studio 中的内存分析器可以通过以下方式帮助您查找和诊断内存问题：</p>
<ul>
<li><p>了解您的应用在一段时间内如何分配内存。内存分析器可以显示实时图表，说明应用的内存使用量、分配的 Java 对象数量以及垃圾回收事件发生的时间。</p>
</li>
<li><p>发起垃圾回收事件，并在应用运行时拍摄 Java 堆的快照。</p>
</li>
<li><p>记录应用的内存分配情况，然后检查所有分配的对象、查看每个分配的堆栈轨迹，并在 Android Studio 编辑器中跳转到相应代码。</p>
</li>
</ul>
<h4 id="释放内存以响应事件"><a href="#释放内存以响应事件" class="headerlink" title="释放内存以响应事件"></a>释放内存以响应事件</h4><p>如 Android 内存管理概览中所述，Android 可以通过多种方式从应用中回收内存，或在必要时完全终止应用，从而释放内存以执行关键任务。为了进一步帮助平衡系统内存并避免系统需要终止您的应用进程，您可以在 Activity 类中实现 ComponentCallbacks2 接口。借助所提供的 onTrimMemory() 回调方法，您的应用可以在处于前台或后台时监听与内存相关的事件，然后释放对象以响应指示系统需要回收内存的应用生命周期事件或系统事件。</p>
<h4 id="查看您应该使用多少内存"><a href="#查看您应该使用多少内存" class="headerlink" title="查看您应该使用多少内存"></a>查看您应该使用多少内存</h4><p>为了允许多个进程同时运行，Android 针对为每个应用分配的堆大小设置了硬性限制。设备的确切堆大小限制因设备总体可用的 RAM 多少而异。如果您的应用已达到堆容量上限并尝试分配更多内存，系统就会抛出 OutOfMemoryError。</p>
<p>为了避免用尽内存，您可以查询系统以确定当前设备上可用的堆空间。您可以通过调用 getMemoryInfo() 向系统查询此数值。它将返回一个 ActivityManager.MemoryInfo 对象，其中会提供与设备当前的内存状态有关的信息，包括可用内存、总内存和内存阈值（如果达到此内存级别，系统就会开始终止进程）。ActivityManager.MemoryInfo 对象还会提供一个简单的布尔值lowMemory，您可以根据此值确定设备是否内存不足。</p>
<p>以下代码段示例演示了如何在应用中使用 getMemoryInfo() 方法。</p>
<h3 id="使用内存效率更高的代码结构"><a href="#使用内存效率更高的代码结构" class="headerlink" title="使用内存效率更高的代码结构"></a>使用内存效率更高的代码结构</h3><p>某些 Android 功能、Java 类和代码结构所使用的内存往往多于其他功能、类和结构。您可以在代码中选择效率更高的替代方案，以尽可能降低应用的内存使用量。</p>
<h4 id="谨慎使用服务"><a href="#谨慎使用服务" class="headerlink" title="谨慎使用服务"></a>谨慎使用服务</h4><p>在不需要某项服务时让其保持运行状态，是 Android 应用可能犯下的最严重的内存管理错误之一。如果您的应用需要某项服务在后台执行工作，请不要让其保持运行状态，除非其需要运行作业。请注意在服务完成任务后使其停止运行。否则，您可能会在无意中导致内存泄漏。</p>
<p>在您启动某项服务后，系统更倾向于让此服务的进程始终保持运行状态。这种行为会导致服务进程代价十分高昂，因为一旦服务使用了某部分 RAM，那么这部分 RAM 就不再可供其他进程使用。这会减少系统可以在 LRU 缓存中保留的缓存进程数量，从而降低应用切换效率。当内存紧张，并且系统无法维护足够的进程以托管当前运行的所有服务时，这甚至可能导致系统出现颠簸。</p>
<p>您通常应该避免使用持久性服务，因为它们会对可用内存提出持续性的要求。我们建议您采用 JobSchedulerJobScheduler 等替代实现方式。要详细了解如何使用 JobScheduler 调度后台进程，请参阅后台优化。</p>
<p>如果您必须使用某项服务，则限制此服务的生命周期的最佳方式是使用 IntentService，它会在处理完启动它的 intent 后立即自行结束。有关详情，请参阅在后台服务中运行。</p>
<h4 id="使用经过优化的数据容器"><a href="#使用经过优化的数据容器" class="headerlink" title="使用经过优化的数据容器"></a>使用经过优化的数据容器</h4><p>编程语言所提供的部分类并未针对移动设备做出优化。例如，常规 HashMap 实现的内存效率可能十分低下，因为每个映射都需要分别对应一个单独的条目对象。</p>
<p>Android 框架包含几个经过优化的数据容器，包括 SparseArray、SparseBooleanArray 和 LongSparseArray。 例如，SparseArray 类的效率更高，因为它们可以避免系统需要对键（有时还对值）进行自动装箱（这会为每个条目分别再创建 1-2 个对象）。</p>
<p>如果需要，您可以随时切换到原始数组以获得非常精简的数据结构。</p>
<h4 id="谨慎对待代码抽象"><a href="#谨慎对待代码抽象" class="headerlink" title="谨慎对待代码抽象"></a>谨慎对待代码抽象</h4><p>开发者往往会将抽象简单地当做一种良好的编程做法，因为抽象可以提高代码灵活性和维护性。不过，抽象的代价很高：通常它们需要更多的代码才能执行，需要更多的时间和更多的 RAM 才能将代码映射到内存中。因此，如果抽象没有带来显著的好处，您就应该避免使用抽象。</p>
<h4 id="针对序列化数据使用精简版-Protobuf"><a href="#针对序列化数据使用精简版-Protobuf" class="headerlink" title="针对序列化数据使用精简版 Protobuf"></a>针对序列化数据使用精简版 Protobuf</h4><p>协议缓冲区是 Google 设计的一种无关乎语言和平台，并且可扩展的机制，用于对结构化数据进行序列化。该机制与 XML 类似，但更小、更快也更简单。如果您决定针对数据使用 Protobuf，则应始终在客户端代码中使用精简版 Protobuf。常规 Protobuf 会生成极其冗长的代码，这会导致应用出现多种问题，例如 RAM 使用量增多、APK 大小显著增加以及执行速度变慢。</p>
<p>有关详情，请参阅 Protobuf 自述文件中的“精简版”部分。</p>
<h4 id="避免内存抖动"><a href="#避免内存抖动" class="headerlink" title="避免内存抖动"></a>避免内存抖动</h4><p>如前所述，垃圾回收事件通常不会影响应用的性能。不过，如果在短时间内发生许多垃圾回收事件，就可能会快速耗尽帧时间。系统花在垃圾回收上的时间越多，能够花在呈现或流式传输音频等其他任务上的时间就越少。</p>
<p>通常，“内存抖动”可能会导致出现大量的垃圾回收事件。实际上，内存抖动可以说明在给定时间内出现的已分配临时对象的数量。</p>
<p>例如，您可以在 for 循环中分配多个临时对象。或者，您也可以在视图的 onDraw() 函数中创建新的 Paint 或 Bitmap 对象。在这两种情况下，应用都会快速创建大量对象。这些操作可以快速消耗新生代 (young generation) 区域中的所有可用内存，从而迫使垃圾回收事件发生。</p>
<p>当然，您必须先在代码中找到内存抖动较高的位置，然后才能进行修复。为此，您应该使用 Android Studio 中的内存分析器。</p>
<p>确定代码中的问题区域后，请尝试减少对性能至关重要的区域中的分配数量。您可以考虑将某些代码逻辑从内部循环中移出，或将其移到基于 Factory 的分配结构中。</p>
<h3 id="移除会占用大量内存的资源和库"><a href="#移除会占用大量内存的资源和库" class="headerlink" title="移除会占用大量内存的资源和库"></a>移除会占用大量内存的资源和库</h3><p>代码中的某些资源和库可能会在您不知情的情况下吞噬内存。APK 的总体大小（包括第三方库或嵌入式资源）可能会影响应用的内存消耗量。您可以通过从代码中移除任何冗余、不必要或臃肿的组件、资源或库，降低应用的内存消耗量。</p>
<h4 id="缩减总体-APK-大小"><a href="#缩减总体-APK-大小" class="headerlink" title="缩减总体 APK 大小"></a>缩减总体 APK 大小</h4><p>您可以通过缩减应用的总体大小来显著降低应用的内存使用量。位图大小、资源、动画帧数和第三方库都会影响 APK 的大小。Android Studio 和 Android SDK 提供了可帮助您缩减资源和外部依赖项大小的多种工具。这些工具支持现代代码收缩方法，例如 R8 编译。（Android Studio 3.3 及更低版本使用 ProGuard，而不是 R8 编译。）</p>
<p>要详细了解如何缩减 APK 的总体大小，请参阅有关如何缩减应用大小的指南。</p>
<h4 id="使用-Dagger-2-实现依赖注入"><a href="#使用-Dagger-2-实现依赖注入" class="headerlink" title="使用 Dagger 2 实现依赖注入"></a>使用 Dagger 2 实现依赖注入</h4><p>依赖注入框架可以简化您编写的代码，并提供一个可供您进行测试及其他配置更改的自适应环境。</p>
<p>如果您打算在应用中使用依赖注入框架，请考虑使用 Dagger 2。Dagger 不使用反射来扫描您应用的代码。Dagger 的静态编译时实现意味着它可以在 Android 应用中使用，而不会带来不必要的运行时代价或内存消耗量。</p>
<p>其他使用反射的依赖注入框架倾向于通过扫描代码中的注释来初始化进程。此过程可能需要更多的 CPU 周期和 RAM，并可能在应用启动时导致出现明显的延迟。</p>
<h4 id="谨慎使用外部库"><a href="#谨慎使用外部库" class="headerlink" title="谨慎使用外部库"></a>谨慎使用外部库</h4><p>外部库代码通常不是针对移动环境编写的，在移动客户端上运行时可能效率低下。如果您决定使用外部库，则可能需要针对移动设备优化该库。在决定是否使用该库之前，请提前规划，并在代码大小和 RAM 消耗量方面对库进行分析。</p>
<p>即使是一些针对移动设备进行了优化的库，也可能因实现方式不同而导致问题。例如，一个库可能使用的是精简版 Protobuf，而另一个库使用的是 Micro Protobuf，导致您的应用出现两种不同的 Protobuf 实现。日志记录、分析、图像加载框架和缓存以及许多您意料之外的其他功能的不同实现都可能导致这种情况。</p>
<p>虽然 ProGuard 可以使用适当的标记移除 API 和资源，但无法移除库的大型内部依赖项。您所需要的这些库中的功能可能需要较低级别的依赖项。如果存在以下情况，这就特别容易导致出现问题：您使用某个库中的 Activity 子类（往往会有大量的依赖项）、库使用反射（这很常见，意味着您需要花费大量的时间手动调整 ProGuard 以使其运行）等。</p>
<p>此外，请避免仅针对数十个功能中的一两个功能使用共享库。您一定不希望产生大量您甚至根本用不到的代码和开销。在考虑是否使用某个库时，请查找与您的需求十分契合的实现。否则，您可以决定自己去创建实现。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-0-0-Unity与Mono和-NET的关系"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-0-0-Unity%E4%B8%8EMono%E5%92%8C-NET%E7%9A%84%E5%85%B3%E7%B3%BB/"
    >0.0 Unity与Mono和.NET的关系</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-0-0-Unity%E4%B8%8EMono%E5%92%8C-NET%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time datetime="2023-07-25T12:56:23.205Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>&gt;</p>
<p><a href="https://www.cnblogs.com/u3ddjw/p/10909975.html" target="_blank" rel="noopener">https://www.cnblogs.com/u3ddjw/p/10909975.html</a></p>
<p><a href="https://www.cnblogs.com/u3ddjw/p/10909975.html" target="_blank" rel="noopener">https://www.cnblogs.com/u3ddjw/p/10909975.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unreal-解决困惑-Actor与component关系"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/11/Unreal-%E8%A7%A3%E5%86%B3%E5%9B%B0%E6%83%91-Actor%E4%B8%8Ecomponent%E5%85%B3%E7%B3%BB/"
    >解决困惑-Actor与component关系</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/11/Unreal-%E8%A7%A3%E5%86%B3%E5%9B%B0%E6%83%91-Actor%E4%B8%8Ecomponent%E5%85%B3%E7%B3%BB/" class="article-date">
  <time datetime="2022-04-10T17:42:00.000Z" itemprop="datePublished">2022-04-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unreal/">Unreal</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Actor不支持嵌套？</p>
<p>那GetComponents函数的“bIncludeFromChildActors”是什么意思？</p>
<p>Components是否支持嵌套？</p>
<p>如果不支持，为什么Details中的Components可有父子关系？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-CG-homogeneous-coordinates-and-transformation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/17/CG-homogeneous-coordinates-and-transformation/"
    >【CG】齐次坐标(homogeneous coordinates )与坐标变换(transformation)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/17/CG-homogeneous-coordinates-and-transformation/" class="article-date">
  <time datetime="2020-11-17T15:39:00.000Z" itemprop="datePublished">2020-11-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-Rendering/">CG&Rendering</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>同一个事物，从不同的视角去看，会有不同的理解。而任何一个视角看到的，都不是事物的全部，任何一种解释，都无法完全描述这个事物。单纯用一种方式去理解它，一定是片面的。只有从不同的层次、不同的角度去理解，我们的认知才能不断逼近这个事物的真相。<br>本文借鉴多位博主的研究成果，企图整理从不同的角度对齐次坐标的理解，帮助感兴趣的朋友更透彻地理解齐次坐标到底是什么，有什么意义，如何应用。</p>
<h2 id="齐次坐标引入"><a href="#齐次坐标引入" class="headerlink" title="齐次坐标引入"></a>齐次坐标引入</h2><h3 id="Problem-Two-parallel-lines-can-intersect"><a href="#Problem-Two-parallel-lines-can-intersect" class="headerlink" title="Problem: Two parallel lines can intersect."></a>Problem: Two parallel lines can intersect.</h3><ul>
<li><p>欧氏几何空间<br>In <strong>Euclidean space (geometry)</strong> - two parallel lines on the same plane cannot intersect, or cannot meet each other forever.</p>
</li>
<li><p>透视空间 - 无穷远处相交<br>In projective space - Finally, the two parallel rails meet at the horizon, which is a point at infinity.<br><img src="./1605592065160.png" alt="Alt text"></p>
</li>
</ul>
<blockquote>
<p>(Actually, Euclidean geometry is a subset of projective geometry</p>
</blockquote>
<p>The Cartesian coordinates of a 2D point can be expressed as (x, y).</p>
<p>What if this point goes far away to infinity? The point at infinity would be (∞,∞), and it becomes meaningless in Euclidean space. <strong>The parallel lines should meet at infinity in projective space, but cannot do in Euclidean space.</strong></p>
<h3 id="Solution-Homogeneous-Coordinates"><a href="#Solution-Homogeneous-Coordinates" class="headerlink" title="Solution: Homogeneous Coordinates"></a>Solution: Homogeneous Coordinates</h3><p>Homogeneous coordinates are a way of <strong>representing N-dimensional coordinates with N+1 numbers</strong>.</p>
<p>(1, 2) becomes (1, 2, 1) in Homogeneous<br>If (1, 2) moves toward infinity, it becomes (∞,∞) in Cartesian coordinates. And it becomes (1, 2, 0) in Homogeneous coordinates.</p>
<p><strong>We can express the point at infinity without using “∞”.</strong></p>
<h3 id="Why-is-it-called-“homogeneous”"><a href="#Why-is-it-called-“homogeneous”" class="headerlink" title="Why is it called “homogeneous”?"></a>Why is it called “homogeneous”?</h3><p>Homogeneous coordinates are scale invariant.<br>(1a, 2a, 3a) in Homogeneous coordinates is the same point as (1/3, 2/3) in Euclidean space.<br>These points are “homogeneous” because they represent the same point in Euclidean space (or Cartesian space).</p>
<h3 id="Proof-Two-parallel-lines-can-intersect"><a href="#Proof-Two-parallel-lines-can-intersect" class="headerlink" title="Proof: Two parallel lines can intersect."></a>Proof: Two parallel lines can intersect.</h3><p><img src="./1605593492210.png" alt="Alt text"></p>
<ul>
<li>if C ≠ D -&gt; there is no solution</li>
<li>if C = D -&gt; two lines are identical (overlapped)</li>
</ul>
<p>笛卡尔坐标系下，两平行线要么重叠，要么永不相交。</p>
<hr>
<p>Rewrite the equations for projective space：<br><img src="./1605593639293.png" alt="Alt text"><br>we have a solution, (x, y, 0)<br>two parallel lines meet at (x, y, 0), which is the point at infinity.</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>从数学的角度讲：</p>
<ul>
<li>区分向量和点</li>
<li>可以表示无穷远的点</li>
<li>易于进行 仿射变化（Affine Transformation）。提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法。</li>
</ul>
<p>从现实意义的角度讲：</p>
<ul>
<li>描述透视空间</li>
<li>区分不同位置的向量</li>
</ul>
<h3 id="区分向量和点"><a href="#区分向量和点" class="headerlink" title="区分向量和点"></a>区分向量和点</h3><p>问题：笛卡尔坐标系下，三维坐标既可以表示向量，也可以表示点，从坐标上无法区分。<br>而实质上，向量和点是有区别的，点的位置是对这个基的原点o所进行的一个位移。<br>当我们在坐标系 xOy 中</p>
<ul>
<li>用 (a,b) 定义一个向量 <strong>v</strong> 时，表示 <strong>v</strong> =a<strong>x</strong> +b<strong>y</strong></li>
<li>用 (a,b) 表示一个点 p 时，表示 p−o=a<strong>x</strong> +b<strong>y</strong></li>
</ul>
<p>假若写下 (2,1)，如无附加说明，不能区别出它是向量还是点。<br>将点的表示重写为：<br><img src="./1605605087117.png" alt="Alt text"></p>
<p>将向量的表示写为:<br><img src="./1605605093577.png" alt="Alt text"></p>
<p>这样能够清晰地区分向量和点。数学家使用这种方式表示坐标 - 在n维向量（或坐标点）后面增加一维，这便是齐次坐标的思想。</p>
<p>通过如下方式可将三维坐标转换成齐次坐标：</p>
<ul>
<li>把3D向量的第4个代数分量设置为0</li>
<li>把3D点的第4个代数分量设置为1</li>
</ul>
<p>对于一个普通坐标的点P=(Px, Py, Pz)，有对应的<strong>一族</strong>齐次坐标(wPx, wPy, wPz, w)，其中w不等于零。</p>
<blockquote>
<p>比如，P(1, 4, 7)的齐次坐标有(1, 4, 7, 1)、（2, 8, 14, 2）、（-0.1, -0.4, -0.7, -0.1）等等。</p>
</blockquote>
<p>最后一个代数分量w称为<strong>比例因子</strong><br>当w=0时，可解释为无穷远的“点”，其意义是描述方向（既然已经是“无穷远”了，其实际位置已经没有意义了，只有用于描述方向的意义）。因此，w=0时，该坐标表示一个向量。对该坐标进行平移变换，不会产生效果，计算过程如图：<br><img src="./1605606438308.png" alt="Alt text"><br>这也符合我们原先的认知：向量没有位置，只有大小和方向。</p>
<h3 id="描述投影几何（-projective-geometry）"><a href="#描述投影几何（-projective-geometry）" class="headerlink" title="描述投影几何（ projective geometry）"></a>描述投影几何（ projective geometry）</h3><p>用眼睛观察世界有一个特点，就是越远的物体看起来就越小，而且我们还能通过“越远越小”这种视觉效果估算距离。 这种现象被称为透视现象，同样的存在这种现象的空间被称为<strong>投影空间</strong>。<br>在笛卡尔空间中，两条平行线是永远不会相交的，但是在透视空间中，两条平行线会相交于一点，这是两种空间最大的区别。</p>
<p>Projective geometry has an extra dimension, called W, in addition to the X, Y, and Z dimensions. This four-dimensional space is called “projective space,” and coordinates in projective space are called “homogeneous coordinates.”<br>（x,y,z）在齐次空间中有无数多个点与之对应。所有点的形式是（wx,wy,wz,w），其轨迹是通过齐次空间原点的“直线”</p>
<h4 id="An-Analogy-In-2D"><a href="#An-Analogy-In-2D" class="headerlink" title="An Analogy In 2D"></a>An Analogy In 2D</h4><p><img src="./1605607149931.png" alt="Alt text"><br>The W dimension is the distance from the projector to the screen.<br>The value of W affects the size (a.k.a. scale) of the image.</p>
<h4 id="Applying-It-To-3D"><a href="#Applying-It-To-3D" class="headerlink" title="Applying It To 3D"></a>Applying It To 3D</h4><p> When W increases, the coordinate expands (scales up). When W decreases, the coordinate shrinks (scales down). The W is basically a scaling transformation for the 3D coordinate.</p>
<p>The usual advice for 3D programming beginners is to always set W=1 whenever converting a 3D coordinate to a 4D coordinate.<br>when you scale a coordinate by 1 it doesn’t shrink or grow, it just stays the same size.</p>
<p>When W=1 it has no effect on the X, Y or Z values.<br>For this reason, when it comes to 3D computer graphics, coordinates are said to be “<strong>correct</strong>” only when W=1.</p>
<ul>
<li>If you rendered coordinates with W&gt;1 then everything would look too small, and with W&lt;1 everything would look too big.</li>
<li>If you tried to render with W=0 your program would crash when it attempted to divide by zero.</li>
<li>With W&lt;0 everything would flip upside-down and back-to-front.</li>
</ul>
<blockquote>
<p>Mathematically speaking, there is no such thing as an “incorrect” homogeneous coordinate. Using coordinates with <strong>W=1</strong> is just <strong>a useful convention</strong> for 3D computer graphics.</p>
</blockquote>
<h4 id="Uses-Of-Homogeneous-Coordinates-In-Computer-Graphics"><a href="#Uses-Of-Homogeneous-Coordinates-In-Computer-Graphics" class="headerlink" title="Uses Of Homogeneous Coordinates In Computer Graphics"></a>Uses Of Homogeneous Coordinates In Computer Graphics</h4><h5 id="Translation-Matrices-For-3D-Coordinates"><a href="#Translation-Matrices-For-3D-Coordinates" class="headerlink" title="Translation Matrices For 3D Coordinates"></a>Translation Matrices For 3D Coordinates</h5><p>In order to do translation, the matrices need to have at least four columns.<br>A four-column matrix can only be multiplied with a four-element vector, which is why we often use homogeneous 4D vectors instead of 3D vectors.</p>
<blockquote>
<p>W的几何意义与投影有关，也只有投影变换矩阵影响到w的值。平移、旋转、缩放矩阵都不影响W。</p>
</blockquote>
<p>The 4th dimension W is usually unchanged, when using homogeneous coordinates in matrix transformation. <strong>W is set to 1 when converting a 3D coordinate into 4D, and it is usually still 1 after the transformation matrices are applied, at which point it can be converted back into a 3D coordinate by ignoring the W.</strong> This is true for all <strong>translation</strong>, <strong>rotation</strong>, and <strong>scaling</strong> transformations, which are by far the most common types of transformations. <strong>The notable exception is projection matrices, which do affect the W dimension</strong>.</p>
<h5 id="Perspective-Transformation"><a href="#Perspective-Transformation" class="headerlink" title="Perspective Transformation"></a>Perspective Transformation</h5><p>Perspective is implemented in 3D computer graphics by using a transformation matrix that changes the W element of each vertex.<br>After the the camera matrix is applied to each vertex, but before the projection matrix is applied, <strong>the Z element of each vertex represents the distance away from the camera</strong>. Therefore, the larger Z is, the more the vertex should be scaled down. The W dimension affects the scale, so <strong>the projection matrix just changes the W value based on the Z value</strong>.<br>投影矩阵根据深度（Z）计算W值，W值影响缩放。<br><img src="./1605610411957.png" alt="Alt text"></p>
<p>投影矩阵相乘之后，执行透视除法，把齐次坐标转换成W=1的形式。<br>After the perspective projection matrix is applied, each vertex undergoes “perspective division.” Perspective division is just a specific term for converting the homogeneous coordinate back to W=1, as explained earlier in the article.<br><img src="./1605610619279.png" alt="Alt text"><br>After perspective division, the W value is discarded, and we are left with a 3D coordinate that has been correctly scaled according to a 3D perspective projection.</p>
<blockquote>
<p> In OpenGL, <strong>perspective division happens automatically after the vertex shader runs on each vertex.</strong> This is one reason why gl_Position, the main output of the vertex shader, is a 4D vector, not a 3D vector.</p>
</blockquote>
<h5 id="Positioning-Directional-Lights"><a href="#Positioning-Directional-Lights" class="headerlink" title="Positioning Directional Lights"></a>Positioning Directional Lights</h5><p>Points at <strong>infinity</strong> occur when W=0. Coordinates with W=0 can not be converted into 3D coordinates.</p>
<p><strong>Directional lights</strong></p>
<ul>
<li>point lights that are infinitely far away.</li>
<li>the rays of light become parallel, and all of the light travels in a single direction.</li>
</ul>
<p>W=1, then it is a point light.<br>W=0, then it is a directional light.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lightPosition.w == <span class="number">0.0</span>)&#123;</span><br><span class="line">    <span class="comment">//directional light code here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//point light code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="仿射变换总结"><a href="#仿射变换总结" class="headerlink" title="仿射变换总结"></a>仿射变换总结</h2><h3 id="旋转、缩放到平移"><a href="#旋转、缩放到平移" class="headerlink" title="旋转、缩放到平移"></a>旋转、缩放到平移</h3><p>对于一个 2 维点 p=(x,y)，<strong>仿射变换</strong>（T）是线性变换（Ap）和平移变换（+t）的叠加:<br>T(p)=Ap+t</p>
<blockquote>
<p>计算机图形学中的图形变换，实际上是在仿射空间中进行的</p>
</blockquote>
<p>线性变换在欧式空间中可以表示为矩阵乘积形式，如旋转变换和缩放变换：<br><img src="./1605604356384.png" alt="Alt text"></p>
<p>而平移变换<br><img src="./1605604375076.png" alt="Alt text"><br>却不能用矩阵相乘的形式表达。</p>
<p>现在引入齐次坐标系表达 p~=(x,y,1)，（尺度不变性，实际上在高一维的空间映射到 w=1 平面, 这样计算后结果直接可导出到欧式空间）。可以将旋转变换和缩放变换表示为：<br><img src="./1605604526234.png" alt="Alt text"></p>
<p>以二维向量为例，平移变换则为：<br><img src="./1605604714025.png" alt="Alt text"></p>
<p>仿射变换的矩阵形式<br><img src="./1605604635107.png" alt="Alt text"></p>
<p>齐次坐标把各种变换都在统一了起来，不管怎样变换，变换多少次，都可以表示成一连串的矩阵相乘。任何三维坐标空间的转换，都可以用一个四维矩阵表示。</p>
<hr>
<p>三维向量平移运算：<br><img src="./1605624685160.png" alt="Alt text"></p>
<h3 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h3><h4 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h4><p>正交投影矩阵的视锥体是一个长方体[l,r][b,t][f,n]，我们要把这个长方体转换到一个正方体[-1,1][-1,1][-1,1]中，如图。<br><img src="./1605619846921.png" alt="Alt text"><br><img src="./1605619859591.png" alt="Alt text"><br>第一步平移，计算出长方体的中心点为[(l+r)/2,(b+t)/2,(f+n)/2]，然后将中心点移动到原点，矩阵为<br><img src="./1605619868421.png" alt="Alt text"><br>第二步缩放，例如从[l,r]缩放到[-1,1]，缩放系数为2/(r-l)，所以矩阵为<br><img src="./1605619877457.png" alt="Alt text"><br>所以正交投影矩阵Mortho = Mscale*Mtranslate</p>
<h4 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h4><p>透视投影的视锥体是一个四棱锥的一部分，其中近平面为z=n，远平面为z=f，我们要把这个视锥体转换到一个正方体[-1,1][-1,1][-1,1]中，可以先把远平面压缩，把视锥体压缩成一个长方体，然后再通过第二步中的正交投影矩阵就可以变换到正方体中，如图。<br><img src="./1605620068159.png" alt="Alt text"><br>三个原则：</p>
<ol>
<li>近平面的所有点坐标不变</li>
<li>远平面的所有点坐标z值不变 都是f</li>
<li>远平面的中心点坐标值不变 为(0,0,f)<br><img src="./1605620366905.png" alt="Alt text"><br>由三角形相似性，对于(x,y,z,1)一点，它在视锥体压缩以后坐标应该为(nx/z,ny/z,unknow,1)。<br><img src="./1605620393640.png" alt="Alt text"><br>也就是我们现在需要找到一个矩阵Mpersp-&gt;ortho，使得上面的转换成立。<br>(x,y,z,1)与(kx,ky,kz,k!=0)这两个点是完全等价的点<br><img src="./1605620546915.png" alt="Alt text"><br>需要找到矩阵Mpersp-&gt;ortho，使得上面的转换成立。</li>
</ol>
<p>Ax+By+Cz+D = nx，求出 A=n,B=C=D=0<br>Ex+Fy+Gz+H = ny，求出F=n,E=G=H=0<br>Mx+Ny+Oz+P = z，求出O=1,M=N=P=0。<br><img src="./1606293635777.png" alt="Alt text"></p>
<p>由（1）近平面的所有点坐标不变<br><img src="./1605621055364.png" alt="Alt text"><br>对于第一二四行，我们写出等式<br>nx+0y+0n+0<em>1=x<br>0x+ny+0n+0</em>1=y<br>0x+0y+1n+0<em>1=1<br>很明显这是有问题的，因为n应该是任意常数，但是现在只有在n等于1时，一二四行的运算才成立<br>所以我们根据前面的方法，再把(x,y,n,1)都乘以一个n等价变为(nx,ny,n</em>n,n)。<br><img src="./1605621104726.png" alt="Alt text"><br>对于第一二四行，我们写出等式<br>nx+0y+0n+0<em>1=nx,<br>0x+ny+0n+0</em>1=ny,<br>0x+0y+1n+0<em>1=n<br>完美成立。现在我们可以安心的求第三行了。<br>设第三行的四个数分别为ABCD<br>可以获得等式 Ax+By+Cn+D = n</em>n。<br>明显A=0,B=0<br>Cn+D = n*n (式1)</p>
<p>我们接下来考虑第三个原则，远平面的中心点坐标值不变 为(0,0,f)<br>同样为了保证之前求的矩阵一二四行成立，我们需要把(0,0,f,1)写成(0,0,f<em>f,f)<br><img src="./1605621167044.png" alt="Alt text"><br>Cf+D = f</em>f（式2）</p>
<p>联立式1式2，解得<br>C = n+f<br>D = -nf</p>
<p>终于，我们求得了Mpersp-&gt;ortho矩阵为<br><img src="./1605621187419.png" alt="Alt text"><br>也就是通过这个矩阵，我们可以把原来的透视投影的视锥体压缩为正交投影的视锥体(长方体)<br>最后我们再乘上一开始求出来正交投影矩阵Morth就得到了透视投影矩阵<br>Mpersp = Mortho*Mpersp-&gt;ortho<br><img src="./1605621299525.png" alt="Alt text"></p>
<p><img src="./1605621446770.png" alt="Alt text"></p>
<p>推导过程及代码：<br><a href="http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html" target="_blank" rel="noopener">http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html</a></p>
<p><strong>After multiplying the vertex position by the projection matrix the coordinates are said to be in Clip Space and after performing the perspective divide the coordinates are in NDC Space (Normalized Device Coordinates).</strong></p>
<h2 id="Prin对齐次坐标、透视投影的理解"><a href="#Prin对齐次坐标、透视投影的理解" class="headerlink" title="Prin对齐次坐标、透视投影的理解"></a>Prin对齐次坐标、透视投影的理解</h2><p>如何理解四维坐标，如何理解w分量？<br>本质问题是，将一个frustum(截头锥体)压缩成一个正方体，求frustum中的点的坐标到正方体空间中点的坐标的一个映射关系。并用矩阵、线性代数的语言描述这一变换，使得所有的点的变换可以用同一个矩阵乘法进行描述，从而可以让计算机对所有顶点批量处理这一变换。</p>
<p>关键点：这个变换不是线性变换，无法用三维矩阵乘法描述。这个变换对所有点不是统一的，还与点到摄像机的距离有关系，不能对所有的点进行统一的变换，意味着对每个点增加一个属性，来描述点到摄像机的距离属性，从而使得这个变换与距离有关，这个属性就是点的w分量。</p>
<p>引入w分量之后，点的坐标扩充到四维，变换矩阵是4x4的矩阵。使用四维矩阵进行投影变换本质上是使用四维空间下的线性变换描述三维空间下的非线性变换（将frustum“捏”成正方体的变换）。<br>引入w分量后，实际上将一个点映射成了无数个点。我们定义了三维空间中点(x, y, z)对应的齐次坐标为(wx, wy, wz, w),(w!=0)。</p>
<p>之前“捏”frustum的操作，用三维空间线性变换是无法描述的，用3x3矩阵乘法进行变换是无法达到要求的。我们发现，当扩充一个维度之后，看待这个问题，之前的一些”无理要求”是可以满足的。</p>
<p>按照把frustum“捏”成正方体的条件，建立方程，在齐次空间下求这个映射函数，求出了满足要求的变换矩阵。变换之后，点的坐标是下图右边这个样子：<br><img src="./1606297457393.png" alt="Alt text"><br>再映射到三维空间的点就是这个样子：<br><img src="./1606297509696.png" alt="Alt text"></p>
<p>这样一来，我们对所有的点都可以进行这个变换过程:</p>
<ol>
<li>映射到齐次坐标空间（增加一个w分量，变为四维坐标）</li>
<li>按照我们对视锥体进行形变的要求，求得4x4变换矩阵。</li>
<li>齐次空间下做统一的缩放、平移变换，这个变换过程中，点将到摄像机的距离体现在w分量上面。</li>
<li>变换后，再将点映射到三维空间，发现原视锥体经变换后成功映射为正方体，其他所有点也经过了相同的映射，结果是合理的。</li>
</ol>
<h2 id="渲染管线中坐标变换总结"><a href="#渲染管线中坐标变换总结" class="headerlink" title="渲染管线中坐标变换总结"></a>渲染管线中坐标变换总结</h2><h3 id="坐标变换过程"><a href="#坐标变换过程" class="headerlink" title="坐标变换过程"></a>坐标变换过程</h3><p>物体空间(object space)-&gt;世界空间(World Space)-&gt;观察空间(View Space)-&gt;裁剪空间(clip space)-&gt;屏幕空间(Screen Space)<br><img src="./1605627042134.png" alt="Alt text"></p>
<ul>
<li>Object Coordinate System: 也称作Local coordinate System，用来定义一个模型本身的坐标系。</li>
<li>World Coordinate System: 3d 虚拟世界中的绝对坐标系，定义好这个坐标系的原点就可以用来描述模型的实现的位置，Camera 的位置，光源的位置。</li>
<li>View Coordinate System: 一般使用用来计算光照效果。</li>
<li>Clip Coordinate System:  对3D场景使用投影变换裁剪视锥。</li>
<li>Normalized device coordinate System (NDC): 归一化设备坐标系</li>
<li>Windows Coordinate System: 最后屏幕显示的2D坐标系统，一般原点定义在屏幕左上角。<h3 id="MVP矩阵及使用"><a href="#MVP矩阵及使用" class="headerlink" title="MVP矩阵及使用"></a>MVP矩阵及使用</h3>模型（Model）、观察（View）和投影（Projection）矩阵</li>
</ul>
<p><img src="./1605625875848.png" alt="Alt text"></p>
<h4 id="The-Model-matrix"><a href="#The-Model-matrix" class="headerlink" title="The Model matrix"></a>The Model matrix</h4><p>We went from Model Space (all vertices defined relatively to the center of the model) to World Space (all vertices defined relatively to the center of the world).<br><img src="./1605625959705.png" alt="Alt text"></p>
<h4 id="The-View-matrix"><a href="#The-View-matrix" class="headerlink" title="The View matrix"></a>The View matrix</h4><p>We went from World Space (all vertices defined relatively to the center of the world, as we made so in the previous section) to Camera Space (all vertices defined relatively to the camera).</p>
<blockquote>
<p>Unity中</p>
<ul>
<li>模型空间 &amp; 世界空间: 左手坐标系.</li>
<li>观察空间: 右手坐标系 (+x轴指向右方, +y轴指向上方, +z轴指向相机的后方)</li>
</ul>
</blockquote>
<p><img src="./1605626040517.png" alt="Alt text"></p>
<blockquote>
<p>The engines don’t move the ship at all. The ship stays where it is and the engines move the universe around it.</p>
</blockquote>
<h4 id="The-Projection-matrix"><a href="#The-Projection-matrix" class="headerlink" title="The Projection matrix"></a>The Projection matrix</h4><p>We’re now in Camera Space. This means that after all theses transformations, a vertex that happens to have x==0 and y==0 should be rendered at the center of the screen. But we can’t use only the x and y coordinates to determine where an object should be put on the screen : its distance to the camera (z) counts, too ! <strong>For two vertices with similar x and y coordinates, the vertex with the biggest z coordinate will be more on the center of the screen than the other.</strong></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generates a really hard-to-read matrix, but a normal, standard 4x4 matrix nonetheless</span></span><br><span class="line">glm::<span class="type">mat4</span> projectionMatrix = glm::perspective(</span><br><span class="line">    glm::<span class="built_in">radians</span>(FoV), <span class="comment">// The vertical Field of View, in radians: the amount of "zoom". Think "camera lens". Usually between 90° (extra wide) and 30° (quite zoomed in)</span></span><br><span class="line">    <span class="number">4.0</span>f / <span class="number">3.0</span>f,       <span class="comment">// Aspect Ratio. Depends on the size of your window. Notice that 4/3 == 800/600 == 1280/960, sounds familiar ?</span></span><br><span class="line">    <span class="number">0.1</span>f,              <span class="comment">// Near clipping plane. Keep as big as possible, or you'll get precision issues.</span></span><br><span class="line">    <span class="number">100.0</span>f             <span class="comment">// Far clipping plane. Keep as little as possible.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>We went from Camera Space (all vertices defined relatively to the camera) to Homogeneous Space (all vertices defined in a small cube. Everything inside the cube is onscreen).</p>
<p>Before projection, we’ve got our blue objects, in Camera Space, and the red shape represents the <strong>frustum</strong> of the camera : the part of the scene that the camera is actually able to see.<br><img src="./1605626582117.png" alt="Alt text"><br>Multiplying everything by the Projection Matrix has the following effect :<br><img src="./1605626624387.png" alt="Alt text"><br>In this image, the frustum is now a perfect cube (between -1 and 1 on all axes, it’s a little bit hard to see it), and all blue objects have been deformed in the same way. Thus, the objects that are near the camera ( = near the face of the cube that we can’t see) are big, the others are smaller. Seems like real life !<br><img src="./1605626691338.png" alt="Alt text"></p>
<p>Another mathematical transformation is applied (this one is automatic, you don’t have to do it yourself in the shader) to fit this to the actual window size :<br><img src="./1605626743536.png" alt="Alt text"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://oncemore2020.github.io/blog/homogeneous/" target="_blank" rel="noopener">https://oncemore2020.github.io/blog/homogeneous/</a><br><a href="http://www.songho.ca/math/homogeneous/homogeneous.html" target="_blank" rel="noopener">http://www.songho.ca/math/homogeneous/homogeneous.html</a><br><a href="https://zhuanlan.zhihu.com/p/110503121" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110503121</a><br><a href="https://blog.csdn.net/yinhun2012/article/details/79566148" target="_blank" rel="noopener">https://blog.csdn.net/yinhun2012/article/details/79566148</a><br><a href="https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/" target="_blank" rel="noopener">https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/</a><br><a href="https://zhuanlan.zhihu.com/p/122411512" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/122411512</a><br><a href="http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-3-matrices/" target="_blank" rel="noopener">http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-3-matrices/</a><br><a href="http://www.guidebee.info/wordpress/?m=201106" target="_blank" rel="noopener">http://www.guidebee.info/wordpress/?m=201106</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rendering/" rel="tag">Rendering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math/" rel="tag">math</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/11/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/10/">10</a><a class="page-number" href="/archives/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/13/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>