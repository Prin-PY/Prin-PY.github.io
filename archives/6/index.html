<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-【资源】Asset-Bundle-2020-10-25-022900"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91Asset-Bundle-2020-10-25-022900/"
    >【资源】Asset Bundle(2020-10-25 022900)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91Asset-Bundle-2020-10-25-022900/" class="article-date">
  <time datetime="2023-07-20T15:00:27.904Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="【资源】Asset-Bundle-2020-10-25-02-29-00"><a href="#【资源】Asset-Bundle-2020-10-25-02-29-00" class="headerlink" title="【资源】Asset Bundle(2020-10-25 02:29:00)"></a>【资源】Asset Bundle(2020-10-25 02:29:00)</h1><h1 id="【资源】Asset-Bundle-2020-10-25-02-29-00-1"><a href="#【资源】Asset-Bundle-2020-10-25-02-29-00-1" class="headerlink" title="【资源】Asset Bundle(2020-10-25 02:29:00)"></a>【资源】Asset Bundle(2020-10-25 02:29:00)</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="资源加载的方式"><a href="#资源加载的方式" class="headerlink" title="资源加载的方式"></a>资源加载的方式</h3><p>Resources加载 - Resources.Load()来直接加载Resources文件夹下的资源</p>
<p>AssetBundle</p>
<p>Addressable</p>
<h4 id="Resources加载的缺点"><a href="#Resources加载的缺点" class="headerlink" title="Resources加载的缺点"></a>Resources加载的缺点</h4><ul>
<li><p>对内存管理造成一定的负担。</p>
</li>
<li><p>在打开应用时加载时间很长。</p>
</li>
<li><p>Resources文件夹下的所有资源统一合并到一个序列化文件中（可以看成统一打一个大包，巨型AB包有什么问题它就有什么问题），对资源优化有一定的限制。</p>
</li>
<li><p>不建议大量使用Resources。</p>
</li>
</ul>
<h3 id="AssetBundle是什么"><a href="#AssetBundle是什么" class="headerlink" title="AssetBundle是什么"></a>AssetBundle是什么</h3><h4 id="从资源的角度"><a href="#从资源的角度" class="headerlink" title="从资源的角度"></a>从资源的角度</h4><p>它是一个 <strong>存在于硬盘上的文件</strong> 。可以称之为 <strong>压缩包</strong> 。这个压缩包可以认为是一个文件夹，里面包含了多个文件。这些文件可以分为两类：serialized file 和 resource files。（序列化文件和源文件）</p>
<ul>
<li><p>serialized files：资源被打碎放在一个对象中，最后统一被写进一个单独的文件（只有一个）。相当于是一个头文件，里面记录了关于这个AB的相关信息，当我们调用 <strong>LoadFromFile</strong> 接口加载AB的时候实际上就是去加载的这一部分信息。这部分信息在Profiler里面的SerilizeField选项里。</p>
</li>
<li><p>resource files（Bundle Content ）：某些二进制资源（图片、声音）被单独保存，方便快速加载</p>
</li>
</ul>
<h4 id="从API的角度"><a href="#从API的角度" class="headerlink" title="从API的角度"></a>从API的角度</h4><p>它是一个AssetBundle对象，我们可以通过代码从一个特定的压缩包加载出来的对象。这个对象包含了所有我们当初添加到这个压缩包里面的内容，我们可以通过这个对象加载出来使用。</p>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ol>
<li><p>AssetBundle是一个压缩包包含模型、贴图、预制体、声音、甚至整个场景，可以在游戏运行的时候被加载；</p>
</li>
<li><p>AssetBundle自身保存着互相的依赖关系；</p>
</li>
<li><p>压缩包可以使用LZMA和LZ4压缩算法，减少包大小，更快的进行网络传输；</p>
</li>
<li><p>把一些可以下载内容放在AssetBundle里面，可以减少安装包的大小；</p>
</li>
</ol>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1616396262550.png)</p>
<h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><p>AB包数量较多，包内资源较少 - 加载一个AB包到内存的时间短，玩家不会有卡顿感，但每个资源实际上加载时间变长。热更新灵活，要更新下载的包体较小。IO次数过多，增大了硬件设备耗能和发热压力。</p>
<p>AB包数量较少，包内资源较多 - 加载一个AB包到内存的时间较长，玩家会有卡顿感，但之后包内的每个资源加载很快。热更新不灵活，要更新下载的包体较大。IO次数不多，硬件压力小。</p>
<h3 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h3><ol>
<li><p>把经常更新的资源放在一个单独的包里面，跟不经常更新的包分离</p>
</li>
<li><p>把需要同时加载的资源放在一个包里面</p>
</li>
<li><p>可以把其他包共享的资源放在一个单独的包里面</p>
</li>
<li><p>把一些需要同时加载的小资源打包成一个包</p>
</li>
<li><p>如果对于一个同一个资源有两个版本，可以考虑通过后缀来区分 v1 v2 v3 unity3dv1 unity3dv2</p>
</li>
</ol>
<h4 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h4><p>a. 一个UI界面或者所有UI界面一个包（这个界面里面的贴图和布局信息一个包）<br>b. 一个角色或者所有角色一个包（这个角色里面的模型和动画一个包）<br>c. 所有的场景所共享的部分一个包（包括贴图和模型）</p>
<h4 id="按照类型分组"><a href="#按照类型分组" class="headerlink" title="按照类型分组"></a>按照类型分组</h4><p>所有 <strong>声音</strong> 资源打成一个包，所有 <strong>shader</strong> 打成一个包，所有 <strong>模型</strong> 打成一个包，所有材质打成一个包</p>
<h4 id="按照使用分组"><a href="#按照使用分组" class="headerlink" title="按照使用分组"></a>按照使用分组</h4><p>把在某一时间内使用的所有资源打成一个包。可以按照关卡分，一个关卡所需要的所有资源包括角色、贴图、声音等打成一个包。也可以按照场景分，一个场景所需要的资源一个包</p>
<h3 id="依赖打包"><a href="#依赖打包" class="headerlink" title="依赖打包"></a>依赖打包</h3><p>(Mat + Cube1) (Mat + Cube2)<br>(Mat) (Cube1) (Cube2)<br>Unity会自动识别，共享的依赖如果已经单独打包，则不会重复打包</p>
<h3 id="关于压缩"><a href="#关于压缩" class="headerlink" title="关于压缩"></a>关于压缩</h3><ul>
<li><p>加载时间：当从本地存储或本地缓存加载时，未压缩的AssetBundles加载速度比压缩的AssetBundles快得多。</p>
</li>
<li><p>构建时间：在压缩文件时，LZMA和LZ 4非常慢，统一编辑器依次处理AssetBundles。拥有大量资产Bundles的项目将花费大量的时间压缩它们。</p>
</li>
<li><p>应用程序大小：如果AssetBundles是在应用程序中提供的，那么压缩它们将减少应用程序的总大小。或者，AssetBundles可以在安装后下载。</p>
</li>
<li><p>内存使用：在Unity 5.3之前，Unity的所有解压缩机制都要求在解压缩之前将整个压缩的AssetBundles加载到内存中。如果内存使用很重要，请使用未压缩或LZ 4压缩AssetBundles。</p>
</li>
</ul>
<h4 id="LZMA和LZ4"><a href="#LZMA和LZ4" class="headerlink" title="LZMA和LZ4"></a>LZMA和LZ4</h4><p>LZMA是流压缩方式（stream-based）。流压缩再处理整个数据块时使用同一个字典，它提供了最大可能的压缩率，但是只支持顺序读取。所以加载AB包时，需要将整个包解压之后才能加载包内资源，会造成卡顿和额外内存占用。</p>
<p>LZ4是块压缩方式（chunk-based）。块压缩的数据被分为大小相同的块，并被分别压缩。不需要完整解压就可以加载包内资源。如果需要实时解压随机读取，块压缩是比较好的选择。<br>使用LZ4压缩，可以获得可以跟不压缩想媲美的加载速度，而且比不压缩文件要小。</p>
<p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1616396217868.png)</p>
<h4 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h4><blockquote>
<p>BuildAssetBundles底层会对传入的BuildAssetBundleOptions值进行处理，根据二进制位数来判断使用哪种策略构建AB包。因此如果在构建AB包时想要使用多种策略，用&amp;连接即可。</p>
</blockquote>
<p>BuildAssetBundleOptions.None：使用LZMA算法压缩，压缩的包更小，但是加载时间更长。使用之前需要整体解压。一旦被解压，这个包会使用LZ4重新压缩。。这就是为什么第一次加载时间长，之后加载时间就没那么长了。在下载的时候可以使用LZMA算法，一旦它被下载了之后，它会使用LZ4算法保存到本地上。</p>
<p>BuildAssetBundleOptions.UncompressedAssetBundle：不压缩，包大，加载快</p>
<p>DisableWriteTypeTree - 8：不包含TypeTree信息。虽然可以使得AB包更小，但是对低版本不兼容。不建议使用。</p>
<p>DeterministicAssetBundle - 16：创建一个哈希来映射存储在AB包里的对象的id。</p>
<p>ForceRebuildAssetBundle - 32：强制重建AB包。</p>
<p>IgnoreTypeTreeChanges - 64：当做增量构建检测时，忽略type tree的变化。</p>
<p>AppendHashToAssetBundleName - 128：添加哈希到AB包名。</p>
<p>ChunkBasedCompression - 256：使用LZ4压缩，压缩率没有LZMA高，但是我们可以加载指定资源而不用解压全部。</p>
<p>StrictMode - 512：如果在构建时有任何错误，则不允许构建成功。</p>
<p>DryRunBuild - 1024：干构建。</p>
<p>DisableLoadAssetByFileName - 4069：禁止AB包通过文件名加载资源。</p>
<p>DisableLoadAssetByFileNameWithExtension - 8192：禁止AB包通过文件扩展名加载资源。</p>
<p>AssetBundleStripUnityVersion：构建时从压缩文件和序列化文件的header中移除Unity版本号。</p>
<h3 id="assetBundleVariant-及自动标记打包API"><a href="#assetBundleVariant-及自动标记打包API" class="headerlink" title="assetBundleVariant 及自动标记打包API"></a>assetBundleVariant 及自动标记打包API</h3><p><strong>different AssetBundle variants will have the same internal IDs</strong> 。因此，AssetBundle的后缀名不仅仅是名称那么简单。而加载使用时，就看作不同名称的AB即可。</p>
<blockquote>
<p>注意：assetBundleName中设置后缀名 “Cube.ab”，并不能启到AssetBundle Variant的作用。后缀名应该在AssetImporter.assetBundleVariant中设置。</p>
</blockquote>
<p>variant 的用处：</p>
<ul>
<li><p>好一点设备上可以加载高模，而差一点的设备中只能加载低模</p>
</li>
<li><p>做分包，不同版本包</p>
</li>
<li><p>做多语言包</p>
</li>
</ul>
<p>手动设置name &amp; variant name:</p>
<p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1621089585094.png)</p>
<p>代码自动设置：</p>
<pre><code class="lang-csharp">
# region 自动做标记

[MenuItem(&quot;AssetBundle/Set AssetBundle Lables&quot; ,false , 100)] 

public static void SetAssetBundleLables()

{ 

//移除掉所有没有使用的标记

AssetDatabase.RemoveUnusedAssetBundleNames(); 

string assetDirectory = &quot;Assets/Res&quot;; 

DirectoryInfo directoryInfo = new DirectoryInfo(assetDirectory); 

DirectoryInfo[] scenesDirectories = directoryInfo.GetDirectories(); 

foreach (var tempDir in scenesDirectories) 

{ 

string sceneDirectory = assetDirectory + &quot;/&quot; \+ tempDir.Name; 

DirectoryInfo sceneDirectoryInfo = new DirectoryInfo(sceneDirectory); 

if (sceneDirectoryInfo == null) 

{ 

Debug.Log(sceneDirectoryInfo + &quot;不存在&quot;); 

return; 

} 

else

{ 

Dictionary&lt;string , string&gt; namePathDictionary = new Dictionary&lt;string, string&gt;(); 

int index = sceneDirectory.LastIndexOf(&quot;/&quot;); 

string sceneName = sceneDirectory.Substring(index + 1); 

OnSceneFileSystemInfo(sceneDirectoryInfo , sceneName , namePathDictionary); 

OnWriteConfig(sceneName , namePathDictionary); 

} 

} 

AssetDatabase.Refresh(); 

Debug.Log(&quot;设置标记成功...&quot;); 

} 

/// &lt;summary&gt;

/// 记录配置文件

/// &lt;/summary&gt;

/// &lt;param name=&quot;sceneDirectory&quot;&gt;&lt;/param&gt;

/// &lt;param name=&quot;namePathDictionary&quot;&gt;&lt;/param&gt;

private static void OnWriteConfig(string sceneName , Dictionary&lt;string , string&gt; namePathDictionary)

{ 

string path = Application.dataPath + &quot;/AssetBundles/&quot; \+ sceneName ; 

if (!Directory.Exists(path)) Directory.CreateDirectory(path); 

Debug.Log(path); 

using (FileStream fs = new FileStream(path + &quot;/Record.txt&quot;, FileMode.OpenOrCreate , FileAccess.Write)) 

{ 

using (StreamWriter sw = new StreamWriter(fs)) 

{ 

sw.WriteLine(namePathDictionary.Count); 

foreach (KeyValuePair&lt;string , string&gt; kv in namePathDictionary) 

{ 

Debug.Log(kv.Value); 

sw.WriteLine(kv.Key+&quot;/&quot;+kv.Value); 

} 

} 

} 

} 

private static void OnSceneFileSystemInfo(FileSystemInfo fileSystemInfo , string sceneNama , Dictionary&lt;string, string&gt; namePathDictionary)

{ 

if (!fileSystemInfo.Exists) 

{ 

Debug.Log(fileSystemInfo + &quot;不存在&quot;); 

return; 

} 

DirectoryInfo directoryInfo = fileSystemInfo as DirectoryInfo; 

FileSystemInfo[] fileSystemInfos = directoryInfo.GetFileSystemInfos(); 

foreach (var systemInfo in fileSystemInfos) 

{ 

FileInfo fileInfo = systemInfo as FileInfo; 

if (fileInfo == null) 

{ 

OnSceneFileSystemInfo(systemInfo, sceneNama , namePathDictionary); 

} 

else

{ 

SetLables(fileInfo, sceneNama , namePathDictionary); 

} 

} 

} 

/// &lt;summary&gt;

/// 修改资源 assetbundle lables

/// &lt;/summary&gt;

private static void SetLables(FileInfo fileInfo , string sceneName , Dictionary&lt;string, string&gt; namePathDictionary)

{ 

if(fileInfo.Extension == &quot;.meta&quot;)return; 

string bundleName = GetBundleName(fileInfo , sceneName); 

int index = fileInfo.FullName.IndexOf(&quot;Assets&quot;); 

string assetPath = fileInfo.FullName.Substring(index); 

AssetImporter assetImporter = AssetImporter.GetAtPath(assetPath); 

assetImporter.assetBundleName = bundleName; 

if (fileInfo.Extension == &quot;.unity&quot;) 

assetImporter.assetBundleVariant = &quot;u3d&quot;; 

else

assetImporter.assetBundleVariant = &quot;assetbundle&quot;; 

string folderName; 

if (bundleName.Contains(&quot;/&quot;)) 

folderName = bundleName.Split(&#39;/&#39;)[1]; 

else

folderName = bundleName; 

string bundlePath = assetImporter.assetBundleName + &quot;.&quot; \+ assetImporter.assetBundleVariant; 

if (!namePathDictionary.ContainsKey(folderName)) 

namePathDictionary.Add(folderName, bundlePath); 

} 

private static string GetBundleName(FileInfo fileInfo, string sceneName)

{ 

string path = fileInfo.FullName; 

int index = path.IndexOf(sceneName) + sceneName.Length; 

string bundlePath = path.Substring(index + 1); 

bundlePath = bundlePath.Replace(@&quot;\&quot;, &quot;/&quot;); 

if (bundlePath.Contains(&quot;/&quot;)) 

{ 

string[] tmp = bundlePath.Split(&#39;/&#39;); 

return sceneName + &quot;/&quot; \+ tmp[0]; 

} 

return sceneName; 

} 

#endregion
</code></pre>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载流程可归为两步：</p>
<ol>
<li><p>从目标路径读取并创建 AssetBundle 对象</p>
</li>
<li><p>从 AssetBundle 对象中创建 Asset</p>
</li>
</ol>
<h3 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h3><h4 id="LoadFromFile"><a href="#LoadFromFile" class="headerlink" title="LoadFromFile"></a>LoadFromFile</h4><p>从磁盘路径读取 AssetBundle 文件，如果文件内容是以 LZMA 格式压缩的，则会将内容解压进内存保存。未压缩(uncompressed) 和块压缩(chunk-compressed) 的部分将会通过 IO 从磁盘读取。</p>
<p>如果AB包是LZ4加载方式，它只会加载AB包的Header，之后需要什么资源再加载那部分的AB包chunk。极大的减少了内存占用。</p>
<blockquote>
<p>但在Editor环境下，API还是会把整个AssetBundle加载到内存中，不应影响实际运行的设备上的性能。</p>
</blockquote>
<pre><code class="lang-csharp">
public class LoadFromFileExample : MonoBehaviour { 

function Start() { 

var myLoadedAssetBundle 

= AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;)); 

if (myLoadedAssetBundle == null) { 

Debug.Log(&quot;Failed to load AssetBundle!&quot;); 

return; 

} 

var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;); 

Instantiate(prefab); 

} 

}
</code></pre>
<h4 id="LoadFromMemory"><a href="#LoadFromMemory" class="headerlink" title="LoadFromMemory"></a>LoadFromMemory</h4><p>从托管代码的字节数组（C#中的byte[]）中加载AssetBundle。要提前用其它的方式将资源的二进制数组加入到内存中。然后该接口会将源数据从托管代码字节数组复制到新分配的、连续的本机内存块中。</p>
<p>如果AssetBundle使用了LZMA压缩，在复制过程中AssetBundle会被解压；如果使用了LZ4压缩或者没有压缩，AssetBundle会被逐字复制（be copied verbatim）。</p>
<p>当资源有加密需求时，可先把AB读取到内存当中，进行解密后再调用该AssetBundle.LoadFromMemory 进行加载。</p>
<p>此API消耗的最大内存量将至少是AssetBundle的两倍：本机内存中的一个副本，和LoadFromMemory(Async)从托管字节数组中复制的一个副本。</p>
<p>因此，从通过此API创建的AssetBundle加载的资产将在内存中一次在托管代码字节数组中，一次在AssetBundle的栈内存副本中，第三次在GPU或系统内存中，用于Asset本身。</p>
<p>适用于需要对原始数据进行解密的方式。</p>
<blockquote>
<p><strong>若把Start()函数声明成返回IEnumrator，编译器会自动将Start的调用处理成协程的模式</strong></p>
</blockquote>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

using System.IO; 

public class Example : MonoBehaviour

{ 

IEnumerator LoadFromMemoryAsync(string path)

{ 

AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path)); 

yield return createRequest; 

AssetBundle bundle = createRequest.assetBundle; 

var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;); 

Instantiate(prefab); 

} 

}
</code></pre>
<h4 id="LoadFromStream"><a href="#LoadFromStream" class="headerlink" title="LoadFromStream"></a>LoadFromStream</h4><p>AssetBundle.LoadFromStream可进行流式加载，不需要将AB全部读到内存中再解密、加载，而是可以通过每次像Buffer中读一部分，解密一部分的方式进行加载，不会多占用一份很大的内存。如果使用该接口，需要自定义一个继承FileStream类，然在Read和Write方法内对byte数组进行异或加密解密处理。</p>
<blockquote>
<p>与 LoadFromFile 类似， LZMA 格式压缩的会被解压进内存，未压缩(uncompressed) 和块压缩(chunk-compressed) 的部分将会直接通过 Stream 来读取。</p>
<p>在加载AssetBundle或捆绑包中的任何资产时，请勿释放Stream对象。它的寿命应该比AssetBundle长。这意味着在调用AssetBundle.Unload之后处理Stream对象。</p>
</blockquote>
<p><a href="https://www.xuanyusong.com/archives/4607" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4607</a></p>
<h3 id="WWW-LoadFromCacheOrDownload（Obsolete）"><a href="#WWW-LoadFromCacheOrDownload（Obsolete）" class="headerlink" title="WWW.LoadFromCacheOrDownload（Obsolete）"></a>WWW.LoadFromCacheOrDownload（Obsolete）</h3><p>Loading an AB from a remote location will automatically <strong>cache</strong> the AssetBundles. If the AssetBundle is compressed, a worker thread will spin up to decompress the bundle and write it to the cache. <strong>Once a bundle has been decompressed and cached, it will load exactly like AssetBundle.LoadFromFile .</strong></p>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

public class LoadFromCacheOrDownloadExample : MonoBehaviour

{ 

IEnumerator Start ()

{ 

while (!Caching.ready) 

yield return null; 

var www = WWW.LoadFromCacheOrDownload(&quot;http://myserver.com/myassetBundle&quot;, 5); 

yield return www; 

if(!string.IsNullOrEmpty(www.error)) 

{ 

Debug.Log(www.error); 

yield return; 

} 

var myLoadedAssetBundle = www.assetBundle; 

var asset = myLoadedAssetBundle.mainAsset; 

} 

}
</code></pre>
<h3 id="UnityWebRequest-AssetBundleDownloadHandler"><a href="#UnityWebRequest-AssetBundleDownloadHandler" class="headerlink" title="UnityWebRequest - AssetBundleDownloadHandler"></a>UnityWebRequest - AssetBundleDownloadHandler</h3><p>它使用工作线程，将下载的数据流存储到一个固定大小的缓冲区中，然后根据下载处理程序的配置方式将缓冲数据放到临时存储或AssetBundle缓存中。</p>
<p>它使用工作线程，将下载的数据流存储到一个固定大小的缓冲区中，然后根据下载处理程序的配置方式将缓冲数据放到临时存储或AssetBundle缓存中。</p>
<p>所有这些操作都发生在非托管代码中，消除了增加堆内存的风险。此外，该下载处理程序并不会保留所有下载字节的栈内存副本，从而进一步减少了下载AssetBundle的内存开销。</p>
<p>如果将缓存信息提供给UnityWebRequest对象，一旦有请求的AssetBundle已经存在于Unity的缓存中，那么AssetBundle将立即可用，并且此API的行为将会与AssetBundle.LoadFromFile相同操作。</p>
<blockquote>
<p>从服务器下载</p>
<ol>
<li>NetBox可以在本地启动服务器，把当前目录作为服务器端的网站</li>
</ol>
</blockquote>
<pre><code class="lang-csharp">
IEnumerator InstantiateObject()

{ 

string uri = &quot;file:///&quot; \+ Application.dataPath + &quot;/AssetBundles/&quot; \+ assetBundleName; 

UnityEngine.Networking.UnityWebRequest request 

= UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0); 

yield return request.Send(); 

AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request); 

GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); 

GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;); 

Instantiate(cube); 

Instantiate(sprite); 

}
</code></pre>
<h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><ol>
<li><p>一般来说，只要有可能，就应该使用AssetBundle.LoadFromFile。这个API在速度、磁盘使用和运行时内存使用方面是最有效的。</p>
</li>
<li><p>对于必须下载或热更新AssetBundles的项目，强烈建议使用UnityWebRequest。</p>
</li>
<li><p>当使用UnityWebRequest时，要确保下载程序代码在加载AssetBundle后正确地调用Dispose。另外，C#的using语句是确保UnityWebRequest被安全处理的最方便的方法。</p>
</li>
<li><p>对于需要独特的、特定的缓存或下载需求的大项目，可以考虑使用自定义的下载器。编写自定义下载程序是一项重要并且复杂的任务，任何自定义的下载程序都应该与AssetBundle.LoadFromFile保持兼容。</p>
</li>
<li><p>在多数情况下，最好在玩家进入应用程序的性能关键区域（如主游戏关卡或世界）之前加载尽可能多的所需对象。这在移动平台上尤为重要，因为在移动平台上，访问本地存储的速度很慢，并且在运行时加载和卸载对象会触发垃圾回收。</p>
</li>
</ol>
<h3 id="同步和异步的优缺点"><a href="#同步和异步的优缺点" class="headerlink" title="同步和异步的优缺点"></a>同步和异步的优缺点</h3><p>Ref: <a href="https://blog.csdn.net/qq_40093529/article/details/85290686" target="_blank" rel="noopener">https://blog.csdn.net/qq_40093529/article/details/85290686</a><br><strong>异步</strong><br>优点：速度快，与主线程无关，<br>缺点：调用比较麻烦，因为你不知道啥时候你的资源准备好了，最好的做法也是使用回调，这样回调就会很多，很乱个人感觉管理起来很不舒服。</p>
<p><strong>同步</strong><br>优点：管理起来方便，而且资源准备好了是可以及时返回的，<br>缺点：是没有异步快<br>综合上诉，最终我选择了 同步，因为我不希望代码不整洁，也不希望写太多的回调函数来通知调用者，资源准备妥当了。那么问题来了，如何解决同步的缺点呢。也就是卡主线程。之前一直以为corotine这玩意可以帮到我们。但是当我深入理解了coroutine以后发现他其实也是在主线程中的。最终我选择了使用c# 的多线程机制来解决这个问题。</p>
<h3 id="Manifests的加载"><a href="#Manifests的加载" class="headerlink" title="Manifests的加载"></a>Manifests的加载</h3><p>加载Manifests文件可以处理资源的依赖</p>
<pre><code class="lang-csharp">
AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath); 

AssetBundleManifest manifest = 

assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;); 

string[] dependencies = manifest.GetAllDependencies(&quot;assetBundle&quot;); 

//Pass the name of the bundle you want the dependencies for.

foreach(string dependency in dependencies) 

{ 

AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency)); 

}
</code></pre>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>卸载有两个方面</p>
<ol>
<li><p>减少内存使用</p>
</li>
<li><p>有可能导致丢失<br>所以什么时候去卸载资源是我们要关注的</p>
</li>
</ol>
<h3 id="AssetBundle-Unload-true"><a href="#AssetBundle-Unload-true" class="headerlink" title="AssetBundle.Unload(true)"></a>AssetBundle.Unload(true)</h3><p>不仅Object被销毁，而且Instance ID的GUID和Local ID引用变无效。<br>When unloadAllLoadedObjects is true, all objects that were loaded from this bundle will be destroyed as well. If there are GameObjects in your Scene referencing those assets, the references to them will become missing.</p>
<p>卸载所有资源，即使有资源被使用着<br>1. 在关卡切换、场景切换<br>2. 资源没被用的时候调用</p>
<h3 id="AssetBundle-Unload-false"><a href="#AssetBundle-Unload-false" class="headerlink" title="AssetBundle.Unload(false)"></a>AssetBundle.Unload(false)</h3><p>虽Object不被销毁，但Instance ID的GUID和Local ID引用变无效。场景中的物体会与该AB包分离链接。即该物体的instance ID引用的GUID和Local ID会断开引用，无法再通过该instance ID找到GUID和Local ID。<br>如果再次加载该AB包时，分离了链接的物体不会受该新加载的AB包管理。因此如果不注意的话可能会导致一些不可控的问题。Unity中有Resources.UnloadUnusedAssets()方法可以很好地解决这个问题。</p>
<p>When unloadAllLoadedObjects is false, compressed file data inside the bundle itself will be freed, but any instances of objects loaded from this bundle will remain intact.</p>
<p>If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways:</p>
<ol>
<li><p>先去除对不想要的Objects的引用（包括场景和代码当中），然后调用 Resources.UnloadUnusedAssets. </p>
</li>
<li><p>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.</p>
</li>
</ol>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>大多数项目应该使用AssetBundle.Unload(True)，并采用一种方法来确保对象不被复制。<br>两种常见的方法是：<br>（1）在应用程序的生命周期内定义一个合适的节点，并在此期间卸载不需要的AssetBundle，例如在关卡切换或加载屏幕期间。这是最简单和最常见的选择。<br>（2）维护单个对象的引用计数，并仅当所有组成对象都未使用时才卸载AssetBundles。这允许应用程序在不重复内存的情况下卸载和重新加载单个对象。</p>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="AssetDatabase"><a href="#AssetDatabase" class="headerlink" title="AssetDatabase"></a>AssetDatabase</h3><pre><code class="lang-csharp">
var names = AssetDatabase.GetAllAssetBundleNames(); 

foreach (var name in names) 

Debug.Log(&quot;AssetBundle: &quot; \+ name);
</code></pre>
<ul>
<li><p>AssetDatabase.GetAllAssetBundleNames() </p>
</li>
<li><p>AssetDatabase.GetAssetPathsFromAssetBundle </p>
</li>
<li><p>AssetDatabase.RemoveAssetBundleName()</p>
</li>
<li><p>AssetDatabase.GetUnusedAssetBundleNames() </p>
</li>
<li><p>AssetDatabase.RemoveUnusedAssetBundleNames() </p>
</li>
<li><p>The callback AssetPostProcessor.OnPostprocessAssetbundleNameChanged is called if user changes the AssetBundle name of an asset.</p>
</li>
</ul>
<h3 id="Asset-PostProcessor"><a href="#Asset-PostProcessor" class="headerlink" title="Asset PostProcessor"></a>Asset PostProcessor</h3><pre><code class="lang-csharp">
using UnityEngine; 

using UnityEditor; 

public class MyPostprocessor : AssetPostprocessor

{ 

void OnPostprocessAssetbundleNameChanged(string path,

string previous, string next)

{ 

Debug.Log(&quot;AB: &quot; \+ path + &quot; old: &quot; \+ previous + &quot; new: &quot; \+ next); 

} 

}
</code></pre>
<h2 id="AB包内部结构"><a href="#AB包内部结构" class="headerlink" title="AB包内部结构"></a>AB包内部结构</h2><p>AssetBundleFileHeader：记录了版本号、压缩等主要描述信息。</p>
<p>AssetFileHeader：包含一个文件列表，记录了每个资源的name、offset、length等信息。</p>
<p>Asset1：</p>
<p>AssetHeader：记录了TypeTree大小、文件大小、format等信息。<br>TypeTree（可选，有不要TypeTree的构建方式）：记录了Asset对象的class ID。Unity可以用class ID来序列化和反序列化一个类。（每个class对应了一个ID，如0是Object类，1是GameObject类等。具体可在Unity官网上查询。）<br>ObjectPath：记录了path ID（资源唯一索引ID）等。<br>AssetRef：记录了AB包对外部资源对引用情况。<br>Asset2…</p>
<p>.manifest文件</p>
<pre><code class="lang-csharp">
`ManifestFileVersion: 0 # 文件版本

CRC: 2657307167 # CRC校验码

Hashes: # 哈希

AssetFileHash: # AB包中所有资源的哈希，可用于增量更新检测

serializedVersion: 2 # Unity序列化版本

Hash: 717e408ba50ee41b0960161fd2d5a827

TypeTreeHash: # AB包中所有类型的哈希，可用于增量更新检测

serializedVersion: 2 # Unity序列化版本

Hash: 8d552bf2f5bdba1177c938cb98ca6f2f

HashAppended: 0

ClassTypes: # TypeTree

\- Class: 1 # GameObject

Script: {instanceID: 0}

\- Class: 21 # Material

Script: {instanceID: 0}

\- Class: 28 # Texture2D

Script: {instanceID: 0}

\- Class: 48 # Shader

Script: {instanceID: 0}

\- Class: 114 # MonoBehaviour

Script: {fileID: 1392445389, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: -765806418, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: -1200242548, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: -146154839, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 708705254, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 1297475563, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 11500000, guid: 20e8969313b8e4614b498f042e99683a, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 11500000, guid: c86dbe77db44a434bb15895563508b65, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 11500000, guid: 1a7e2f4cb82d9b94a91270d550c880c0, type: 3}

\- Class: 115 # MonoScript

Script: {instanceID: 0}

\- Class: 128 # Font

Script: {instanceID: 0}

\- Class: 198 # ParticleSystem

Script: {instanceID: 0}

\- Class: 199 # ParticleSystemRenderer

Script: {instanceID: 0}

\- Class: 213 # Sprite

Script: {instanceID: 0}

\- Class: 222 # CanvasRenderer

Script: {instanceID: 0}

\- Class: 224 # RectTransform

Script: {instanceID: 0}

\- Class: 687078895 # SpriteAtlas

Script: {instanceID: 0}

Assets: # 包含资源

- Assets/Bundle/.../a.prefab

- Assets/Bundle/.../b.prefab

- Assets/Bundle/.../c.spriteatlas

Dependencies: # AB包依赖

- /Users/apple/.../AssetBundles/Android/q

- /Users/apple/.../AssetBundles/Android/w

- /Users/apple/.../AssetBundles/Android/e

- /Users/apple/.../AssetBundles/Android/r

- /Users/apple/.../AssetBundles/Android/t`
</code></pre>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h3><p>加密思路：<br>1、在构建完AB包后，可以将AB包中的内容以byte[]形式读取。<br>2、之后选用任意加密方式对该byte[]加密。<br>3、加密完后重新写入AB包中。<br>4、AB包加密完成。</p>
<blockquote>
<p>这样对AB包加密之后，如果使用AssetBundle.LoadFromFile()来加载加密的AB包是会报错的，因为Unity以及无法识别加密过后的内容。</p>
</blockquote>
<p>解密思路：<br>1、先以byte[]形式读取AB包中的内容。<br>2、之后使用对应的解密算法对该byte[]进行解密。<br>3、解密过后的byte[]通过AssetBundle.LoadFromMemory()来进行加载。<br>4、AB包加载完成。</p>
<p>占用内存的峰值至少是他所处理的AssetBundle大小的两倍：一份由此API创建在本机内存中的副本和一份传递给此API的位于托管字节数组中的副本。通过此API从AssetBundle加载的Asset会在内存中被复制3次：在托管代码中的字节数组、本机内存中的副本以及在GPU或系统内存中的Asset本体。</p>
<h3 id="耗费小的思路-偏移量"><a href="#耗费小的思路-偏移量" class="headerlink" title="耗费小的思路-偏移量"></a>耗费小的思路-偏移量</h3><p>在构建完AB包之后，在AB包前插入N个随机byte。AssetBundle.LoadFromFile()的第三个参数是AB包内容的byte偏移量。也就是说从offset个byte开始读取AB包的内容。</p>
<blockquote>
<p>对于资源加密，我们大多数时候能做到的是防小白不防专家，不管你是采用简单的或者复杂的，在反编译高手手里都有点苍白</p>
</blockquote>
<pre><code class="lang-csharp">
public static AssetBundle LoadFromFile(string path, uint crc, ulong offset);
</code></pre>
<p>具体实现可参考：<a href="https://zhuanlan.zhihu.com/p/75964237" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75964237</a></p>
<h3 id="LoadFromStream-1"><a href="#LoadFromStream-1" class="headerlink" title="LoadFromStream"></a>LoadFromStream</h3><p><a href="https://www.xuanyusong.com/archives/4607" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4607</a></p>
<h2 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h2><p>CRC MD5 SHA1<br>相同点：<br>CRC、MD5、SHA1都是通过对数据进行计算，来生成一个校验值，该校验值用来校验数据的完整性。<br>不同点：</p>
<ol>
<li><p>算法不同。CRC采用多项式除法，MD5和SHA1使用的是替换、轮转等方法；</p>
</li>
<li><p>校验值的长度不同。CRC校验位的长度跟其多项式有关系，一般为16位或32位；MD5是16个字节（128位）；SHA1是20个字节（160位）；</p>
</li>
<li><p>校验值的称呼不同。CRC一般叫做CRC值；MD5和SHA1一般叫做哈希值（Hash）或散列值；</p>
</li>
<li><p>安全性不同。这里的安全性是指检错的能力，即数据的错误能通过校验位检测出来。CRC的安全性跟多项式有很大关系，相对于MD5和SHA1要弱很多；MD5的安全性很高，不过大概在04年的时候被山东大学的王小云破解了；SHA1的安全性最高。</p>
</li>
<li><p>效率不同，CRC的计算效率很高；MD5和SHA1比较慢。</p>
</li>
<li><p>用途不同。CRC一般用作通信数据的校验；MD5和SHA1用于安全（Security）领域，比如文件校验、数字签名等。</p>
</li>
</ol>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="和项目一起安装"><a href="#和项目一起安装" class="headerlink" title="和项目一起安装"></a>和项目一起安装</h3><ul>
<li><p>减少项目构建时间并允许更简单的迭代开发。</p>
</li>
<li><p>发布可更新内容的初始修订版。</p>
</li>
</ul>
<h3 id="安装后再下载它们"><a href="#安装后再下载它们" class="headerlink" title="安装后再下载它们"></a>安装后再下载它们</h3><p>这就允许在安装后再更新游戏内容，而不必强迫用户重新下载整个应用程序。<br>将它们放在某个Web服务器上，并通过UnityWebRequest发布。Unity将自动在本地存储上缓存下载的AssetBundles。如果下载的AssetBundle是LZMA压缩的，那么AssetBundle将以未压缩或重新压缩的形式存储在缓存中，就像LZ 4一样（依赖Caching.compressionEnabled设置），以便将来更快地加载。如果下载的包是LZ 4压缩的，AssetBundles将被压缩存储。如果缓存被填满，Unity将从缓存中删除最近使用最少的AssetBundle。</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>Unity有一个内置的AssetBundle缓存系统，可以用来缓存通过UnityWebRequest API下载的AssetBundles，该API的重载会接受一个AssetBundle版本号作为参数。这个数字不是存储在AssetBundles里的，也不是由AssetBundles系统生成的。</p>
<p>缓存系统跟踪传递给UnityWebRequest的最后一个版本号。当使用版本号调用此API时，缓存系统通过比较版本号来检查是否存在缓存的AssetBundle。如果这些数字匹配，系统将加载缓存的AssetBundle。如果数字不匹配，或者没有缓存的AssetBundle，那么Unity将下载一个新的副本。此新副本将与新的版本号相关联。</p>
<p>缓存系统中的AssetBundle只通过它们的文件名来标识，而不是通过下载它们的完整URL。这意味着具有相同文件名的AssetBundle可以存储在多个不同的位置，例如CDN。只要文件名相同，缓存系统就会将它们识别为相同的AssetBundle。</p>
<h2 id="相关优化"><a href="#相关优化" class="headerlink" title="相关优化"></a>相关优化</h2><h3 id="冗余问题"><a href="#冗余问题" class="headerlink" title="冗余问题"></a>冗余问题</h3><p>在Unity5.0后，BuildAssetBundleOptions.CollectDependencies永久开启，即Unity会自动检测物体引用的资源并且一并打包，防止资源丢失遗漏的问题出现。有些情况下，如果没指定某公共资源的存放在哪个AB包中，这个公共资源就会被自动打进引用它的AB包中，所以出现多个不同的AB包中有重复的资源存在的现象。这就是资源冗余。</p>
<p>a. 把需要共享的资源打包到一起<br>b. 分割包，这些包不是在同一时间使用的<br>c. 把共享部分打包成一个单独的包</p>
<h3 id="图集重复问题"><a href="#图集重复问题" class="headerlink" title="图集重复问题"></a>图集重复问题</h3><p>在Unity当中，Sprite2D会被打包到一个图集当中（由Packing Tag决定）。如果不指定PackingTag，Sprite会打包到同一个图集当中。一个Sprite打包到AssetBundle中时，它所在的整个图集都会被打包进去。<br>解决方法：确保同一个图集当中的图片打包到同一个AssetBundle当中去。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li><p>Android贴图问题</p>
</li>
<li><p>iOS文件处理重复fixed in Unity 5.3.2p2.</p>
</li>
</ul>
<h2 id="UnityAssetBundleBrowserTool"><a href="#UnityAssetBundleBrowserTool" class="headerlink" title="UnityAssetBundleBrowserTool"></a>UnityAssetBundleBrowserTool</h2><h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><p>Build的时候，该文件夹下的所有东西会被原封不动地打包到我们的安装包当中。<br>一般放一些二进制文件、 AssetBundles。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://segmentfault.com/a/1190000038943912" target="_blank" rel="noopener">https://segmentfault.com/a/1190000038943912</a><br><a href="https://blog.uwa4d.com/archives/USparkle_Addressable3.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/USparkle_Addressable3.html</a></p>
<p><a href="https://learn.unity.com/tutorial/assets-resources-and-assetbundles" target="_blank" rel="noopener">https://learn.unity.com/tutorial/assets-resources-and-assetbundles</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【疑难问题处理】异常捕获与处理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E3%80%91%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86/"
    >【疑难问题处理】异常捕获与处理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E3%80%91%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2023-07-20T15:00:27.900Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a href="https://github.com/Prin-PY/Unity-Excpetion-Crash" target="_blank" rel="noopener">https://github.com/Prin-PY/Unity-Excpetion-Crash</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【动画】Unity动画系统"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90%E5%8A%A8%E7%94%BB%E3%80%91Unity%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"
    >【动画】Unity动画系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90%E5%8A%A8%E7%94%BB%E3%80%91Unity%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2023-07-20T15:00:27.890Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Animation-System-Overview"><a href="#Animation-System-Overview" class="headerlink" title="Animation System Overview"></a>Animation System Overview</h2><h3 id="Animation-Type"><a href="#Animation-Type" class="headerlink" title="Animation Type"></a>Animation Type</h3><h4 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h4><p>The Root node allows Unity to establish consistency between Animation clips for a generic model.</p>
<h4 id="Humanoid"><a href="#Humanoid" class="headerlink" title="Humanoid"></a>Humanoid</h4><p>With rare exceptions, humanoid models have the same basic structure. This structure represents the major articulated parts of the body: the head and limbs. The first step to using Unity’s Humanoid animation features is to set up and configure an Avatar. Unity uses the Avatar to map the simplified humanoid bone structure to the actual bones present in the Model’s skeleton.</p>
<h4 id="Legacy-Animation-System"><a href="#Legacy-Animation-System" class="headerlink" title="Legacy Animation System"></a>Legacy Animation System</h4><p>Our legacy animation system is only included for backward compatibility with old projects, and it has a very limited feature set compared with our current animation system. The only reason you should use it is for legacy projects built using the old system.</p>
<h4 id="pros-and-cons"><a href="#pros-and-cons" class="headerlink" title="pros and cons"></a>pros and cons</h4><ul>
<li><p>Humanoid allows for retargeting animations on all humanoid type characters. Mecanim allows a better integration of humanoid avatars.</p>
</li>
<li><p>Generic allows for characters that aren’t humanoid and doesn’t match the humanoid mecanim structure.</p>
</li>
</ul>
<p>Humanoid requires you to have only 2 spine bones. Generic doesn’t have that restriction.</p>
<hr>
<p>The Humanoid system is used for animating human body types. This can mean humans, robots, upright animals, or whatever else you can think of that looks like a human. In any case, for this type of animation, it is best to create the animations in a separate modelling program, and then import them to Unity. If the model is correctly rigged, everything should import very smoothly.</p>
<p>The Generic system is very simple. It is used for any type of animation that is not humanoid. You can use it to open a door, fire a gun, etc.. For this type of animation, it is probably easier to use the animation editor that Unity provides to make your animations.</p>
<hr>
<p>Humanoid与Generic是不太可能完全相同的。Humanoid模式其本质是让通过Unity引擎自己的Avatar模板来驱动的，这个模板仅有30~35根骨骼（具体数字忘记了），而一般3D Max做出来的模型，其骨骼是很难与之一一对应，比如你上图中的手骨，其在3D Max中很可能是有动画的，而在Humanoid中主要还是映射过去计算的。这样就存在了部分骨骼之间的骨骼位置不一致，从而导致了Skinning后的结果也会不一致。</p>
<p>Humanoid模式使用的精髓还在于Retargeting，而这一点就基本上决定了不可能与原始动画完全一致，如果想要完全一致，Unity提供了另一种模式：Generic。<br><a href="https://answer.uwa4d.com/question/5a38b5775f86da7f0e37863d" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a38b5775f86da7f0e37863d</a></p>
<hr>
<blockquote>
<p>Legacy is outdated and probably going to be phased out. So there are no pros with it.</p>
</blockquote>
<h4 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h4><pre><code class="lang-csharp">
Generic vs Humanoid，Generic的耗时约为Humanoid的60%。但是Humanoid在运行中内存占用、文件大小和加载效率都会比Generic要小。追求性能的话可转换为Generic，不常用的模型可将格式设置为Humanoid，这样两者兼顾。
</code></pre>
<p>作者： <em>ArayA</em><br>链接：<a href="https://www.jianshu.com/p/6fc0332357e8" target="_blank" rel="noopener">https://www.jianshu.com/p/6fc0332357e8</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="关于-“Mecanim-动画系统”"><a href="#关于-“Mecanim-动画系统”" class="headerlink" title="关于 “Mecanim 动画系统”"></a>关于 “Mecanim 动画系统”</h3><p>Mecanim integrated humanoid animation retargeting, muscle control, and the state machine system.<br>Mecanim 并没有清楚的定义与边界。<br>“Mecanim” has now simply come to mean our main animation system.<br>Unity的Mecanim动画系统，是一套基于状态机的动画控制系统，是一个面向动画应用的动画系统。</p>
<blockquote>
<p>Mecanim operated only with humanoid characters, our legacy animation system was still required for animating non-humanoid characters and other keyframe-based animation of gameobjects within Unity.</p>
</blockquote>
<h2 id="角色模型动画Workflow"><a href="#角色模型动画Workflow" class="headerlink" title="角色模型动画Workflow"></a>角色模型动画Workflow</h2><p>1.通过建模软件创建角色模型网格（涉及建模软件的使用）<br>2.针对角色姿态，以及动画布置，创建角色骨骼<br>3.进行骨骼的蒙皮，将网格和角色网格绑定起来（顶点权重调整）<br>4.利用绑定好骨骼的角色制作动画，导出资源<br>5.Unity提取资源文件中的人物模型，提取动画切片（Clip）<br>6.通过Mecanim动画系统进行编辑，创建动画状态，动画的融合、过渡调整，设定过渡条件，结合脚本控制，将动画应用到游戏开发中</p>
<blockquote>
<p>需要我们在网格建立的时候考虑应用动画是对于网格的拉伸，扭曲，需要有好的拓扑结构<br> 在创建骨骼时，要符合15块骨骼为基准的骨骼结构<br> 对于蒙皮，可能要结合需要被应用的动画资源，或是对于目前已制作出的动画效果，对权重进行反复的调整<br> Unity无法解析physique蒙皮，因此我们必须使用Skin进行网格的蒙皮</p>
</blockquote>
<h2 id="ImportSettings操作"><a href="#ImportSettings操作" class="headerlink" title="ImportSettings操作"></a>ImportSettings操作</h2><p>ImportSettings影响的是对AnimationClip的导入，导入之后，曲线就只能手动编辑关键帧了，所以，影响到整体曲线形成方式的操作都在ImportSettings当中设置。</p>
<p>Loop Pose：Enable to make animation loop seamlessly. （使动画首尾姿态尽量无缝衔接，避免出现突变。实质上就是动画末尾到开头的过渡效果。）</p>
<p>Bake Into Pose：将角色对应属性的变换植入到身体（Pose）的运动中，让根节点对应属性的运动不发生改变。勾选Bake Into Pose，将消除根节点对应的运动属性，在切片播放时，角色对应的旋转/位移，将不会被植入到Unity中。</p>
<h3 id="ApplyRootMotion"><a href="#ApplyRootMotion" class="headerlink" title="ApplyRootMotion"></a>ApplyRootMotion</h3><p>动画的运动包括根节点的运行（RootMotion）和各个骨骼节点相对于根节点的运动。其根节点（Root）默认为Animator所在的物体。</p>
<p>动画导入后，如果不Bake，运动分为Root的运动和子节点骨骼的运动两部分。</p>
<ul>
<li><p>在播放动画时，不ApplyRootMotion，则不会进行根节点的运动，也就是只看到人物各个骨骼在相对于根节点做动作，而人物整体不运动。例如对于奔跑的动作，如果人物的位移与旋转是由根节点的位移与旋转实现的，播放时，人的手和脚在摆动，而位置不变。</p>
</li>
<li><p>播放动画时，勾选了ApplyRootMotion，则会将动画资源中Root的运动数据应用到根节点上，根节点会进行相应的位移和旋转。而RootMotion执行的是相对于初始位置的运动，因此奔跑的动作循环播放会导致人物一直前进。</p>
</li>
</ul>
<p>如果Bake，则会将RootMotion运动的信息烘焙到各个骨骼点上 ，导入的动画就没有Root节点运动的信息，无论是否ApplyRootMotion，角色的根节点的transform都不会改变，而骨骼节点执行的是相对于根节点的运动，并且是原先根节点运动(前进转身等)运动与骨骼节点运动（摆手臂等）的叠加。</p>
<p>总之RootMotion记录的是根节点相对于动画初始transform的运动。如果Bake，就将整体运动信息烘焙到骨骼上，根节点不动，动画循环播放，每次会从原位置开始运动。如果不Bake，不ApplyRootMotion，动画只有骨骼节点的运动， 没有整体的运动。如果ApplyRootMotion，就会将根节点的整体运动执行，每次开始播放动画，都相对于当前动画的位置运动。</p>
<h4 id="自定义RootMotionNode"><a href="#自定义RootMotionNode" class="headerlink" title="自定义RootMotionNode"></a>自定义RootMotionNode</h4><p>在ImportSettings中可以设置RootMotionNode：</p>
<p><img src="【动画】Unity动画系统/1615977607114.png" alt="Alt text"></p>
<p>如果设置了RootMotionNode，则会进行Bake，以所选节点为Root，将运动信息烘焙到子节点上，运行时，依然看到根节点transform是不变的，但是角色会前进一段后回到原位置。</p>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>如果不进行Bake，并且ApplyRootMotion的话，每一帧都需要更新根节点的位置，并在此基础上确定各个骨骼的位置，会有一定的开销。<br>如果ApplyRootMotion勾选，Unity每帧都会在ApplyOnAnimatorMove函数中调用ApplyBuiltinRootMotion。</p>
<p><img src="【动画】Unity动画系统/1615977339562.png" alt="Alt text"></p>
<p>如果不勾选，则不会调用：</p>
<p><img src="【动画】Unity动画系统/1615977392724.png" alt="Alt text"></p>
<h3 id="动画剪辑"><a href="#动画剪辑" class="headerlink" title="动画剪辑"></a>动画剪辑</h3><p>通过Clips下方的加号来新建AnimationClip，在下方可以更改AnimationClip的名字，在Length条上可以对动画进行裁剪。</p>
<p><img src="【动画】Unity动画系统/1615984365722.png" alt="Alt text"></p>
<p>剪辑时，下方将会显示出曲线图。通过红色/黄色/绿色，来标记剪切出的剪辑中，角色的某种姿态属性是否能够构成循环。（绿色可以，红色不可以，黄色取中间值）。<br>裁剪的结果是否能循环体现在Bake选项后的红色提示灯上，用于在Bake时参考：</p>
<p><img src="【动画】Unity动画系统/1615984621432.png" alt="Alt text"></p>
<p>由于Bake后Root是不动的，动画会循环播放，因此，绿色状态下才建议开发者进行Bake。如果是红色状态 ，Bake后动画的播放就会不连续。</p>
<h3 id="其它参数"><a href="#其它参数" class="headerlink" title="其它参数"></a>其它参数</h3><p>Cycle Offset：应是一个0到1之间的数值，否则无效，可以设定循环时起始播放位置的偏移</p>
<p>Base Upon：对应属性的改变要以什么为参照（通常保持默认即可）<br>—original 引用FBX文件中原先的位置，方位坐标，并以此为参照，通常对Y轴启用，对Rotation启用可能导致人物初始朝向不是Z轴正方向，对XZ平面启用可能导致人物不在原点位置<br>—Body Orientation 按身体的朝向变化为参照，通常对Rotation启用<br>—Center Of Mass 按身体重心位置为参照，选定时，身体重心位置会被至于原点，通常不对Y轴启用，而对XY平面启用<br>—feet 按脚底的Y轴高度为参照（Y轴高度的另一个参照）</p>
<p>Mirror：左右镜像翻转动画，可以节省动画师的工作量</p>
<h2 id="Animator组件的属性"><a href="#Animator组件的属性" class="headerlink" title="Animator组件的属性"></a>Animator组件的属性</h2><p>Controller：状态机的配置资源文件，整合Clip资源，创建状态机状态（State），设置动画 <strong>过渡</strong> 与 <strong>融合</strong> 。</p>
<p>Avatar：动画节点导引替身，与动画复用（尤其是人形动画复用）有关，通过配置和应用Avatar，可以实现不同FBX模型之间的动画复用</p>
<p>Update Mode：状态机播放动画的时间模式。</p>
<p><img src="【动画】Unity动画系统/1615987896583.png" alt="Alt text"></p>
<p>Normal：使用游戏Upadte的更新模式<br>Animate Physics：使用物理周期的更新模式（使用Unity中的物理系统实现位移，角色需要与场景中的物体进行物理交互）<br>Unscaled Time：不受TimeScale影响的更新模式（通常应用于GUI界面的动画）</p>
<p>Culling Mode：剔除模式</p>
<p>Always Animate：无论物体是否被摄像机可见，总是计算所有节点的运动，完整的进行动画播放<br>Cull Update Transforms：当物体不被摄像机可见时，仅计算根节点的位移植入，保证物体位置上的正确<br>Cull Completely：当物体不被摄像机可见时，完全终止动画的运行</p>
<h2 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h2><h3 id="Sub-State-Machine"><a href="#Sub-State-Machine" class="headerlink" title="Sub-State Machine"></a>Sub-State Machine</h3><p>创建一个子动画组。创建的指向动画组的过渡，当过渡触发时，就会来到该动画组的Entry，并进入该动画组的初始状态。</p>
<p>指向Exit的过渡 - 当触发时，就会返回上一层的Entry并进入上一层的初始状态。</p>
<p><img src="【动画】Unity动画系统/1615988240440.png" alt="Alt text"></p>
<h3 id="Blend-Tree"><a href="#Blend-Tree" class="headerlink" title="Blend Tree"></a>Blend Tree</h3><p>动画融合树</p>
<h3 id="动画过渡"><a href="#动画过渡" class="headerlink" title="动画过渡"></a>动画过渡</h3><p><strong>Has Exit Time</strong> ：勾选时上一个状态对于的动画片段必须被播放到末尾，才允许这个过渡被触发，不勾选可以在任意时刻进行过渡</p>
<p><strong>Eixt Time</strong> ：CurrentState所对应的动画片段，开始进行过渡融合的位置对起始位置的偏移（百分比）<br><strong>Transition Duration(s)</strong> ：过渡融合的区间长度（百分比或秒）<br><strong>Transition Offset</strong> ：过渡：NextState动画，进行过渡融合对应起始位置的偏移（百分比）</p>
<p><strong>Fixed Duration</strong> ：过渡区间的计算方式（决定Transition Duration的单位），不勾选按照对CurrentState动画的相对百分比长度计算，勾选按照恒定的秒时长计算</p>
<p><strong>Interruption Source</strong> ：打断来源，允许该过渡被来自CurrentState或NextState的其它过渡打断<br>被CurrentState打断则发生了“跳转”，NextState的指向被改变（例如受击打断了攻击）<br>被NextState打断则发生了“跃进”，动画迅速的完成了两个状态的过渡（例如从站立状态快速过渡到冲刺斩，奔跑状态被越过）</p>
<p><strong>合理的运用打断，实现快节奏的状态切换，是制作动作游戏的基础</strong></p>
<p>Ordered Interruption：针对CurrentState出发的过渡，是否只允许比当前过渡优先级高的过渡打断该过渡</p>
<h3 id="State配置"><a href="#State配置" class="headerlink" title="State配置"></a>State配置</h3><p>Motion：这个State所引用的动画片段</p>
<p>Speed：动画片段的播放速度（置为-1可倒放动画）</p>
<p>Multiplier：Speed的一个倍率因子，需要勾选Parameter，可选定一个浮点动画参数来动态控制这个因子</p>
<p>Normalized Time：片段播放位置，0到1之间浮点，需要一个被控制的浮点动画参数来作为输出映射，从而我们可以在脚本中获取这个片段的播放进度（Normallize Time * 片段帧长度，可以得到当前片段播放到第几帧）</p>
<p>Mirror：是否进行左右翻转，可以勾选要Parameter，可选定一个布尔动画参数来动态控制</p>
<p>Cycle Offset：偏移量（和之前Clip中的偏移相同），0到1之间的浮点值，可勾选Parameter选定一个浮点动画参数来动态控制</p>
<p>Foot IK：脚部的IK反向力学修正，针对人物上坡，上楼梯时的踏空而行进行修正</p>
<p>Write Default：初始化属性，如果一个Clip对于角色某个节点的某个属性完全不涉及，那么播放该Clip时，对于不涉及的属性值，是要置为初始状态，还是置为其它Clip末尾时对该值的修改结果。勾选则置为0帧初状态，不勾选则应用之前播放的Clip对其修改的结果</p>
<p>Write Default主要是针对人物骨骼之外的一些节点，例如武器，跟随物，这些节点只在部分互动动作之中被用到，那些没有使用该节点的动作执行时，是要让节点处于初始状态，还是上一次互动动作末尾时的状态</p>
<h2 id="Animator-Override-Controller"><a href="#Animator-Override-Controller" class="headerlink" title="Animator Override Controller"></a>Animator Override Controller</h2><p>Animator Override Controller 也是一种Controller状态机配置资源文件，它可以继承一种指定的Animator Controller，并在此基础上进行修改，从而在复用Controller的同时，做出针对性的修改。<br>Override Controller与AnimationController作用相同，只是可以替换AnimationClip的取值。</p>
<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>AnimationState面板上可以添加StateMachineBehaviour类Script，通过Override相关函数响应相关事件。</p>
<p><img src="【动画】Unity动画系统/1615987356620.png" alt="Alt text"></p>
<p><img src="【动画】Unity动画系统/1615987405918.png" alt="Alt text"></p>
<p>AnimationClip编辑时，可在关键帧添加AnimationEvent。</p>
<p><img src="【动画】Unity动画系统/1615987432960.png" alt="Alt text"></p>
<p>关键帧触发事件时，调用AnimationClip所在物体上的脚本中的同名函数。</p>
<p><img src="【动画】Unity动画系统/1615987484236.png" alt="Alt text"></p>
<h3 id="Mono—-gt-SMB的通信"><a href="#Mono—-gt-SMB的通信" class="headerlink" title="Mono—&gt;SMB的通信"></a>Mono—&gt;SMB的通信</h3><ol>
<li>拖动赋值 —— 序列化的方法</li>
</ol>
<p><img src="【动画】Unity动画系统/1615989784924.png" alt="Alt text"></p>
<ol>
<li>API</li>
</ol>
<pre><code class="lang-csharp">
//Awake OR Start

var smb = animator.GetBehaviour&lt;StateMechine&gt;(); 

//这里会是从父动画组到子动画组以及其中包含的State，这个遍历顺序下，遇到的第一个StateMechine

var smbS = animator.GetBehaviours&lt;StateMechine&gt;(); 

//返回一个数组包含Controller中所有的StateMechine
</code></pre>
<h3 id="SMB—-gt-Mono的通信"><a href="#SMB—-gt-Mono的通信" class="headerlink" title="SMB—&gt;Mono的通信"></a>SMB—&gt;Mono的通信</h3><ol>
<li><p>依然是序列化方法，同样需要用到两个Inspector窗口</p>
</li>
<li><p>在Mono中获取到该SMB，之后在Mono的Awake/Start对SMB中的Mono挂点进行赋值（逆向设置）</p>
</li>
</ol>
<h2 id="Avatar相关"><a href="#Avatar相关" class="headerlink" title="Avatar相关"></a>Avatar相关</h2><p>Avatar能够复用的条件是，生成源Avatar的FBX模型中的骨骼层级结构及名称与当前FBX相同</p>
<p><img src="【动画】Unity动画系统/1615989156276.png" alt="Alt text"></p>
<p>复用方式：Avatar的存在主要是为了解决人物动画的复用问题，不同来源的FBX中，对于骨骼节点的层级结构，以及命名可能不尽相同，因此Unity以Avatar作为一个中介，不同的FBX都对Avatar中的标准人物骨骼结构去创建映射关系。在Animator状态机进行动画控制时，依照人物模型创建的Avatar，将人物动画片段对标准人物骨骼中的节点控制，映射到当前的人物模型当中，从而就实现了对不同来源FBX中，人物动画的复用。</p>
<h2 id="一些API"><a href="#一些API" class="headerlink" title="一些API"></a>一些API</h2><pre><code class="lang-csharp">
animator.GetFloat(blendHash); 

animator.SetFloat(blendHash, Input.GetAxis(&quot;Horizontal&quot;)); 

int layerID = animator.GetLayerIndex(&quot;Base Layer&quot;); 

animatorStateInfo = animator.GetCurrentAnimatorStateInfo(layerID); 

animatorStateInfo = animator.GetNextAnimatorStateInfo(layerID); 

transitionInfo = animator.GetAnimatorTransitionInfo(layerID); 

int idleHash = Animator.StringToHash(&quot;Idle&quot;); 

int layerID = animator.GetLayerIndex(&quot;Base Layer&quot;); 

animatorStateInfo = animator.GetCurrentAnimatorStateInfo(layerID); 

if (animatorStateInfo.shortNameHash == idleHash)//判定当前状态是否是Idle状态

{ 

Debug.Log(&quot;OnState Idle&quot;); 

} 

int flyHash = Animator.StringToHash(&quot;Base Layer.FlyMechine.Fly&quot;); 

animatorStateInfo = animator.GetCurrentAnimatorStateInfo(0); 

if (animatorStateInfo.fullPathHash == flyHash) 

{ 

Debug.Log(&quot;OnState Fly&quot;); 

} 

int tagHash = Animator.StringToHash(&quot;tagName&quot;); 

if(animatorStateInfo.tagHash==tagHash){ 

//do something

}
</code></pre>
<h2 id="动画系统性能"><a href="#动画系统性能" class="headerlink" title="动画系统性能"></a>动画系统性能</h2><p><strong>Mesh</strong> 面片数对Camera.Render的影响最大，而对其他Animator.Update、MeshSkinning.Update几乎没有影响。<br><strong>骨骼数量</strong> 增多时则主要影响Animator.Update，MeshSkinning.Update</p>
<p>当我们打开多线程渲染 <strong>Multithread Rendering</strong> 后，会开启Render Thread。然后主线程Camera.Render的耗时则会大幅下降，并且之前开销越大，则下降幅度越明显。</p>
<p>而打开 <strong>Optimize Game Objects</strong> 选项后，Animator.Update，MeshSkinning.Update的耗时则会大幅下降</p>
<p>当开启 <strong>Apply Root Motion</strong> 后，主线程中Animator.Update函数开销会增加很多，主要增加开销的函数是ApplyBuiltinRootMotion。有没有办法优化这块呢，答案是肯定的。只要勾选上Optimize Game Objects，这个函数的大部分计算就会放到子线程Worker Thread中去运算了。所以当你要用到Apply Root Motion时，记得一定要开启Optimize Game Objects。</p>
<p>推荐大家使用Optimal来进行动画压缩。</p>
<h3 id="多角色场景解决方案"><a href="#多角色场景解决方案" class="headerlink" title="多角色场景解决方案"></a>多角色场景解决方案</h3><h4 id="Bake-Mesh"><a href="#Bake-Mesh" class="headerlink" title="Bake Mesh"></a>Bake Mesh</h4><p>利用SkinnedMeshRender.BakeMesh来对场景中同种模型角色进行烘焙，将蒙皮网格SkinnedMesh转换成普通Mesh。根据所要播放的动画及播放时间可以在网格中获取对应的网格数据从而进行渲染。<br>使用Bake Mesh的优点是能大幅降低CPU的开销，但是同时也会增加运行时的内存占用，具体的内存占用跟Mesh的面片数和动画片段长度成正比，因此在使用此方案时要特别注意降低Mesh的面片数和动画片段。</p>
<h4 id="GPU-Skinning"><a href="#GPU-Skinning" class="headerlink" title="GPU Skinning"></a>GPU Skinning</h4><p>Skinning过程转移到GPU中</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.jianshu.com/p/6fc0332357e8" target="_blank" rel="noopener">https://www.jianshu.com/p/6fc0332357e8</a><br><a href="https://zhuanlan.zhihu.com/p/105029905" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105029905</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【动画】Animator-ApplyRootMotion"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90%E5%8A%A8%E7%94%BB%E3%80%91Animator-ApplyRootMotion/"
    >【动画】Animator &amp; ApplyRootMotion</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90%E5%8A%A8%E7%94%BB%E3%80%91Animator-ApplyRootMotion/" class="article-date">
  <time datetime="2023-07-20T15:00:27.888Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【内存】内存底层深入"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91%E5%86%85%E5%AD%98%E5%BA%95%E5%B1%82%E6%B7%B1%E5%85%A5/"
    >【内存】内存底层深入</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91%E5%86%85%E5%AD%98%E5%BA%95%E5%B1%82%E6%B7%B1%E5%85%A5/" class="article-date">
  <time datetime="2023-07-20T15:00:27.878Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="物理内存的访问"><a href="#物理内存的访问" class="headerlink" title="物理内存的访问"></a>物理内存的访问</h3><p>CPU访问内存是一个慢速过程。<br>访问过程：先访问Cache，Cache包含L1，L2，L3，也就是一级缓存，二级缓存和三级缓存，若在这些缓存里全没找到我们要的数据，再去访问内存，接着会把找到的数据存放到Cache中，完成一次操作。</p>
<p>过多的Cache Miss就会导致大量的内存和Cache的IO交换，浪费大量时间。</p>
<blockquote>
<p>Unity ECS方案: 可以将存储在内存中的不连续数据，变为连续的数据，从而降低Cache Miss的概率。</p>
</blockquote>
<h3 id="台式设备和移动设备内存架构差异"><a href="#台式设备和移动设备内存架构差异" class="headerlink" title="台式设备和移动设备内存架构差异"></a>台式设备和移动设备内存架构差异</h3><ul>
<li><p>移动设备 <strong>没有独立显卡</strong> 。</p>
</li>
<li><p>移动设备 <strong>没有独立显存</strong> ，内存和显存是同一块内存。</p>
</li>
</ul>
<blockquote>
<p>所以有可能我们游戏占用的内存并不大，但是依旧爆内存了，其实是因为显存分配不出来了。这种情况，我们可以去查看一下Log，例如Android会有一个 OpenGL Error：Out Of Memory。</p>
</blockquote>
<ul>
<li>移动设备的CPU面积更小，因此会导致 <strong>缓存级数更少</strong> ，大小也更小，例如一般的台式机三级缓存可能有8-16M，而移动设备则只有2M左右。</li>
</ul>
<h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>内存分页（IOS上大部分为16K/page）是内存管理的最小单位，当Unity需要申请内存的时候，都会以block的方式（若干个页）进行申请。如果某一页在若干次GC（IOS为8次）之后仍然为Empty的话，它就会被释放，实际的物理内存就会被还给物理内存。</p>
<h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/370467923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/370467923</a><br><a href="https://zhuanlan.zhihu.com/p/362941227" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/362941227</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【内存】Unity内存组成"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91Unity%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90/"
    >【内存】Unity内存组成</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91Unity%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90/" class="article-date">
  <time datetime="2023-07-20T15:00:27.854Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><p>Ref: <a href="https://blog.csdn.net/greedylin/article/details/103711555" target="_blank" rel="noopener">https://blog.csdn.net/greedylin/article/details/103711555</a><br>物理内存</p>
<h3 id="1-1-Cache"><a href="#1-1-Cache" class="headerlink" title="1.1 Cache"></a>1.1 Cache</h3><p>CPU访问内存是一个慢速过程，因此会使用cache来加速访问，CPU如果在Cache中没有找到数据，称为一次Cache Missing，如果内存数据 指令是不连续的，会导致大量的Cache Missing</p>
<p>Unity的ECS和DOTS的目的之一就是提高内存的连续性，减少Cache Missing</p>
<blockquote>
<p>台式设备与移动设备的内存架构差异很大<br> CPU板上面积更小，缓存级数更少，大小也更小，例如一台台式机，L3的大小为8-16M,而移动的CPU,例如骁龙845，只有2M，Cache Missing的概率更大</p>
</blockquote>
<h3 id="1-2-显存"><a href="#1-2-显存" class="headerlink" title="1.2 显存"></a>1.2 显存</h3><p>移动设备没有独立显卡以及显存，有的时候，你的内存使用并不大，但还是会内存溢出，例如在Android上，可以看一下有没有OpenGL的out of memory的log，这意味这显存使用太大了</p>
<h3 id="1-3-虚拟内存"><a href="#1-3-虚拟内存" class="headerlink" title="1.3 虚拟内存"></a>1.3 虚拟内存</h3><ol>
<li><p>内存交换<br><strong>移动设备不支持内存交换</strong> （注：就是把部分物理内存中的数据保存在硬盘上）<br>谷歌的解释是移动设备和台式设备的IO <strong>速度</strong> 是不一样的，因此移动设备在做内存交换的时候会耗费大量的时间在IO上，并且移动设备的存储介质的 <strong>可擦写次数</strong> 和台式设备差距也很大</p>
</li>
<li><p>iOS可以进行内存压缩<br>把不活跃的内存压缩起来，放在特定的内存空间中，以节约物理内存，所以在iOS上可以看到有的时候实际使用的内存比物理内存大很多</p>
</li>
</ol>
<h3 id="1-4-内存寻址范围"><a href="#1-4-内存寻址范围" class="headerlink" title="1.4 内存寻址范围"></a>1.4 内存寻址范围</h3><p>32位CPU和64位CPU<br>严格来说，它们的寻址范围是无法确定谁高谁低的，CPU的位数指的是运算位数，不是MCU位数，只是目前大部分是对应的，即32位CPU对应32位的寻址范围，64位CPU对应64位的寻址范围</p>
<h3 id="1-5-栈内存"><a href="#1-5-栈内存" class="headerlink" title="1.5 栈内存"></a>1.5 栈内存</h3><p>主要存储小而短的数据。主要是一些值类型得数据，分配和回收很简单，快捷。</p>
<h3 id="1-6-堆内存"><a href="#1-6-堆内存" class="headerlink" title="1.6 堆内存"></a>1.6 堆内存</h3><p>主要存储大而时间长的数据，主要是引用类型数据。</p>
<h4 id="堆内存分配步骤："><a href="#堆内存分配步骤：" class="headerlink" title="堆内存分配步骤："></a>堆内存分配步骤：</h4><ol>
<li><p>检查堆中分配单元是否足够，如果充足则直接分配，如果不够则执行b步骤。</p>
</li>
<li><p>检测到堆内存不足则出发gc释放内存（耗时），再次检查堆中分配单元是否足够，如果充足则直接分配，如果不够则执行c步骤。</p>
</li>
<li><p>扩大堆内存大小（非常耗时），再来分配内存。</p>
</li>
</ol>
<h4 id="堆内存回收方式有三种："><a href="#堆内存回收方式有三种：" class="headerlink" title="堆内存回收方式有三种："></a>堆内存回收方式有三种：</h4><ol>
<li><p>系统定期自动回收。</p>
</li>
<li><p>分配内存不足时触发内存回收。</p>
</li>
<li><p>我们自己手动触发回收（执行：System.GC.Collect()）。</p>
</li>
</ol>
<h3 id="其他术语"><a href="#其他术语" class="headerlink" title="其他术语"></a>其他术语</h3><p>OOM - Out Of Memory</p>
<h2 id="2-硬件设备"><a href="#2-硬件设备" class="headerlink" title="2 硬件设备"></a>2 硬件设备</h2><h3 id="2-1-显存"><a href="#2-1-显存" class="headerlink" title="2.1 显存"></a>2.1 显存</h3><p>显存，也被叫做帧缓存，它的作用是用来存储显卡芯片处理过或者即将提取的渲染数据。如同计算机的内存一样，显存是用来存储要处理的图形信息的部件。</p>
<p>PC上，显存是显卡上的一部分，是一块独立的存储设备。<br>移动设备上，内存与显存在硬件层面上是一体的，在软件层面上，将内存中的一部分划分出来作为显存。</p>
<h4 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h4><p>显卡是主板上一个BGA封装的chipset，类似于CPU（Central Processing Unit），业内叫GPU(Graphics Processing Unit），市场上主要有nVIDIA和AMD两个厂商。图形芯片相当于显卡的CPU，不过它的主要任务是处理显示信息，在处理信息的过程中，它会产生大量的临时数据（未处理的、正在处理的、已经处理完成的），这就需要一个专门的地方来存放这些临时数据，那就是显存了，它也可能是一个芯片，也可能只是芯片的一部分，这要看硬件的设计（独立显卡和集成显卡）。</p>
<p>显卡的工作原理是：在显卡开始工作(图形渲染建模)前，通常是把所需要的材质和纹理数据传送到显存里面。开始工作时候(进行建模渲染)，这些数据通过AGP总线进行传输，显示芯片将通过AGP总线提取存储在显存里面的数据，除了建模渲染数据外还有大量的顶点数据和工作指令流需要进行交换，这些数据通过RAMDAC转换为模拟信号输出到显示端，最终就是我们看见的图像。</p>
<h2 id="3-Unity内存"><a href="#3-Unity内存" class="headerlink" title="3 Unity内存"></a>3 Unity内存</h2><h3 id="3-1-U3D开发使用的三种内存"><a href="#3-1-U3D开发使用的三种内存" class="headerlink" title="3.1 U3D开发使用的三种内存"></a>3.1 U3D开发使用的三种内存</h3><p>Ref: <a href="https://gameinstitute.qq.com/community/detail/103695" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/103695</a><br>实际上，Unity3D游戏开发使用的内存一共有三种：程序代码、托管堆(Managed Heap)以及本机堆(Native Heap)。</p>
<p><img src="【内存】Unity内存组成/游戏运行内存.png" alt="Alt text"></p>
<h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><p>包括了所有的Unity3D游戏开发 <strong>引擎</strong> ，使用的 <strong>库</strong> ，以及你所写的所有的 <strong>游戏代码</strong> 。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity3D游戏开发默认场景， <em>什么代码都不放</em> ，在 <em>iOS设备</em> 上占用内存应该在 <em>17MB</em> 左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。</p>
<blockquote>
<p>Editor和Runtime是完全不同的，不仅是内存大小不同，分配时机，方式都不同，例如一个asset，在Runtime下，不主动load，不会进内存，Editor下，只要打开Unity，就可能会加载进内存，这种策略是为了保证编辑时的流畅，这种策略也导致首次打开Unity项目耗时特别长，会转换资源，再load相关资源，在2019.3中有了新的策略，按需导入和加载</p>
</blockquote>
<h4 id="托管堆-Managed-Heap-Mono堆内存"><a href="#托管堆-Managed-Heap-Mono堆内存" class="headerlink" title="托管堆(Managed Heap)(Mono堆内存)"></a>托管堆(Managed Heap)(Mono堆内存)</h4><p>是被Mono使用的一部分内存。Mono是一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例(比如用new生成的列表，实例中的各种声明的变量等)。</p>
<p>“ <strong>托管</strong> ”的意思是Mono“应该” <strong>自动地改变堆的大小来适应你所需要的内存</strong> ，并且定时地使用垃圾回收(Garbage Collect)来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收，这就是内存泄露。</p>
<p>ManagedHeap的内存值是由所写的C#代码来引起并造成的, 与GameObject数量、资源量无关。</p>
<p>同时，Managedheap的大小完全是由Mono来决定的，用户所写的任何脚本均是由Mono来负责解析。 <strong>Mono的堆内存</strong> 是 <strong>只升不降</strong> 的，这是Mono的一个问题，Unity暂时也无法对其进行修改。因此，只能建议开发者在编写代码时尽可能地优化代码，避免不需要的堆内存分配。其原理如下：</p>
<blockquote>
<p>在Unity环境下， <strong>Mono堆内存的占用，是只会增加不会减少的</strong> 。具体来说，可以将Mono堆，理解为一个内存池，每次Mono内存的申请，都会在池内进行分配；释放的时候，也是归还给池，而不会归还给操作系统。如果某次分配，发现池内内存不够了，则会对池进行扩建——向操作系统申请更多的内存扩大池以满足该次的内存分配。需要注意的是，每次对池的扩建，都是一次较大的内存分配，每次扩建，都会将池扩大6-10M左右</p>
</blockquote>
<h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><p>Reserved Mono内存：Mono向操作系统申请的总内存<br>Used Total：Mono内存池的代码使用到的内存</p>
<blockquote>
<p>Reserve：预定，储备，拥有</p>
<p>如果是在Editor中运行时，那么该数值是会比较大，因为编辑器运行游戏时，底层会做很多额外的事情，比如更多的log输出等，从而占据较多的堆内存。而如果在真机运行时看到该数值时，那么80M是比较大的，这个需要你对你的代码来进行优化，避免一些不必要的堆内存分配。比如，不要总是new一个class、array、container等等。<br> 可以在CPU Profiler中的GC Alloc处查看游戏每帧的堆内存分配。<br> 建议时刻关注CPU Profiler中的GC Collect值，查看由哪些选项分配较大或不断分配GC Allocation。这个是造成Managed Heap不断增大的原因。</p>
</blockquote>
<h4 id="原生堆-Native-Heap"><a href="#原生堆-Native-Heap" class="headerlink" title="原生堆(Native Heap)"></a>原生堆(Native Heap)</h4><p>是Unity3D游戏开发引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity3D 使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。</p>
<p>听起来很美好也和托管堆一样，但是由于Unity3D有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用(贴图什么的你懂的)，也是Unity3D给人留下“吃内存”印象的罪魁祸首。</p>
<h3 id="3-2-Profiler中的内存划分"><a href="#3-2-Profiler中的内存划分" class="headerlink" title="3.2 Profiler中的内存划分"></a>3.2 Profiler中的内存划分</h3><h4 id="Simple模式"><a href="#Simple模式" class="headerlink" title="Simple模式"></a>Simple模式</h4><p>Total: Accumulated value from all areas below</p>
<p>Unity: The amount of memory allocations in native Unity code, tracked by the native memory manager system and allocated in memory pools according to their type, source and platform specific allocation patterns.</p>
<p>Mono: The total heap size and used heap size managed code uses. This memory is garbage collected.</p>
<p>GfxDriver: The estimated amount of memory the driver uses on Textures, render targets, Shaders, and Mesh data.</p>
<blockquote>
<p>用来显示的数据，如Mesh、Texture等，Unity加载出来就会直接放在显存当中，需要显示时，不需要在内存中来读取。加载时，（如果没有开启Read/Write），有短暂的时间在内存当中，有一个从内存向显存传输数据的过程。传输结束就会把内存当中的部分删除掉。<br> 如果Mesh等开启Read/Write，为了方便对其进行读写，内存当中的数据不会被清除掉，内存与显存中各有一份。</p>
</blockquote>
<p>Audio: The Audio system’s estimated memory usage</p>
<p>Video: The Video system’s estimated memory usage</p>
<p>Profiler: Total memory the Profiler uses</p>
<h4 id="Detailed模式"><a href="#Detailed模式" class="headerlink" title="Detailed模式"></a>Detailed模式</h4><p>Assets — 当前从 scenes, Resources 和 Asset Bundles加载的总资源。<br>Built-in Resources — Unity Editor 资源 或者 Unity default 资源,<br>Not Saved — 被标记为 DontSave的GameObjects<br>Scene Memory — GameObject和它附属的Components<br>Other — 其他不在上面几条分类中的。</p>
<p>Other 下的一些内容：</p>
<ul>
<li><p>Objects - 实际上这里值是由一些BUG导致的。这一项表示各种从Object继承的对象，包括纹理，Mesh等等。它们在某个时刻和实际上的对象断开了链接，可以忽略。</p>
</li>
<li><p>System.ExecutableAndDlls：这是Unity的猜测值。它尝试通过汇总文件大小来猜测已加载的二进制代码消耗的内存。</p>
</li>
</ul>
<h4 id="Used和Reserved"><a href="#Used和Reserved" class="headerlink" title="Used和Reserved"></a>Used和Reserved</h4><p>Used和Reserved均是物理内存<br>Reserved是unity向系统申请的总内存，Unity底层为了不经常向系统申请开辟内存，开启了较大一块内存作为缓存，即所谓的Reserved内存，而运行时，unity所使用的内存首先是向Reserved中来申请内存，当不使用时也是先向Reserved中释放内存，从而来保证游戏运行的流畅性。</p>
<blockquote>
<p>建议尽可能地控制Used Total的大小，Used Total越大，则Reserved Total越大，而当Used Total降下去后，Reserved Total也是会随之下降的（但并不一定与Used Total同步）。</p>
</blockquote>
<p>通过PSS来查看移动端的内存是相当不准确的。<br>而PSS中多出的内存大致分为两部分</p>
<ol>
<li><p>App在运行会调用底层的一些核心库，这些库都会占用一定的内存</p>
</li>
<li><p>第二部分则是移动系统决定的，即虽然游戏中已经将资源卸载掉，但在系统层面上，系统并不会及时将其清除，而是将其缓存住，这样做的处理是为了便于以后该资源的复用效率，同时，当系统的内存分配达到上限时，系统本身会调用内存清理机制来轮询这些缓存区域，进而释放内存。</p>
</li>
</ol>
<h4 id="GfxDriver"><a href="#GfxDriver" class="headerlink" title="GfxDriver"></a>GfxDriver</h4><p>GfxDriver可以理解为GPU显存开销，主要由Texture，Vertex buffer以及index buffer组成。所以尽可能地减少或释放Texture和mesh等资源，即可降低GfxDriver内存。</p>
<h3 id="3-3-★★★-Unity内存管理机制与GC"><a href="#3-3-★★★-Unity内存管理机制与GC" class="headerlink" title="3.3 ★★★ Unity内存管理机制与GC"></a>3.3 ★★★ Unity内存管理机制与GC</h3><h4 id="Destroy机制与Custom-Null-Check-of-Unity"><a href="#Destroy机制与Custom-Null-Check-of-Unity" class="headerlink" title="Destroy机制与Custom Null Check of Unity"></a>Destroy机制与Custom Null Check of Unity</h4><h5 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h5><p>Destroy了B对象所在的GameObject后，遍历打印B的引用都为Null，在Inspector面板上看是missing。而这时候进行GC，堆内存其实并未释放这些B对象。只有当A对象中的数组被清空后，再调用GC，才可释放这些对象所占内存。</p>
<h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>Unity中对Null的检测做了特殊的处理，在Unity中MonoBehaviour对象除了存在于Managed Heap中作为“壳”(wrapper objects)，在Native内存中还会有一个相对应的“实体”，在调用Destroy时，真正被释放的正是这个“实体”。而在判断一个MonoBehaviour对象是否为Null时，Unity会首先检测“实体”是否已经被销毁，如果是则返回为true，但此时Managed Heap中的“壳”实际上依然是被引用的，从而就会出现对象的Null判断为true，但实际上还是被引用着，无法被GC释放的问题。<br>如果作为Unity.GameObject对象是null，而作为System.Object对象不是null，说明这个对象已经被Unity标记为销毁了，Unity.GameObject重载的==运算符让游戏逻辑认为它是空的。</p>
<blockquote>
<p>官方解释：<a href="http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/" target="_blank" rel="noopener">http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/</a><br> When you get a c# object of type “GameObject”[2], it contains almost nothing. this is because Unity is a C/C++ engine. All the actual information about this GameObject (its name, the list of components it has, its HideFlags, etc) lives in the c++ side. The only thing that the c# object has is a pointer to the native object. We call these c# objects “wrapper objects”. The lifetime of these c++ objects like GameObject and everything else that derives from UnityEngine.Object is explicitly managed. These objects get destroyed when you load a new scene. Or when you call Object.Destroy(myObject); on them. Lifetime of c# objects gets managed the c# way, with a garbage collector. This means that it’s possible to have a c# wrapper object that still exists, that wraps a c++ object that has already been destroyed. If you compare this object to null, our custom == operator will return “true” in this case, even though <strong>the actual c# variable is in reality not really null</strong>.<br> downsides: </p>
<ul>
<li><p>It is counterintuitive.</p>
</li>
<li><p>Comparing two UnityEngine.Objects to eachother or to null is slower than you’d expect.</p>
</li>
<li><p>The custom ==operator is not thread safe, so you cannot compare objects off the main thread. (this one we could fix).</p>
</li>
<li><p>It behaves inconsistently with the ?? operator, which also does a null check, but that one does a pure c# null check, and cannot be bypassed to call our custom null check.</p>
</li>
</ul>
</blockquote>
<h5 id="总结：Destroy机制"><a href="#总结：Destroy机制" class="headerlink" title="总结：Destroy机制"></a>总结：Destroy机制</h5><p>将Native对象Destroy掉（是否立刻释放Native层的内存不清楚），C#层的壳不做处理，访问C#层对象时，会进行判空——根据引用的C#层对象，访问相应的Native层对象，看是否被Destroy，如果Native对象是Destroyed，则返回null。此时的null是fake null，C#层的对象壳还在被引用，无法被GC。只有将C#层手动置空，或者所在的容器Clear掉，才能被GC。</p>
<h5 id="create-an-instance-of-a-MonoBehaviour-derived-class只能通过AddComponent"><a href="#create-an-instance-of-a-MonoBehaviour-derived-class只能通过AddComponent" class="headerlink" title="create an instance of a MonoBehaviour derived class只能通过AddComponent"></a>create an instance of a MonoBehaviour derived class只能通过AddComponent</h5><p>更详细的解释：<a href="http://answers.unity3d.com/questions/745685/nullreferenceexception-on-startcoroutine.html" target="_blank" rel="noopener">http://answers.unity3d.com/questions/745685/nullreferenceexception-on-startcoroutine.html</a><br>In C# / .NET / Mono instances actually can’t be destroyed since they live in a managed memory environment. Objects are destroyed when all references to the object are gone, no longer valid. After that the garbage collector eventually kicks in and removes the object.</p>
<p>However in Unity, since it’s core is written in C++, (native) objects can be destroyed on command (with Destroy to be more precise). The Destroy method actually only destroys the object on the c++ side. The managed representation of the object (your MonoBehaviour script) will still be there since the GC can only collect the object when there are no references anymore. That’s why Unity actually “fakes” that the reference is null when the object has lost it’s native counterpart.</p>
<p>If you use the “new” keyword to create an instance of a MonoBehaviour derived class the instance doesn’t have a native counterpart and will always pretend to be null. If you want to create an instance at runtime it has to be attached to a gameobject. This is done with AddComponent</p>
<h4 id="Native对象的种类及回收方式的理解"><a href="#Native对象的种类及回收方式的理解" class="headerlink" title="Native对象的种类及回收方式的理解"></a>Native对象的种类及回收方式的理解</h4><p>Native层的对象类型：</p>
<ol>
<li><p>Component类型，创建出来是一个component类的对象实例。这部分实例可以Destroy。Destroy掉Native对象就会销毁，C#层的壳不会销毁，由C#的GC进行管理</p>
</li>
<li><p>资源类型（Assets，Component会引用到，类似于Texture、Mesh等）。在Destroy某个GameObject时，component会被销毁，而component所引用的资源（Texture、Mesh等）不会立刻销毁。如果这部分资源没有被引用，那么调用UnloadUnusedAssets可以卸载掉，释放内存。或者使用UnloadAsset()进行强制卸载。</p>
</li>
</ol>
<p>至于说component类的资源在Destroy后是否能够立刻释放内存，不太清楚。这一点不好测试，也不需要关注，因为component对象本身在Native层占用的内存也很小。可能是立刻释放内存，也可能是将引用断掉，统一回收处理。</p>
<h4 id="关于Native层资源垃圾回收机制的思考"><a href="#关于Native层资源垃圾回收机制的思考" class="headerlink" title="关于Native层资源垃圾回收机制的思考"></a>关于Native层资源垃圾回收机制的思考</h4><p>由于在之前对加载资源时过程的内存进行监控时，发现当Native层内存过高时，加载资源时，内存会下降。猜想在Native层也存在类似于Mono层的GC机制，当内存到达一定数值时，会对未被引用的资源进行卸载。<br>之所以会crash，是因为GC在试图卸载未被引用的资源以后，还是空间不足，那么再强行加载资源，就会因为内存分配不出来而crash。（有大部分资源因为被引用而无法卸载）</p>
<h4 id="场景切换时的内存"><a href="#场景切换时的内存" class="headerlink" title="场景切换时的内存"></a>场景切换时的内存</h4><p>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.<br>Destroy掉前一个场景中的GameObject，如果GameObject上挂载的Monobehaviour没有被其他地方引用的话，调用GC.Collect()会回收掉他占用的内存。</p>
<p>虽然GameObject被Destroy掉了， 如果Monobehaviour被其他在场景切换时无法销毁的对象所引用，那么其Mono层的对象是无法被回收的。比如：MonoBehaviour类中的某个函数注册了SceneManager类的sceneLoaded事件，那么这个对象就被SceneManager静态地引用了，该对象就无法销毁，Mono层地内存就无法释放。</p>
<h2 id="4-Unity的垃圾回收相关接口"><a href="#4-Unity的垃圾回收相关接口" class="headerlink" title="4 Unity的垃圾回收相关接口"></a>4 Unity的垃圾回收相关接口</h2><h2 id="5-Unity内存管理的一些经验"><a href="#5-Unity内存管理的一些经验" class="headerlink" title="5 Unity内存管理的一些经验"></a>5 Unity内存管理的一些经验</h2><h3 id="5-1-管理方式"><a href="#5-1-管理方式" class="headerlink" title="5.1 管理方式"></a>5.1 管理方式</h3><ul>
<li><p>引擎管理内存</p>
</li>
<li><p>用户管理内存, 即profiler中C#分配的托管内存</p>
</li>
</ul>
<h4 id="一次完整的GC流程："><a href="#一次完整的GC流程：" class="headerlink" title="一次完整的GC流程："></a>一次完整的GC流程：</h4><ol>
<li><p>音频等其他由逻辑触发的资源释放；</p>
</li>
<li><p>C#的GC：GC.Collect()；</p>
</li>
<li><p>释放无用资源：Resources.UnloadUnusedAssets()；</p>
</li>
<li><p>Lua的GC。</p>
</li>
</ol>
<h3 id="5-2-Unity监测不到的内存"><a href="#5-2-Unity监测不到的内存" class="headerlink" title="5.2 Unity监测不到的内存"></a>5.2 Unity监测不到的内存</h3><ul>
<li><p>用户分配的native内存</p>
</li>
<li><p>例如自己写的一个C++插件分配的内存</p>
</li>
<li><p>lua分配的内存</p>
</li>
</ul>
<h3 id="5-3-优化建议"><a href="#5-3-优化建议" class="headerlink" title="5.3 优化建议"></a>5.3 优化建议</h3><p>Mono内存和native内存是PSS内存主要的组成部分，mono内存更多的起到内存调用的功能，因此常常成为了开发人员优化内存的起点；</p>
<p>而native内存中包含了大量对象的资源，也是内存优化中的重要部分。</p>
<h4 id="以NGUI或者说UGUI为例如何去做优化"><a href="#以NGUI或者说UGUI为例如何去做优化" class="headerlink" title="以NGUI或者说UGUI为例如何去做优化"></a>以NGUI或者说UGUI为例如何去做优化</h4><p>通常一个Panel会产生1个或多个Draw Call，以一个Panel为单位，Draw Call 的数量通常由当前 Panel 中使用的Atlas、Font的数量所决定。<br>要降低UI渲染时的 Draw Call数量则需要对 Atlas 的制作进行合理的规划，即在保证使用较少的 Atlas 的同时，还需要保证 Atlas之间不会存在交叉遮挡。<br>要注意UI Texture的使用，每个UITexture自身会占用一个Draw Call，同时如果其Depth值穿插在了其他来自相同Atlas的UISprite中，还会导致Draw Call的打断，造成不必要的额外Draw Call。<br>另外还可以借助Panel Tool和Draw Call Tool来对UI部分的Draw Call进行分析，前者可以显示每个UIPanel包含了多少个Draw Call，而后者可以显示每个Draw Call由哪些UIWidget组成。</p>
<h3 id="5-4-几个方面的内存管理及涉及到的要点"><a href="#5-4-几个方面的内存管理及涉及到的要点" class="headerlink" title="5.4 几个方面的内存管理及涉及到的要点"></a>5.4 几个方面的内存管理及涉及到的要点</h3><h4 id="Unity-Native-Memory"><a href="#Unity-Native-Memory" class="headerlink" title="Unity Native Memory"></a>Unity Native Memory</h4><p>Unity重载了C++所有内存分配的操作符</p>
<ul>
<li><p>Allocator与memory lable<br>memory lable是内存操作符需要的一个参数，就是在profiler中的各种lable，作用是将这块内存分配到哪一个类型的Allocator池中，每一个Allocator池单独做自己的跟踪</p>
</li>
<li><p>NewAsRoot<br>所有的Allocator的生成都是在执行NewAsRoot的操作符的前提下生成的，NewAsRoot会生成memory island作为一个root，在这个root下面会有很多子内存，例如一个shader，加载一个shader的时候，会生成该shader的root，每个shader会有很多的子数据，例如subshader pass等，会作为该root的子内存，在统计Runtime的内存时，只会统计root</p>
</li>
<li><p>会及时返还给系统</p>
</li>
</ul>
<h5 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h5><p>注意scene中GameObject的数量是否过多，数量过多会导致native内存显著增涨，在创建一个GameObject的时候，Unity会在C++中构建一个或者多个的Object来保存相关信息，因此，当发现Native内存过大时，优先检查Scene中的GameObject数量</p>
<h5 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h5><ol>
<li><p>DSP buffer<br>Unity中对应多档的设置，当需要播放声音时，会向CPU发送对应指令，如果指令发送太频繁，会导致CPU和IO压力 ,因此很多的音频插件，例如Unity中使用的，会使用DSP buffer，当这个buffer被填满之后，再发送指令，所以当这个buffer越大，CPU压力越小，内存占用越多，声音延迟也越大，因为每次都要等这个buffer被填满后才能播放，在一些Android设备上常常出现声音延迟过大，可以优先看看这个选项</p>
</li>
<li><p>Force to mono<br>很多的音频都是双声道的，但是左右声道完全一致，这就会导致内存和包体空间的浪费，在这种情况下，开启这个选项，会强制为单声道，减少内存和包体大小，对音质要求不高的项目可以使用（注：测试发现，只是把音频文件变为单声道，实际播放的时候，例如是双声道播放，还是双声道的，只是播放的是一样的）</p>
</li>
</ol>
<h5 id="code-size"><a href="#code-size" class="headerlink" title="code size"></a>code size</h5><p>很多人忽略的问题，代码本身也占内存（也会导致cache missing），其中一个主要的问题是模板泛型的滥用，编译C++时，会把所有的泛型展开为静态类，如果一个类使用了四个泛型，编译出来的cpp文件可能高达25M，这对il2cpp的编译速度造成很大影响，因为一个单一的cpp文件，是无法并行编译的</p>
<h5 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h5><ol>
<li><p>TypeTree<br>用于不同版本构建的AssetBundle可以在不同版本的Unity上保持兼容，防止序列化出错，如果Build AssetBundle的Unity版本和运行时的版本一致，可以关闭这个功能，关闭之后有三个好处<br>a. 减少内存占用<br>b. 减小包体大小<br>c. build和运行时会变快，因为当需要序列化有TypeTree的AssetBundle时，会序列化两次，先序列化TypeTree信息，再序列化数据，反序列化也需要两次</p>
</li>
<li><p>LZ4&amp;Lzma<br>LZ4是一种trunk-base的压缩技术，速度几乎是Lzma的10倍，但是压缩的体积会高出30%，trunk-base的压缩方式，在解压时可以减少内存占用，因为不需要解压整个文件，解压每个trunk的时候，可以复用buffer（在中国增强版中会推出一个基于LZ4的AssetBundle加密功能）</p>
</li>
<li><p>Size&amp;Count<br>就是AssetBundle的颗粒度控制，尽量减少AssetBundle的数量，可以减少AssetBundle头文件的内存和包体大小占用，有的资源的头文件甚至比数据还大，官方建议一个AssetBundle的大小在1-2M之间，不过这个建议是考虑网络带宽的影响，实际使用可以根据自身的环境设置</p>
</li>
</ol>
<h5 id="Resources文件夹"><a href="#Resources文件夹" class="headerlink" title="Resources文件夹"></a>Resources文件夹</h5><p>能不用就不用，在打包的时候，Unity也会为所有的Resources下面的资源构建一个头文件，一棵红黑树(R-B Tree)，在游戏启动的时候就会加载进内存，并且不会卸载，因此也会拖慢启动速度，因为红黑树没有加载分析完，是不会进入游戏的，目前这种方式主要用于Debug，甚至一些公司在Debug也不会使用Resources，而使用AssetBundle了</p>
<h5 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h5><ol>
<li><p>upload buffer<br>和DSP buffer类似，就是填满多少Texture数据时，向GPU push一次</p>
</li>
<li><p>r/w<br>如果没有必要就不要开启，一个Texture正常的加载流程为<br>加载进内存 -&gt; 解析 -&gt; upload buffer -&gt; 从内存中delete<br>开启选项后，不会从内存delete，导致内存和显存中都存在一份（注：貌似iOS不会存在两份，而是使用一个虚拟指针，指向同一块数据，具体细节可以查证一下）</p>
</li>
<li><p>mip maps<br>例如UI这些就别开启了，也能减少内存占用</p>
</li>
</ol>
<h5 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h5><ol>
<li><p>r/w<br>和Texture r/w类似，能不开就不开</p>
</li>
<li><p>compression<br>需要注意的是，在某些版本中，开了还不如不开，需要自己测试一下</p>
</li>
</ol>
<h5 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h5><p>可以看看Unity官方的最佳实践（<a href="https://blog.csdn.net/greedylin/article/details/80645860" target="_blank" rel="noopener">https://blog.csdn.net/greedylin/article/details/80645860</a>）</p>
<h4 id="Unity-Managed-Memory"><a href="#Unity-Managed-Memory" class="headerlink" title="Unity Managed Memory"></a>Unity Managed Memory</h4><p>详见我的笔记：Unity游戏Mono内存管理与泄漏</p>
<h5 id="VM内存池"><a href="#VM内存池" class="headerlink" title="VM内存池"></a>VM内存池</h5><ol>
<li><p>VM会返还内存给OS吗？<br>会的，条件是同一个内存block，6次GC都没有访问到时，就会返还，所以概率很小，特别是mono，il2cpp几率还会高一点</p>
</li>
<li><p>当VM内存池高于某个阈值时，会根据一些条件，乘出一块内存</p>
</li>
<li><p>注意，有时候托管内存已经释放了，实际内存可能还会涨，因为内存碎片化的问题，导致一些内存块无法复用，建议操作内存时，先使用大内存，再使用小内存</p>
</li>
</ol>
<h5 id="GC机制考量"><a href="#GC机制考量" class="headerlink" title="GC机制考量"></a>GC机制考量</h5><ol>
<li><p>Throughput（回收能力）<br>一次回收，能够回收多少的内存</p>
</li>
<li><p>Pause times（暂停时长）<br>回收时，对主线程的影响有多大</p>
</li>
<li><p>Fragmentation（碎片化）<br>回收之后，回收的内存会对整体碎片化贡献多少</p>
</li>
<li><p>Mutator overhead（额外消耗）<br>回收行为本身的消耗</p>
</li>
<li><p>Scalability（可扩展性）<br>能否扩展到多线程</p>
</li>
<li><p>Portability（可移植性）<br>能否在不同平台使用</p>
</li>
</ol>
<h5 id="Boehm"><a href="#Boehm" class="headerlink" title="Boehm"></a>Boehm</h5><p>Unity当前使用的GC算法</p>
<ol>
<li><p>Non-generational（不分代式）<br>分代的特征是指：例如会将大块内存 小内存以及超小内存 长久内存（例如一块长时间未访问的内存会移入长久内存）会放在不同的内存区域管理，Unity未采用的一个考量是，不分代式的速度很快</p>
</li>
<li><p>Non-compaction（非压缩式）<br>压缩是指：当一块内存被回收时，会移动其他内存，使之紧密连接，Unity目前不会压缩，会把它空着，如果下次分配的内存小于空着的内存，就会再次使用</p>
</li>
<li><p>为什么选择这种听起来不合理的GC算法呢？<br>a. 历史原因（Unity和Mono的恩怨，导致一直使用老版本的Mono）<br>b. 目前Unity的重点转向了il2cpp，采用了Incremental GC（渐进式GC），解决主线程卡顿问题，原理是分帧进行，将一次卡顿峰值平摊到多帧里面，平摊卡顿时间<br>c. 未来考虑使用SGen算法或升级Boehm？<br>SGen是一种分代的GC算法，可以减少碎片化，调用执行快，或者考虑升级Boehm算法<br>d. 目前il2cpp上面是Unity自己写的Boehm算法，在策略上会更激进</p>
</li>
</ol>
<h5 id="Zombie-Memory（僵尸内存）"><a href="#Zombie-Memory（僵尸内存）" class="headerlink" title="Zombie Memory（僵尸内存）"></a>Zombie Memory（僵尸内存）</h5><ol>
<li><p>无用内存<br>代码设计不好，以为可以释放，但是没有释放的内存，所以大家要关注活跃度不高的内存</p>
</li>
<li><p>通过代码管理和性能工具来分析</p>
</li>
</ol>
<h5 id="实践注意点"><a href="#实践注意点" class="headerlink" title="实践注意点"></a>实践注意点</h5><ul>
<li><p>Don’t Null it,but Destroy it<br>不要置空就完事了，记得显式调用Destroy</p>
</li>
<li><p>Class VS Struct<br>可以关注Unity的DOTS和ECS</p>
</li>
<li><p>Closures and anonymous methods（闭包和匿名函数）</p>
</li>
<li><p>Coroutines（协程）<br>协程可以看作闭包和匿名函数的特例，在il2cpp中，每一个闭包和匿名函数，都会new一个对象出来，只是无法访问，里面的数据，即使是你认为用完就丢的局部变量，在你用完了之后，也不会立即释放，而是等到这个对象释放才释放，有的项目在游戏一开始就开启一个协程，一直到游戏结束，这样使用是错误的，会导致闭包中的数据一直占用内存，正确的做法是用到的时候生成一个协程，不用的时候就扔掉，协程的设计不是当作线程使用的</p>
</li>
<li><p>configurations（配置表）<br>如果配置较大，不要一下全部加载进内存，有两个解决方案：</p>
<ol>
<li><p>通过网络流量获得相关的配置信息</p>
</li>
<li><p>按需加载，例如进入一个关卡时，再加载这个关卡的配置</p>
</li>
</ol>
</li>
<li><p>Singleton（单例）<br>一定要慎用，在C++的年代，这就是万恶之源，不要什么都往这里面扔，会导致内存无法释放，注意单例的引用关系，当引用关系变得复杂时，很难确定哪些东西没有及时释放</p>
</li>
</ul>
<h2 id="6-内存相关工具"><a href="#6-内存相关工具" class="headerlink" title="6 内存相关工具"></a>6 内存相关工具</h2><h3 id="Unity-Profiler"><a href="#Unity-Profiler" class="headerlink" title="Unity Profiler"></a>Unity Profiler</h3><h4 id="Profiler-Detailed-中的一些参数"><a href="#Profiler-Detailed-中的一些参数" class="headerlink" title="Profiler Detailed 中的一些参数"></a>Profiler Detailed 中的一些参数</h4><h2 id="7-关于Unity的闪退与卡顿"><a href="#7-关于Unity的闪退与卡顿" class="headerlink" title="7 关于Unity的闪退与卡顿"></a>7 关于Unity的闪退与卡顿</h2><h3 id="Unity程序闪退与卡顿原因"><a href="#Unity程序闪退与卡顿原因" class="headerlink" title="Unity程序闪退与卡顿原因"></a>Unity程序闪退与卡顿原因</h3><p>1.闪退<br>原因1：程序吃内存。表现为内存泄露或加载资源时闪退等。<br>原因2：程序吃CPU。表现为​程序执行复杂运算时闪退等。<br>原因3：系统内存回收机制。它按照优先级回收内存。如果内存很紧张的时候会回收掉前 台进程，有可能就把我们的程序给杀掉。<br>原因4：兼容性问题。​程序对目标设备的软硬件环境的兼容情况也会造成闪退。</p>
<p>2.卡顿<br>原因1：某帧堆积的任务过多。建议采用多线程或把任务量平摊到多个帧执行。</p>
<p>原文地址：<a href="http://blog.sina.com.cn/s/blog_80cc3d870102vefy.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_80cc3d870102vefy.html</a></p>
<h3 id="Unity内存不足引起崩溃的几种原因"><a href="#Unity内存不足引起崩溃的几种原因" class="headerlink" title="Unity内存不足引起崩溃的几种原因"></a>Unity内存不足引起崩溃的几种原因</h3><p>At some points a game may crash with “out of memory” though it in theory it should fit in fine. When this happens compare your normal game memory footprint and the allocated memory size when the crash happens. If the numbers are not similar, then there is a memory spike. This might be due to:</p>
<p>在某些时刻，一个游戏可能由于“内存不足”而崩溃。尽管理论上它最后应当是合适的。当这个问题发生而引发崩溃时，对比你的正规的游戏内存轨迹和已分配内存大小。如果得到的数字不是类似的，那么这就发生了一个内存峰值。这可能是由于：</p>
<ul>
<li><p>Two big scenes being loaded at the same time - use an empty scene between two bigger ones to fix this.<br>两个大场景被同时加载——为了解决它，在两个更大的场景中间使用一个空的场景。</p>
</li>
<li><p>Additive scene loading - remove unused parts to maintain the memory size.<br>附加的场景加载——移除没有用到的部分来维护内存大小。</p>
</li>
<li><p>Huge asset bundles loaded to the memory<br>巨大的资源包被加载到内存</p>
</li>
<li><p>Loading via WWW or instantiating (a huge amount of) big objects like:<br>通过WWW加载或是实例化（大量的实例化）庞大的对象，例如：</p>
<ul>
<li><p>Textures without proper compression (a no go for mobiles).<br>没有合适压缩的贴图（对于移动设备是无效的）。</p>
</li>
<li><p>Textures having Get/Set pixels enabled. This requires an uncompressed copy of the texture in memory.<br>被启用了 获取/设置像素 的贴图。这需要在内存中创建一个贴图的未压缩的复制品。</p>
</li>
<li><p>Textures loaded from JPEG/PNGs at runtime are essentially uncompressed.<br>动态地从JPEG/PNGs加载的贴图没有基本上被压缩。</p>
</li>
<li><p>Big mp3 files marked as decompress on loading.<br>在加载时，巨大的mp3文件被标记为解压缩。</p>
</li>
</ul>
</li>
<li><p>Keeping unused assets in weird caches like static monobehavior fields, which are not cleared when changing scenes.<br>在怪异的缓存中（像静态monobehavior区域，当变换场景时它不会被清理）保留了未使用的资源。</p>
</li>
</ul>
<p>Ref:<br><a href="https://blog.csdn.net/y90o08u28/article/details/87202259" target="_blank" rel="noopener">https://blog.csdn.net/y90o08u28/article/details/87202259</a><br><a href="https://blog.csdn.net/jxw167/article/details/74555351" target="_blank" rel="noopener">https://blog.csdn.net/jxw167/article/details/74555351</a><br><a href="https://www.cnblogs.com/msxh/p/12987632.html" target="_blank" rel="noopener">https://www.cnblogs.com/msxh/p/12987632.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【内存】PSS内存组成"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91PSS%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90/"
    >【内存】PSS内存组成</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90%E5%86%85%E5%AD%98%E3%80%91PSS%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90/" class="article-date">
  <time datetime="2023-07-20T15:00:27.850Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="【内存】PSS内存组成/1631087823435.png" alt=""></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【Editor-Extension】IMGUI"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90Editor-Extension%E3%80%91IMGUI/"
    >【Editor Extension】IMGUI</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90Editor-Extension%E3%80%91IMGUI/" class="article-date">
  <time datetime="2023-07-20T15:00:27.544Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>An immediate mode graphic user interface (GUI), also known as IMGUI, is a graphical user interface design pattern which uses an immediate mode graphics library to create the GUI. via. Wikipedia</p>
<p>即时模式图形用户界面（IMGUI）代表了一种范例，其中用户界面的创建（对于客户端应用程序）和实现更简单（对于工具箱设计器）。</p>
<h3 id="传统用户界面系统缓存状态的缺点"><a href="#传统用户界面系统缓存状态的缺点" class="headerlink" title="传统用户界面系统缓存状态的缺点"></a>传统用户界面系统缓存状态的缺点</h3><p>传统用户界面系统设计和使用的复杂性是由此类系统保持了各种状态引起的。程序员通常被要求在应用程* 序和用户界面之间来回主动地复制状态，以便用户界面反映应用程序的状态，反之，为了使用户界面中发生的更改影响应用程序的状态。UI系统的状态是实际状态的一份COPY/CACHE。</p>
<p>从客户端应用的角度看，UI更像是一堆对象的集合（通常称为widget），这些对象分装了需要和应用交互的各种状态。这个同步过程是双向的，为了让用户了解到当前应用的状态，状态需要从应用端转移到UI端；为了让应用知道当前用户的操作，状态需要从UI端转移到应用端。 </p>
<p>此外，通知应用程序用户与接口交互的方式（这反过来表明需要重新同步状态）通常采用回调的形式。这需要应用程序为感兴趣的任何低级交互实现“事件处理程序”，通常是通过手动或通过各种代码生成技巧将某些工具箱基类子类化；在任何一种情况下，都会使客户机应用程序的生命周期更加复杂。</p>
<h3 id="IMGUI"><a href="#IMGUI" class="headerlink" title="IMGUI"></a>IMGUI</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>IMGUI通过要求应用程序实时显式传递可视化和交互所需的所有状态来消除这种状态同步。 用户界面只保留了为方便系统支持的每种小部件所需的功能所需的最小状态量。</p>
<p>Widget不再是对象，甚至可以说是不存在的。它们采用过程方法调用的形式，用户界面本身从有状态的对象集合变成了方法调用的实时序列。</p>
<p>这种实现方式的基础是实时应用程序循环的概念，也就是说，应用以实时的帧率处理逻辑和绘制（30 frames per second或者更高）。在游戏场景，这个是很常见的。</p>
<p>乍看起来，通过传递参数的方式实现看上去很冗余，但实际上并不是这样的。看上去会影响绘制性能。但是，对于现代的CPU和GPU而言，这个不是问题。</p>
<p>其优点在于简单和灵活。删除用户界面系统中的隐式状态缓存可以减少与缓存相关的bug的可能性，也完全消除了工具箱将小部件作为对象公开给客户机应用程序的需要。在逻辑上，小部件从对象变为方法调用。我们将看到，这从根本上改变了客户机应用程序处理用户界面实现的方式。</p>
<p>简单总结，IMGUI有以下优点：</p>
<ul>
<li><p>丝毫不需要分配内存，也即需要的内存为零！</p>
</li>
<li><p>速度很快。即使使用非常复杂的UI并且只有单线程的情况下，大多数（如果不是全部）ImGUI在60fps（帧）的速度下运行没有任何问题。</p>
</li>
<li><p>不需要对必须管理的对象进行创建和销毁操作。</p>
</li>
<li><p>没有状态，因为没有对象来存储状态。</p>
</li>
<li><p>基本不需要编制数据。</p>
</li>
<li><p>没有需要注册或响应的事件或回调。</p>
</li>
</ul>
<h4 id="IMGUI的缺点"><a href="#IMGUI的缺点" class="headerlink" title="IMGUI的缺点"></a>IMGUI的缺点</h4><h5 id="可能需要更多的CPU"><a href="#可能需要更多的CPU" class="headerlink" title="可能需要更多的CPU"></a>可能需要更多的CPU</h5><p>传统的GUI系统当元素有变化时，只需重新绘制局部元素。</p>
<p>ImGUI则相反，任何时候你想更改任何内容，整个图形用户界面就要重新绘制。即使是光标。以我们进入Excel示例，所有75个工具栏控件和300个单元格都将因为一个闪烁的光标而重新绘制。这是IMGUI的最坏情况。大量的CPU被浪费了。</p>
<h5 id="可访问性问题"><a href="#可访问性问题" class="headerlink" title="可访问性问题"></a>可访问性问题</h5><p>通常GUI不保留任何数据，所以它可能做不了保留模式GUI能够做的那些事情。</p>
<h5 id="动画的支持性"><a href="#动画的支持性" class="headerlink" title="动画的支持性"></a>动画的支持性</h5><p>大多数ImGUI都是无状态的，所以所有的动画都取决于应用程序。</p>
<h2 id="Unity-IMGUI"><a href="#Unity-IMGUI" class="headerlink" title="Unity IMGUI"></a>Unity IMGUI</h2><p>IMGUI is a code-driven GUI system. It is driven by calls to the OnGUI function on any script which implements it. </p>
<p>“Immediate Mode” refers to the way the IMGUI is created and drawn. To create IMGUI elements, you must write code that goes into a special function named OnGUI. The code to display the interface is executed every frame, and drawn to the screen. There are no persistent gameobjects<br>other than the object to which your OnGUI code is attached, or other types of objects in the hierarchy related to the visual elements that are drawn.</p>
<h3 id="Unity-GameObject-based-UI-system-vs-IMGUI"><a href="#Unity-GameObject-based-UI-system-vs-IMGUI" class="headerlink" title="Unity GameObject-based UI system vs IMGUI"></a>Unity GameObject-based UI system vs IMGUI</h3><p>GameObject-based UI system has far better tools to work with the visual design and layout of the UI.</p>
<p>适用情况：Unity’s main GameObject-based UI system is used for normal in-game user interfaces that players might use and interact with.</p>
<p>IMGUI allows you to create a wide variety of functional GUIs using code. Rather than creating GameObjects, manually positioning them, and then writing a script that handles its functionality, you can do everything at once with just a few lines of code. The code produces GUI controls that are drawn and handled with a single function call.</p>
<h3 id="Controls"><a href="#Controls" class="headerlink" title="Controls"></a>Controls</h3><p>The Control defines the content</p>
<h3 id="GUIStyle-amp-GUISkin"><a href="#GUIStyle-amp-GUISkin" class="headerlink" title="GUIStyle &amp; GUISkin"></a>GUIStyle &amp; GUISkin</h3><p>GUItyles define the appearance of a GUI Control. GUISkins are a collection of GUIStyles. </p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><h4 id="Fixed-Layout-amp-Automatic-Layout"><a href="#Fixed-Layout-amp-Automatic-Layout" class="headerlink" title="Fixed Layout &amp; Automatic Layout"></a>Fixed Layout &amp; Automatic Layout</h4><ul>
<li><p>Fixed Layout makes sense to use when you have a pre-designed interface to work from. </p>
</li>
<li><p>Automatic Layout makes sense to use when you don’t know how many elements you need up front, or don’t want to worry about hand-positioning each Control.</p>
</li>
</ul>
<p>About Automatic Layout:</p>
<ul>
<li><p>GUILayout is used instead of GUI</p>
</li>
<li><p>No Rect() function is required for Automatic Layout Controls</p>
</li>
</ul>
<h4 id="GUILayoutOptions"><a href="#GUILayoutOptions" class="headerlink" title="GUILayoutOptions"></a>GUILayoutOptions</h4><p>You can use GUILayoutOptions to override some of the Automatic Layout parameters. You do this by providing the options as the final parameters of the GUILayout Control.</p>
<h3 id="GUI-vs-EditorGUI"><a href="#GUI-vs-EditorGUI" class="headerlink" title="GUI vs EditorGUI"></a>GUI vs EditorGUI</h3><p>The difference between GUI and EditorGUI is primarily just their use case. GUI is used to display GUI items in game. GUI was the original way of creating Unity UI before their new canvas APIs. EditorGUI is used to create custom editors for your scripts and other editor customization.</p>
<p>One exception to that rule is that certain GUI classes are used for both. For instance, GUISkin and GUIStyle are used by both and their current values are accessed using GUI.skin regardless if used in game or in editor.</p>
<h2 id="经验与思考"><a href="#经验与思考" class="headerlink" title="经验与思考"></a>经验与思考</h2><h3 id="关于OnGUI调用逻辑的探究"><a href="#关于OnGUI调用逻辑的探究" class="headerlink" title="关于OnGUI调用逻辑的探究"></a>关于OnGUI调用逻辑的探究</h3><p>Monobehaviour脚本的OnGUI在Play时确实是会每帧都调用，每帧都重新绘制内容。表现在使用如下脚本，Play时，字体会随着正弦函数不断连续变大变小。</p>
<pre><code class="lang-csharp">
// C# example

using UnityEngine; 

using System.Collections; 

public class Fontsize : MonoBehaviour

{ 

void OnGUI ()

{ 

//Set the GUIStyle style to be label

GUIStyle style = GUI.skin.GetStyle (&quot;label&quot;); 

//Set the style font size to increase and decrease over time

//This specific example requires that the default font (Arial) is loaded and marked as dynamic. You cannot change the size of any font that is not marked as dynamic.

style.fontSize = (int)(20.0f + 10.0f * Mathf.Sin (Time.time)); 

//the font does not smoothly change size, this is becauses there is not an infinite number of font sizes.

GUI.Label (new Rect (10, 10, 200, 80), &quot;Hello World!&quot;); 

} 

}
</code></pre>
<p>但是在EditorWindow下，如果OnGUI中没有写EditorWindow.Repaint()的话，OnGUI并不会每帧都调用，字体大小不会自动连续地按照正弦曲线变大变小。只有当触发一定的事件时（比如点击窗口，在某个按钮上hover等），EditorWindow才会重新绘制，调用OnGUI。</p>
<p>如果OnGUI中主动调用Repaint()，则OnGUI会每帧都调用，原理还不明确。</p>
<h3 id="EditorGUI的一个BUG"><a href="#EditorGUI的一个BUG" class="headerlink" title="EditorGUI的一个BUG"></a>EditorGUI的一个BUG</h3><p>EditorGUI有两个函数，BeginChangeCheck、EndChangeCheck()，用以检测特定范围内，UI元素的值是否发生改变。<br>当Begin与Begin发生嵌套时，会</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/Immediate_mode_GUI" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Immediate_mode_GUI</a></p>
<p><a href="https://www.tangledrealitystudios.com/development-tips/gui-vs-guilayout-vs-editorgui-vs-editorguilayout-and-when-to-use-them/" target="_blank" rel="noopener">https://www.tangledrealitystudios.com/development-tips/gui-vs-guilayout-vs-editorgui-vs-editorguilayout-and-when-to-use-them/</a></p>
<p><a href="https://www.cnblogs.com/grass-and-moon/p/13864696.html" target="_blank" rel="noopener">https://www.cnblogs.com/grass-and-moon/p/13864696.html</a><br><a href="https://blog.csdn.net/csdnnews/article/details/90746003" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/90746003</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-”游戏程序员核心竞争力“问题总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E2%80%9D%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B%E2%80%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"
    >”游戏程序员核心竞争力“问题总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E2%80%9D%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B%E2%80%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2023-07-20T15:00:27.541Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="信息提取"><a href="#信息提取" class="headerlink" title="信息提取"></a>信息提取</h1><h2 id="道理"><a href="#道理" class="headerlink" title="道理"></a>道理</h2><p><strong>缓解焦虑的唯一办法，只有提高能力。</strong></p>
<h2 id="研究领域"><a href="#研究领域" class="headerlink" title="研究领域"></a>研究领域</h2><ol>
<li>客户端渲染</li>
<li>服务器架构</li>
<li>gameplay专家，游戏逻辑</li>
<li>技术管理/主程序</li>
<li>优化</li>
<li>引擎功能开发</li>
</ol>
<h1 id="内容搜集"><a href="#内容搜集" class="headerlink" title="内容搜集"></a>内容搜集</h1><h2 id="MaxwellGeng"><a href="#MaxwellGeng" class="headerlink" title="MaxwellGeng"></a>MaxwellGeng</h2><p>什么叫“数学比较差，做不了图形的东西”？ 我也软件工程在读，我数学底子也差（微分和积分一个BC一个C了解一下？），现在起码通了一遍PBR的材质和后处理特效了，也跟着GDC和Siggraph分享以及Github上众多前辈留下的脚印比着葫芦画瓢写了一套晃晃悠悠的渲染管线了，这不叫“图形学的东西”吗？CPP底子薄？谁CPP底子不薄啊？？生下来就会啊？！</p>
<h2 id="Jerish"><a href="#Jerish" class="headerlink" title="Jerish"></a>Jerish</h2><p>我有价值，起码当前的我是有竞争力的，我在UE4上（以及相关技术）的功底就是我当前的核心竞争力。我有一个特点，就是能钻研，你只要有源码我就能看，愿意主动看，而且还尽可能要求自己都看懂，看懂还能给人讲明白，能正确的修改其中的问题。</p>
<p><strong>竞争力就是你的必要性以及不可替代性。必要性是指你所在的技术位置很重要，很多游戏团队都需要。不可替代性是指花同样的成本（或稍微高一些）去找一个能替代你的人很困难。</strong></p>
<p>在完成自己的任务后就开始研究身边人的工作内容，看看他们做的东西难点在哪？我有没有办法解决？差距在哪里？同时，我在空闲时间就去看各大游戏公司的招聘条件，主程什么要求、高级程序员什么要求，我离这个要求有多远。实在一点的说，衡量你竞争力的标准就是你能不能找到工资更高的工作，所以你完全可以通过网络，技术qq群等去查找你需要的能力。  </p>
<p><img src="”游戏程序员核心竞争力“问题总结/Image.png" alt=""></p>
<p>专心搞技术，那么就 <strong>客户端渲染</strong> 、 <strong>服务器架构</strong> 选一个不停的深入研究<br>国内短期还不会需要 <strong>gameplay专家</strong><br>如果想走 <strong>技术管理</strong> ，那就不要在意客户端服务器gameplay，能学多少学多少，然后多跟项目，了解各方面的技术与项目管理细节。我在和主程沟通的时候，发现他什么都懂，可以流畅的与所有程序沟通不同的技术，定制目标，安排任务，还能提出建议给出参考资料。这就是 <strong>主程序</strong> 的竞争力。</p>
<h2 id="flashyiyi"><a href="#flashyiyi" class="headerlink" title="flashyiyi"></a>flashyiyi</h2><p>做架构的，做图形的，做战斗的，做UI的，做优化的，做工具的</p>
<p>程序员只靠技术，竞争力确实比较有限，但只要你能稍微跨点界，你的竞争力都会飞速上涨，跨美术或者策划都行， <strong>管理能力强</strong> ，也是优点。</p>
<p><strong>架构</strong> 就不用说了，基本都是老资格。重要程度也不用多说。</p>
<p>做 <strong>优化</strong> 的不是说只做优化，而是会做优化。你会做优化，你就有了自己的核心竞争力。说的明白点就是搞底层的。</p>
<p><strong>做工具的——引擎功能开发</strong> 要点是了解各个开发者的真实需求，而且架构能力要好，通用性要高，做出来的东西不至于没人愿意用（随便找个人来做这个的结果通常都是没人用）。我这个名字可能不太好，其实就是做引擎的。但现在没必要做引擎，所以就是做通用组件，搞编辑器啥的。<br>我举个具体的例子，一个数据编辑器的要点是什么？1.修改简单，具体做法就是通过元标签生成界面。2.热更，修改数据后在游戏内部就能生效。然而这种需求，基本上不要指望策划或者美术会给你提，他们只会缺什么要什么。这得靠你的悟性。当然实现上也不能说没有难度。</p>
<p><strong>图形</strong> 好像也不用提，因为稍微有点门槛。图形后面还可以转TA，必要性更高，即使是国内的低级项目也有需求（高级的图程，不做牛逼东西，确实不太用得上）。</p>
<p>做 <strong>战斗</strong> 的，基本就是写逻辑，oop能力要强，基本也不会没人要。而且做战斗的经常会直接参与战斗细节的调整，因为自己调比暴露参数快多了，细节参数需求也很难到位，尤其遇到纠缠在一起的复杂逻辑。能自己调战斗的程序员必然是有竞争力的，没有也有，毕竟逻辑足够复杂，而且招到合适的不比招个图程容易。如果有人觉得图程更难，说明他们游戏的逻辑部分太简单。逻辑这东西，难度是随着复杂度指数级上升的。</p>
<h2 id="顾煜"><a href="#顾煜" class="headerlink" title="顾煜"></a>顾煜</h2><p><strong>缓解焦虑的唯一办法，只有提高能力。</strong><br>不是只有做图形学才是做游戏开发的唯一出路，游戏开发领域值得学习的东西太多了。</p>
<p>先打好基础。游戏开发本质上还是软件开发，编程语言本身、设计模式、架构、软件工程知识等，都要深入学习。</p>
<p>再从Gameplay切入。寻路、人物行为、高层动画、网络同步方案、UI界面、各种脚本，高层gameplay一般比较直观，不存在太多的前置技术需求，每一个领域都是可以快速切入，在几个月里面深入熟悉。</p>
<p>然后考虑偏底层的模块。多线程、资源管理、内存管理、性能优化、工具链、渲染等等。这些领域需要一些前置的技术学习，但每一个领域也都不是学不会的，只是费时更久些。</p>
<p>最后方方面面知识都接触过了，融会贯通，培养技术的想象力，能结合各种技术，随时结合已有的技术，解决具体的问题。</p>
<h2 id="gougou槐宏文"><a href="#gougou槐宏文" class="headerlink" title="gougou槐宏文"></a>gougou槐宏文</h2><p>最稀缺的人才，就是高质量独立游戏制作者的模式，一个人可以包揽设计和实现，一个人可以完成迭代，从设计到打磨玩法全部做好（需要动画美术支持可能），这是最理想的gameplay最稀缺的人才。</p>
<p>做游戏是工程学，不是做研究。一个好的工作室的技术积累，大部分的时间不是研究高精尖的算法，而是 <strong>在优化自己的生产管线</strong> 。也就是说，如何 <strong>提高自己工作室某个类型开发过程的效率</strong> ，降低开发成本，优化迭代速度，靠着强大的产出工具链产出内容，完成优秀的产品。如果你仔细看看很多gdc关于pipeline的talk，看看虚幻引擎的工具集，等等，你会发现，这里面不只是技术的积累，更是在某一个游戏领域经验的积累。比如ue4的cinematic的工具集，没有做过很多大型3A游戏的cine的经验是没有办法优化的如此好的，这里面当然需要好的程序技术，但是也需要对这个行业，对游戏开发很懂的人才能做出来，这不是一个算法的问题。好的pipeline可以极大的节省成本，优化流程，是一个游戏工作室最核心的竞争力和技术积累之一。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-YAML"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-YAML/"
    >YAML</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-YAML/" class="article-date">
  <time datetime="2023-07-20T15:00:27.534Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>YAML TAG： <a href="https://stackoverflow.com/questions/15233335/i-dont-understand-what-a-yaml-tag-is" target="_blank" rel="noopener">https://stackoverflow.com/questions/15233335/i-dont-understand-what-a-yaml-tag-is</a></p>
<p>YAML 文档：<a href="https://yaml.org/spec/1.2.2/#rule-ns-tag-directive" target="_blank" rel="noopener">https://yaml.org/spec/1.2.2/#rule-ns-tag-directive</a></p>
<p>YAML 博客：<a href="https://www.jianshu.com/p/20c3cde0f189" target="_blank" rel="noopener">https://www.jianshu.com/p/20c3cde0f189</a></p>
<p>Unity YAML解析方案：<a href="https://stackoverflow.com/questions/21473076/pyyaml-and-unusual-tags" target="_blank" rel="noopener">https://stackoverflow.com/questions/21473076/pyyaml-and-unusual-tags</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/5/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/4/">4</a><a class="page-number" href="/archives/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/archives/7/">7</a><a class="page-number" href="/archives/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/7/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>