<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-Windows与MacOS在U3D项目中的使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Windows%E4%B8%8EMacOS%E5%9C%A8U3D%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"
    >Windows与MacOS在U3D项目中的使用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Windows%E4%B8%8EMacOS%E5%9C%A8U3D%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2023-07-25T12:56:23.327Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Windows的优劣</p>
<ol>
<li><p>优势</p>
<ol>
<li><p>和美术协作比较方便</p>
</li>
<li><p>显卡性能也有保障</p>
</li>
<li><p>设备性价比高</p>
</li>
<li></li>
</ol>
</li>
</ol>
<p>MacOS的优劣</p>
<ol>
<li><p>优势</p>
<ol>
<li><p>出包或者做平台关联 api。 有时候要导出 xcode 项目，需要在 xcode 里写代码。</p>
</li>
<li><p>好看逼格高系统舒服</p>
</li>
</ol>
</li>
<li><p>设备成本较高。同等价位设备性能较差</p>
</li>
</ol>
<p>主要使用windows 开发，mac 打包</p>
<p>参考讨论：<a href="https://www.v2ex.com/t/670347" target="_blank" rel="noopener">https://www.v2ex.com/t/670347</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-YAML"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-YAML/"
    >YAML</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-YAML/" class="article-date">
  <time datetime="2023-07-25T12:56:23.327Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>YAML TAG： <a href="https://stackoverflow.com/questions/15233335/i-dont-understand-what-a-yaml-tag-is" target="_blank" rel="noopener">https://stackoverflow.com/questions/15233335/i-dont-understand-what-a-yaml-tag-is</a></p>
<p>YAML 文档：<a href="https://yaml.org/spec/1.2.2/#rule-ns-tag-directive" target="_blank" rel="noopener">https://yaml.org/spec/1.2.2/#rule-ns-tag-directive</a></p>
<p>YAML 博客：<a href="https://www.jianshu.com/p/20c3cde0f189" target="_blank" rel="noopener">https://www.jianshu.com/p/20c3cde0f189</a></p>
<p>Unity YAML解析方案：<a href="https://stackoverflow.com/questions/21473076/pyyaml-and-unusual-tags" target="_blank" rel="noopener">https://stackoverflow.com/questions/21473076/pyyaml-and-unusual-tags</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity线上技术大会"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Unity%E7%BA%BF%E4%B8%8A%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A/"
    >Unity线上技术大会</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Unity%E7%BA%BF%E4%B8%8A%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A/" class="article-date">
  <time datetime="2023-07-25T12:56:23.301Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="Unity线上技术大会/1605524504449.png" alt="Alt text"></p>
<p><img src="Unity线上技术大会/1605526082081.png" alt="Alt text"></p>
<p><img src="Unity线上技术大会/1605526188199.png" alt="Alt text"></p>
<p>Unity</p>
<h3 id="ShaderProfiler"><a href="#ShaderProfiler" class="headerlink" title="ShaderProfiler"></a>ShaderProfiler</h3><p>capture<br>看到当前Active的shader<br>subshader<br>variant</p>
<h3 id="AssetBundle加密方案"><a href="#AssetBundle加密方案" class="headerlink" title="AssetBundle加密方案"></a>AssetBundle加密方案</h3><h3 id="instant-game"><a href="#instant-game" class="headerlink" title="instant game"></a>instant game</h3><p>安装包降低<br>资源打包成独立的AssetBundle，单个包大小不超过1MB<br>视线内的资源优先加载。</p>
<h3 id="Windup"><a href="#Windup" class="headerlink" title="Windup"></a>Windup</h3><p><img src="Unity线上技术大会/1605527989245.png" alt="Alt text"></p>
<p><img src="Unity线上技术大会/1605528077501.png" alt="Alt text"></p>
<p><img src="Unity线上技术大会/1605528097381.png" alt="Alt text"></p>
<p><img src="Unity线上技术大会/1605528110907.png" alt="Alt text"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity相关Culling知识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Unity%E7%9B%B8%E5%85%B3Culling%E7%9F%A5%E8%AF%86/"
    >Unity相关Culling知识</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Unity%E7%9B%B8%E5%85%B3Culling%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2023-07-25T12:56:23.300Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Frustum Culling</p>
<p>剔除被其他物体遮挡的，摄像机不可见(但在视锥体内)的渲染物体。使用 Occlusion Culling 需要手动设置，并在 Occlusion Culling Window 中通过 Bake 计算剔除数据。</p>
<p><a href="https://docs.unity3d.com/Manual/OcclusionCulling.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/OcclusionCulling.html</a></p>
<p> <strong>Builtin管线</strong></p>
<p>视锥体剔除 - 视锥体剔除是引擎自己做的，在给GPU提交数据进行渲染前，会执行视锥体剔除，决定哪些可见哪些不可见。经过剔除之后，Renderer的isVisible值就表示相应物体的可见性，不过此时已经在这帧的Update之后了。在Update当中取IsVisible属性获取的实际上是上一帧的可见性。 至于视锥体剔除的实现方法我们不清楚，可能引擎底层会有一些优化，使用kd-tree进行空间划分等等。</p>
<p> <strong>SRP的Culling：</strong></p>
<ol>
<li><p>SRP的Culling可以自己写</p>
</li>
<li><p>URP的管线相对比较固定，可定制化程度低，Culling不太好自己写</p>
</li>
</ol>
<p>Occlusion Culling is different from Frustum Culling. Frustum Culling only disables the renderers for objects that are outside the camera’s viewing area but does not disable anything hidden from view by overdraw. Note that when you use Occlusion Culling you will still benefit from Frustum Culling.</p>
<p>Occlusion Culling </p>
<p>在移动端使用的比较少，属于用 CPU时间换一定的CPU时间和一定的GPU时间的操作。使用方法是：预先烘焙遮挡剔除信息（对于一定的区域，哪些物体被遮挡），在游戏运行时，经过视锥体剔除之后，对于视锥体内的物体，相机到了一定的位置，会去取预先烘焙的信息，来判断哪些物体被遮挡，对相应的物体进行剔除，进而节省被遮挡的物体提交渲染进行、在GPU端进行绘制的时间。</p>
<p>Camera.layerCullDistance</p>
<p>For performance reasons, you might want to cull small objects earlier. For example, small rocks and debris could be made invisible at much smaller distance than large buildings. To do that, put small objects into a separate layer and set up per-layer cull distances using Camera.layerCullDistances script function.</p>
<p><a href="https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html</a></p>
<p>CullingGroup API</p>
<p>CullingGroup offers a way to integrate your own systems into Unity’s culling and LOD pipeline.The CullingGroup will calculate visibility based on frustum culling and static occlusion culling only. It will not take dynamic objects into account as potential occluders.</p>
<p><a href="https://docs.unity3d.com/Manual/CullingGroupAPI.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/CullingGroupAPI.html</a></p>
<p>Unity的CullingGroup API是纯逻辑的东西，不影响渲染。其使用方法是：在逻辑代码中定义CullingGroup，Group中加入一些球体(位置与半径，是逻辑上的球体，实际是不可见的)，并加入要检测的相机，渲染时，Unity会判断这些球体是否可见，进而判断CullingGroup的可见性。在渲染之后，可以在代码中获取该Group的可见性，进而据此控制一些逻辑。如果不用代码去取CullingGroup的信息，那么它就是没有用的。</p>
<p>ref: <a href="https://blog.csdn.net/kenight/article/details/82760667" target="_blank" rel="noopener">https://blog.csdn.net/kenight/article/details/82760667</a></p>
<p>使用Unity提供的API自己实现视锥体剔除逻辑：</p>
<p>using System.Collections.Generic;</p>
<p>using UnityEditor;</p>
<p>using UnityEngine;</p>
<p>using System.Linq;</p>
<p>public class FrustumTest : MonoBehaviour</p>
<p>{</p>
<p>public Camera CulingCamera;</p>
<p>public Renderer[] CullingTestObjects;</p>
<p>private Plane[] planes;</p>
<p>void OnEnable()</p>
<p>{</p>
<p>planes = new Plane[6];</p>
<p>}</p>
<p>void Update()</p>
<p>{</p>
<p>GeometryUtility.CalculateFrustumPlanes(CulingCamera, planes);</p>
<p>for (var index = 0; index &lt; CullingTestObjects.Length; index++)</p>
<p>{</p>
<p>var bounds = CullingTestObjects[index].bounds;</p>
<p>var result = GeometryUtility.TestPlanesAABB(planes, bounds);</p>
<p>CullingTestObjects[index].enabled = result;</p>
<p>}</p>
<p>}</p>
<p>[MenuItem(“Test/Create”)]</p>
<p>static void Create()</p>
<p>{</p>
<p>var gos = new List<GameObject>();</p>
<p>var root = new GameObject(“Root”).transform;</p>
<p>for (var i = 0; i &lt; 10; i++)</p>
<p>{</p>
<p>for (var j = 0; j &lt; 10; j++)</p>
<p>{</p>
<p>for (var k = 0; k &lt; 10; k++)</p>
<p>{</p>
<p>var go = GameObject.CreatePrimitive(PrimitiveType.Cube);</p>
<p>go.transform.position = new Vector3(i, j, k) * 2;</p>
<p>go.transform.parent = root;</p>
<p>gos.Add(go);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>var test = new GameObject(“FrustumTest”).AddComponent<FrustumTest>();</p>
<p>test.CulingCamera = Camera.main;</p>
<p>test.CullingTestObjects = gos.Select(item =&gt; item.GetComponent<Renderer>()).ToArray();</p>
<p>}</p>
<p>}</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity的渲染顺序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Unity%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/"
    >Unity的渲染顺序</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Unity%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/" class="article-date">
  <time datetime="2023-07-25T12:56:23.296Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="决定渲染顺序的因素"><a href="#决定渲染顺序的因素" class="headerlink" title="决定渲染顺序的因素"></a>决定渲染顺序的因素</h2><p><img src="Unity的渲染顺序/1617976734905.png" alt="Alt text"></p>
<h3 id="Camera-Depth"><a href="#Camera-Depth" class="headerlink" title="Camera Depth"></a>Camera Depth</h3><p>按照Camera的Depth值从低到高的顺序，逐个Camera进行渲染。</p>
<p><img src="Unity的渲染顺序/1617962792081.png" alt="Alt text"></p>
<p>每个Camera绘制的内容可以在CullingMask当中设置——设置绘制哪些Layers的物体</p>
<p><img src="Unity的渲染顺序/1617962839947.png" alt="Alt text"></p>
<p>物体的Layer可以在Inspector面板进行设置。</p>
<p><img src="Unity的渲染顺序/1617962903268.png" alt="Alt text"></p>
<h3 id="Opaque-Skybox-Transparent"><a href="#Opaque-Skybox-Transparent" class="headerlink" title="Opaque-Skybox-Transparent"></a>Opaque-Skybox-Transparent</h3><p>Queue&lt;=2500 - Opaque<br>Queue&gt;=2501 - Transparent</p>
<h3 id="Sorting-Layers-Order-in-Layer"><a href="#Sorting-Layers-Order-in-Layer" class="headerlink" title="Sorting Layers + Order in Layer"></a>Sorting Layers + Order in Layer</h3><p>可在Project Settings-&gt;Tags and Layers-&gt;SortingLayers中添加Layer。</p>
<p><img src="Unity的渲染顺序/1617975393846.png" alt="Alt text"></p>
<p>在ParticleSystem、Sprite等Unity动态生成网格的Component中设置Sorting Layer与Order in Layer，来决定物体绘制的顺序，绘制时按从小到大排序。</p>
<p><img src="Unity的渲染顺序/1617976086216.png" alt="Alt text"></p>
<p><img src="Unity的渲染顺序/1617976104615.png" alt="Alt text"></p>
<h3 id="RenderQueue"><a href="#RenderQueue" class="headerlink" title="RenderQueue"></a>RenderQueue</h3><p>RenderQueure是Material的一个属性。<br>按照渲染队列，从低到高绘制。</p>
<p>Background (1000) - rendered before any others. You’d typically use this for things that really need to be in the background.</p>
<p>Geometry (default) (2000) - this is used for most objects. Opaque geometry uses this queue.</p>
<p>AlphaTest (2450) - alpha tested geometry uses this queue. It’s a separate queue from Geometry one since it’s more efficient to render alpha-tested objects after all solid ones are drawn.</p>
<p>Transparent (3000) - this render queue is rendered after Geometry and AlphaTest, in back-to-front order. Anything alpha-blended (i.e. shaders that don’t write to depth buffer) should go here (glass, particle effects).</p>
<p>Overlay (4000) - this render queue is meant for overlay effects. Anything rendered last should go here (e.g. lens flares, UI).</p>
<h3 id="Sorting-Fudge"><a href="#Sorting-Fudge" class="headerlink" title="Sorting Fudge"></a>Sorting Fudge</h3><p>Particle System组件还有一个属性：Sorting Fudge，在其他值都相同时，这个值会影响绘制的先后顺序，值比较高的先绘制。</p>
<p><img src="Unity的渲染顺序/1617976537790.png" alt="Alt text"></p>
<h3 id="深度排序"><a href="#深度排序" class="headerlink" title="深度排序"></a>深度排序</h3><p>按照 <strong>包围盒</strong> 中心点的深度进行排序</p>
<ul>
<li><p>不透明物体 - 由近到远（从前向后）</p>
</li>
<li><p>透明物体 - 由远到近（从后向前）</p>
</li>
</ul>
<h2 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h2><h3 id="明确分层"><a href="#明确分层" class="headerlink" title="明确分层"></a>明确分层</h3><p>例如UI上的半透明（特效、面片）始终在3D场景之上，则一般分多个相机来绘制。<br>大片填充率的物件，例如地形，天空等，一般为提高深度命中，都会选择在延后批次绘制。<br>Draw character before the terrain.</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/55762351" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55762351</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity的架构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Unity%E7%9A%84%E6%9E%B6%E6%9E%84/"
    >Unity的架构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Unity%E7%9A%84%E6%9E%B6%E6%9E%84/" class="article-date">
  <time datetime="2023-07-25T12:56:23.296Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><p>Unity当中渲染的部分是用C++执行的<br>Mono是Unity运行过程中的一部分，负责在特定的时间编译C#脚本，运行C#程序集。<br>所以，操作系统之上是基于C++的Unity程序，在Unity当中的一部分是Mono，Mono负责Unity当中与C#相关的部分。</p>
<p>整个Unity程序的运行是基于一帧一帧的刷新来进行的。<br>如果在一帧当中，调用了一个耗时比较长的函数，整个程序就会卡在这一帧，直到这个函数调用结束。<br>在编辑器模式下，通过MenuItem调用一个函数，就是在一帧里面进行函数调用，这个函数耗时比较长，这一帧就会等待这个函数调用完再刷新。</p>
<p>Unity当中有些程序是支持多线程的，比如烘培操作，烘培的时候，会在右下角开一个进度条，但是Game界面的程序还是会不断地一帧一帧刷新，不会阻塞，就是在多个线程下运行的结果。</p>
<p>在Mono之上是整个C#环境，Unity在运行时，C#环境就一直在内存当中运行的。</p>
<h2 id="关于异常"><a href="#关于异常" class="headerlink" title="关于异常"></a>关于异常</h2><p>在脚本运行的时候，抛出异常，会一层一层往上抛。<br>异常被try catch时，如果catch到，那么try当中的代码就会跳过。也就是说，被try的函数就会在异常出终止，进而从catch语句块之后的代码开始继续运行。</p>
<p>如果自己写的程序不catch这个异常，那么这个异常会最终被Unity catch到，那么，Unity调用的我写的整个函数，就会终止掉。而实际上，整个C#的程序是没有终止的，Unity的C#程序还在内存当中，与我自己catch到异常没有本质的区别。而且，出异常的函数所分配的资源，如果不写代码释放掉，就没有其他好办法来释放了。因为这部分资源是在Unity的C#环境中的，只有重启整个Unity，才能强制释放。</p>
<p>如果某个脚本索引了一个文件流，由于文件流没有被释放而造成文件被锁、无法重新打开，可以对这个脚本进行reimport，Why？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity渲染相关API"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Unity%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3API/"
    >Unity渲染相关API</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Unity%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3API/" class="article-date">
  <time datetime="2023-07-25T12:56:23.295Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>从引擎提供的接口的层面去看渲染相关知识体系。</p>
<h2 id="CommandBuffer"><a href="#CommandBuffer" class="headerlink" title="CommandBuffer"></a>CommandBuffer</h2><p>List of graphics commands(rendering commands - “set render target, draw mesh, …”) to execute. </p>
<blockquote>
<p>Command Buffers - <strong>“list of things to do” buffers</strong></p>
</blockquote>
<p>Command buffers can be created and then executed many times if needed.<br>Typically they would be used to extend Unity’s rendering pipeline in some custom ways. For example, you could render some additional objects into deferred rendering g-buffer after all regular objects are done, or do custom processing of light shadow maps. </p>
<p>相关API：</p>
<ul>
<li><p>Camera.AddCommandBuffer</p>
</li>
<li><p>Light.AddCommandBuffer</p>
</li>
<li><p>Graphics.ExecuteCommandBuffer</p>
</li>
</ul>
<p>Some of its Public Methods：</p>
<ul>
<li><p>Blit - Add a “blit into a render texture” command.(Note that Blit changes the currently active render target. After Blit executes, dest becomes the active render target.)</p>
</li>
<li><p>DrawMesh - Add a “draw mesh” command.</p>
</li>
<li><p>DrawMeshInstanced</p>
</li>
<li><p>SetComputeBufferParam - Adds a command to set an input or output buffer parameter on a ComputeShader.</p>
</li>
<li><p>DrawRenderer - Add a “draw renderer” command.</p>
</li>
</ul>
<h3 id="low-level-amp-high-level-command-buffer"><a href="#low-level-amp-high-level-command-buffer" class="headerlink" title="low-level &amp; high-level command buffer"></a>low-level &amp; high-level command buffer</h3><p><strong>A command buffer in graphics</strong> is a low-level list of commands to execute. For example, 3D rendering APIs like Direct3D or OpenGL typically end up constructing a command buffer that is then executed by the GPU. Unity’s multi-threaded renderer also constructs a command buffer between a calling thread and the “worker thread” that submits commands to the rendering API.</p>
<p><strong>In Unity scripting API</strong> , the “commands” are somewhat higher level. Instead of containing things like “set internal GPU register X to value Y”, the commands are “Draw this mesh with that material” and so on.</p>
<p>For example, you could render some additional objects into deferred shading G-buffer after all regular objects are done. Or render some clouds immediately after skybox is drawn, but before anything else. Or render custom lights (volume lights, negative lights etc.) into deferred shading light buffer after all regular lights are done. And so on; we think there are a lot of interesting ways to use them.</p>
<h2 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a>Renderer</h2><p>A renderer is what makes an object appear on the screen. Use this class to access the renderer of any object, mesh or Particle System. Renderers can be disabled to make objects invisible, and the materials can be accessed and modified through them. </p>
<p>Some of its Properties:</p>
<ul>
<li><p>bounds </p>
</li>
<li><p>isVisible </p>
</li>
<li><p>lightmapIndex </p>
</li>
<li><p>sharedMaterial </p>
</li>
<li><p>sortingOrder </p>
</li>
<li><p>worldToLocalMatrix </p>
</li>
</ul>
<p>Public Methods:</p>
<ul>
<li><p>GetPropertyBlock </p>
</li>
<li><p>SetPropertyBlock </p>
</li>
</ul>
<p>Messages:</p>
<ul>
<li><p>OnBecameVisible </p>
</li>
<li><p>OnBecameInvisible </p>
</li>
</ul>
<h3 id="Mesh-Renderer"><a href="#Mesh-Renderer" class="headerlink" title="Mesh Renderer"></a>Mesh Renderer</h3><ul>
<li><p>Mesh Renderer</p>
</li>
<li><p>Materials</p>
</li>
<li><p>Lighting</p>
</li>
<li><p>Lightmapping</p>
</li>
</ul>
<h3 id="Line-Renderer"><a href="#Line-Renderer" class="headerlink" title="Line Renderer"></a>Line Renderer</h3><p>The Line Renderer component takes an array of two or more points in 3D space, and draws a straight line between each one. You can use a Line Renderer to draw anything from a simple straight line to a complex spiral.</p>
<h3 id="Trail-Renderer"><a href="#Trail-Renderer" class="headerlink" title="Trail Renderer"></a>Trail Renderer</h3><p>The Trail Renderer component renders a trail of polygons behind a moving GameObject. This can be used to give an emphasized feeling of motion to a moving object, or to highlight the path or position of moving objects. </p>
<h2 id="RenderBuffer"><a href="#RenderBuffer" class="headerlink" title="RenderBuffer"></a>RenderBuffer</h2><p>Color or depth buffer part of a RenderTexture.</p>
<p>RenderTexture = RenderBuffer combination.</p>
<p>A single RenderTexture object represents both color and depth buffers, but many complex rendering algorithms require using the same depth buffer with multiple color buffers or vice versa.</p>
<p>Related API</p>
<ul>
<li><p>RenderTexture.colorBuffer</p>
</li>
<li><p>RenderTexture.depthBuffer</p>
</li>
<li><p>Graphics.activeColorBuffer</p>
</li>
<li><p>Graphics.activeDepthBuffer</p>
</li>
<li><p>Graphics.SetRenderTarget.</p>
</li>
</ul>
<h2 id="RenderTexture"><a href="#RenderTexture" class="headerlink" title="RenderTexture"></a>RenderTexture</h2><p>Render textures are textures that can be rendered to.<br>They can be used to implement image based rendering effects, dynamic shadows, projectors, reflections or surveillance cameras.</p>
<p>RenderTexture是unity定义的一种特殊的Texture类型,它是连接着一个FrameBufferObject的存在于GPU端的Texture(Server-Side Texture)</p>
<p>One typical usage of render textures is setting them as the “target texture” property of a Camera (Camera.targetTexture), this will make a camera render into a texture instead of rendering to the screen.</p>
<p>Static Properties:</p>
<ul>
<li><p>antiAliasing </p>
</li>
<li><p>colorBuffer </p>
</li>
<li><p>depthBuffer</p>
</li>
<li><p>sRGB </p>
</li>
<li><p>useMipMap </p>
</li>
</ul>
<p>Public Methods:</p>
<ul>
<li><p>Create </p>
</li>
<li><p>GenerateMips </p>
</li>
<li><p>IsCreated </p>
</li>
<li><p>Release </p>
</li>
</ul>
<p>Static Methods:</p>
<ul>
<li><p>GetTemporary </p>
</li>
<li><p>ReleaseTemporary </p>
</li>
</ul>
<h3 id="RenderTexture-active"><a href="#RenderTexture-active" class="headerlink" title="RenderTexture.active"></a>RenderTexture.active</h3><p>Currently active render texture.<br>All rendering goes into the active RenderTexture. If the active RenderTexture is null everything is rendered in the main window.</p>
<p>Setting RenderTexture.active is the same as calling Graphics.SetRenderTarget. </p>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

// Get the contents of a RenderTexture into a Texture2D

public class ExampleClass : MonoBehaviour

{ 

static public Texture2D GetRTPixels(RenderTexture rt)

{ 

// Remember currently active render texture

RenderTexture currentActiveRT = RenderTexture.active; 

// Set the supplied RenderTexture as the active one

RenderTexture.active = rt; 

// Create a new Texture2D and read the RenderTexture image into it

Texture2D tex = new Texture2D(rt.width, rt.height); 

tex.ReadPixels(new Rect(0, 0, tex.width, tex.height), 0, 0); 

// Restorie previously active render texture

RenderTexture.active = currentActiveRT; 

return tex; 

} 

}
</code></pre>
<h2 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h2><p>Raw interface to Unity’s drawing functions.<br>This is the high-level shortcut into the optimized mesh drawing functionality of Unity.</p>
<p>Static Properties</p>
<ul>
<li><p>activeColorBuffer - Currently active color buffer (Read Only).</p>
</li>
<li><p>activeColorGamut - Returns the currently active color gamut.</p>
</li>
<li><p>activeDepthBuffer - Currently active depth/stencil buffer (Read Only).</p>
</li>
</ul>
<p>Static Methods</p>
<ul>
<li><p>Blit(位块传送) - Copies source texture into destination render texture with a shader.</p>
</li>
<li><p>DrawMesh - Draw a mesh.</p>
</li>
<li><p>DrawMeshInstanced - Draw the same mesh multiple times using GPU instancing.</p>
</li>
<li><p>DrawMeshInstancedIndirect - Draw the same mesh multiple times using GPU instancing.</p>
</li>
<li><p>DrawMeshInstancedProcedural - Draw the same mesh multiple times using GPU instancing. This is similar to Graphics.DrawMeshInstancedIndirect, except when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.</p>
</li>
<li><p>DrawMeshNow - Draw a mesh immediately.</p>
</li>
<li><p>DrawTexture - Draw a texture in screen coordinates.</p>
</li>
<li><p>ExecuteCommandBuffer - Execute a command buffer.</p>
</li>
</ul>
<h3 id="Graphics-Blit"><a href="#Graphics-Blit" class="headerlink" title="Graphics.Blit"></a>Graphics.Blit</h3><p>Copies source texture into destination render texture with a shader.<br>Blit sets dest as the render target, sets source <strong>_MainTex</strong> property on the <strong>material</strong> , and draws a full-screen quad.</p>
<p>This is mostly used for implementing post-processing effects.</p>
<p>If you are using the Built-in Render Pipeline, when dest is null, Unity uses the screen backbuffer as the blit destination. However, if the main camera is set to render to a RenderTexture (that is, if Camera.main has a non-null targetTexture property), the blit uses the render target of the main camera as destination.<br>If you are using a Scriptable Render Pipeline (like HDRP or Universal RP), to blit to the screen backbuffer using Graphics.Blit, you have to call Graphics.Blit from inside a method that you register as the RenderPipelineManager.endFrameRendering callback.</p>
<p>Note that if you want to use a depth or stencil buffer that is part of the source (Render)texture, you have to manually write an equivalent of the Graphics.Blit function - i.e. Graphics.SetRenderTarget with destination color buffer and source depth buffer, setup orthographic projection (GL.LoadOrtho), setup material pass (Material.SetPass) and draw a quad (GL.Begin).</p>
<p>Graphics.Blit changes RenderTexture.active. Keep track of the previously active RenderTexture if you need to use it after calling Graphics.Blit.</p>
<h3 id="Graphics-SetRenderTarget"><a href="#Graphics-SetRenderTarget" class="headerlink" title="Graphics.SetRenderTarget"></a>Graphics.SetRenderTarget</h3><p>This function sets which RenderTexture or a RenderBuffer combination will be rendered into next.<br>Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually.</p>
<p>Calling SetRenderTarget with just a RenderTexture argument is the same as setting RenderTexture.active property.</p>
<h3 id="Graphics-DrawMeshInstanced"><a href="#Graphics-DrawMeshInstanced" class="headerlink" title="Graphics.DrawMeshInstanced"></a>Graphics.DrawMeshInstanced</h3><p>Draw the same mesh multiple times using GPU instancing.</p>
<blockquote>
<p>Similar to Graphics.DrawMesh, this function draws meshes for one frame without the overhead of creating unnecessary game objects.</p>
</blockquote>
<p>The transformation matrix of each instance of the mesh should be packed into the matrices array. You can specify the number of instances to draw, or by default it is the length of the matrices array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using SetFloatArray, SetVectorArray and SetMatrixArray.</p>
<p><img src="Unity渲染相关API/1607334545990.png" alt="Alt text"></p>
<p>Note: You can only draw a maximum of 1023 instances at once.</p>
<h3 id="Graphics-DrawMeshInstancedIndirect"><a href="#Graphics-DrawMeshInstancedIndirect" class="headerlink" title="Graphics.DrawMeshInstancedIndirect"></a>Graphics.DrawMeshInstancedIndirect</h3><p>Similar to Graphics.DrawMeshInstanced, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from bufferWithArgs.</p>
<h2 id="GL"><a href="#GL" class="headerlink" title="GL"></a>GL</h2><p>Low-level graphics library.<br>Note that in almost all cases using Graphics.DrawMesh or CommandBuffer is more efficient than using immediate mode drawing.</p>
<p>GL immediate drawing functions use whatever is the “current material” set up right now (see Material.SetPass). The material controls how the rendering is done (blending, textures, etc.), so unless you explicitly set it to something before using GL draw functions, the material can happen to be anything. Also, if you call any other drawing commands from inside GL drawing code, they can set material to something else, so make sure it’s under control as well.</p>
<p>GL drawing commands execute immediately. That means if you call them in Update(), they will be executed before the camera is rendered (and the camera will most likely clear the screen, making the GL drawing not visible).</p>
<p>The usual place to call GL drawing is most often in OnPostRender() from a script attached to a camera, or inside an image effect function (OnRenderImage).</p>
<h2 id="Matrix4x4"><a href="#Matrix4x4" class="headerlink" title="Matrix4x4"></a>Matrix4x4</h2><p>A standard 4x4 transformation matrix.<br>A transformation matrix can perform arbitrary linear 3D transformations (i.e. translation, rotation, scale, shear etc.) and perspective transformations using homogenous coordinates. </p>
<p>Matrices in Unity are column major. - 列优先存储（不同于GLSL的行优先）</p>
<h3 id="Matrix4x4-TRS"><a href="#Matrix4x4-TRS" class="headerlink" title="Matrix4x4.TRS"></a>Matrix4x4.TRS</h3><pre><code class="lang-csharp">
public static Matrix4x4 TRS(Vector3 pos, Quaternion q, Vector3 s);
</code></pre>
<p>Creates a translation, rotation and scaling matrix.</p>
<p>The returned matrix is such that it places objects at position pos, oriented in rotation q and scaled by s.</p>
<h2 id="Quaternion"><a href="#Quaternion" class="headerlink" title="Quaternion"></a>Quaternion</h2><h3 id="Quaternion-LookRotation"><a href="#Quaternion-LookRotation" class="headerlink" title="Quaternion.LookRotation"></a>Quaternion.LookRotation</h3><p>Creates a rotation with the specified forward and upwards directions.</p>
<p>Z axis will be aligned with forward, X axis aligned with cross product between forward and upwards, and Y axis aligned with cross product between Z and X.</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Unity Documentation<br><a href="https://www.jianshu.com/p/fa73c0f6762d" target="_blank" rel="noopener">https://www.jianshu.com/p/fa73c0f6762d</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity场景管理和切换"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Unity%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%88%87%E6%8D%A2/"
    >Unity场景管理和切换</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Unity%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%88%87%E6%8D%A2/" class="article-date">
  <time datetime="2023-07-25T12:56:23.294Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="关于yield-return"><a href="#关于yield-return" class="headerlink" title="关于yield return"></a>关于yield return</h2><p>对于yield return，目前我还无法深入理解其底层实现原理，无法看懂他编译成的IL代码。但是目前可以理解他的使用方法与机制。<br>yield return会每次返回后记录返回的位置，待等待的时间到了之后，从返回的位置继续往下执行。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="SceneManager-LoadScene"><a href="#SceneManager-LoadScene" class="headerlink" title="SceneManager.LoadScene"></a>SceneManager.LoadScene</h3><p>When using SceneManager.LoadScene, the scene <strong>loads in the next frame</strong> , that is it does not load immediately. This <strong>semi-asynchronous</strong> behavior can cause frame stuttering and can be confusing because load does not complete immediately.</p>
<p>Because loading is set to complete in the next rendered frame, calling SceneManager.LoadScene forces all previous AsyncOperations to complete, even if AsyncOperation.allowSceneActivation is set to false.</p>
<blockquote>
<p>如果场景名称重复，路径不同：<br> The given sceneName can either be the Scene name only, without the .unity extension, or the path as shown in the BuildSettings window still without the .unity extension. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with the same name but different paths, you should use the full path.</p>
</blockquote>
<h4 id="切换时相关Mono内存问题"><a href="#切换时相关Mono内存问题" class="headerlink" title="切换时相关Mono内存问题"></a>切换时相关Mono内存问题</h4><p>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.<br>Destroy掉前一个场景中的GameObject，如果GameObject上挂载的Monobehaviour没有被其他地方引用的话，调用GC.Collect()会回收掉他占用的内存。</p>
<p>虽然GameObject被Destroy掉了， 如果Monobehaviour被其他在场景切换时无法销毁的对象所引用，那么其Mono层的对象是无法被回收的。比如：MonoBehaviour类中的某个函数注册了SceneManager类的sceneLoaded事件，那么这个对象就被SceneManager静态地引用了，该对象就无法销毁，Mono层的内存就无法释放。</p>
<h3 id="LoadSceneMode"><a href="#LoadSceneMode" class="headerlink" title="LoadSceneMode"></a>LoadSceneMode</h3><p>(TODO: 是否会自动卸载，有待验证)<br>使用Single模式，关闭已经加载的所有场景（不是卸载，卸载是另一个函数 —— UnloadSceneAsync()），只加载一个新场景，新场景被添加到SceneManager的目录中。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>SetActiveScene() 激活已加载的场景，如果场景未加载，返回false。</p>
<p>GetActiveScene() 获取已激活的场景。</p>
<p>CreateScene() 运行时创建一个新场景。</p>
<p>MergeScenes(SceneManagement.Scene sourceScene, SceneManagement.Scene destinationScene) 将源场景的内容合并到目标场景中，并删除源场景。 源场景根目录下的所有游戏对象都将移动到目标场景的根目录。需要注意的是，该函数具有破坏性 —— 合并完成后，源场景将被销毁。</p>
<p>MoveGameObjectToScene()<br>将GameObject从其当前场景移动到新场景。<br>只能将根游戏对象从一个场景移动到另一个场景。 这意味着要移动的GameObject不能是其场景中任何其他GameObject的子对象。 这仅适用于将GameObjects移动到已加载的场景（LoadSceneMode.Additive）。 如果要加载单个场景，请确保在要移动到新场景的GameObject上使用DontDestroyOnLoad，否则Unity会在加载新场景时删除它。</p>
<p>UnloadSceneAsync()<br>销毁与给定场景关联的所有GameObject，并从SceneManager中移除场景。给定的场景名称可以是完整的场景路径，“构建设置”窗口中显示的路径，也可以是场景名称。<br>注意：</p>
<ol>
<li><p>由于它是异步的，因此无法保证完成时间。</p>
</li>
<li><p>资产目前尚未卸载。 为了释放资产内存，可以调用 Resources.UnloadUnusedAssets() 。</p>
</li>
<li><p>如果没有要加载的场景，则无法使用 UnloadSceneAsync() 。 </p>
</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="进度条异步加载场景"><a href="#进度条异步加载场景" class="headerlink" title="进度条异步加载场景"></a>进度条异步加载场景</h3><p>AsyncOperation的progress（0-1）属性在allowSceneActivation 为false时，最大加载到0.9就会暂停，直到allowSceneActivation 为true时才会继续加载0.9-1.0的这10%。<br>直到progress = 1.0时 isDone = true。</p>
<blockquote>
<p>在Unity编辑器模式下是看不出来进度条正常变化的，只有导出项目后才能看到正常进度条</p>
</blockquote>
<pre><code class="lang-csharp">
using System.Collections; 

using System.Collections.Generic; 

using UnityEngine; 

using UnityEngine.UI; 

using UnityEngine.SceneManagement; 

public class LoadSceneProgressBar : MonoBehaviour

{ 

private Slider _progress; 

void Awake()

{ 

_progress = GetComponent&lt;Slider&gt;(); 

} 

//使用协程

void Update()

{ 

if(Input.GetKeyDown(KeyCode.Space)) 

StartCoroutine(LoadScene()); 

} 

IEnumerator LoadScene()

{ 

//用Slider 展示的数值

int disableProgress = 0; 

int toProgress = 0; 

//异步场景切换

AsyncOperation op = SceneManager.LoadSceneAsync(&quot;MainScene_DayLight&quot;); 

//不允许有场景切换功能

op.allowSceneActivation = false; 

//op.progress 只能获取到90%，最后10%获取不到，需要自己处理

while (op.progress &lt; 0.9f) 

{ 

//获取真实的加载进度

toProgress = (int)(op.progress * 100); 

while (disableProgress &lt; toProgress) 

{ 

++disableProgress; 

_progress.value = disableProgress / 100.0f;//0.01开始

yield return new WaitForEndOfFrame(); 

} 

} 

//因为op.progress 只能获取到90%，所以后面的值不是实际的场景加载值了，90~100之间的是假进度条。

toProgress = 100; 

while (disableProgress &lt; toProgress) 

{ 

++disableProgress; 

_progress.value = disableProgress / 100.0f; 

yield return new WaitForEndOfFrame(); 

} 

op.allowSceneActivation = true; 

} 

}
</code></pre>
<p>对于LoadSceneAsync，如果不使用yield return，也会在后台线程自动完成异步加载，只是无法一帧一帧获取当前的加载进度，无法实现加载完之后调用的逻辑。<br>通过while+yield return的方式，是为了保证每帧执行一次while中的语句块，从而监控加载过程，并在加载结束后触发相应的逻辑。</p>
<h3 id="从AssetBundle加载场景"><a href="#从AssetBundle加载场景" class="headerlink" title="从AssetBundle加载场景"></a>从AssetBundle加载场景</h3><pre><code class="lang-csharp">
// Load an assetbundle which contains Scenes.

// When the user clicks a button the first Scene in the assetbundle is

// loaded and replaces the current Scene.

using UnityEngine; 

using UnityEngine.SceneManagement; 

public class LoadScene : MonoBehaviour

{ 

private AssetBundle myLoadedAssetBundle; 

private string[] scenePaths; 

// Use this for initialization

void Start()

{ 

myLoadedAssetBundle = AssetBundle.LoadFromFile(&quot;Assets/AssetBundles/scenes&quot;); 

scenePaths = myLoadedAssetBundle.GetAllScenePaths(); 

} 

void OnGUI()

{ 

if (GUI.Button(new Rect(10, 10, 100, 30), &quot;Change Scene&quot;)) 

{ 

Debug.Log(&quot;Scene2 loading: &quot; \+ scenePaths[0]); 

SceneManager.LoadScene(scenePaths[0], LoadSceneMode.Single); 

} 

} 

}
</code></pre>
<h3 id="分组加载卸载场景"><a href="#分组加载卸载场景" class="headerlink" title="分组加载卸载场景"></a>分组加载卸载场景</h3><pre><code class="lang-csharp">
/**************************************************************************

Copyright:@maxdong

Author: maxdong

Date: 2017-07-04

Description:加载关卡，可以分组加载和卸载。使用Unity版本为5.3.0.

因为里面使用了场景管理的一个类，这个类在5.3.0以上版本才添加的。

测试操作：使用空格键来切换场景，然后间隔5秒后才开始卸载。

**************************************************************************/

using UnityEngine; 

using System.Collections; 

using UnityEngine.SceneManagement; 

[System.Serializable] 

public class LevelOrder

{ 

[Header(&quot;每组关卡名称&quot;)] 

public string[] LevelNames; 

} 

public class ChangLevelsHasMain : MonoBehaviour

{ 

[Header(&quot;所有关卡列表&quot;)] 

public LevelOrder[] levelOrder; 

private static int index; 

private int totalLevels = 0; 

private int levelOrderLength; 

void Start ()

{ 

for (int i = 0; i &lt; levelOrder.Length; i++) 

{ 

totalLevels += levelOrder[i].LevelNames.Length; 

} 

if (totalLevels != SceneManager.sceneCountInBuildSettings) 

{ 

} 

levelOrderLength = levelOrder.Length; 

} 

// Update is called once per frame

void Update ()

{ 

if (Input.GetKeyDown(KeyCode.Space)) 

{ 

bool isOk = LoadNextLevels(); 

if (isOk) 

{ 

InvokeRepeating(&quot;UnloadLastLevel&quot;, 2.0f, 5); 

} 

} 

} 

bool LoadNextLevels()

{ 

bool bResult = true; 

//index = index % levelOrderLength;

if (index &lt; 0 || index &gt;= levelOrderLength) 

{ 

bResult = false; 

return bResult; 

} 

int LoadTimes = levelOrder[index].LevelNames.Length; 

for (int i = 0; i &lt; LoadTimes; i++) 

{ 

SceneManager.LoadSceneAsync(levelOrder[index].LevelNames[i], LoadSceneMode.Additive); 

} 

return bResult; 

} 

void UnloadLastLevel()

{ 

if (index == 0) 

{ 

index++; 

CancelInvoke(&quot;UnloadLastLevel&quot;); 

return; 

} 

// 上一組的關卡

int TmpLast = (index - 1) &gt;= 0 ? (index - 1) : levelOrderLength - 1; 

int LoadTimes = levelOrder[index].LevelNames.Length; 

for (int i = 0; i &lt; LoadTimes; i++) 

{ 

Scene Tmp = SceneManager.GetSceneByName(levelOrder[index].LevelNames[i]); 

if (!Tmp.isLoaded) 

{ 

return; 

} 

} 

// 下一關卡全部加載完畢後，卸載之前關卡

for (int i = 0; i &lt; levelOrder[TmpLast].LevelNames.Length; i++) 

{ 

SceneManager.UnloadScene(levelOrder[TmpLast].LevelNames[i]); 

} 

index++; 

CancelInvoke(&quot;UnloadLastLevel&quot;); 

} 

}
</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/Ha1f_Awake/article/details/93319307" target="_blank" rel="noopener">https://blog.csdn.net/Ha1f_Awake/article/details/93319307</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity控制程序停止运行"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Unity%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C/"
    >Unity控制程序停止运行</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Unity%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C/" class="article-date">
  <time datetime="2023-07-25T12:56:23.294Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="停止运行的Game"><a href="#停止运行的Game" class="headerlink" title="停止运行的Game"></a>停止运行的Game</h2><p>在编辑状态下，不点击停止播放键也一样能够控制程序停止运行</p>
<pre><code class="lang-csharp">
#if UNITY_EDITOR

UnityEditor.EditorApplication.isPlaying = false; 

#else

Application.Quit(); 

#endif
</code></pre>
<h2 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity大气散射"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Unity%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/"
    >Unity大气散射</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Unity%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/" class="article-date">
  <time datetime="2023-07-25T12:56:23.294Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="USky使用方法"><a href="#USky使用方法" class="headerlink" title="USky使用方法"></a>USky使用方法</h2><p>建立USky空物体</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/5/">5</a><a class="page-number" href="/archives/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/archives/8/">8</a><a class="page-number" href="/archives/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>