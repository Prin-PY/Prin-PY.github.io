<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-Unity中的路径获取"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-Unity%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96/"
    >Unity中的路径获取</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-Unity%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96/" class="article-date">
  <time datetime="2023-07-20T15:00:27.401Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="AssetDatabase"><a href="#AssetDatabase" class="headerlink" title="AssetDatabase"></a>AssetDatabase</h2><h3 id="获取选中资源"><a href="#获取选中资源" class="headerlink" title="获取选中资源"></a>获取选中资源</h3><pre><code class="lang-csharp">
[MenuItem(&quot;Tools/GetSelectPaths&quot;)] 

public static void Execute()

{ 

string[] strs = Selection.assetGUIDs; 

var curPath = System.IO.Directory.GetCurrentDirectory();//获取当前根目录

foreach (var item in strs) 

{ 

string path = AssetDatabase.GUIDToAssetPath(item); 

Debug.Log(curPath+&quot;/&quot;+path); 

} 

}
</code></pre>
<h3 id="Active-Deactive选中物体"><a href="#Active-Deactive选中物体" class="headerlink" title="Active/Deactive选中物体"></a>Active/Deactive选中物体</h3><pre><code class="lang-csharp">
[MenuItem(&quot;Example/Toggle Active of Selected %i&quot;)] 

static void DoToggle()

{ 

Object[] activeGOs = Selection.GetFiltered( 

typeof(GameObject), 

SelectionMode.Editable | SelectionMode.TopLevel); 

foreach (GameObject obj in activeGOs) 

{ 

obj.SetActive(!obj.activeSelf); 

} 

}
</code></pre>
<h3 id="遍历所有文件"><a href="#遍历所有文件" class="headerlink" title="遍历所有文件"></a>遍历所有文件</h3><pre><code class="lang-csharp">
private readonly string configJsonPath = AssetDatabase.GetAllAssetPaths() 

.FirstOrDefault(p =&gt; p.EndsWith(&quot;uwascan_ruleconfig.json&quot;));
</code></pre>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>获取路径：”………………../Assets”</p>
<pre><code class="lang-csharp">
string path = Application.dataPath;
</code></pre>
<h3 id="遍历所有文件夹-待学习"><a href="#遍历所有文件夹-待学习" class="headerlink" title="遍历所有文件夹 (待学习)"></a>遍历所有文件夹 (待学习)</h3><pre><code class="lang-csharp">
//遍历所选文件夹，查找该文件夹以及子文件夹中 后缀为 .prefab的文件路径

using UnityEngine; 

using System.Collections; 

using System.Collections.Generic; 

using UnityEditor; 

using System.IO; 

public class CameraMove : MonoBehaviour { 

// 在菜单来创建 选项 ， 点击该选项执行搜索代码

[MenuItem(&quot;Tools/遍历项目所有文件夹&quot;)] 

static void CheckSceneSetting()

{ 

List&lt;string&gt; dirs = new List&lt;string&gt;(); 

GetDirs(Application.dataPath, ref dirs); 

} 

//参数1 为要查找的总路径， 参数2 保存路径

private static void GetDirs(string dirPath, ref List&lt;string&gt; dirs)

{ 

foreach (string path in Directory.GetFiles(dirPath)) 

{ 

//获取所有文件夹中包含后缀为 .prefab 的路径

if (System.IO.Path.GetExtension(path) == &quot;.prefab&quot;) 

{ 

dirs.Add(path.Substring(path.IndexOf(&quot;Assets&quot;))); 

Debug.Log(path.Substring(path.IndexOf(&quot;Assets&quot;))); 

} 

} 

if (Directory.GetDirectories(dirPath).Length &gt; 0) //遍历所有文件夹

{ 

foreach (string path in Directory.GetDirectories(dirPath)) 

{ 

GetDirs(path, ref dirs); 

} 

} 

} 

}
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity中的Texture相关知识-To-Update"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-Unity%E4%B8%AD%E7%9A%84Texture%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-To-Update/"
    >Unity中的Texture相关知识(To Update)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-Unity%E4%B8%AD%E7%9A%84Texture%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-To-Update/" class="article-date">
  <time datetime="2023-07-20T15:00:27.380Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>纹理</strong> - A texture is a 2D image (even 1D and 3D textures exist) used to add detail to an object.</p>
<p>使用 <strong>纹理映射（texture mapping）</strong> 技术，我们可以把一张图“黏”在模型表面，逐 <strong>纹素（texel）</strong> （纹素的名字是为了和像素进行区分）地控制模型的颜色。</p>
<ul>
<li>纹素 - The individual color values are called a texture element, or texel.</li>
</ul>
<h3 id="Texture的作用"><a href="#Texture的作用" class="headerlink" title="Texture的作用"></a>Texture的作用</h3><p>To add more detail to our objects we can use colors for each vertex to create some interesting images. However, to get a fair bit of realism we’d have to have many vertices so we could specify a lot of colors. This takes up a considerable amount of extra overhead, since each model needs a lot more vertices and for each vertex a color attribute as well.</p>
<p>若不使用Texture，而使用顶点的Color属性的话，为了真实性，需要更多的顶点，并且每个顶点都要增加额外的颜色信息。</p>
<h2 id="Texture-Coordinates"><a href="#Texture-Coordinates" class="headerlink" title="Texture Coordinates"></a>Texture Coordinates</h2><p>In order to map a texture to the triangle we need to tell each vertex of the triangle which part of the texture it corresponds to. Each vertex should thus have a texture coordinate associated with them that specifies what part of the texture image to sample from. Fragment interpolation then does the rest for the other fragments.</p>
<p><img src="Unity中的Texture相关知识\(To Update\" alt="Alt text"><br>_files/1613985653479.png)</p>
<p><strong>纹理映射坐标（texture-mapping coordinates） / UV坐标：</strong> 存储在每个顶点上，定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个二维变量(u，v)来表示，其中u是横向坐标，而v是纵向坐标。</p>
<p>Each texel has a unique address in the texture. The address can be thought of as a column and row number, which are labeled u and v. </p>
<p>Texture coordinates are in texture space. That is, they are relative to the location (0,0) in the texture. </p>
<blockquote>
<p>顶点UV坐标的范围通常都被归一化到[0，1]范围内。<br> 在OpenGL里，纹理空间的原点位于左下角，而在DirectX中，原点位于左上角。Unity使用的纹理空间是符合OpenGL的传统的</p>
</blockquote>
<h3 id="uv-uv2-uv3-uv4"><a href="#uv-uv2-uv3-uv4" class="headerlink" title="uv, uv2, uv3, uv4"></a>uv, uv2, uv3, uv4</h3><p><img src="Unity中的Texture相关知识\(To Update\" alt="Alt text"><br>_files/UV.png)<br>unity一共支持4套uv，在shader编程中，分别叫UV0, UV1, UV2, UV3，而在c＃编程中分别叫uv, uv2, uv3, uv4。<br>通常来说(使用c# API中的命名)，uv用于主纹理, uv2用于光照贴图(Lightmap)的采样, uv3用于实时动态光照, uv4可进行自定义。<br>uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。如果在建模软件中只做了一套uv，将模型导入unity的时候，在导入设置中勾选Generate Lightmap UVs, unity会自动为我们生成用于光照贴图的uv2。uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p>
<blockquote>
<p>3DMax和maya等软件都能对模型加多套uv<br> 注意模型在fbx里可以保留多套uv，但是obj里只能保留默认的第一套<br> 另外unity里现在貌似支持最多四套</p>
</blockquote>
<h3 id="清除不必要的UV通道"><a href="#清除不必要的UV通道" class="headerlink" title="清除不必要的UV通道"></a>清除不必要的UV通道</h3><p>某些时候，因为美术的一些意外操作，会引入多个我们不需要的UV通道。<br>由于unity的光照贴图会自动占用uv2通道，如果你的项目中又使用的是动态加载光照贴图的方式的话，最好不要在导入模型的时候把UV2设置为null，如果你这样做了有可能会导致光照贴图显示不出来的问题。<br>如果物体不需要烘培，你自己也不使用uv2，则可以删除该通道。</p>
<pre><code class="lang-csharp">
//删除color和uv

public class ClearModelUV:AssetPostprocessor

{ 

void OnPostprocessModel(GameObject rImaportModel)

{ 

this.ClearMeshUVAndColorChannel(rImaportModel); 

} 

private void ClearMeshUVAndColorChannel(GameObject rImportModel)

{ 

List&lt;Vector2&gt; rNewUV = null; 

List&lt;Color32&gt; rNewColor = null; 

var rFilters= rImportModel.GetComponentsInChildren&lt;MeshFilter&gt;(); 

for (int filter_index = 0; filter_index &lt; rFilters.Length; filter_index++) 

{ 

rFilters[filter_index].sharedMesh.SetColors(rNewColor); 

rFilters[filter_index].sharedMesh.SetUVs(1, rNewUV); 

rFilters[filter_index].sharedMesh.SetUVs(2, rNewUV); 

rFilters[filter_index].sharedMesh.SetUVs(3, rNewUV); 

} 

} 

}
</code></pre>
<h2 id="Texture-Import-Settings"><a href="#Texture-Import-Settings" class="headerlink" title="Texture Import Settings"></a>Texture Import Settings</h2><h3 id="Texture-Type"><a href="#Texture-Type" class="headerlink" title="Texture Type"></a>Texture Type</h3><p>Default 默认的纹理类型，普通的图片<br>Normal map 法线贴图</p>
<blockquote>
<p>【关于法线贴图：就是看起来与3D效果无异的2D贴图】<br> 游戏场景中譬如雕刻这种3D细节，如果做3D模型的话，就会浪费显示芯片，使游戏性能下降，便会用法线贴图，既不影响玩家体验游戏又不影响游戏性能</p>
</blockquote>
<p>Editor GUI and Legacy GUI GUI编辑器用到的UI贴图<br>Sprite(2D and UI) 图片精灵，主要用于2D游戏中，把一张大的图分割成一张张小图，大的图叫图集atlas,<br>小的图叫精灵sprite,可以通过精灵名字来使用精灵.<br>Cursor 鼠标或者叫光标的贴图<br>Cubemap 立方体的纹理<br>Cookie 遮罩贴图 聚光灯贴图<br>Lightmap 光照或者叫烘焙贴图<br>Advanced 高级(可自定义一些贴图属性)</p>
<h3 id="Alpha-Source-α通道来源"><a href="#Alpha-Source-α通道来源" class="headerlink" title="Alpha Source (α通道来源)"></a>Alpha Source (α通道来源)</h3><ol>
<li><p>None：强制无α通道。</p>
</li>
<li><p>Input Texture Alpha：使用纹理自带的α通道。</p>
</li>
<li><p>From Gray Scale：使用纹理RGB通道的均值来生成α通道。</p>
</li>
</ol>
<h3 id="Alpha-Is-Transparent"><a href="#Alpha-Is-Transparent" class="headerlink" title="Alpha Is Transparent"></a>Alpha Is Transparent</h3><p>当alpha用于透明处理时，我们要勾上该选项，可以防止不透明边缘锯齿现象</p>
<p>性”alpha is transparency”，原理是在压缩之前对贴图进行颜色放大处理来搞定边缘锯齿问题，这个颜色放大处理等同于ps里的最小值滤镜操作，对图片边缘做强化处理。</p>
<p>一个坑：（<a href="http://blog.coolcoding.cn/?p=198" target="_blank" rel="noopener">http://blog.coolcoding.cn/?p=198</a>）<br>如果有一张PNG图片, 95%的地方是全透明的,而在全透明的地方,RGB值是有意义的;<br>如果设置了alphaIsTransparency属性,则全透明的地方,Unity会将RGB值全部丢失!!!<br>如果要使用此纹理的4个通道做数据存储时(比如地型的4通道混合)<br>千万不能勾选alphaIsTransparency属性<br>除非此PNG图片仅仅用于UI显示。</p>
<h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><p>Non Power of 2：NPOT的处理方式。<br>Read/Write Enabled：读写开关，非必要不开启，否则会增加一倍的 内存。<br>Generate Mip Maps：生成Mip Maps，会增加33%的内存。一般用 于模型纹理，UI、天空盒等纹理不需要开启。<br>Border Mip Maps：防止低阶的Mip Map的色彩值溢出边界，一般用 于光照Cookie。<br>Mip Map Filtering：过滤算法，Box和Kaiser。<br>Fadeout Mip Maps：根据层阶使Mip Map慢慢变灰，一般用于细节 贴图（DetailMaps）。</p>
<h3 id="Wrap-Mode"><a href="#Wrap-Mode" class="headerlink" title="Wrap Mode"></a>Wrap Mode</h3><p>Wrap mode determines how texture is sampled when texture coordinates are outside of the typical 0..1 range.<br>这由纹理的映射函数来决定。在OpenGL中，这类映射函数称为“Texture Wrapping Mode”；在D3D中，称为“Texture Addressing Mode”。</p>
<h4 id="Repeat-重复"><a href="#Repeat-重复" class="headerlink" title="Repeat 重复"></a>Repeat 重复</h4><p>Tiles the texture, creating a repeating pattern.<br>When UVs are outside of the 0…1 range, the integer part will be ignored, thus creating a repeating pattern.<br>在算法上，忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上。对于大多数复制纹理的使用，在纹理顶部的纹理单元应与底部的纹理单元相匹配，在纹理左侧的纹理单元也应与右侧的纹理单元相匹配。这样才能做到无缝连接。</p>
<h4 id="Clamp-拉伸"><a href="#Clamp-拉伸" class="headerlink" title="Clamp 拉伸"></a>Clamp 拉伸</h4><p>makes the texture edge pixels be stretched when outside of of 0..1 range.<br>This is useful for preventing wrapping artifacts when mapping an image onto an object and you don’t want the texture to tile. UV coordinates will be clamped to the range 0…1. When UVs are larger than 1 or smaller than 0, the last pixel at the border will be used.<br>将大于1.0的数值设置为1.0，将小于0.0的数值设置为0.0，即将超出[0.0,1.0]范围的数值截取到[0.0,1.0]范围内，这样会导致纹理边缘的重复。</p>
<h4 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h4><p>Tiles the texture, creating a repeating pattern by mirroring it at every integer boundary.</p>
<h4 id="Mirror-Once"><a href="#Mirror-Once" class="headerlink" title="Mirror Once"></a>Mirror Once</h4><p>Mirrors the texture once, then clamps to edge pixels.<br>This effectively mirrors the texture around zero UV coordinates, and repeats edge pixel values when outside of [-1..1] range.</p>
<blockquote>
<p>This mode is called “mirror and clamp to edge” in graphics APIs like Vulkan, Metal and OpenGL. This feature is not always supported when using OpenGL ES and Vulkan graphics APIs, specifically on ARM and Qualcomm GPUs platforms. Check SystemInfo.supportsTextureWrapMirrorOnce to figure out whether the system is capable..</p>
</blockquote>
<h4 id="Per-axis"><a href="#Per-axis" class="headerlink" title="Per-axis"></a>Per-axis</h4><p>Choose this to individually control how Unity wraps Textures at the U axis and V axis. </p>
<h3 id="Filter-Mode"><a href="#Filter-Mode" class="headerlink" title="Filter Mode"></a>Filter Mode</h3><p>控制纹理通过三维变换拉伸的计算(过滤)方式</p>
<p>Point：最近点采样，当纹理坐标没有刚好对应Texture上的一个采样点时，它会选择最近的一个采样点作为该坐标的采样值，</p>
<p>当纹理没有拉伸变形时，这样还不错，因为速度是最快的，但如果拉伸变形了，会出现马赛克现象。</p>
<p>Bilinear：双线性过滤，以像素对应的纹理坐标为中心，采样它周围4个texel（纹素）的像素，取平均值作为该坐标采样值。这是Unity默认的模式，过渡效果相对平滑，当然速度会比最近点采样有一定下降。会有模糊化现象。</p>
<p>Trilinear：三线性过滤，会对像素大小和纹素大小最接近的两层Mipmap level分别进行双线性过滤，再对结果进行线性插值。由于使用了两次双线性过滤，也就是计算2x4=8个像素的值，速度会更加下降，当然滤波效果更好。同上也会有模糊化现象。</p>
<h3 id="Aniso-Level"><a href="#Aniso-Level" class="headerlink" title="Aniso Level"></a>Aniso Level</h3><p>各向异性级别。当以一个过小的角度观察纹理时，此数值越高观察的纹理质量就越高，该参数对于提高地面等纹理的显示效果非常明显。</p>
<blockquote>
<p>Default 点了没效果不能重置所有设置，还是得手动选择.废弃的按钮</p>
</blockquote>
<h3 id="对不同平台的压缩设置"><a href="#对不同平台的压缩设置" class="headerlink" title="对不同平台的压缩设置"></a>对不同平台的压缩设置</h3><ul>
<li><p>Max Size：最大尺寸。</p>
</li>
<li><p>Compression：压缩质量。</p>
</li>
<li><p>Format：压缩格式。<br>格化式存储该纹理的类型，纹理的精度越高，占用的内存越大，得到的效果也越好</p>
</li>
<li><p>Compressed 默认压缩方式,PVRTC图片格式，压缩选项将会针对你的目标平台来选择最合适的压缩算法替换原来的我们给的图片格式(比如我们给的是PNG格式)。<br>16 bits 无压缩16位格式，比32位节省一半的空间和内存。<br>Truecolor 无压缩32位以上真彩色,适合对色彩要求较高的情况下使用，比较占空间和内存。</p>
</li>
<li><p>Compressor Quality：压缩质量</p>
</li>
<li><p>Use Crunch Compression：紧凑压缩</p>
</li>
</ul>
<blockquote>
<p>Crunched 这种类型将会根据显卡的GPU来选择合适的压缩格式进行压缩然后会选用一种CPU上就能处理的压缩格式再压缩一遍。如果在制作供人下载的资源包的时候这种类型非常的合适。这个类型的压缩需要很长时间，但在运行时解压是非常快的。</p>
</blockquote>
<h3 id="其他纹理类型设置"><a href="#其他纹理类型设置" class="headerlink" title="其他纹理类型设置"></a>其他纹理类型设置</h3><h3 id="Normal-Map"><a href="#Normal-Map" class="headerlink" title="Normal Map"></a>Normal Map</h3><p>与Default相比增加了一下设置：<br>Create from Grayscale：从灰度高度图（Heightmap）创建。<br>Bumpiness：崎岖度。<br>Filtering：滤波算法。</p>
<ol>
<li>Smooth：平滑，标准前向差分算法。 2. Sharp：尖锐，Sobel滤波器。</li>
</ol>
<h4 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h4><p>与Default相比增加了一下设置：<br>Sprite Mode：精灵模式。</p>
<ol>
<li><p>Single：单图。</p>
</li>
<li><p>Multiple：多图。</p>
</li>
<li><p>Polygon：多边形，在SpriteEditor里使用多边形裁剪精灵。<br>PackingTag：指定图集。<br>PixelsPer Unit：每单位像素数，在世界场景中，每单位距离有多少个 像素。</p>
</li>
</ol>
<p>Mesh Type：网格类型（Polygon模式无此属性）。</p>
<ol>
<li>FullRect：矩形。 2. Tight：紧凑的，根据Alpha通道生成Mesh。（2DObject）<br>ExtrudeEdge：拉伸边缘。</li>
</ol>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie类型的纹理设置<br>与Default相比增加了一下设置：<br>Light Type：光照类型。</p>
<ol>
<li><p>Spotlight：聚光灯，形状必须为2D。</p>
</li>
<li><p>Directional：平行光，形状必须为2D。</p>
</li>
<li><p>Point：点光源，形状必须为立方体。</p>
</li>
</ol>
<h2 id="Sprite及图集的使用"><a href="#Sprite及图集的使用" class="headerlink" title="Sprite及图集的使用"></a>Sprite及图集的使用</h2><blockquote>
<p>只有Sprite模式的图片才可以打包成图集</p>
</blockquote>
<p>旧版：<br>Sprite Mode 设置为 Muitiple 设置Packing Tag<br>Window-&gt;Sprite Packer –&gt;点击 Pack 即可</p>
<p>新版：<br>Project Setting -&gt; Editor -&gt; Sprite Packer -&gt; Mode = Always Enabled<br>新建 Sprite Atlas<br>选择打包图集的文件夹或者依次添加单独图片，点击Pack Preview后自动打包成一个图集</p>
<p>代码获取图集并动态选择Sprite：</p>
<pre><code class="lang-csharp">
using UnityEditor; 

using UnityEngine; 

using UnityEngine.U2D; 

using UnityEngine.UI; 

public class SpriteAtlasExample : MonoBehaviour

{ 

private void Awake()

{ 

SpriteAtlas atlas = AssetDatabase.LoadAssetAtPath&lt;SpriteAtlas&gt;(&quot;Assets/TestAtlas.spriteatlas&quot;); 

Sprite sprite = atlas.GetSprite(&quot;Icon2&quot;); 

if (sprite != null) 

{ 

GetComponent&lt;Image&gt;().sprite = sprite; 

} 

} 

}
</code></pre>
<h2 id="压缩格式相关"><a href="#压缩格式相关" class="headerlink" title="压缩格式相关"></a>压缩格式相关</h2><h3 id="图像文件格式"><a href="#图像文件格式" class="headerlink" title="图像文件格式"></a>图像文件格式</h3><p>文件格式是图像为了存储信息而使用的对信息的特殊编码方式，它存储在磁盘中，或者内存中，但是并不能被GPU所识别，因为以向量计算见长的GPU对于这些 复杂的计算无能为力。这些文件格式当被游戏读入后，还是需要经过CPU转换成图形硬件支持的格式，再传送到GPU端进行使用。<br>常用的图片格式及特点如下：</p>
<ul>
<li><p>JPG 有损压缩 文件小 不支持透明</p>
</li>
<li><p>PNG 无损压缩 文件小 支持透明</p>
</li>
<li><p>TAG 无损压缩 文件大 支持透明</p>
</li>
<li><p>DDS 无损压缩 文件最小 支持透明</p>
</li>
</ul>
<p>不同格式的本质区别在于压缩算法不一样，结果图片大小，还原度也各不相同。</p>
<blockquote>
<p>TIFF（Tag Image File Format）文件是由Aldus和Microsoft公司为扫描仪和桌上出版系统研制开发的一种较为通用的图像文件格式。TIFF格式灵活易变，同时定义了四类不同的格式：TIFF－B适用于二值图像；TIFF－G适用黑白灰度图像；TIFF－P适用于带调色板的彩色图像；TIFF－R适用于RGB真彩图像。TIFF支持多种编码方法，其中包括RGB无损压缩、RLE压缩以及JPEG压缩等。</p>
<p>GIF（Graphics Interchange Format ）是CompuServe公司在1987年开发的图像文件格式。GIF文件的数据是经过压缩的，它采用了可变长度的压缩算法。GIF的图像深度从1 bit到8 bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。</p>
</blockquote>
<h3 id="3D-图形硬件支持的压缩格式"><a href="#3D-图形硬件支持的压缩格式" class="headerlink" title="3D 图形硬件支持的压缩格式"></a>3D 图形硬件支持的压缩格式</h3><p>JPG, PNG, PSD are not used <strong>during realtime rendering by 3D graphics hardware</strong> such as a graphics card or mobile device. 3D graphics hardware requires Textures to be compressed in specialized formats which are <strong>optimised for fast Texture sampling</strong> . The various different platforms and devices available each have their own different proprietary formats.</p>
<p>By default, the Unity Editor automatically converts Textures to the most appropriate format to match the build target you have selected. Only the converted Textures are included in your build; your source Asset<br>files are left in their original format, in your project’s Assets folder.</p>
<blockquote>
<p>如果发现GPU不支持当前压缩格式，Unity就会将纹理转换成RGB（A），首先是解压过程的消耗，其次是内存中会保存两个纹理。</p>
</blockquote>
<h4 id="简单纹理格式"><a href="#简单纹理格式" class="headerlink" title="简单纹理格式"></a>简单纹理格式</h4><p>RGBA8888 每个像素4字节，RGBA通道各占用8位<br>RGBA4444 每个像素2字节，RGBA通道各占用4位<br>RGB888 每个像素3字节，RGB通道各占用8位，无透明通道<br>RGB565 每个像素2字节，RGB通道各占用5/6/5位，无透明通道<br>RGBA5551 每个像素2字节，RGB通道各占用5位，透明通道1位，所以要么完全透明要么不透明</p>
<blockquote>
<p>所有设备对RGB 16BITS/ARGB 16BITS/RGB A16BITS/RGB 24BITS/ARGB 32BITS等支持都很好，只是这些格式算是非压缩格式，对内存消耗和渲染消耗非常不友好。</p>
</blockquote>
<h4 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h4><ul>
<li><p>DXT - 有损压缩方式</p>
</li>
<li><p>ETC - （Ericsson Texture Compression），在移动平台中广泛采用。它是一种为感知质量设计的有损算法，其依据是人眼对亮度改变的反应要高于色度改变。</p>
<ul>
<li><p>ETC1：安卓原生支持，在各种Android设备上非透明纹理都可以采用ETC1格式。ETC1不支持透明，对于透明纹理，在Android设备上，可以把RGB和Alpha拆到2张ETC1纹理上，游戏中再合成使用。</p>
</li>
<li><p>ETC2是ETC1的扩张，向后兼容ETC1，对RGB的压缩质量更好，并且支持透明通道。ETC2比ETC1压缩质量更高，而且支持透明，在Android设备上再也不需要打不同纹理格式的包了。不过需要OpenGL ES 3.0以上才可以，目前很多设备只支持OpenGL ES 2.0。</p>
</li>
</ul>
</li>
<li><p>PVRTC（PowerVR Texture Compression） - 压缩比高，也是有损压缩。iOS只支持PVRTC的压缩格式。</p>
</li>
</ul>
<p>关于压缩后的在储存上的大小，假设高清(ARGB32)大小为1，那么大概数据如下：</p>
<pre><code class="lang-csharp">
RGB PVRTC 4BITS:0.25

ARGB PVRTC 4BITS:0.25

RGB PVRTC 2BITS:0.13

ARGB PVRTC 2BITS:0.13

RGBA ETC2 4BITS:0.25

RGBA ETC2 8BITS:0.25

RGB \+ 1-bit ALPHA ETC2 8BITS:0.2

DXT1 :0.3

DXT5 : 0.6

ARGB 16BITS:0.33

RGB 16BITS:0.5

RGB 24BITS:0.85

ARGB 32BITS:1
</code></pre>
<p>内存中的大小，假设高清(ARGB32)大小为1，那么大概数据如下：</p>
<pre><code class="lang-csharp">
RGB PVRTC 2BITS:0.0625

ARGB PVRTC 2BITS:0.0625

RGB PVRTC 4BITS:0.125

ARGB PVRTC 4BITS:0.125

RGBA ETC2 4BITS:0.125

RGBA ETC2 8BITS:0.25

RGB \+ 1-bit ALPHA ETC2 8BITS:0.125

DXT1 : 0.125

DXT5 : 0.25

ARGB 16BITS:0.5

RGB 16BITS:0.5

RGB 24BITS:0.8

ARGB 32BITS:1
</code></pre>
<h4 id="格式选择"><a href="#格式选择" class="headerlink" title="格式选择"></a>格式选择</h4><p>一般方案：ETC1+Alpha/PVRTC4 和 RGB16/RGBA16 搭配使用。</p>
<hr>
<h5 id="高清无压缩"><a href="#高清无压缩" class="headerlink" title="高清无压缩"></a>高清无压缩</h5><p>RGBA32 （等同于原图了，效果最好，效率最差。）</p>
<hr>
<h5 id="中清晰中压缩"><a href="#中清晰中压缩" class="headerlink" title="中清晰中压缩"></a>中清晰中压缩</h5><ul>
<li><p>不透明贴图 ：RGB 16BITS</p>
</li>
<li><p>透明贴图：RGBA 16BITS + Dithering</p>
</li>
</ul>
<blockquote>
<p>RGBA16在遇到渐变的时候表现很差，可能需要做抖动（Dithering）处理。<br> 16位压缩会带来颜色损失，但如果本来美术就是按16BITS画的话，就不会损失，日本好些手游都是按16BITS来画的。这样的游戏一般少渐变艳度高比较容易看出来。</p>
</blockquote>
<hr>
<h5 id="低清晰高压缩"><a href="#低清晰高压缩" class="headerlink" title="低清晰高压缩"></a>低清晰高压缩</h5><p>ETC1+Alpha/PVRTC4（能直接被GPU使用，占用少，效率高。）</p>
<p>IOS下 </p>
<ul>
<li><p>普通不透明：RGB PVRTC 4BITS</p>
</li>
<li><p>普通透明：RGBA PVRTC 4BITS</p>
</li>
</ul>
<blockquote>
<p>PVRTC 要求方形的图集贴图<br> 非方形的贴图会被转成16位RGB(A)的压缩格式。</p>
</blockquote>
<p>Android下：</p>
<ul>
<li><p>普通不透明：RGB ETC 4BITS</p>
</li>
<li><p>普通透明：</p>
<ul>
<li><p>RGBA 16BIT</p>
</li>
<li><p>有针对性的选择DXT5/ATC8 BITS/ETC2 8BITS</p>
</li>
<li><p>如果有技术支持，可以采用RGB ETC 4BITS加一张ALPHA 8的贴图来实现透明效果。</p>
</li>
</ul>
</li>
</ul>
<p><strong>对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16</strong></p>
<blockquote>
<p>Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；<br> iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。<br> 另外，针对Android 上的带Alpha通道的图片，还有一种常见的做法，即把Alpha通道独立出来作为另一张纹理，从而将 RGB 部分和 Alpha 部分分别采用 ETC1来压缩，但渲染时就需要自定义的 Shader来处理。</p>
</blockquote>
<p>windows：<br>使用Compressed格式。会压缩为DXT5（带透明通道），DXT1 格式。</p>
<h4 id="关于POT-Power-Of-Two"><a href="#关于POT-Power-Of-Two" class="headerlink" title="关于POT(Power Of Two)"></a>关于POT(Power Of Two)</h4><p>Only textures with width/height being multiple of 4 can be compressed to ETC1 format.（ 只有宽/高的尺寸是4的倍数才能被压缩成ETC1格式。)<br>Only POT textures can be compressed to ETC1 format. ( 只有POT(Power of two,2的幂次方)的贴图才能被压缩成ETC1格式。)</p>
<p>如果纹理的原始尺寸不是2的幂次方的话，则可在Unity中可以通过导入设置来进行更正。</p>
<p><img src="Unity中的Texture相关知识\(To Update\" alt="Alt text"><br>_files/1604336979482.png)</p>
<ul>
<li><p>None不做处理</p>
</li>
<li><p>ToNearest（选择最接近的幂次方）</p>
</li>
<li><p>ToLarger（选择最大尺寸的幂次方）</p>
</li>
<li><p>ToSmaller（选择最小尺寸的幂次方）</p>
</li>
</ul>
<p>以一张513x1023尺寸的图片来举例：</p>
<ul>
<li><p>None：513x1023</p>
</li>
<li><p>ToNearest：512x1024</p>
</li>
<li><p>ToLarger：1024x1024</p>
</li>
<li><p>ToSmaller：512x512</p>
</li>
</ul>
<h2 id="实用的小工具"><a href="#实用的小工具" class="headerlink" title="实用的小工具"></a>实用的小工具</h2><h3 id="Texture转换成Texture2D"><a href="#Texture转换成Texture2D" class="headerlink" title="Texture转换成Texture2D"></a>Texture转换成Texture2D</h3><pre><code class="lang-csharp">
/// &lt;summary&gt;

/// Texture转换成Texture2D...

/// &lt;/summary&gt;

/// &lt;param name=&quot;texture&quot;&gt;&lt;/param&gt;

/// &lt;returns&gt;&lt;/returns&gt;

Texture2D TextureToTexture2D(Texture texture)

{ 

Texture2D texture2D = new Texture2D(texture.width, texture.height, TextureFormat.RGBA32, false); 

RenderTexture currentRT = RenderTexture.active; 

RenderTexture renderTexture = RenderTexture.GetTemporary(texture.width, texture.height, 32); 

Graphics.Blit(texture, renderTexture); 

RenderTexture.active = renderTexture; 

texture2D.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0); 

texture2D.Apply(); 

RenderTexture.active = currentRT; 

RenderTexture.ReleaseTemporary(renderTexture); 

return texture2D; 

}
</code></pre>
<h3 id="Texture2D形式截图"><a href="#Texture2D形式截图" class="headerlink" title="Texture2D形式截图"></a>Texture2D形式截图</h3><pre><code class="lang-csharp">
/// &lt;summary&gt;

/// 截图...

/// &lt;/summary&gt;

/// &lt;param name=&quot;rect&quot;&gt;截图的区域&lt;/param&gt;

/// &lt;returns&gt;&lt;/returns&gt;

Texture2D CaptureScreenshot(Rect rect) 

{ 

// 先创建一个的空纹理，大小可根据实现需要来设置

Texture2D screenShot = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24,false); 

// 读取屏幕像素信息并存储为纹理数据，

screenShot.ReadPixels(rect, 0, 0); 

screenShot.Apply(); 

// 然后将这些纹理数据，成一个png图片文件

byte[] bytes = screenShot.EncodeToPNG(); 

string filename = Application.dataPath + &quot;/Screenshot.png&quot;; 

System.IO.File.WriteAllBytes(filename, bytes); 

Debug.Log(string.Format(&quot;截屏了一张图片: {0}&quot;, filename)); 

// 最后，我返回这个Texture2d对象，这样我们直接，所这个截图图示在游戏中，当然这个根据自己的需求的。

return screenShot; 

}
</code></pre>
<h3 id="Texture保存到本地"><a href="#Texture保存到本地" class="headerlink" title="Texture保存到本地"></a>Texture保存到本地</h3><pre><code class="lang-csharp">
/// &lt;summary&gt;

/// 将Texture转为本地PNG...

/// &lt;/summary&gt;

/// &lt;param name=&quot;filePath&quot;&gt;&lt;/param&gt;

/// &lt;param name=&quot;teture&quot;&gt;&lt;/param&gt;

/// &lt;returns&gt;&lt;/returns&gt;

public static bool saveMainTextureToPng(string filePath, Texture teture)

{ 

if (teture.GetType() != typeof(Texture2D)) 

{ 

return false; 

} 

Texture2D savedTexture = (Texture2D)teture; 

try

{ 

Texture2D newTexture = new Texture2D(savedTexture.width, savedTexture.height, TextureFormat.RGBA32, false); 

newTexture.SetPixels(0, 0, savedTexture.width, savedTexture.height, savedTexture.GetPixels()); 

newTexture.Apply(); 

byte[] bytes = newTexture.EncodeToPNG(); 

if (bytes != null &amp;&amp; bytes.Length &gt; 0) 

{ 

if (File.Exists(filePath)) 

{ 

File.Delete(filePath); 

} 

System.IO.File.WriteAllBytes(filePath, bytes); 

} 

} 

catch (IOException ex) 

{ 

return false; 

} 

return true; 

}
</code></pre>
<h3 id="将图片转换为byte数组"><a href="#将图片转换为byte数组" class="headerlink" title="将图片转换为byte数组"></a>将图片转换为byte数组</h3><pre><code class="lang-csharp">
/// &lt;summary&gt;

/// 将图片转换为byte数组...

/// &lt;/summary&gt;

/// &lt;param name=&quot;filePath&quot;&gt;图片路径&lt;/param&gt;

/// &lt;returns&gt;&lt;/returns&gt;

public static byte[] ReadTexture(string filePath)

{ 

FileStream fileStream = new FileStream(filePath, FileMode.Open, System.IO.FileAccess.Read); 

fileStream.Seek(0, SeekOrigin.Begin); 

//创建byte数组 ... 

byte[] buffer = new byte[fileStream.Length]; 

fileStream.Read(buffer, 0, (int)fileStream.Length); 

fileStream.Close(); 

fileStream.Dispose(); 

fileStream = null; 

return buffer; 

}
</code></pre>
<h2 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h2><p><a href="https://www.cnblogs.com/suogasus/p/5311264.html" target="_blank" rel="noopener">https://www.cnblogs.com/suogasus/p/5311264.html</a></p>
<p>Alpha通道是计算机图形学中的术语，指的是特别的通道，意思是“非彩色”通道，主要是用来保存选区和编辑选区</p>
<ul>
<li><p>Alpha 没有透明度的意思，不代表透明度。opacity 和 transparency 才和透明度有关，前者是不透明度，后者是透明度。比如 css 中的「opacity: 0.5」就是设定元素有 50% 的不透明度。</p>
</li>
<li><p>一个图像的每个像素都有 RGB 三个通道，后来 Alvy Ray Smith 提出每个像素再增加一个 Alpha 通道，取值为0到1，用来储存这个像素是否对图片有「贡献」，0代表透明、1代表不透明。也就是说，「Alpha 通道」储存一个值，其外在表现是「透明度」，Alpha 和透明度没啥关系。</p>
</li>
<li><p>为什么取名为 Alpha 通道，我觉得是因为这是除RGB以外「第一个通道」的意思，没有别的更深刻的含义。</p>
</li>
<li><p>Alpha 通道」是图片内在的一个属性，用 css 或者其他外部方法设定透明度，并没有改变图片的 Alpha 通道的值。</p>
</li>
</ul>
<p>真正让图片变透明的不是Alpha 实际是Alpha所代表的数值和其他数值做了一次运算<br>比如你有一张图片你想抠出图片中间的一部分 在PS里你会建立一个蒙板 然后在蒙板里把不需要的地方填充成黑色 需要的留成白色 这个时候实际上是是做了一次乘法<br>用黑色所代表的数值0去乘以你所填充的地方 那么这个地方就变透明了 </p>
<p>设Alpha值[0，255]区间映射为[0，1]区间相对应的值表示，即Alpha值为0—1之间的数值。则图形文件中各个像素点可表示为：<br>Graphx（Redx，Greenx，Bulex，Alphax）<br>屏幕上相应像素点的显示值就转换为：<br>Dispx（Redx<em>Alphax，Greenx</em>Alphax，Bluex*Alphax）</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>Alpha通道<br>颜色通道<br>复合通道<br>专色通道<br>矢量通道</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>《Unity Shader入门精要》 冯乐乐<br><a href="https://zhuanlan.zhihu.com/p/126752791" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126752791</a><br><a href="https://www.jianshu.com/p/bec1a7514b08" target="_blank" rel="noopener">https://www.jianshu.com/p/bec1a7514b08</a><br><a href="https://blog.csdn.net/ynnmnm/article/details/44983545" target="_blank" rel="noopener">https://blog.csdn.net/ynnmnm/article/details/44983545</a><br><a href="https://www.jianshu.com/p/832e242523a4" target="_blank" rel="noopener">https://www.jianshu.com/p/832e242523a4</a><br><a href="https://blog.csdn.net/skymanwu/article/details/295121" target="_blank" rel="noopener">https://blog.csdn.net/skymanwu/article/details/295121</a><br><a href="https://blog.csdn.net/qq_29266497/article/details/81515326" target="_blank" rel="noopener">https://blog.csdn.net/qq_29266497/article/details/81515326</a><br><a href="https://learnopengl.com/Getting-started/Textures" target="_blank" rel="noopener">https://learnopengl.com/Getting-started/Textures</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity中Culling相关技术"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-Unity%E4%B8%ADCulling%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"
    >Unity中Culling相关技术</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-Unity%E4%B8%ADCulling%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/" class="article-date">
  <time datetime="2023-07-20T15:00:27.378Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Frustum-Culling"><a href="#Frustum-Culling" class="headerlink" title="Frustum Culling"></a>Frustum Culling</h2><p>剔除被其他物体遮挡的，摄像机不可见(但在视锥体内)的渲染物体。使用 Occlusion Culling 需要手动设置，并在 Occlusion Culling Window 中通过 Bake 计算剔除数据。<br><a href="https://docs.unity3d.com/Manual/OcclusionCulling.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/OcclusionCulling.html</a></p>
<h3 id="Builtin管线"><a href="#Builtin管线" class="headerlink" title="Builtin管线"></a>Builtin管线</h3><p>视锥体剔除 - 视锥体剔除是引擎自己做的，在给GPU提交数据进行渲染前，会执行视锥体剔除，决定哪些可见哪些不可见。经过剔除之后，Renderer的isVisible值就表示相应物体的可见性，不过此时已经在这帧的Update之后了。在Update当中取IsVisible属性获取的实际上是上一帧的可见性。 至于视锥体剔除的实现方法我们不清楚，可能引擎底层会有一些优化，使用kd-tree进行空间划分等等。</p>
<h3 id="SRP的Culling"><a href="#SRP的Culling" class="headerlink" title="SRP的Culling"></a>SRP的Culling</h3><ol>
<li><p>SRP的Culling可以自己写</p>
</li>
<li><p>URP的管线相对比较固定，可定制化程度低，Culling不太好自己写</p>
</li>
</ol>
<p>Occlusion Culling is different from Frustum Culling. Frustum Culling only disables the renderers for objects that are outside the camera’s viewing area but does not disable anything hidden from view by overdraw. Note that when you use Occlusion Culling you will still benefit from Frustum Culling.</p>
<h2 id="Occlusion-Culling"><a href="#Occlusion-Culling" class="headerlink" title="Occlusion Culling"></a>Occlusion Culling</h2><p>在移动端使用的比较少，属于用 CPU时间换一定的CPU时间和一定的GPU时间的操作。使用方法是：预先烘焙遮挡剔除信息（对于一定的区域，哪些物体被遮挡），在游戏运行时，经过视锥体剔除之后，对于视锥体内的物体，相机到了一定的位置，会去取预先烘焙的信息，来判断哪些物体被遮挡，对相应的物体进行剔除，进而节省被遮挡的物体提交渲染进行、在GPU端进行绘制的时间。</p>
<h2 id="Camera-layerCullDistance"><a href="#Camera-layerCullDistance" class="headerlink" title="Camera.layerCullDistance"></a>Camera.layerCullDistance</h2><p>For performance reasons, you might want to cull small objects earlier. For example, small rocks and debris could be made invisible at much smaller distance than large buildings. To do that, put small objects into a separate layer and set up per-layer cull distances using Camera.layerCullDistances script function.<br><a href="https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html</a></p>
<h2 id="CullingGroup-API"><a href="#CullingGroup-API" class="headerlink" title="CullingGroup API"></a>CullingGroup API</h2><p>CullingGroup offers a way to integrate your own systems into Unity’s culling and LOD pipeline.The CullingGroup will calculate visibility based on frustum culling and static occlusion culling only. It will not take dynamic objects into account as potential occluders.<br><a href="https://docs.unity3d.com/Manual/CullingGroupAPI.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/CullingGroupAPI.html</a></p>
<p>Unity的CullingGroup API是纯逻辑的东西，不影响渲染。其使用方法是：在逻辑代码中定义CullingGroup，Group中加入一些球体(位置与半径，是逻辑上的球体，实际是不可见的)，并加入要检测的相机，渲染时，Unity会判断这些球体是否可见，进而判断CullingGroup的可见性。在渲染之后，可以在代码中获取该Group的可见性，进而据此控制一些逻辑。如果不用代码去取CullingGroup的信息，那么它就是没有用的。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://blog.csdn.net/kenight/article/details/82760667" target="_blank" rel="noopener">https://blog.csdn.net/kenight/article/details/82760667</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity-C预处理指令"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-Unity-C%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/"
    >Unity&amp;C预处理指令</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-Unity-C%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/" class="article-date">
  <time datetime="2023-07-20T15:00:27.375Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Unity-amp-C-预处理指令"><a href="#Unity-amp-C-预处理指令" class="headerlink" title="Unity&amp;C#预处理指令"></a>Unity&amp;C#预处理指令</h1><h1 id="Unity-amp-C-预处理指令-1"><a href="#Unity-amp-C-预处理指令-1" class="headerlink" title="Unity&amp;C#预处理指令"></a>Unity&amp;C#预处理指令</h1><h2 id="预处理指令（条件编译）"><a href="#预处理指令（条件编译）" class="headerlink" title="预处理指令（条件编译）"></a>预处理指令（条件编译）</h2><p>预处理器指令指导编译器在实际编译开始之前对信息进行预处理。<br>所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。<br>C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。在 C# 中，预处理器指令用于在条件编译中起作用。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。</p>
<pre><code class="lang-csharp">
#define 它用于定义一系列成为符号的字符。通过使用符号作为传递给 #if 指令的表达式，表达式将返回 true。

#undef 它用于取消定义符号。

#if 它用于测试符号是否为真。

#else 它用于创建复合条件指令，与 #if 一起使用。

#elif 它用于创建复合条件指令。

#endif 指定一个条件指令的结束。

#line 它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。

#error 它允许从代码的指定位置生成一个错误。

#warning 它允许从代码的指定位置生成一级警告。

#region 它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。

#endregion 它标识着 #region 块的结束。
</code></pre>
<h3 id="Conditional特性"><a href="#Conditional特性" class="headerlink" title="Conditional特性"></a>Conditional特性</h3><p>可以把输出日志的函数使用Conditional特性来标记上，只有在Unity编辑器中开启了指定的宏命令，这个输出日志的函数才能被编译，即可很方便地开关日志。<br><code>[Conditional(&quot;EnableLog&quot;)]</code><br>需要在Unity编辑器中添加上EnableLog宏命令，该方法才能被编译。</p>
<h2 id="Unity自带的一些宏定义"><a href="#Unity自带的一些宏定义" class="headerlink" title="Unity自带的一些宏定义"></a>Unity自带的一些宏定义</h2><p>UNITY_EDITOR Unity编辑器<br>UNITY_EDITOR_WIN Windows 操作系统.<br>UNITY_EDITOR_OSX macos操作系统<br>UNITY_STANDALONE_OSX 专门为macos（包括Universal, PPC，Intel architectures）平台的定义<br>UNITY_STANDALONE_WIN 专门为windows平台的定义<br>UNITY_STANDALONE_LINUX 专门为Linux平台的定义<br>UNITY_STANDALONE 独立平台 (Mac OS X, Windows or Linux).<br>UNITY_WII WII 游戏机平台<br>UNITY_IOS iOS系统平台<br>UNITY_IPHONE iPhone<br>UNITY_ANDROID android系统平台<br>UNITY_PS4 ps4平台<br>UNITY_SAMSUNGTV 三星TV平台<br>UNITY_XBOXONE Xbox One 平台<br>UNITY_TIZEN Tizen 平台<br>UNITY_TVOS Apple TV 平台<br>UNITY_WSA #define directive for Universal Windows Platform. Additionally, NETFX_CORE is defined when compiling C# files against .NET Core and using .NET scripting backend.<br>UNITY_WSA_10_0 #define directive for Universal Windows Platform. Additionally WINDOWS_UWP is defined when compiling C# files against .NET Core.<br>UNITY_WINRT UNITY_WSA.<br>UNITY_WINRT_10_0 UNITY_WSA_10_0<br>UNITY_WEBGL #define directive for WebGL.<br>UNITY_FACEBOOK faceBook平台(WebGL or Windows standalone).<br>UNITY_ADS 调用广告方法，版本 5.2 以后<br>UNITY_ANALYTICS 调用unity分析服务，版本5.2以后<br>UNITY_ASSERTIONS 控制指令的过程</p>
<p>UNITY_5 unity5版本, 包含所有的5.x.y版本<br>UNITY_5_0 Unity5.0版本,包含所有的5.0.x版本<br>UNITY_5_0_1 Unity5.0.1版本</p>
<h2 id="自定义宏定义"><a href="#自定义宏定义" class="headerlink" title="自定义宏定义"></a>自定义宏定义</h2><p>File - Build Settings - Player Settings - Other Settings<br>多个用分号隔开</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity-Native-Programming（C与C-互相调用）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-Unity-Native-Programming%EF%BC%88C%E4%B8%8EC-%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%EF%BC%89/"
    >Unity Native Programming（C与C++互相调用）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-Unity-Native-Programming%EF%BC%88C%E4%B8%8EC-%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%EF%BC%89/" class="article-date">
  <time datetime="2023-07-20T15:00:27.359Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Unity-Native-Programming（C-与C-互相调用）"><a href="#Unity-Native-Programming（C-与C-互相调用）" class="headerlink" title="Unity Native Programming（C#与C++互相调用）"></a>Unity Native Programming（C#与C++互相调用）</h1><h1 id="Unity-Native-Programming（C-与C-互相调用）-1"><a href="#Unity-Native-Programming（C-与C-互相调用）-1" class="headerlink" title="Unity Native Programming（C#与C++互相调用）"></a>Unity Native Programming（C#与C++互相调用）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>主要是C/C++这种操作系统级别的语言作为桥接，几乎所有高级编程语言都支持C/C++扩展，交互。</p>
<p>c/c++可以编译成.so动态库（android平台下），.dll动态库（window平台和编辑器下），.a静态库（iOS平台下），.bundle包（Mac平台下和编辑器下）</p>
<blockquote>
<p>目前.Net平台中托管环境调用非托管环境有三种方法： <strong>P/Invoke</strong> , C++ Interop, COM Interop。C++ Interop是针对托管C++使用的方法（说实话C++/CLI感觉没啥前途），COM Interop则是针对Window软件开发而采用的方式。所以我们只剩下一种解决方案：也就是PInvoke来进行托管环境与非托管环境的互操作。</p>
</blockquote>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="库、动态库和静态库（-dll，-so，-lib，-a）"><a href="#库、动态库和静态库（-dll，-so，-lib，-a）" class="headerlink" title="库、动态库和静态库（.dll，.so，.lib，.a）"></a>库、动态库和静态库（.dll，.so，.lib，.a）</h3><p><strong>库</strong> - 库 是写好的现有的，成熟的，可以复用的代码。一般是软件作者为了发布方便、替换方便或二次开发目的，而发布的一组可以单独与应用程序进行compile time或runtime <strong>链接</strong> 的 <strong>二进制</strong> 可重定位 <strong>目标码文件</strong> 。</p>
<blockquote>
<p>本质上来说库是一种 <strong>可执行代码的二进制形式</strong> ， <strong>可以被操作系统载入内存执行</strong> 。可以在编译时由编译器直接链接到可执行程序中，也可以在运行时由操作系统的runtime enviroment根据需要动态加载到内存中。</p>
</blockquote>
<h4 id="链接种类"><a href="#链接种类" class="headerlink" title="链接种类"></a>链接种类</h4><p><strong>链接</strong> + 把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。</p>
<p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607254489703.png" alt="Alt text"></p>
<p><strong>静态链接库</strong> - 静态编译时由编译器到指定目录寻找并且进行链接，一旦链接完成，最终的可执行程序中就包含了该库文件中的所有有用信息，包括代码段、数据段等。</p>
<ul>
<li><p>使用静态库的时候，会将静态库的信息直接编译到可执行文件中</p>
</li>
<li><p>优点：当静态库被删除，对可执行文件没有影响</p>
</li>
<li><p>优点：直接被链接进可执行程序中之后，该可执行程序就不再依赖于运行环境的设置了（当然仍然会依赖于 CPU指令集和操作系统支持的可执行文件格式等硬性限制）</p>
</li>
<li><p>缺点:浪费内存空间。如果静态库被修改，可执行程序要重新编译</p>
</li>
</ul>
<p><strong>动态链接库</strong> - 在应用程序运行时，由操作系统根据应用程序的请求，动态到指定目录下寻找并装载入内存中，同时需要进行地址重定向。</p>
<ul>
<li><p>加载器在加载动态库时，操作系统会先检查动态库是否因为其它程序已经将这个动态库信息加载到了内存中。如果没有加载到内存中，操作系统会将动态库载入内存，并将它的引用计数设置为1;如果已经加载到内存，仅将动态库的引用计数加1。</p>
</li>
<li><p>优点：用户甚至可以在程序运行时随时替换该动态库，这就构成了动态插件系统的基础。</p>
</li>
</ul>
<blockquote>
<p>动态链接库的效率可能比静态链接库要差 - 程序总无法直接调用动态库中的函数符号，而只能通过调用操作系统的runtime enviroment接口来动态载入某个函数符号，同时获得该函数符号在内存中的地址，将其保存为函数指针进行调用，这就在函数调用时增加了一次间接寻址的过程。</p>
</blockquote>
<h4 id="不同平台的命名"><a href="#不同平台的命名" class="headerlink" title="不同平台的命名"></a>不同平台的命名</h4><hr>
<p>Android / Linux下：<br>静态库( static library ) : lib库名.a<br>动态库( shared library ) : lib库名.so(shared object)</p>
<hr>
<p>window：下<br>静态库:lib库名.lib<br>动态库:lib库名.dll(dynamic link library)</p>
<p><strong>Dynamic-link library (DLL)</strong> is <strong>Microsoft’s implementation</strong> of the <strong>shared library concept</strong> in the Microsoft Windows and OS/2 operating systems. These libraries usually have the file extension <strong>DLL</strong> , <strong>OCX</strong> (for libraries containing ActiveX controls), or <strong>DRV</strong> (for legacy system drivers). </p>
<blockquote>
<p>The file formats for DLLs are the same as for Windows EXE files – that is, Portable Executable (PE) for 32-bit and 64-bit Windows, and New Executable (NE) for 16-bit Windows. As with EXEs, DLLs can contain <strong>code</strong> , <strong>data</strong> , and <strong>resources</strong> , in any combination.</p>
</blockquote>
<p>相关链接：<a href="https://stackoverflow.com/questions/9688200/difference-between-shared-objects-so-static-libraries-a-and-dlls-so" target="_blank" rel="noopener">Difference between shared objects (.so), static libraries (.a), and DLL’s (.so)?</a></p>
<hr>
<blockquote>
<p>如何知道一个可执行程序依赖哪些库?<br> ldd命令可以查看一个可执行程序依赖的共享库</p>
</blockquote>
<pre><code class="lang-csharp">
# ldd + 路径/可执行程序
</code></pre>
<h3 id="ABI（Application-binary-interface）"><a href="#ABI（Application-binary-interface）" class="headerlink" title="ABI（Application binary interface）"></a>ABI（Application binary interface）</h3><p>In computer software, an application binary interface (ABI) is an interface between two <strong>binary program modules</strong>.</p>
<ul>
<li><p>a library or operating system facility</p>
</li>
<li><p>program that is being run by a user</p>
</li>
</ul>
<p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607772411910.png" alt="Alt text"></p>
<p><em>来源：WIKIPEDIA</em></p>
<p>An ABI defines how data structures or computational routines are accessed <strong>in machine code</strong> , which is a <strong>low-level</strong> , hardware-dependent format.<br>In contrast, an API defines this access in <strong>source code</strong> , which is a relatively <strong>high-level</strong> , hardware-independent, often human-readable format.<br>A common aspect of an ABI is <strong>the calling convention</strong> , which determines how data is provided as input to, or read as output from, computational routines.</p>
<h4 id="ABIs包含的一些细节"><a href="#ABIs包含的一些细节" class="headerlink" title="ABIs包含的一些细节"></a>ABIs包含的一些细节</h4><ul>
<li><p>a <strong>processor instruction set</strong> (with details like register file structure, stack organization, memory access types, …)</p>
</li>
<li><p>the sizes, layouts, and alignments of <strong>basic data types</strong> that the processor can directly access</p>
</li>
<li><p>the <strong>calling convention</strong> , which controls how the arguments of functions are passed, and return values retrieved. </p>
</li>
<li><p>in the case of a complete operating system ABI, <strong>the binary format of object files</strong> , <strong>program libraries</strong> , and so on.</p>
</li>
</ul>
<h4 id="Android-ABIs"><a href="#Android-ABIs" class="headerlink" title="Android ABIs"></a>Android ABIs</h4><p>Different Android devices use different <strong>CPUs</strong> , which in turn support different <strong>instruction sets</strong>. Each combination of CPU and instruction set has its own Application Binary Interface (ABI). </p>
<blockquote>
<p>查看安卓手机ABI:<br> adb shell cat /proc/cpuinfo<br> adb shell getprop ro.product.cpu.abi</p>
</blockquote>
<p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607774108632.png" alt="Alt text"></p>
<p>The default behavior of the build system is to include the binaries for each ABI in a single APK, also known as a <strong>fat APK</strong>.</p>
<p>At installation time, the package manager unpacks only the most appropriate machine code for the target device. ( <strong>Automatic extraction of native code at install time</strong> )</p>
<p>a fat APK may contain:</p>
<pre><code class="lang-csharp">
/lib/armeabi/libfoo.so

/lib/armeabi-v7a/libfoo.so

/lib/arm64-v8a/libfoo.so

/lib/x86/libfoo.so

/lib/x86_64/libfoo.so
</code></pre>
<h4 id="Generate-code-for-a-specific-ABI"><a href="#Generate-code-for-a-specific-ABI" class="headerlink" title="Generate code for a specific ABI"></a>Generate code for a specific ABI</h4><p>Gradle (whether used via Android Studio or from the command line) builds for all non-deprecated ABIs by default. </p>
<p>For example, to build for only 64-bit ABIs, set the following configuration in your build.gradle</p>
<pre><code class="lang-csharp">
android {

defaultConfig {

ndk {

abiFilters &#39;arm64-v8a&#39;, &#39;x86_64&#39;

}

}

}
</code></pre>
<h3 id="存储类型说明符-Storage-Class-Specifiers"><a href="#存储类型说明符-Storage-Class-Specifiers" class="headerlink" title="存储类型说明符(Storage Class Specifiers)"></a>存储类型说明符(Storage Class Specifiers)</h3><ul>
<li><p><strong>Storage class specifiers</strong> in C language tells the compiler <strong>where</strong> to store a variable, <strong>how</strong> to store the variable, <strong>what</strong> is the initial value of the variable and <strong>life time</strong> of the variable.</p>
</li>
<li><p>A storage class defines the <strong>scope (visibility)</strong> and <strong>life-time</strong> of <strong>variables</strong> and/or <strong>functions</strong> within a C++ Program. </p>
</li>
</ul>
<blockquote>
<p><strong>Declaration specifiers(声明说明符)</strong> (decl-specifier-seq) is a sequence of the following whitespace-separated specifiers, in any order.<br> (via. <a href="https://en.cppreference.com/w/cpp/language/declarations" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/declarations</a>)</p>
</blockquote>
<p>C provides the following storage-class specifiers:</p>
<ul>
<li><p>auto</p>
</li>
<li><p>register</p>
</li>
<li><p>static</p>
</li>
<li><p>extern</p>
</li>
<li><p>typedef</p>
</li>
<li><p>__declspec ( extended-decl-modifier-seq ) /<em> Microsoft-specific </em>/</p>
</li>
</ul>
<p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607186665209.png" alt="ABIs and supported instruction sets"></p>
<h4 id="EXTERN"><a href="#EXTERN" class="headerlink" title="EXTERN"></a>EXTERN</h4><p>The scope of this extern variable is throughout the main program. It is equivalent to global variable. <strong>Definition for extern variable might be anywhere in the C program</strong>.</p>
<pre><code class="lang-csharp">
#include&lt;stdio.h&gt;

int x = 10 ; 

int main( )

{ 

extern int y; 

printf(&quot;The value of x is %d \n&quot;,x); 

printf(&quot;The value of y is %d&quot;,y); 

return 0; 

} 

int y=50;
</code></pre>
<h4 id="REGISTER"><a href="#REGISTER" class="headerlink" title="REGISTER"></a>REGISTER</h4><ul>
<li><p>Register variables are also local variables, but stored in register memory. Whereas, auto variables are stored in main CPU memory.</p>
</li>
<li><p>Register variables will be accessed very faster than the normal variables since they are stored in register memory rather than main memory.</p>
</li>
<li><p>But, only limited variables can be used as register since register size is very low. (16 bits, 32 bits or 64 bits)</p>
</li>
</ul>
<h4 id="declspec"><a href="#declspec" class="headerlink" title="__declspec"></a>__declspec</h4><p>__declspec是Microsoft特定的属性，允许您指定存储类信息。但是，许多其他编译器供应商（例如GCC）现在支持此 <strong>语言扩展</strong> ，以与针对Microsoft编译器编写的已安装代码库兼容。</p>
<p>The <strong>extended attribute syntax</strong> for specifying <strong>storage-class information</strong> uses the __declspec keyword, which specifies that an instance of a given type is to be stored with a Microsoft-specific storage-class attribute listed below. </p>
<ul>
<li><p>thread</p>
</li>
<li><p>naked</p>
</li>
<li><p>dllimport</p>
</li>
<li><p>dllexport</p>
</li>
<li><p>(Others)</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>语言概念</th>
<th>具体概念</th>
<th>代码  </th>
</tr>
</thead>
<tbody>
<tr>
<td>Keyword</td>
<td></td>
<td>__declspec  </td>
</tr>
<tr>
<td>decl-specifier（声明修饰符）</td>
<td></td>
<td>__declspec ( extended-decl-modifier-seq )  </td>
</tr>
<tr>
<td>extended-decl-modifier（声明修饰符的拓展）</td>
<td>Storage-Class Attributes（Specifier）</td>
<td>dllexport, dllimport等  </td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Microsoft将该__declspec符号发明为C ++语言的扩展。我相信GCC现在支持它，但这主要是出于与Microsoft编译器兼容的原因。而且我不了解“特定于MS”与“特定于编译器”有何不同。微软编写了一个C ++编译器，许多人使用它。它随Visual Studio一起提供。 via. <a href="https://qastack.cn/programming/8863193/what-does-declspecdllimport-really-mean" target="_blank" rel="noopener">QAStack</a></p>
</blockquote>
<p>可以指定的那些存储类属性中的两个是dllimport和dllexport。这些向编译器指示分别从DLL导入或导出函数或对象。</p>
<h5 id="dllexport-dllimport"><a href="#dllexport-dllimport" class="headerlink" title="dllexport, dllimport"></a>dllexport, dllimport</h5><p>You can use them to export and import functions, data, and objects to or from a DLL.</p>
<p>dllexport是把DLL中的相关代码（类，函数，数据）暴露出来为其他应用程 序使用。</p>
<p>These attributes explicitly define the DLL’s interface to its client, which can be the executable file or another DLL. Declaring functions as dllexport eliminates the need for a module-definition (.def) file, at least with respect to the specification of exported functions.</p>
<p>若要导出类中的所有公共数据成员和成员函数，关键字必须出现在类名的左边，如下所示：</p>
<pre><code class="lang-csharp">
class __declspec(dllexport) CExampleExport : public CObject 

{ 

... class definition ... 

};
</code></pre>
<p>dllexport of a function exposes the function with its decorated name. For C++ functions, this includes name mangling. For C functions or functions that are declared as extern “C”, this includes platform-specific decoration that’s based on the calling convention. For information on name decoration in C/C++ code, see Decorated Names. No name decoration is applied to exported C functions or C++ extern “C” functions using the __cdecl calling convention.</p>
<h5 id="特殊用法——提供者和使用者共用同一个头文件"><a href="#特殊用法——提供者和使用者共用同一个头文件" class="headerlink" title="特殊用法——提供者和使用者共用同一个头文件"></a>特殊用法——提供者和使用者共用同一个头文件</h5><pre><code class="lang-csharp">
#ifndef DLL_H_ 

#define DLL_H_ 

#ifdef DLLProvider 

#define DLL_EXPORT_IMPORT __declspec(dllexport) 

#else

#define DLL_EXPORT_IMPORT __declspec(dllimport) 

#endif

DLL_EXPORT_IMPORT int add(int ,int); 

#endif
</code></pre>
<h5 id="更详细的资料"><a href="#更详细的资料" class="headerlink" title="更详细的资料"></a>更详细的资料</h5><p>参见: <a href="https://www.cnblogs.com/yyxt/p/4241802.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyxt/p/4241802.html</a></p>
<h2 id="Unity中C-调用C-：PInvoke"><a href="#Unity中C-调用C-：PInvoke" class="headerlink" title="Unity中C#调用C++：PInvoke"></a>Unity中C#调用C++：PInvoke</h2><h3 id="Unity-Plugins"><a href="#Unity-Plugins" class="headerlink" title="Unity Plugins"></a>Unity Plugins</h3><p>In Unity, you normally use scripts to create functionality, but you can also include code created outside Unity in the form of a plug-in. There are two kinds of plug-ins you can use in Unity: Managed plug-ins and Native plug-ins.</p>
<h4 id="Managed-plug-ins"><a href="#Managed-plug-ins" class="headerlink" title="Managed plug-ins"></a>Managed plug-ins</h4><p>Managed plug-ins are managed .NET assemblies created with tools like Visual Studio. They contain only .NET code which means that they can’t access any features that are not supported by the .NET libraries.<br>However, managed code is accessible to the standard .NET tools that Unity uses to compile scripts. There is thus little difference in usage between managed plug-in code and Unity script code, except for the fact that the plug-ins are compiled outside Unity and so the source may not be available.</p>
<h4 id="Native-plug-ins"><a href="#Native-plug-ins" class="headerlink" title="Native plug-ins"></a>Native plug-ins</h4><p>Native plug-ins are are libraries of native code written in C, C++, Objective-C, etc. They are platform-specific.</p>
<p>They can access features like OS calls and third-party code libraries that would otherwise not be available to Unity.</p>
<h3 id="Unity-Assets-Plugins文件夹"><a href="#Unity-Assets-Plugins文件夹" class="headerlink" title="Unity Assets/Plugins文件夹"></a>Unity Assets/Plugins文件夹</h3><p>Plugins文件夹用来放native插件。它们会被自动包含进build中去。（注意这个文件夹只能是Assets文件夹的直接子目录。）</p>
<ol>
<li><p>Plugins/x86<br>如果为32bit或64bit平台创建游戏，那么这个文件夹下的native plugin文件会被自动的包含在游戏build中。如果这个文件夹不存在，则Unity会查找Plugins文件夹下的native pluglins。</p>
</li>
<li><p>Plugins/x86_64<br>如果为32bit或64bit平台创建游戏，那么这个文件夹下的native plugin文件会被自动的包含在游戏build中。如果这个文件夹不存在，则Unity会查找Plugins文件夹下的native pluglins。<br>如果要创建universal build，建议你同时使用这两个文件夹。然后将32bit和64bit的native plugins放进相应的文件夹中。</p>
</li>
<li><p>Plugins/Android<br>在这个文件夹里放入Java.jar文件。用于java语言的plugins。.so文件也会被包含进来。<br>See <a href="http://docs.unity3d.com/Documentation/Manual/PluginsForAndroid.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/PluginsForAndroid.html</a></p>
</li>
</ol>
<p>Android平台根据cpu架构不同放在对应文件夹下面，比如Anroid/libs/armeabi-v7a。</p>
<ol>
<li>Plugins/iOS<br>A limited, simple way to automatically add (as symbolic links) any .a, .m, .mm, .c, or .cpp files into the generated Xcode project. See<br>[<a href="http://docs.unity3d.com/Documentation/Manual/PluginsForIOS.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/PluginsForIOS.html</a><br>If you need more control how to automatically add files to the Xcode project, you should make use of the PostprocessBuildPlayer feature. Doing so does not require you to place such files in the Plugins/iOS folder. See[<a href="http://docs.unity3d.com/Documentation/Manual/BuildPlayerPipeline.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/BuildPlayerPipeline.html</a></li>
</ol>
<h3 id="PInvoke简单实践：Windows平台下调用Native代码"><a href="#PInvoke简单实践：Windows平台下调用Native代码" class="headerlink" title="PInvoke简单实践：Windows平台下调用Native代码"></a>PInvoke简单实践：Windows平台下调用Native代码</h3><h4 id="编写C-代码并导出"><a href="#编写C-代码并导出" class="headerlink" title="编写C++代码并导出"></a>编写C++代码并导出</h4><p>Write functions in a C-based language to access whatever features you need and compile them into a library. </p>
<ol>
<li><p>建立Win32工程</p>
</li>
<li><p>写代码</p>
</li>
</ol>
<p>TestLibAdd.h</p>
<pre><code class="lang-csharp">
#ifndef __TESTLIBADD__

#define __TESTLIBADD__

extern &quot;C&quot; __declspec(dllexport) int __stdcall Add(int a, int b); 

#endif
</code></pre>
<p>TestLibAdd.cpp</p>
<pre><code class="lang-csharp">
#include &quot;TestLib-Add.h&quot;

__declspec(dllexport) int __stdcall Add(int a, int b)

{ 

return a + b; 

}
</code></pre>
<blockquote>
<p>__declspec(dllexport)代表需要导出的函数，需要放在函数定义的前面。<br> extern “C”表示以C语言方式进行导出<br> <strong>stdcall表示以标准方式调用。由于定义了extern “C”与</strong> stdcall，编译器会对函数名进行整理，在库中会独立对应一个标识符，C#也会根据相同的规则去寻找符合条件的函数以进行调用。<br> 在非托管dll导出的时候往往会用到不同的调用方式，所以相同的在C#中也可以通过调整DllImport中的CallingConvention进行指定以保证找到相应的函数。</p>
</blockquote>
<ol>
<li><p>右键点击工程，选择属性，选择生成动态库dll</p>
</li>
<li><p>选择平台类型</p>
</li>
</ol>
<p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607244642003.png" alt="Alt text"></p>
<ol>
<li>我们右键工程进行生成，分别生成x86与x64的版本。</li>
</ol>
<p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607244666427.png" alt="Alt text"></p>
<ol>
<li>分别将生成的.dll与.pdb放入到对应的文件夹中。x86放入x86文件夹，x64放入x86_64文件夹下。</li>
</ol>
<h4 id="在C-中编写接口"><a href="#在C-中编写接口" class="headerlink" title="在C#中编写接口"></a>在C#中编写接口</h4><p>Create a C# script which calls functions in the native library.</p>
<p>定义函数</p>
<ul>
<li><p>static - 非托管函数无需实例化就可直接调用</p>
</li>
<li><p>extern - 告诉编译器该函数在外部定义，不需要函数体</p>
</li>
<li><p>DllImport(“DLL名称”) - Unity会首先搜索Plugin，如果在Windows平台会去搜索系统目录，如果仍未找到就会抛出DllNotFound异常。</p>
</li>
</ul>
<blockquote>
<p>DllImport定义在命名空间<code>System.Runtime.InteropServices</code>中</p>
</blockquote>
<p>基本格式：</p>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Runtime.InteropServices; 

class SomeScript : MonoBehaviour { 

#if UNITY_IPHONE

// On iOS plugins are statically linked into

// the executable, so we have to use __Internal as the

// library name.

[DllImport (&quot;__Internal&quot;)] 

#else

// Other platforms load plugins dynamically, so pass the name

// of the plugin&#39;s dynamic library.

[DllImport (&quot;PluginName&quot;)] 

#endif

private static extern float FooPluginFunction (); 

void Awake () { 

// Calls the FooPluginFunction inside the plugin

// And prints 5 to the console

print (FooPluginFunction ()); 

} 

}
</code></pre>
<p>笔者的案例：</p>
<pre><code class="lang-csharp">
using System.Runtime.InteropServices; 

namespace TestNativeLib

{ 

public class TestNativeLibInterface

{ 

[DllImport(&quot;TestNativeLib&quot;)] 

public static extern int Add(int a, int b); 

} 

}
</code></pre>
<blockquote>
<p>可能遇到的其他问题: 指定字符集、指定调用方式、指定调用入口。遇到时查阅相关资料即可</p>
</blockquote>
<p>在C#中调用就像普通调用C#函数一样。</p>
<pre><code class="lang-csharp">
using System.Collections; 

using System.Collections.Generic; 

using UnityEngine; 

using UnityEngine.UI; 

namespace TestNativeLib

{ 

public class AddUI : MonoBehaviour

{ 

private Text text; 

private int cnt; 

void Start()

{ 

text = GetComponent&lt;Text&gt;(); 

StartCoroutine(NumUIUpdate()); 

} 

IEnumerator NumUIUpdate()

{ 

WaitForSeconds wfs = new WaitForSeconds(0.3f); 

while(true) 

{ 

text.text = cnt.ToString(); 

cnt = TestNativeLibInterface.Add(cnt, 2); 

yield return wfs; 

} 

} 

} 

}
</code></pre>
<h3 id="Native-C-plug-ins-for-Android"><a href="#Native-C-plug-ins-for-Android" class="headerlink" title="Native (C++) plug-ins for Android"></a>Native (C++) plug-ins for Android</h3><p>Unity supports native plug-ins for Android written in C/C++ and packaged in a <strong>shared library (.so)</strong> or a <strong>static library (.a)</strong>. </p>
<p>To build a C++ plug-in for Android, use the <strong>Android NDK</strong> and get yourself familiar with the steps required to build a shared library. </p>
<p>When using the <strong>IL2CPP</strong> scripting backend, you can use C/C++ source files as plug-ins and Unity compiles them along with IL2CPP generated files. This includes all <strong>C/C++ source files</strong> with extensions .c, .cc, .cpp and .h.</p>
<h4 id="how-the-Android-platform-manages-native-code-in-APKs-ABI-management"><a href="#how-the-Android-platform-manages-native-code-in-APKs-ABI-management" class="headerlink" title="how the Android platform manages native code in APKs(ABI management)"></a>how the Android platform manages native code in APKs(ABI management)</h4><h5 id="Native-code-in-app-packages"><a href="#Native-code-in-app-packages" class="headerlink" title="Native code in app packages"></a>Native code in app packages</h5><p>Both the Play Store and Package Manager expect to find NDK-generated libraries on filepaths inside the APK matching the following pattern:</p>
<pre><code class="lang-csharp">
/lib/&lt;abi&gt;/lib&lt;name&gt;.so
</code></pre>
<p>a fat APK may contain:a fat APK may contain:</p>
<pre><code class="lang-csharp">
/lib/armeabi/libfoo.so

/lib/armeabi-v7a/libfoo.so

/lib/arm64-v8a/libfoo.so

/lib/x86/libfoo.so

/lib/x86_64/libfoo.so
</code></pre>
<h5 id="Android-platform-ABI-support"><a href="#Android-platform-ABI-support" class="headerlink" title="Android platform ABI support"></a>Android platform ABI support</h5><p>You can force install an apk for a specific ABI. This is useful for testing. Use the following command:</p>
<pre><code class="lang-csharp">
adb install --abi abi-identifier path_to_apk
</code></pre>
<h5 id="Automatic-extraction-of-native-code-at-install-time"><a href="#Automatic-extraction-of-native-code-at-install-time" class="headerlink" title="Automatic extraction of native code at install time"></a>Automatic extraction of native code at install time</h5><p>When it finds the libraries that it’s looking for, the package manager copies them to <code>/lib/lib&lt;name&gt;</code>.so, under the application’s native library directory (<code>&lt;nativeLibraryDir&gt;/</code>). The following snippets retrieve the nativeLibraryDir:</p>
<pre><code class="lang-csharp">
import android.content.pm.PackageInfo; 

import android.content.pm.ApplicationInfo; 

import android.content.pm.PackageManager; 

... 

ApplicationInfo ainfo = this.getApplicationContext().getPackageManager().getApplicationInfo 

( 

&quot;com.domain.app&quot;, 

PackageManager.GET_SHARED_LIBRARY_FILES 

); 

Log.v( TAG, &quot;native library dir &quot; \+ ainfo.nativeLibraryDir );
</code></pre>
<h4 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h4><ol>
<li><p>配置安卓开发环境 <a href="https://developer.android.com/" target="_blank" rel="noopener">https://developer.android.com/</a></p>
</li>
<li><p>Android Studio -&gt; Settings -&gt; Apperance &amp; Behaviour -&gt; System Settings -&gt;Android SDK -&gt; SDK Tools。安装CMake、NDK</p>
</li>
</ol>
<p><img src="assets/Unity%20Native%20Programming（C与C++互相调用）/1607349255030.png" alt="Alt text"></p>
<h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><p>how to use CMake with the NDK</p>
<ul>
<li><p>the Android Gradle Plugin’s <code>ExternalNativeBuild</code></p>
</li>
<li><p>invoking CMake directly</p>
</li>
</ul>
<h4 id="更多Android-Native代码开发教程"><a href="#更多Android-Native代码开发教程" class="headerlink" title="更多Android Native代码开发教程"></a>更多Android Native代码开发教程</h4><ol>
<li><p>官网 <a href="https://developer.android.com/studio/projects/add-native-code" target="_blank" rel="noopener">https://developer.android.com/studio/projects/add-native-code</a></p>
</li>
<li><p>国内博客 <a href="https://www.cnblogs.com/lsdb/p/9337285.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsdb/p/9337285.html</a></p>
</li>
<li></li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/30746354" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30746354</a><br><a href="https://www.cnblogs.com/yyxt/p/4241802.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyxt/p/4241802.html</a><br><a href="https://fresh2refresh.com/c-programming/c-storage-class-specifiers/" target="_blank" rel="noopener">https://fresh2refresh.com/c-programming/c-storage-class-specifiers/</a><br><a href="https://docs.microsoft.com/en-us/cpp/cpp/declspec?view=msvc-160" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/cpp/declspec?view=msvc-160</a><br><a href="https://blog.csdn.net/junxuezheng/article/details/100557176" target="_blank" rel="noopener">https://blog.csdn.net/junxuezheng/article/details/100557176</a><br><a href="https://www.cnblogs.com/andyliu1988/p/3222892.html" target="_blank" rel="noopener">https://www.cnblogs.com/andyliu1988/p/3222892.html</a><br><a href="https://docs.unity3d.com/Manual/Plugins.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/Plugins.html</a><br><a href="https://docs.unity3d.com/Manual/AndroidNativePlugins.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/AndroidNativePlugins.html</a><br><a href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Application_binary_interface</a><br><a href="https://developer.android.com/ndk/guides/abis" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/abis</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity-Crash-与-符号表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-Unity-Crash-%E4%B8%8E-%E7%AC%A6%E5%8F%B7%E8%A1%A8/"
    >Unity Crash 与 符号表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-Unity-Crash-%E4%B8%8E-%E7%AC%A6%E5%8F%B7%E8%A1%A8/" class="article-date">
  <time datetime="2023-07-20T15:00:27.357Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a href="https://www.cnblogs.com/wayland/articles/13092292.html" target="_blank" rel="noopener">https://www.cnblogs.com/wayland/articles/13092292.html</a></p>
<p><a href="https://blog.csdn.net/weixin_44084447/article/details/122929279" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44084447/article/details/122929279</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/77984555" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77984555</a></p>
<p><a href="https://grrava.blogspot.com/2016/01/unity-crash-dumps-to-rescue.html" target="_blank" rel="noopener">https://grrava.blogspot.com/2016/01/unity-crash-dumps-to-rescue.html</a></p>
<p><a href="https://www.sebaslab.com/how-to-debug-unity-natively-using-mixed-c-and-c-stack/" target="_blank" rel="noopener">https://www.sebaslab.com/how-to-debug-unity-natively-using-mixed-c-and-c-stack/</a></p>
<p><a href="https://www.cnblogs.com/caiger-blog/p/16211519.html" target="_blank" rel="noopener">https://www.cnblogs.com/caiger-blog/p/16211519.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Unity-Addressasble"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-Unity-Addressasble/"
    >Unity Addressasble</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-Unity-Addressasble/" class="article-date">
  <time datetime="2023-07-20T15:00:27.354Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ul>
<li>Unity Addressasble<ul>
<li>Heading</li>
</ul>
</li>
</ul>
<h2 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-UGUI"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-UGUI/"
    >UGUI</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-UGUI/" class="article-date">
  <time datetime="2023-07-20T15:00:27.351Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Canvas渲染"><a href="#Canvas渲染" class="headerlink" title="Canvas渲染"></a>Canvas渲染</h2><h3 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h3><p><img src="UGUI/1620891879051.png" alt="Alt text"></p>
<p>Pixel Perfect - 使UI元素像素对应，效果就是边缘清晰不模糊。</p>
<h3 id="RenderMode"><a href="#RenderMode" class="headerlink" title="RenderMode"></a>RenderMode</h3><h4 id="Screen-Space-Overlay"><a href="#Screen-Space-Overlay" class="headerlink" title="Screen Space-Overlay"></a>Screen Space-Overlay</h4><p>the Canvas is scaled to fit the screen and then rendered directly without reference to the scene or a camera</p>
<p>If the screen’s size or resolution are changed then the UI will automatically rescale to fit. </p>
<p>The UI will be drawn over any other graphics such as the camera view.<br>此模式只适合单纯的UI开发</p>
<h4 id="Screen-Space-Camera"><a href="#Screen-Space-Camera" class="headerlink" title="Screen Space - Camera"></a>Screen Space - Camera</h4><p>the Canvas is rendered as if it were drawn on a plane object some distance in front of a given camera. </p>
<p>The onscreen size of the UI does not vary with the distance since it is always rescaled to fit exactly within the camera frustum.</p>
<p>If the screen’s size or resolution or the camera frustum are changed then the UI will automatically rescale to fit.</p>
<p>可以用来实现在UI上显示3D模型的需求</p>
<p>参数：<br>Render Camera:渲染摄像机<br>Plane Distance:画布距离摄像机的距离<br>Sorting Layer<br>Order in Layer</p>
<h4 id="World-Space"><a href="#World-Space" class="headerlink" title="World Space"></a>World Space</h4><p>the plane need not face the camera and can be oriented however you like.</p>
<p>参数Event Camera - 用来指定接受事件的摄像机</p>
<h2 id="分辨率自适应-Canvas-Scaler"><a href="#分辨率自适应-Canvas-Scaler" class="headerlink" title="分辨率自适应 - Canvas Scaler"></a>分辨率自适应 - Canvas Scaler</h2><h3 id="关于Pixels-Per-Unity"><a href="#关于Pixels-Per-Unity" class="headerlink" title="关于Pixels Per Unity"></a>关于Pixels Per Unity</h3><p>Sprite中的设置：</p>
<p><img src="UGUI/1620895502265.png" alt="Alt text"></p>
<p>对于256x256的图片，这个值设置成100，意味着这个图的大小是 2.56x2.56 Units。</p>
<p>Canvas中的设置：</p>
<p><img src="UGUI/1620895706110.png" alt="Alt text"></p>
<p>指的是元素的1Unit对应UI屏幕上的多少像素。<br>2.56x2.56 Units的图片，对应屏幕上的256x256的像素。</p>
<p>For sprites that have the same Pixels Per Unit as the Reference Pixels Per Unit in the Canvas, the pixel density will be one to one.</p>
<h3 id="自适应方法"><a href="#自适应方法" class="headerlink" title="自适应方法"></a>自适应方法</h3><p>Reference Resolution - 开发时的分辨率。以后缩放就参考它。</p>
<p><img src="UGUI/1620896163082.png" alt="Alt text"></p>
<p>适应屏幕分辨率，本质是选择一个合适的缩放Canvas的方式。屏幕的宽高比会变化，Canvas的宽高比要与屏幕永远一致。Unity提供了几种方式 ，用来对Canvas进行缩放，来保证Canvas的宽高比与实际屏幕一致。</p>
<h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>Match - Determines if the scaling is using the width or height as reference, or a mix in between.<br>处于中间某处时，对上述两者的影响进行权重加成 。所以一般我们都把其放在0.5的位置（0.618）</p>
<p>缩放时，UI元素之间的相对位置的比例是不变的。<br>Canvas进行 <strong>等比缩放</strong> 。</p>
<p>如图，Reference Resolution为800x600。</p>
<p><img src="UGUI/1620897020559.png" alt="Alt text"></p>
<p>Match Width - 匹配Width，保持Canvas的Width与Reference一致，缩放Heigth来保证比例与屏幕一致。比例一致后，Scale指的是当前的Canvas最终画到手机上时，应该进行的缩放。</p>
<p>当Resolution为1600x800时，Width不变，缩放Canvas的Height来保持比例与屏幕一致。因此，Canvas变为800x300。Scale为2，表示 屏幕 = Canvas x 2 ，Canvas放大两倍后画到屏幕上。</p>
<p><img src="UGUI/1620897086485.png" alt="Alt text"></p>
<p><img src="UGUI/1620898602324.png" alt="Alt text"></p>
<p>一般是Match Height，保持Canvas的高度不变，背景图的宽度画的长一点，用来适配不用的屏幕。UI元素的锚点设置为四个角即可。</p>
<p><img src="UGUI/1620900142626.png" alt="Alt text"></p>
<h4 id="Expand-amp-Shrink"><a href="#Expand-amp-Shrink" class="headerlink" title="Expand &amp; Shrink"></a>Expand &amp; Shrink</h4><p>Expand - Expand the canvas area either horizontally or vertically, so the size of the canvas will never be smaller than the reference.<br>Shrink - Crop the canvas area either horizontally or vertically, so the size of the canvas will never be larger than the reference.</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#104;&#x74;&#116;&#112;&#x73;&#58;&#47;&#x2f;&#x64;&#111;&#99;&#x73;&#46;&#117;&#110;&#x69;&#116;&#121;&#51;&#100;&#46;&#x63;&#x6f;&#109;&#47;&#x50;&#97;&#99;&#x6b;&#97;&#103;&#101;&#x73;&#47;&#99;&#111;&#109;&#x2e;&#117;&#x6e;&#105;&#116;&#121;&#x2e;&#x75;&#x67;&#x75;&#105;&#64;&#49;&#x2e;&#x30;&#x2f;&#x6d;&#x61;&#x6e;&#x75;&#97;&#x6c;&#47;&#99;&#x6c;&#x61;&#x73;&#x73;&#45;&#67;&#x61;&#110;&#118;&#x61;&#115;&#x2e;&#x68;&#x74;&#x6d;&#108;">&#104;&#x74;&#116;&#112;&#x73;&#58;&#47;&#x2f;&#x64;&#111;&#99;&#x73;&#46;&#117;&#110;&#x69;&#116;&#121;&#51;&#100;&#46;&#x63;&#x6f;&#109;&#47;&#x50;&#97;&#99;&#x6b;&#97;&#103;&#101;&#x73;&#47;&#99;&#111;&#109;&#x2e;&#117;&#x6e;&#105;&#116;&#121;&#x2e;&#x75;&#x67;&#x75;&#105;&#64;&#49;&#x2e;&#x30;&#x2f;&#x6d;&#x61;&#x6e;&#x75;&#97;&#x6c;&#47;&#99;&#x6c;&#x61;&#x73;&#x73;&#45;&#67;&#x61;&#110;&#118;&#x61;&#115;&#x2e;&#x68;&#x74;&#x6d;&#108;</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-U3D资源优化（零碎）知识点汇总"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-U3D%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%EF%BC%88%E9%9B%B6%E7%A2%8E%EF%BC%89%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
    >U3D资源优化（零碎）知识点汇总</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-U3D%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%EF%BC%88%E9%9B%B6%E7%A2%8E%EF%BC%89%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="article-date">
  <time datetime="2023-07-20T15:00:27.334Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h2><h3 id="ImportSettings"><a href="#ImportSettings" class="headerlink" title="ImportSettings"></a>ImportSettings</h3><p>Force To Mono：将多声道音频混合为单声道，一般手机使用单声道足够满足需求<br>Load In Background：When this option is enabled, the loading of the clip will happen at a delayed time on a separate thread, without blocking the main thread. 分线程加载， 不阻塞主线程<br>Ambisonic：是否环绕声</p>
<p>Load Type：加载方式</p>
<p><strong>Decompress On Load</strong> ：在音频 <strong>加载后马上解压缩</strong> 。对 <strong>较小的压缩声音</strong> 使用此选项可以避免动态解压缩的性能开销，不过在加载时解压缩Vorbis编码的声音将使用大约十倍于内存的内存（对于ADPCM编码约为3.5倍），因此请勿对大文件使用此选项。<br><strong>Compressed In Memory</strong> ：将声音压缩在内存中并在 <strong>播放时解压缩</strong> 。 此选项具有轻微的性能开销（特别是对于Ogg / Vorbis压缩文件），因此仅将其 <strong>用于加载时解压缩将使用大量内存的较大的文件</strong> 。 解压缩发生在 <strong>混音器线程</strong> 上，可以在探查器窗口的音频窗格中的”DSP CPU(Digital Signal Processor)”部分进行监视。<br><strong>Streaming</strong> ： <strong>动态解码</strong> 声音。 此方法使用 <strong>最少量的内存来缓冲从磁盘中逐步读取并在运行中解码的压缩数据</strong> 。 解压缩发生在单独的流线程上，可以在Profiler窗口的音频窗格的”Streaming CPU”部分中监视其CPU使用情况。 即使没有加载任何音频数据，Streaming的剪辑也有大约200KB的消耗。</p>
<p>Preload Audio Data：预加载</p>
<p>Compression Format<br>PCM：此选项以 <strong>更大的文件</strong> 大小为代价提供 <strong>更高的质量</strong> ，并且最适 <strong>合非常短的声音</strong> 效果。<br>ADPCM：这种格式对于 <strong>包含大量噪音</strong> 且 <strong>需要大量播放</strong> 的声音非常有用，例如脚步声，撞击声，武器。 <strong>压缩比</strong> 是PCM的 <strong>3.5倍</strong> ，而且 <strong>CPU使用率</strong> 远 <strong>低</strong> 于MP3 / Vorbis格式，这使其成为上述类别声音的首选。<br>Vorbis/MP3：压缩为较小的文件，但与PCM音频相比 <strong>质量稍低</strong> 。 <strong>压缩量</strong> 可通过”质量”滑块进行 <strong>配置</strong> 。 此格式最适合 <strong>中等长度</strong> 的音效和音乐。</p>
<p>Sample Rate Setting： 采样率设置<br>Preserve Sample Rate: 保留采样率<br>Optimize Sample Rate：此设置根据分析的最高频率内容自动优化采样率。<br>Override Sample Rate：此设置允许手动覆盖采样率，因此可以有效地避免采样内容丢失。</p>
<blockquote>
<p>要关注:<br> OriginalSize:磁盘大小<br> ImportedSize:内存大小<br> Ratio:ImportedSize占OriginalSize比例</p>
</blockquote>
<h3 id="设置建议"><a href="#设置建议" class="headerlink" title="设置建议"></a>设置建议</h3><ol>
<li><p>建议都勾选ForceToMono：将多声道音频混合为单声道</p>
</li>
<li><p>在iOS上请使用MP3格式，在Android上使用Vorbis</p>
</li>
<li><p>场景等长音效使用Streaming + Vorbis/MP3</p>
</li>
<li><p>技能等短音效使用DecompressOnLoad + ADPCM</p>
</li>
<li><p>采样率选择手动控制到22050左右</p>
</li>
<li><p>短音频可选格式aifff或wav，长音频可选格式mp3或ogg</p>
</li>
</ol>
<h3 id="导入后处理脚本"><a href="#导入后处理脚本" class="headerlink" title="导入后处理脚本"></a>导入后处理脚本</h3><pre><code class="lang-csharp">
using System; 

using UnityEngine; 

using System.Collections; 

using UnityEditor; 

public class MyAudioProcessor : AssetPostprocessor

{ 

public void OnPreprocessAudio()

{ 

if (!assetPath.StartsWith(&quot;Assets/MyAudio&quot;)) return; 

AudioImporter audioImporter = (AudioImporter)assetImporter; 

audioImporter.forceToMono = true; 

//Android设置

AudioImporterSampleSettings androidSettings = new AudioImporterSampleSettings(); 

androidSettings.loadType = AudioClipLoadType.DecompressOnLoad; //长音效用Streaming，短的用DecompressOnLoad

androidSettings.compressionFormat = AudioCompressionFormat.Vorbis; //Android用Vorbis

androidSettings.quality = 100; 

androidSettings.sampleRateSetting = AudioSampleRateSetting.OverrideSampleRate; //采样率控制到22050左右

androidSettings.sampleRateOverride = 22050; 

audioImporter.SetOverrideSampleSettings(&quot;Android&quot;, androidSettings); 

//iOS设置

AudioImporterSampleSettings iOSSettings = new AudioImporterSampleSettings(); 

iOSSettings.loadType = AudioClipLoadType.DecompressOnLoad; //长音效用Streaming，短的用DecompressOnLoad

iOSSettings.compressionFormat = AudioCompressionFormat.MP3; //iOS用MP3

iOSSettings.quality = 100; 

iOSSettings.sampleRateSetting = AudioSampleRateSetting.OverrideSampleRate; //采样率控制到22050左右

iOSSettings.sampleRateOverride = 22050; 

audioImporter.SetOverrideSampleSettings(&quot;iOS&quot;, iOSSettings); 

} 

}
</code></pre>
<blockquote>
<p>Ref:<br> <a href="https://blog.csdn.net/LeoHiJack/article/details/95228708" target="_blank" rel="noopener">https://blog.csdn.net/LeoHiJack/article/details/95228708</a><br> <a href="https://blog.csdn.net/u013244147/article/details/104548393" target="_blank" rel="noopener">https://blog.csdn.net/u013244147/article/details/104548393</a><br> <a href="https://zhuanlan.zhihu.com/p/27438828" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27438828</a></p>
</blockquote>
<h2 id="Cull-Transparent-Mesh"><a href="#Cull-Transparent-Mesh" class="headerlink" title="Cull Transparent Mesh"></a>Cull Transparent Mesh</h2><p>Unity2018.2加入的新功能：Image对应的CanvasRenderer组件上可以勾选Cull Transparent Mesh</p>
<blockquote>
<p>官方描述：Indicates whether geometry emitted by this renderer can be ignored when the vertex color alpha is close to zero for every vertex of the mesh.</p>
</blockquote>
<p>若Image的Color属性的Alpha值接近于0，则该Image是看不见的，如果对其进行渲染，则会造成不必要的渲染性能开销。<br>如果在Image对应的CanvasRenderer开启Cull Transparent Mesh，则Unity进行渲染时会对该Image的Color的Alpha值进行检测，若该值接近于0，就忽略该Image，不进行绘制，节约性能。</p>
<p><img src="U3D资源优化（零碎）知识点汇总/2.png" alt="Alt text"></p>
<p><img src="U3D资源优化（零碎）知识点汇总/1.png" alt="Alt text"></p>
<p>如上图，第二张图Image组件的Alpha值为0，由FrameDebugger可见，Unity没有对该Image进行绘制。</p>
<p>更具体的，可见讨论：<br>I assume this culling test has a cost, which is why it’s not enabled by default/done automatically.</p>
<p>实现上：<br>this checkbox toggles a shader feature to cull pixels in the fragment shader with very low alpha value.</p>
<p>Docs would seem to indicate this uses the vertex colour alpha at the vertex stage:</p>
<p><a href="https://docs.unity3d.com/ScriptReference/CanvasRenderer-cullTransparentMesh.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/CanvasRenderer-cullTransparentMesh.html</a></p>
<p>But e.g:</p>
<p><a href="https://github.com/TwoTailsGames/Un...er/DefaultResourcesExtra/UI/UI-Default.shader" target="_blank" rel="noopener">https://github.com/TwoTailsGames/Un…er/DefaultResourcesExtra/UI/UI-Default.shader</a></p>
<blockquote>
<p>Ref:<br> <a href="https://twitter.com/dmitriy_focus/status/1166706421389496321?lang=en" target="_blank" rel="noopener">https://twitter.com/dmitriy_focus/status/1166706421389496321?lang=en</a><br> <a href="https://docs.unity3d.com/ScriptReference/CanvasRenderer-cullTransparentMesh.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/CanvasRenderer-cullTransparentMesh.html</a><br> <a href="https://forum.unity.com/threads/practical-effect-of-cull-transparent-mesh.746711/" target="_blank" rel="noopener">https://forum.unity.com/threads/practical-effect-of-cull-transparent-mesh.746711/</a></p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-U3D工具链积累"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-U3D%E5%B7%A5%E5%85%B7%E9%93%BE%E7%A7%AF%E7%B4%AF/"
    >U3D工具链积累</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-U3D%E5%B7%A5%E5%85%B7%E9%93%BE%E7%A7%AF%E7%B4%AF/" class="article-date">
  <time datetime="2023-07-20T15:00:27.332Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/7/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/6/">6</a><a class="page-number" href="/archives/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/archives/9/">9</a><a class="page-number" href="/archives/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/9/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>