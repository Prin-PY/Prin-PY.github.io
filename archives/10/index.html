<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-Map及其与Material、Texture的关系"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Map%E5%8F%8A%E5%85%B6%E4%B8%8EMaterial%E3%80%81Texture%E7%9A%84%E5%85%B3%E7%B3%BB/"
    >Map及其与Material、Texture的关系</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Map%E5%8F%8A%E5%85%B6%E4%B8%8EMaterial%E3%80%81Texture%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time datetime="2023-07-25T12:56:23.253Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote>
<p>贴图的英语 Map 其实包含了另一层含义就是“映射”。<br> 贴图指的是映射关系，其功能就是把纹理通过 UV 坐标映射到3D 物体表面。贴图包含了除了纹理以外其他很多信息，比方说 UV 坐标、贴图输入输出控制等等。</p>
</blockquote>
<p>UV坐标：水平方向是U，竖直方向是V。因为图片（纹理）是一个二维的平面，所以只需要UV坐标便可以确定图片的位置。（当然也有三维贴图，要用到UVW坐标，暂时还接触不到。）</p>
<h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>材质 Material包含贴图 Map，贴图包含纹理 Texture。<br>材质(Material)：物体的质地，物体看起来是什么做的<br>贴图(Map)<br>纹理(Texture)：普通的材质图片<br>贴图 + 着色器(Shader) = 材质球</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://gameinstitute.qq.com/community/detail/115074" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/115074</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-LUA相关"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-LUA%E7%9B%B8%E5%85%B3/"
    >LUA相关</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-LUA%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2023-07-25T12:56:23.253Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul>
<li><p><a href="https://github.com/mpeterv/luacheck" target="_blank" rel="noopener">https://github.com/mpeterv/luacheck</a></p>
</li>
<li></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Graphics-Tier-Settings-Quality-Level"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Graphics-Tier-Settings-Quality-Level/"
    >Graphics - Tier Settings &amp; Quality Level</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Graphics-Tier-Settings-Quality-Level/" class="article-date">
  <time datetime="2023-07-25T12:56:23.251Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>优化中经常提到，根据机型配置的高低，进行不同的设置，使用不同性能的资源，那么这个究竟如何实现的，Unity使用什么样的机制支持这件事？</p>
</blockquote>
<h2 id="Graphics-Tier-Settings"><a href="#Graphics-Tier-Settings" class="headerlink" title="Graphics Tier Settings"></a>Graphics Tier Settings</h2><p>通过图形API或者设备的版本确定一些 <strong>全局的Graphics设置</strong> 以及所加载的 <strong>Shader脚本内容</strong> 。从而达到目的: </p>
<ul>
<li><p>兼容不同版本的图形API、显示设备</p>
</li>
<li><p>根据设备的性能调整项目质量的高低，在性能上适应不同的设备。</p>
</li>
</ul>
<blockquote>
<p>Use the Graphics settings (main menu: Edit &gt; Project Settings, then select the Graphics category) to apply global settings for Graphics.</p>
</blockquote>
<p>These settings allow you to make platform-specific adjustments to rendering and shader compilation, by tweaking built-in defines. </p>
<h3 id="常用设置项及其含义"><a href="#常用设置项及其含义" class="headerlink" title="常用设置项及其含义"></a>常用设置项及其含义</h3><h3 id="How-is-this-selection-done"><a href="#How-is-this-selection-done" class="headerlink" title="How is this selection done?"></a>How is this selection done?</h3><p>默认：Unity根据设备的版本或图形API自动选择。</p>
<h4 id="Tier-1"><a href="#Tier-1" class="headerlink" title="Tier 1"></a>Tier 1</h4><p>Android - all devices that have support for OpenGL ES 2 only</p>
<p>iOS - all devices before iPhone 5S (not including 5S, but including 5C), iPods up to and including 5th generation, iPads up to 4th generation, iPad mini first generation</p>
<p>Desktops: DirectX 9, HoloLens</p>
<h4 id="Tier-2"><a href="#Tier-2" class="headerlink" title="Tier 2"></a>Tier 2</h4><p>Android - all devices with OpenGL ES 3 support</p>
<p>iOS - all devices starting from iPhone 5S, iPad Air, iPad mini 2nd generation, iPod 6th generation<br>AppleTV</p>
<p>Web</p>
<p>Vulkan on Android is Tier 2.</p>
<h4 id="Tier-3"><a href="#Tier-3" class="headerlink" title="Tier 3"></a>Tier 3</h4><p>Desktops: OpenGL, Metal, DirectX 11+ , Vulkan </p>
<p>for desktops is in Tier 3</p>
<h3 id="Scripting-API"><a href="#Scripting-API" class="headerlink" title="Scripting API"></a>Scripting API</h3><p>自定义：使用脚本在Runtime强行设置。</p>
<pre><code class="lang-csharp">
Graphics.activeTier : Rendering.GraphicsTier
</code></pre>
<p>Initially this value is auto-detected from the hardware in use.<br><strong>Changing this value affects any subsequently loaded shaders. (So you have to do that before any shaders are loaded.)</strong><br>TierN corresponds to shader define UNITY_HARDWARE_TIERN</p>
<p>Runtime根据机型自定义Tier</p>
<pre><code class="lang-csharp">
deviceID = SystemInfo.deviceModel; 

if(deviceID == &quot;iPhone10,3 &quot; || deviceID == &quot;iPhone10,6&quot;){ 

// This is an iPhoneX

//now change the graphics tier to tier 3

Graphics.activeTier = GraphicsTier.Tier3 

}
</code></pre>
<p><strong>set it once when you app starts.</strong></p>
<h2 id="Quality-Level"><a href="#Quality-Level" class="headerlink" title="Quality Level"></a>Quality Level</h2><p>设置方法：menu: Edit &gt; Project Settings, then select the Quality category</p>
<p>Set the level of graphical quality it attempts to render.<br>Generally speaking, quality comes at the expense of framerate and so it may be best not to aim for the highest quality on mobile devices or older hardware since it tends to have a detrimental effect on gameplay. </p>
<p>有Unity默认的Levels，也可以自己添加Levels，自己命名。</p>
<h3 id="Scripting-API-1"><a href="#Scripting-API-1" class="headerlink" title="Scripting API"></a>Scripting API</h3><p>Runtime设置Level</p>
<pre><code class="lang-csharp">
using UnityEngine; 

public class Example : MonoBehaviour

{ 

void OnGUI()

{ 

string[] names = QualitySettings.names; 

GUILayout.BeginVertical(); 

for (int i = 0; i &lt; names.Length; i++) 

{ 

if (GUILayout.Button(names[i])) 

{ 

QualitySettings.SetQualityLevel(i, true); 

} 

} 

GUILayout.EndVertical(); 

} 

}
</code></pre>
<blockquote>
<p>Note that: changing the quality level can be an expensive operation if the new level has different anti-aliasing setting. It’s fine to change the level when applying in-game quality options, but if you want to dynamically adjustquality level at runtime, pass false to applyExpensiveChanges so that expensive changes are not always applied.<br> When building a player quality levels that are not used for that platform are stripped. You should not expect a given quality setting to be at a given index. It’s best to query the available quality settings and use the returned index.</p>
</blockquote>
<h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p>Graphics Tier Settings一般是在真机上运行时自动选择，由于涉及到Grapics API的兼容性，开发者或用户一般不自己改Tier。</p>
<p>Quality Level比较常用，开发者可以根据场景或设备的性能设置Level。或者以UI的形式把设置Level的接口开放给用户，让用户根据自己的情况选择游戏质量。</p>
<p>判断设备高低端的方法：<br>不同的游戏厂商有不同的方法。</p>
<ul>
<li><p>粗糙一点的可能根据CPU的频率判断。</p>
</li>
<li><p>SystemInfo的API可以获取CPU等型号，根据型号判断等等。</p>
</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://forum.unity.com/threads/tiers-in-graphicsettings.485408/" target="_blank" rel="noopener">https://forum.unity.com/threads/tiers-in-graphicsettings.485408/</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-GPU-Skinning"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-GPU-Skinning/"
    >GPU Skinning</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-GPU-Skinning/" class="article-date">
  <time datetime="2023-07-25T12:56:23.251Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="蒙皮-Skinning"><a href="#蒙皮-Skinning" class="headerlink" title="蒙皮(Skinning)"></a>蒙皮(Skinning)</h3><p>将模型的网格皮肤(skin mesh)绑定给骨骼的过程</p>
<h3 id="刚体蒙皮"><a href="#刚体蒙皮" class="headerlink" title="刚体蒙皮"></a>刚体蒙皮</h3><h3 id="顶点混合"><a href="#顶点混合" class="headerlink" title="顶点混合"></a>顶点混合</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Image-Raw-Image"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Image-Raw-Image/"
    >Image &amp; Raw Image</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Image-Raw-Image/" class="article-date">
  <time datetime="2023-07-25T12:56:23.251Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>而Image提供了四种ImageType：Simple（普通）、Sliced（切割）、Tiled（平铺）、Filled（填充），而且它还是布局元素（ILayoutElement），可以被各种布局组（ILayoutGroup）所包含，将它和其他布局元素进行布局。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Source Image：只支持Sprite类型的图片<br>Color：给图片混合上颜色<br>Material：材质(一些特殊情况需要使用材质)<br>Raycast Target：是否接收射线检测<br>Image Type：图片类型(普通，九宫切图，平铺，填充)<br>Preserve Aspect：是否保持宽高比<br>Set Native Size：设置元素为原本的像素大小</p>
<h4 id="Image-Type"><a href="#Image-Type" class="headerlink" title="Image Type"></a>Image Type</h4><h5 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h5><p>随意拉伸，会变形，可以勾选上PreserveAspect按原宽高比进行拉伸</p>
<h5 id="Sliced"><a href="#Sliced" class="headerlink" title="Sliced"></a>Sliced</h5><p>按照Sprite Editor中的九宫格进行拉伸处理</p>
<p><img src="assets/Image%20&amp;%20Raw%20Image/20200103131209912.png" alt="Alt text"></p>
<p>1，3，7，9区域不会进行拉伸，2和8区域会横向拉伸，4和6区域会纵向拉伸，5区域横纵都会拉伸</p>
<h5 id="Tilled"><a href="#Tilled" class="headerlink" title="Tilled"></a>Tilled</h5><p>图片本身大小会保持不变，像铺地面砖那样填充满整个Image控件</p>
<p><img src="assets/Image%20&amp;%20Raw%20Image/20200103132414236.png" alt="Alt text"></p>
<h5 id="Filled"><a href="#Filled" class="headerlink" title="Filled"></a>Filled</h5><p>图片以不同的方式呈现出来，例如技能冷却，血条，进度条</p>
<h2 id="Raw-Image"><a href="#Raw-Image" class="headerlink" title="Raw Image"></a>Raw Image</h2><blockquote>
<p>the Image control requires its Texture to be a Sprite<br> the Raw Image can accept any Texture.</p>
</blockquote>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>raw: 生的，未加工的<br>支持任何一种贴图模式，包括Render Texture和Movie Texture<br>只为我们提供了修改UV的方法，除此之外都是继承自MaskableGraphic的方法</p>
<blockquote>
<p>DefaultTexture类型会将贴图宽和高转换为2的n次幂<br> Sprite类型不会对宽和高进行自动拉伸，可以在Inspector—Advanced—Non—Power of 2选择是否进行转换</p>
</blockquote>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>Color<br>Material<br>Raycast Target<br>UV Rect：设置UV缩放和偏移(x和y属性用于控制UV左右、上下偏移，W和H属性用于控制UV的重复次数)</p>
<blockquote>
<p>可以在Import Settings中的Wrap Model设置循环的模式，Repeat模式可以用于2D游戏的背景图循环</p>
</blockquote>
<p>Set Native Size：设置元素为原本的像素大小</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/ecidevilin/article/details/52556724" target="_blank" rel="noopener">https://blog.csdn.net/ecidevilin/article/details/52556724</a><br><a href="http://&quot;https://blog.csdn.net/LLLLL&lt;strong" target="_blank" rel="noopener">/article/details/103807887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param”&gt;https://blog.csdn.net/LLLLL/article/details/103807887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-GPU和CPU的区别"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-GPU%E5%92%8CCPU%E7%9A%84%E5%8C%BA%E5%88%AB/"
    >GPU和CPU的区别</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-GPU%E5%92%8CCPU%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2023-07-25T12:56:23.251Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>GPU比较适合大量可并行的简单任务。比如场景渲染，光照处理等等。<br>GPU也支持一些其他的运算，比如通过GLSL，HLSL和Cg支持并行运算等等。<br>GPU同时也对游戏中的一些物理效果提供支持，比如PhysX。<br><strong>GPU负责显示特效</strong></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU用于一些数值运算，比如伤害，随机数等等。同时你的敌人AI也是CPU运算出来的。<br>越是大型的单机游戏，游戏资源量越大，资源的实时加载以及处理也是大多由CPU来完成的。<br><strong>CPU负责游戏逻辑</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-DrawCall"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-DrawCall/"
    >DrawCall</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-DrawCall/" class="article-date">
  <time datetime="2023-07-25T12:56:23.250Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Draw Call就是CPU调用图形编程接口，比如DirectX或OpenGL，来命令GPU进行渲染的操作。<br>（DirectX中的DrawIndexedPrimitive命令，OpenGL中的glDrawElement命令）</p>
<p>命令缓冲区(Command Buffer)<br>CPU向其中添加命令，而由GPU从中读取命令<br>添加和读取的过程相互独立<br>命令有很多种类，而Draw Call是其中的一种<br>改变渲染状态（Shader，Texture）</p>
<h1 id="影响帧率"><a href="#影响帧率" class="headerlink" title="影响帧率"></a>影响帧率</h1><p>每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据，状态，命令等。在这一阶段，CPU需要完成很多工作，例如检查渲染状态等。<br>GPU的渲染能力很强，渲染速度往往快于CPU提交命令的速度。<br>如果Draw Call的数量太多，CPU就会把大量时间花费在提交Draw Call命令上，造成CPU的过载。</p>
<h2 id="如何减少Draw-Call"><a href="#如何减少Draw-Call" class="headerlink" title="如何减少Draw Call"></a>如何减少Draw Call</h2><h3 id="批处理-Batching"><a href="#批处理-Batching" class="headerlink" title="批处理(Batching)"></a>批处理(Batching)</h3><p>把很多小的Draw Call合并成一个大的Draw Call。</p>
<blockquote>
<p>在CPU和RAM中合并网格，而 <strong>合并网格</strong> 本身是需要计算，消耗CPU时间，而且 <strong>创建新网格</strong> 也会占用内存。因此批处理的频次不宜太高，不然造成的消耗可能得不偿失</p>
</blockquote>
<p>Unity内置了Draw Call Batching技术：在一次DrawCall中批量处理多个物体。只要物体的变换和材质相同，GPU就可以按完全相同的方式进行处理，即可以把它们放在一个Draw Call中。</p>
<p>条件: 合并的网格会在一次渲染任务中进行绘制，他们的渲染数据，渲染状态和shader都是一样的，因此合并的条件至少是： <strong>同材质、同贴图、同shader</strong> 。最好网格顶点格式也一致。</p>
<p>Unity提供了Dynamic Batching和Static Batching两种方式。</p>
<h4 id="Dynamic-Batching"><a href="#Dynamic-Batching" class="headerlink" title="Dynamic Batching"></a>Dynamic Batching</h4><p>Dynamic Batching是完全自动进行的，不需要也无法进行任何干预。</p>
<p>动态批处理的约束：</p>
<ol>
<li><p>批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。</p>
</li>
<li><p>如果着色器使用顶点位置，法线和UV值三种属性，那么只能批处理300顶点以下的物体；如果着色器需要使用顶点位置，法线，UV0，UV1和切向量，那么只能批处理180顶点以下的物体。</p>
</li>
<li><p>不要使用缩放，分别拥有缩放大小（1,1,1）和（2,2,2）的两个物体将不会进行批处理。</p>
</li>
<li><p>统一缩放的物体不会和非统一缩放的物体进行批处理。</p>
</li>
<li><p>使用缩放尺度（1,1,1）和（1,2,1）的两个物体将不会进行批处理，但是使用缩放尺度（1,2,1）和（1,3,1）的两个物体将可以进行批处理。</p>
</li>
<li><p>使用不同材质的实例化物体将会导致批处理失败。</p>
</li>
<li><p>拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。</p>
</li>
<li><p>多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。</p>
</li>
<li><p>预设体的实例会自动地使用相同的网格模型和材质。 </p>
</li>
<li><p>网格合并的顶点数量有上限（Unity中好像是65535还是900？）</p>
</li>
<li><p>使用MultiplePass的shader也不会进行批处理</p>
</li>
<li><p>接受实时阴影的物体也不会进行批处理</p>
</li>
</ol>
<h4 id="Static-Batching"><a href="#Static-Batching" class="headerlink" title="Static Batching"></a>Static Batching</h4><p>Static Batching需要把静止的物体标记为Static，然后无论大小，都会组成Batch。<br>如何对动态加载的静态物体进行静态合批操作：</p>
<pre><code class="lang-csharp">
GameObject go = (GameObject)Instantiate(...); 

go.isStatic = true;//将实例化的物体设置为静态

go.transform.parent = root.transform; 

gosList.Add(go); 

gos = gosList.ToArray(); 

StaticBatchingUtility.Combine(gos, root);静态合并
</code></pre>
<blockquote>
<p>可以通过CombineChildren脚本（StandardAssets/Scripts/UnityScripts/CombineChildren）手动把物体组合在一起，但这个脚本会影响可见性测试，因为组合在一起的物体始终会被看作一个物体，从而会增加GPU要处理的几何体数量，因此要小心使用。</p>
</blockquote>
<h5 id="坏处：VBO增大，通过内存来换取性能"><a href="#坏处：VBO增大，通过内存来换取性能" class="headerlink" title="坏处：VBO增大，通过内存来换取性能"></a>坏处：VBO增大，通过内存来换取性能</h5><p>如果在静态批处理前有一些物体共享了相同的网格（例如这里的两个箱子），那么每一个物体都会有一个该网格的复制品，即一个网格会变成多个网格被发送给GPU。<br>如果使用同一网格的对象很多，可能需要牺牲一定的渲染性能，避免使用静态批处理。例如，如果在一个使用了1000个重复树模型的森林中使用静态批处理，那么结果就会产生1000倍的内存，这会造成严重的内存影响。</p>
<h4 id="Batching对提升性能的启发"><a href="#Batching对提升性能的启发" class="headerlink" title="Batching对提升性能的启发"></a>Batching对提升性能的启发</h4><ol>
<li><p>避免使用大量小的网格，当确实需要时，考虑是否要合并。</p>
</li>
<li><p>首先是尽量减少场景中使用的材质数量，即尽量共享材质，对于仅纹理不同的材质可以把纹理组合到一张更大的纹理中。把纹理打包成图集，减少材质数量。</p>
</li>
<li><p>把不会移动的物体标记为Static。</p>
</li>
<li><p>合并本身有消耗，因此尽量在编辑器下进行合并</p>
</li>
</ol>
<h3 id="减少反光阴影等"><a href="#减少反光阴影等" class="headerlink" title="减少反光阴影等"></a>减少反光阴影等</h3><p>尽量少的使用反光，阴影之类的，因为那会使物体多次渲染。<br>同样的设置，如果将灯光的阴影效果打开，DrawCall会大幅增加，使用lightmap可以实现想要的阴影效果</p>
<h3 id="遮挡剔除"><a href="#遮挡剔除" class="headerlink" title="遮挡剔除"></a>遮挡剔除</h3><p>对于复杂的静态场景，还可以考虑自行设计遮挡剔除算法，减少可见的物体数量同时也可以减少Draw Call。</p>
<h3 id="NGUI的优化"><a href="#NGUI的优化" class="headerlink" title="NGUI的优化"></a>NGUI的优化</h3><p>NGUI主要是有三大模块组成：UIPanel，UIWidget，UIDrawcall组成。其中UIPanel是用来管理UIWidget控件和UIDrawCall，而UIWidget是所有组件的基类。</p>
<p>在NGUI框架中，会有一个静态的list用来存放所有的Panel，然后每个单独的Panel下会保存自己的UIWidget和UIDrawCall，在每次绘制的时候panel会遍历自己下面的所有层级下的子物体，直到查找结束，或者遇到新的panel会跳出当前分支，继续寻找其他分支，直到全部查找结束。所以说在实际运行中，每次都会为一个UIWidget绘制一个DrawCall，如果这时候连续的多个UIWidget使用的材质和纹理一致，就会公用一个DrawCall。<br>使用不同材质和纹理：</p>
<p><img src="DrawCall/1592212245575.png" alt="Alt text"></p>
<p>使用材质和纹理：</p>
<p><img src="DrawCall/1592212252241.png" alt="Alt text"></p>
<p>使用同一个图集，并且使用同样的材质在同一个panel下才会合并为一个Drawcall</p>
<blockquote>
<p>如果使用同一个图集、材质，但是中间夹杂了其他的渲染状态，也会导致重新调用一次DrawCall。</p>
<p>另外还需要注意一点就是在panel下如果动态的物体，就是为了实现某种效果，需要UI 进行位置移动，这种情况下，最好做成动态分离，因为只要panel下UI有移动，panle就会对清空之前的保存的UIWidget和UIDrawCall，重新进行渲染，这样就会造成性能浪费</p>
</blockquote>
<p>对UI进行界面排布就需要对图集和层级做好规划，进而减少DrawCall次数</p>
<h2 id="计算（值得以后研究，把这个公式运用到优化实践中）"><a href="#计算（值得以后研究，把这个公式运用到优化实践中）" class="headerlink" title="计算（值得以后研究，把这个公式运用到优化实践中）"></a>计算（值得以后研究，把这个公式运用到优化实践中）</h2><p>NVIDIA 在 GDC 曾提出，25K batchs/sec 会吃满 1GHz 的 CPU，100的使用率。所以他们推出了一条公式，来预估游戏中大概可以 Run 多少个 Batch：<br>举个例子：如果你的目标是游戏跑30FPS、使用2GHz的CPU、20%的工作量拨给Draw Call来使用，那你每帧可以有多少Draw Call呢？<br>333 Batchs/Frame = 25K <em> 2 </em> (0.2/30)</p>
<p>Ref：<br><a href="https://blog.csdn.net/yu1368072332/article/details/85676537" target="_blank" rel="noopener">https://blog.csdn.net/yu1368072332/article/details/85676537</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Destroy"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Destroy/"
    >Destroy</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Destroy/" class="article-date">
  <time datetime="2023-07-25T12:56:23.249Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Ref: <a href="https://www.cnblogs.com/timeObjserver/p/7575035.html" target="_blank" rel="noopener">https://www.cnblogs.com/timeObjserver/p/7575035.html</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UNITY Destroy()和DestroyImadiate()都不会立即释放对象内存</p>
<p>DestroyImadiate是立即将物体从场景hierachy中移除，并标记为 “null”，注意 是带引号的null。这是UNITY内部的一个处理技巧。关于这个技巧有很争议。</p>
<p>Destroy要等到帧末才会将物体从场景层级中移除并标记为”null”。</p>
<p>不管如何，二者都只是UNITY引擎层面的标记与处理，但在.NET底层，对象的内存都没有释放，只有手动GC.Collect()或等待NET去GC时才会释放掉对象内存。<br>如果该对象在其他地方还有引用的话，GC也无法将对象的内存释放。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>（1）obj并不会立即销毁，而是需要等待下一个Update更新，所以还是可以被print出来；<br>（2）DestroyImmediate立即对对像进行销毁，print出来是null；<br>（3）Destroy销毁场景中的物体，但内存中还存在，当令它需要销毁时，只是给一个标识。而内存中它依然是存在的，只有当内存不够，或一段时间没有再次被引用时（或者更多合理的条件满足），机制才会将它销毁并释放内存；<br>（4）这样做的目的就是为了避免频繁对内存的读写操作。回收器会定时清理一次内存中引用计数为0的对象，很可能你的要销毁的对象在其他地方还有引用而你自己不清楚，直接销毁可能导致其他地方空引用错误；<br>（5）建议使用平常Destroy函数，而不是DestroyImmediate函数；</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试代码如下：点ADD按钮不断创建对象，点DEL按钮清除所有对象，通过观察进程内存数值来察看对象内存是否释放。</p>
<pre><code class="lang-csharp">
using System.Collections; 

using System.Collections.Generic; 

using System.Diagnostics; 

using UnityEngine; 

using UnityEngine.UI; 

public class MyGo : MonoBehaviour

{ 

byte[] data = new byte[83000]; 

} 

public class testad : MonoBehaviour { 

Transform objs; 

Text txt; 

Process proc; 

// Use this for initialization

void Start () { 

var btnadd = transform.Find(&quot;btnAdd&quot;).GetComponent&lt;Button&gt;(); 

btnadd.onClick.AddListener(OnClckAdd); 

var btndel = transform.Find(&quot;btnDel&quot;).GetComponent&lt;Button&gt;(); 

btndel.onClick.AddListener(OnClckDel); 

objs = transform.Find(&quot;objs&quot;); 

txt = transform.Find(&quot;Text&quot;).GetComponent&lt;Text&gt;(); 

proc = Process.GetCurrentProcess(); 

} 

void OnClckAdd()

{ 

for (int i = 0; i &lt; 20; ++i) 

{ 

var go = new GameObject(); 

go.AddComponent&lt;MyGo&gt;(); 

go.transform.SetParent(objs); 

} 

} 

void OnClckDel()

{ 

for (int i = objs.childCount - 1; i &gt;= 0; i--) 

{ 

GameObject.DestroyImmediate(objs.GetChild(i).gameObject); 

} 

System.GC.Collect(); 

} 

// Update is called once per frame

float timer = 0; 

void Update () { 

if (timer &gt; 0.5f) 

{ 

timer = 0; 

txt.text = ((int)(proc.WorkingSet64 / 1024)).ToString(); 

} 

timer += Time.deltaTime; 

} 

}
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Draw-Call与Batching-TODO"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Draw-Call%E4%B8%8EBatching-TODO/"
    >Draw Call与Batching(TODO)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Draw-Call%E4%B8%8EBatching-TODO/" class="article-date">
  <time datetime="2023-07-25T12:56:23.249Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>To draw a GameObject on the screen, the engine has to issue a draw call to the graphics API (such as OpenGL or Direct3D).<br><strong>每次引擎准备数据并通知GPU的过程称为一次Draw Call</strong> 。<br><strong>The command that tells the GPU to render a certain set of vertices as triangles with a certain state (shaders, blend state and so on)</strong></p>
<h3 id="耗时原因"><a href="#耗时原因" class="headerlink" title="耗时原因"></a>耗时原因</h3><p>在没有进行拼合的情况下，引擎准备数据并通知GPU的过程是逐个物体进行的，对于每个物体，不只GPU的渲染，CPU重新 <strong>设置材质/Shader</strong> 也是一项非常耗时的操作。</p>
<p><strong>Draw Call耗时主要是CPU端的耗时——</strong><br>Unity3d官方 - Draw calls are often resource-intensive(资源密集型的，大量占用资源的), with the graphics API doing significant work for every draw call, causing <strong>performance overhead(开销)on the CPU side</strong>. This is mostly caused <strong>by the state changes done between the draw calls</strong> (such as switching to a different Material), which causes resource-intensive validation and translation steps in the graphics driver.</p>
<p>There are some real costs with making draw calls, it requires <strong>setting up a bunch of state</strong> ( <strong>which set of vertices to use, what shader to use and so on</strong> ), and state changes have a cost both on the hardware side (updating a bunch of registers) and on the driver side (validating and translating your calls that set state).</p>
<p>为何要减少DrawCall？<br><strong>The main reason to make fewer draw calls is that graphics hardware can transform and render triangles much faster than you can submit them.</strong> If you submit few triangles with each call, you will be completely bound by the CPU and the GPU will be mostly idle. The CPU won’t be able to feed the GPU fast enough.</p>
<p><strong>The main cost of draw calls only apply if each call submits too little data</strong> , since this will cause you to be CPU-bound, and stop you from utilizing the hardware fully.</p>
<blockquote>
<p>Making a single draw call with two triangles is cheap, but if you submit too little data with each call, you won’t have enough CPU time to submit as much geometry to the GPU as you could have.</p>
<p>(我还不太懂的)draw calls can also cause the command buffer to be flushed, but in my experience that usually happens when you call SwapBuffers, not when submitting geometry. Video drivers generally try to buffer as much as they can get away with (several frames sometimes!) to squeeze out as much parallelism from the GPU as possible.</p>
</blockquote>
<h3 id="方法与建议"><a href="#方法与建议" class="headerlink" title="方法与建议"></a>方法与建议</h3><p>目前，我们建议DrawCall的主体范围(5%~95%) 控制在[0,150]范围内。</p>
<p>方法：减少所渲染物体的材质种类，并通过Draw Call Batching 来减少其数量。</p>
<h3 id="Note：游戏性能并非Draw-Call越小越好。"><a href="#Note：游戏性能并非Draw-Call越小越好。" class="headerlink" title="Note：游戏性能并非Draw Call越小越好。"></a>Note：游戏性能并非Draw Call越小越好。</h3><p>决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的 <strong>总线带宽</strong> 。当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。</p>
<h2 id="Batch-Draw-Call-Setpass-Call"><a href="#Batch-Draw-Call-Setpass-Call" class="headerlink" title="Batch, Draw Call, Setpass Call"></a>Batch, Draw Call, Setpass Call</h2><p>DrawCall</p>
<p>DrawCall：CPU每次调用图像编程接口 glDrawElements（OpenGl中的图元渲染函数）或者 DrawIndexedPrimitive（DirectX中的顶点绘制方法）命令GPU渲染的操作称为一次Draw Call。Draw Call就是一次渲染命令的调用，它指向一个需要被渲染的图元（primitive）列表，不包含任何材质信息，glDrawElements 或者 DrawIndexedPrimitive 函数的作用是将CPU准备好的顶点数据渲染出来。</p>
<p>Batch</p>
<p>一个Batch：提交vbo，提交ibo，提交shader，设置好硬件渲染状态，设置好光源属性，CPU调用GPU渲染。</p>
<p>这其实就是渲染流程的运用阶段，最终输出一个渲染图元（点、线、面等），再传递给GPU进行几何阶段和光栅化阶段的渲染显示。一个Batch必然会触发一次或多次DrawCall，且包含了该对象的所有的网格和顶点数据以及材质信息。把数据加载到显存是指把渲染所需的数据从硬盘加载到内存（RAM），再将网格和纹理等加载到显卡（VRAM），这一步比较耗时。设置渲染状态就是设置场景中的网格的顶点（Vertex）/片元（Fragment）着色器，光源属性，材质等。Unity提供的动态合批（Dynamic Batching ）合并的就是这一过程，将渲染状态相同的对象合并成一个Batch，减少DrawCall。</p>
<blockquote>
<p>如果一个batch和另一个batch使用的不是同种材质或者同一个材质的不同pass，那么就要触发一次set pass call来重新设定渲染状态。例如，Unity要渲染20个物体，这20个物体使用同种材质（但不一定mesh等价），假设两次dynamic batch各自合批了10个物体，则对于这次渲染，set pass call为1（只需要渲染一个材质），batch为2（向GPU提交了两次VBO，IBO等数据）。</p>
</blockquote>
<p>SetPassCall</p>
<p>Shader脚本中一个Pass语义块就是一个完整的渲染流程，一个着色器可以包含多个Pass语义块，每当GPU运行一个Pass之前，就会产生一个SetPassCall，所以可以理解为一次完整的渲染流程次数。</p>
<p>由此可见，一个Batch包含一个或多个DrawCall，都是产生是在CPU阶段，而目前普遍渲染的瓶颈恰恰就是CPU，GPU的处理速度比CPU快多了，Draw Call太高，CPU会把大量时间花费在处理Draw Call调用上。如果Batch太大，CPU需要频繁的从硬盘加载数据，切换渲染状态，这个消耗要比DrawCall大，所以后面Unity才逐渐弱化了DrawCall的显示。</p>
<h3 id="主要看哪个指标"><a href="#主要看哪个指标" class="headerlink" title="主要看哪个指标"></a>主要看哪个指标</h3><p>SetPass Call与 Draw Call相比，SetPass Call的指标与性能相关性更大（比如Static Batching的开启不影响Draw Call数，而SetPass Call通常会明显下降）。但 SetPass Call在某些情况下也同样存在问题，比如往一个场景中添加任意个相邻且材质相同的大网格物体（使Dynamic Batching失效）时，SetPass Call并不会变化。因此在UWA中，我们所使用的是类似Profiler 中 Total Batches 这一项指标，通常该数值与 Frame Debugger 中的数值基本一致，因此可以通过该工具来查看每个Batch的内容，从而更有针对性地进行优化。</p>
<h2 id="Draw-call-batching"><a href="#Draw-call-batching" class="headerlink" title="Draw call batching"></a>Draw call batching</h2><blockquote>
<p>You can enable or disable Dynamic and Static batching through Unity’s Player settings under Other Settings.</p>
<p>Built-in Batching的优劣：<br> Built-in batching has several <strong>benefits</strong> compared to manually merging GameObjects together; most notably, GameObjects <strong>can still be culled individually</strong>.<br> However, it also has some <strong>downsides</strong> ; <strong>static</strong> batching incurs <strong>memory and storage overhead</strong> , and <strong>dynamic</strong> batching incurs some <strong>CPU overhead</strong>.</p>
</blockquote>
<h3 id="Dynamic-batching"><a href="#Dynamic-batching" class="headerlink" title="Dynamic batching"></a>Dynamic batching</h3><h4 id="Meshes"><a href="#Meshes" class="headerlink" title="Meshes"></a>Meshes</h4><p>条件:</p>
<ol>
<li><p>share the same Material(共享相同的材质 <strong>实例</strong> )</p>
</li>
<li><p>fulfill other criteria</p>
<ul>
<li><p>顶点数量：Batching dynamic GameObjects has certain overhead per vertex, so batching is applied only to Meshes containing no more than 900 vertex attributes, and no more than 300 vertices. 如果你的着色器使用顶点位置，法线和一个UV，那么你可以动态批处理多达300个顶点；而如果你的着色器使用顶点位置，法线，UV0，UV1和切线，那么只有180个顶点。</p>
</li>
<li><p>镜像信息：GameObjects are not batched if they contain mirroring on the transform. 例如A物体的大小是(1f, 1f, 1f)，而B物体的大小则是(-1f, -1f, -1f)，则无法做批处理。</p>
</li>
<li><p>Using different <strong>Material instances</strong> causes GameObjects not to batch together, even if they are essentially the same. The exception is shadow caster rendering.</p>
</li>
<li><p>GameObjects with lightmaps have additional renderer parameters: lightmap index and offset/scale into the lightmap. Generally, dynamic lightmapped GameObjects should point to exactly the same lightmap location to be batched.</p>
</li>
<li><p>Multi-pass Shaders break batching. 几乎所有的Unity着色器都支持多个灯光的正向渲染模式（Forward Rendering），这要求额外的渲染次数，所以绘制 “额外的每像素灯”时不会被批处理；Legacy Deferred（Light Pre-Pass）渲染路径不能被动态批处理，因为它必须绘制物体两次。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>If you need to access shared Material properties from the scripts, then it is important to note that <strong>modifying Renderer.material creates a copy of the Material</strong>. Instead, use Renderer.sharedMaterial to keep Materials shared.</p>
<p>Shadow casters can often be batched together while rendering, even if their Materials are different. Shadow casters in Unity can use dynamic batching even with different Materials, as long as the values in the Materials needed by the shadow pass are the same. For example, many crates could use Materials with different Textures on them, but for the shadow caster rendering the textures are not relevant, so in this case they can be batched together.</p>
<p>如果Draw Call的开销比合批要低, 那么合批就没有意义了. Dynamic batching works by transforming all GameObject vertices into world space on the CPU, so it is only an advantage if that work is smaller than doing a draw call. The resource requirements of a draw call depends on many factors, primarily the graphics API used. For example, on consoles or modern APIs like Apple Metal, the draw call overhead is generally much lower, and often dynamic batching cannot be an advantage at all.</p>
</blockquote>
<h4 id="Particle-Systems-Line-Renderers-Trail-Renderers"><a href="#Particle-Systems-Line-Renderers-Trail-Renderers" class="headerlink" title="Particle Systems, Line Renderers, Trail Renderers"></a>Particle Systems, Line Renderers, Trail Renderers</h4><p>ParticleSystem等属于 <strong>Components with geometry that Unity generates dynamically(带有动态生成的几何图形的组件)</strong></p>
<p>具体处理方式:</p>
<ul>
<li><p>For each compatible renderer type, Unity builds all batchable content into 1 large Vertex Buffer.</p>
</li>
<li><p>The renderer sets up the Material state for the batch.</p>
</li>
<li><p>Unity binds the Vertex Buffer to the Graphics Device.</p>
</li>
<li><p>For each Renderer in the batch, Unity updates the offset into the Vertex Buffer, and then submits a new draw call.</p>
</li>
</ul>
<p>When measuring the cost of the Graphics Device calls, the slowest part of rendering a Component is the set-up of the Material state. Submitting draw calls at different offsets into a shared Vertex Buffer is very fast by comparison.</p>
<h3 id="Static-batching"><a href="#Static-batching" class="headerlink" title="Static batching"></a>Static batching</h3><p><strong>本质上是用空间换时间,要在渲染耗时与内存占用之间做权衡.</strong></p>
<p>Static batching allows the engine to reduce draw calls for geometry of any size provided it <strong>shares the same material</strong> , and <strong>does not move</strong>.</p>
<ul>
<li><p>优点：more efficient than dynamic batching (it does not transform vertices on the CPU)</p>
</li>
<li><p>缺点：uses more memory.</p>
</li>
</ul>
<blockquote>
<p>Using static batching requires <strong>additional memory for storing the combined geometry</strong>. If several GameObjects shared the same geometry before static batching, then a copy of geometry is created for each GameObject, either in the Editor or at runtime. This might not always be a good idea; sometimes you have to sacrifice rendering performance by avoiding static batching for some GameObjects to keep a smaller memory footprint. For example, marking trees as static in a dense forest level can have serious memory impact.</p>
</blockquote>
<p>内部实现: Internally, static batching works by transforming the static GameObjects into world space and building one shared vertex and index buffer for them.</p>
<h3 id="实践技巧"><a href="#实践技巧" class="headerlink" title="实践技巧"></a>实践技巧</h3><h4 id="Dynamic-Batching的开启"><a href="#Dynamic-Batching的开启" class="headerlink" title="Dynamic Batching的开启"></a>Dynamic Batching的开启</h4><p>Built-in管线，在Project Settings -&gt; Player当中：</p>
<p><img src="Draw Call与Batching\(TODO\" alt="Alt text"><br>_files/1617977824829.png)</p>
<p>SRP，在RenderPipelineAsset的Inspector面板的Advanced下：</p>
<p><img src="Draw Call与Batching\(TODO\" alt="Alt text"><br>_files/1617977877330.png)</p>
<h4 id="使用图集合并Material"><a href="#使用图集合并Material" class="headerlink" title="使用图集合并Material"></a>使用图集合并Material</h4><p>If you have two identical Materials which differ only in Texture, you can combine those Textures into a single big Texture. This process is often called Texture atlasing (see the Wikipedia page on Texture atlases for more information). Once Textures are in the same atlas, you can use a single Material instead.</p>
<p>atlas (also called a sprite sheet or an image sprite) is an image containing multiple smaller images, usually packed together to reduce overall dimensions.<br><strong>Benefits</strong><br>In an application where many small textures are used frequently, it is often more efficient to store the textures in a texture atlas which is treated as a single unit by the graphics hardware. This reduces the overhead of a context switch by increasing memory locality.</p>
<h4 id="无法合批的常见原因及案例"><a href="#无法合批的常见原因及案例" class="headerlink" title="无法合批的常见原因及案例"></a>无法合批的常见原因及案例</h4><p>详情见：<br><a href="https://github.com/Unity-Technologies/BatchBreakingCause" target="_blank" rel="noopener">https://github.com/Unity-Technologies/BatchBreakingCause</a></p>
<h2 id="SRP-Batching"><a href="#SRP-Batching" class="headerlink" title="SRP Batching"></a>SRP Batching</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.uwa4d.com/archives/Simple_PA_Rendering.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Simple_PA_Rendering.html</a><br><a href="https://blog.uwa4d.com/archives/optimzation_cpu.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/optimzation_cpu.html</a><br><a href="https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive" target="_blank" rel="noopener">https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive</a><br><a href="https://docs.unity3d.com/Manual/DrawCallBatching.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br><a href="https://en.wikipedia.org/wiki/Texture_atlas" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Texture_atlas</a><br><a href="https://www.zhihu.com/question/60614886" target="_blank" rel="noopener">https://www.zhihu.com/question/60614886</a><br><a href="https://zhuanlan.zhihu.com/p/76562300" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76562300</a><br><a href="https://zhuanlan.zhihu.com/p/366779113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/366779113</a><br><a href="https://answer.uwa4d.com/question/58d29b8b5a5050b366a6b6ae" target="_blank" rel="noopener">https://answer.uwa4d.com/question/58d29b8b5a5050b366a6b6ae</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-CubeMap-Skybox"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-CubeMap-Skybox/"
    >CubeMap &amp; Skybox</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-CubeMap-Skybox/" class="article-date">
  <time datetime="2023-07-25T12:56:23.243Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Cubemap"><a href="#Cubemap" class="headerlink" title="Cubemap"></a>Cubemap</h2><p>A Cubemap is a collection of <strong>six square textures</strong> that represent the reflections on an environment. The six squares form the faces of an imaginary cube that surrounds an object; each face represents the view along the directions of the world axes (up, down, left, right, forward and back).</p>
<p>可以使用方向向量对它们索引和采样</p>
<pre><code class="lang-csharp">
samplerCUBE _CubeMap; 

fixed4 frag (v2f i) : SV_Target 

{ 

fixed4 col = texCUBE(_CubeMap, normalize(i.vertexLocal.xyz)); 

return col; 

}
</code></pre>
<h2 id="制作方法"><a href="#制作方法" class="headerlink" title="制作方法"></a>制作方法</h2><h3 id="Legacy-Cubemap-Assets"><a href="#Legacy-Cubemap-Assets" class="headerlink" title="Legacy Cubemap Assets"></a>Legacy Cubemap Assets</h3><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185104728.png" alt="Alt text"></p>
<h3 id="Cubemap-texture"><a href="#Cubemap-texture" class="headerlink" title="Cubemap texture"></a>Cubemap texture</h3><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185140709.png" alt="Alt text"></p>
<h3 id="PanoramaToCubemap"><a href="#PanoramaToCubemap" class="headerlink" title="PanoramaToCubemap"></a>PanoramaToCubemap</h3><p><img src="assets/CubeMap%20&amp;%20Skybox/1615185709526.png" alt="Alt text"></p>
<h3 id="Shader实现"><a href="#Shader实现" class="headerlink" title="Shader实现"></a>Shader实现</h3><p>使用Texture2D格式，在Shader当中组织，而不使用Unity的Cubemap格式。</p>
<p><img src="assets/CubeMap%20&amp;%20Skybox/1615185174675.png" alt="Alt text"></p>
<h2 id="Skybox的实现"><a href="#Skybox的实现" class="headerlink" title="Skybox的实现"></a>Skybox的实现</h2><h3 id="使用Cubemap"><a href="#使用Cubemap" class="headerlink" title="使用Cubemap"></a>使用Cubemap</h3><p>制作Cubemap资源 。Buitin Shader当中的Skybox/Cubemap可以对Cubemap采样</p>
<p><img src="assets/CubeMap%20&amp;%20Skybox/1615185387170.png" alt="Alt text"></p>
<h3 id="在Shader中对6张图采样"><a href="#在Shader中对6张图采样" class="headerlink" title="在Shader中对6张图采样"></a>在Shader中对6张图采样</h3><p>Builtin Shader: Mobile-Skybox</p>
<p><img src="assets/CubeMap%20&amp;%20Skybox/1615185458141.png" alt="Alt text"></p>
<h3 id="Panorama-全景画"><a href="#Panorama-全景画" class="headerlink" title="Panorama(全景画)"></a>Panorama(全景画)</h3><p>Builtin Shader: Skybox/Panoramic<br>可以直接Texture2D格式的对全景图进行采样。</p>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://blog.csdn.net/v_xchen_v/article/details/79474193" target="_blank" rel="noopener">https://blog.csdn.net/v_xchen_v/article/details/79474193</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/9/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/8/">8</a><a class="page-number" href="/archives/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/archives/11/">11</a><a class="page-number" href="/archives/12/">12</a><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/11/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>