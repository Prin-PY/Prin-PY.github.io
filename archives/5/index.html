<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-强哥UI课"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E5%BC%BA%E5%93%A5UI%E8%AF%BE/"
    >强哥UI课</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E5%BC%BA%E5%93%A5UI%E8%AF%BE/" class="article-date">
  <time datetime="2023-07-20T15:00:27.947Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><h3 id="Canvas组件"><a href="#Canvas组件" class="headerlink" title="Canvas组件"></a>Canvas组件</h3><p>Render Mode</p>
<ul>
<li><p>Screen Space - Overlay</p>
</li>
<li><p>Screen Space - Camera</p>
</li>
<li><p>World Space</p>
</li>
</ul>
<p>Pixel Perfect 在要提高清晰度的时候才选择。 一般不推荐选择</p>
<h3 id="Rect-Transform"><a href="#Rect-Transform" class="headerlink" title="Rect Transform"></a>Rect Transform</h3><h3 id="CanvasRenderer"><a href="#CanvasRenderer" class="headerlink" title="CanvasRenderer"></a>CanvasRenderer</h3><h3 id="EventSystem-amp-GraphicRaycaster"><a href="#EventSystem-amp-GraphicRaycaster" class="headerlink" title="EventSystem &amp; GraphicRaycaster"></a>EventSystem &amp; GraphicRaycaster</h3><p>找被点中的物体</p>
<h3 id="Event-Trigger"><a href="#Event-Trigger" class="headerlink" title="Event Trigger"></a>Event Trigger</h3><p>这个是UGUI里面封装好的一个Component，里面预设了很多UGUI支持的UI事件，方便大家用来自定义一些消息响应，比如点击事件，也可以用来制作一些特殊的UI响应，例如长按事件</p>
<h2 id="Lesson2"><a href="#Lesson2" class="headerlink" title="Lesson2"></a>Lesson2</h2><h3 id="分辨率适配"><a href="#分辨率适配" class="headerlink" title="分辨率适配"></a>分辨率适配</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-序列化与反序列化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"
    >序列化与反序列化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-date">
  <time datetime="2023-07-20T15:00:27.944Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Ref: <a href="https://zhuanlan.zhihu.com/p/27990334" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27990334</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>序列化</strong> 又称串行化，是.NET运行时环境用来支持用户定义类型的流化的机制。其目的是以某种存储形式使自定义对象持久化，或者将这种对象从一个地方传输到另一个地方。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化是指把 <strong>对象</strong> 转换为 <strong>字节序列</strong> 的过程</p>
<p>对象序列化的最主要的用处就是在 <strong>传递和保存对象</strong> 的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了 <strong>对象的状态以及相关的描述信息</strong> 。序列化机制的核心作用就是对象状态的保存与重建。</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列化是指把 <strong>字节序列</strong> （有序字节流）恢复为 <strong>对象</strong> 的过程</p>
<p>客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化 <strong>重建对象，恢复对象状态</strong></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li><p>永久性保存对象，保存对象的字节序列到本地文件或者数据库中；</p>
</li>
<li><p>通过序列化以字节流的形式使对象在网络中进行传递和接收；</p>
</li>
<li><p>通过序列化在进程间传递对象；</p>
</li>
</ol>
<h2 id="Unity序列化"><a href="#Unity序列化" class="headerlink" title="Unity序列化"></a>Unity序列化</h2><p>Unity的场景文件和预制体默认就是以二进制的文件保存在工程目录下。<br>在 <strong>检视面板</strong> 中可以看到的，就是被 <strong>成功序列化了的参数</strong> 。与序列化相关的常用的关键字如下，可以组合使用。</p>
<ul>
<li><p>SerializeField : 表示变量可被序列化。众所周知，公有变量可以在检视面板中看到并编辑，而私有和保护变量不行。SerializeField与private，protected结合使用可以达到让脚本的变量在检视面板里可视化编辑，同时保持它的私有性的目的。</p>
</li>
<li><p>HideInInspector : 将原本显示在检视面板上的序列化值隐藏起来。</p>
</li>
<li><p>NonSerialized :通过此方法可以将一个公有变量不序列化并且不显示在检视面板中。</p>
</li>
<li><p>Serializable：用在类的前面，表示该类可被序列化。</p>
</li>
</ul>
<p><strong>相关API</strong><br>SerializedObject: <a href="https://docs.unity3d.com/ScriptReference/SerializedObject.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/SerializedObject.html</a><br>SerializedProperty: <a href="https://docs.unity3d.com/ScriptReference/SerializedProperty.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/SerializedProperty.html</a></p>
<blockquote>
<p>注意：并非所有的公有变量都是可以被序列化的。其中const，static是静态的，属于类而非对象，无法序列化。链表和字典在内存中的存储是不连续的，也无法序列化。其中const，static，readonly的区别可参考文章：<a href="https://www.cnblogs.com/suizhikuo/p/4739388.html" target="_blank" rel="noopener">https://www.cnblogs.com/suizhikuo/p/4739388.html</a></p>
</blockquote>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="二进制方法（Binary-Formatter）"><a href="#二进制方法（Binary-Formatter）" class="headerlink" title="二进制方法（Binary Formatter）"></a>二进制方法（Binary Formatter）</h3><pre><code class="lang-csharp">
void WriteTest()

{ 

DemoClass demo = new DemoClass (100, &quot;RCD&quot;); 

FileStream fs = new FileStream (&quot;demo.bin&quot;, FileMode.OpenOrCreate); 

BinaryFormatter bf = new BinaryFormatter (); 

bf.Serialize (fs, demo); 

fs.Close (); 

Debug.LogError (&quot;write done&quot;); 

} 

void ReadTest()

{ 

FileStream fs = new FileStream(&quot;demo.bin&quot;, FileMode.Open); 

BinaryFormatter bf = new BinaryFormatter(); 

DemoClass demo = bf.Deserialize(fs) as DemoClass; 

fs.Close(); 

demo.Output(); 

}
</code></pre>
<blockquote>
<p>注意：二进制方法可以序列化私有变量，不能序列化被[NonSerialized ]修饰的变量且类需要被[Serializable ]标识。</p>
</blockquote>
<h3 id="Xml序列化"><a href="#Xml序列化" class="headerlink" title="Xml序列化"></a>Xml序列化</h3><p>XML(Extensible Markup Language, 可扩展标记语言), 标准通用标记语言(Standard Generalized Markup language, SGML)的子集。是一种用于标记电子文件使其具有结构性的标记语言。<br>提供统一的方法来描述和交换独立于应用程序或供应商的 <strong>结构化数据</strong> 。</p>
<pre><code class="lang-csharp">
using System.IO; 

using System.Xml.Serialization; 

using UnityEditor; 

先定义一个类： 

public class Studnet{ 

public string m_Name = &quot;仑仑&quot;; 

} 

public class SerializeDemo : MonoBehaviour { 

void Start()

{ 

//序列化：

Student student = new Student(); 

//第一要确定储存的位置

//Application.dataPath就是unity中的Asset文件夹 

StreamWriter sw = new StreamWriter(Application.dataPath + &quot;/Demo.xml&quot;); 

//第二要对什么类型序列化

XmlSerializer xs = new XmlSerializer(typeof(Student)); 

//第三对对象序列化

xs.Serialize(sw, student); 

//关闭流

sw.Close(); 

//刷新Asset文件

AssetDatabase.Refresh(); 

//运行程序会在Asset目录下看到Demo.xml文件

//反序列化

//第一确定对哪个文件进行反序列化

StreamReader sr = new StreamReader(Application.dataPath + &quot;/Demo.xml&quot;); 

//第二要确定对什么类型反序列化

XmlSerializer xs1 = new XmlSerializer(typeof(Student)); 

//第三反序列化

Student student1 = xs1.Deserialize(sr) as Student; 

//关闭流

sr.Close(); 

//会在控制台看到 “仑仑”

print(student1.m_Name); 

} 

} 

SerializeDemo
</code></pre>
<h2 id="其他Unity数据存储方法"><a href="#其他Unity数据存储方法" class="headerlink" title="其他Unity数据存储方法"></a>其他Unity数据存储方法</h2><h3 id="ScriptableObject-自动序列化"><a href="#ScriptableObject-自动序列化" class="headerlink" title="ScriptableObject(自动序列化)"></a>ScriptableObject(自动序列化)</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h5><p>需要指定创建的目录和资源名称，如果资源已经存在，则不会创建新资源；</p>
<pre><code class="lang-csharp">
public class MakeScriptableObject { 

[MenuItem(&quot;Assets/Create/My Scriptable Object&quot;)] 

public static void CreateMyAsset()

{ 

MyScriptableObjectClass asset = ScriptableObject.CreateInstance&lt;MyScriptableObjectClass&gt;(); 

AssetDatabase.CreateAsset(asset, &quot;Assets/NewScripableObject.asset&quot;); 

AssetDatabase.SaveAssets(); 

EditorUtility.FocusProjectWindow(); 

Selection.activeObject = asset; 

} 

}
</code></pre>
<h5 id="CreateAssetMenu"><a href="#CreateAssetMenu" class="headerlink" title="CreateAssetMenu"></a>CreateAssetMenu</h5><p>可以在Assets下任意目录创建资源，而且可以创建多个资源；</p>
<pre><code class="lang-csharp">
[CreateAssetMenu(fileName = &quot;data&quot;, menuName = &quot;ScriptableObjects/SpawnManagerScriptableObject&quot;, order = 1)] 

public class SpawnManagerScriptableObject : ScriptableObject { 

public string prefabName; 

public int numberOfPrefabsToCreate; 

public Vector3[] spawnPoints; 

}
</code></pre>
<p>在Assets下创建一个可编程对象资源，设置好所需数据；如果需要在其它脚本中获取该数据，是需要声明一个该类型变量，然后为其赋值或加载该数据资源；然后，就像使用用一个类中的公有变量一样使用即可；</p>
<pre><code class="lang-csharp">
public SpawnManagerScriptableObject spawnManagerValues; 

//spawnManagerValues.prefabName
</code></pre>
<h3 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a>PlayerPrefs</h3><p>Ref: <a href="https://www.jianshu.com/p/579be3b8e1e3" target="_blank" rel="noopener">https://www.jianshu.com/p/579be3b8e1e3</a><br>PlayerPrefs是Unity内置的一个静态类，可以用于存储一些简单的数据类型：int ,string ,float。可以用它来做成计分板这类需要可持续化存储的小地方。</p>
<h4 id="PlayerPrefs数据存储在哪里"><a href="#PlayerPrefs数据存储在哪里" class="headerlink" title="PlayerPrefs数据存储在哪里?"></a>PlayerPrefs数据存储在哪里?</h4><p>1.在Mac OS X上存储在~/Library/PlayerPrefs文件夹，名为unity.[company name].[product name].plist,这里company和product名是在project Setting中设置的<br>2.在windows下，playerPrefs被存储在注册的HKCU\Software[company name][product name]键下，这里company和product名是在project setting中设置的。<br>3.在Android上，数据存储（持久化）在设备上。数据保存在SharedPreferences中。</p>
<h4 id="PlayerPrefs有哪些方法？"><a href="#PlayerPrefs有哪些方法？" class="headerlink" title="PlayerPrefs有哪些方法？"></a>PlayerPrefs有哪些方法？</h4><p>分为五类：SetXXX , GetXXX , DeleteXXX, HasKey , Save.<br>传送门：<a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/PlayerPrefs.html</a></p>
<ol>
<li><p>SetXXX : 是你要储存的数据类型，这里必须是一组键值对，第一个参数是Key,第二个参数是对应的Value。</p>
</li>
<li><p>GetXXX：这里是获取数据的函数，只有一个参数Key,用来获取对应Key的Value.<br>3.HasKey: 这个可以用来做判断。比如有两组数据一组有XX这个Key,另一组没有XX这个Key,这个时候我们就可以对这两组数据进行差异化操作。</p>
</li>
<li><p>DeleteXX:用于删除数据。</p>
</li>
<li><p>Save:用于在突发退出程序时，保存数据以备恢复时使用，但是会导致程序间断所以不建议调用。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-小知识点与小工具"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%B0%8F%E5%B7%A5%E5%85%B7/"
    >小知识点与小工具</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%B0%8F%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2023-07-20T15:00:27.932Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Gizmos"><a href="#Gizmos" class="headerlink" title="Gizmos"></a>Gizmos</h2><p><strong>Gizmos</strong> 在编辑模式下Gizmos可以提供可视化的提示。它们只在Scene场景中显示不在Play模式下显示，但是你可以通过工具栏调整它们。</p>
<p><strong>Gizmos公共类</strong> 允许你绘制图标，线条，和其他的东西。Gizmos在<code>OnDrawGizmos</code>方法中执行绘制，它被Unity编辑器自动调用。另一个可选的方法是<code>OnDrawGizmosSelected</code>，它只能被可选的对象调用。</p>
<p>Demo: 绘制顶点的位置，利用OnDrawGizmos在每个顶点绘制一个小球。</p>
<p><code>csharp private void OnDrawGizmos () { Gizmos.color = Color.black; for (int i = 0; i &lt; vertices.Length; i++) { Gizmos.DrawSphere(vertices[i], 0.1f); } }</code> </p>
<h2 id="OnValidate"><a href="#OnValidate" class="headerlink" title="OnValidate"></a>OnValidate</h2><p>调用时机:</p>
<ul>
<li>脚本被加载时</li>
<li>Inspector 中的任何值被修改时</li>
</ul>
<p>Cases：<br>设置循环值</p>
<p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { public float objectRotation; void OnValidate() { // objectRotation objectRotation = objectRotation % 360; } }</code> </p>
<p>需要设计人员输入 16 到 4096 之间 2的整数次幂时。<br>Unity提供了ClosestPowerOfTwo函数，方便我们取得最接近的值。同时我们使用RangeAttribute 属性来限定一下输入数值的区间，同时能更好的看出来处理后的值跟原始输入值的区别。</p>
<p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { [RangeAttribute(16, 4096)] public int textureSize; void OnValidate() { // textureSize textureSize = Mathf.ClosestPowerOfTwo(textureSize); } }</code> </p>
<p>使用场景 -需要“Nitro”车的速度比其他车的速度大至少20mph.</p>
<p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { [RangeAttribute(10, 300)] [Tooltip(&quot;mph&quot;)] public int maxCarSpeed; [RangeAttribute(10, 300)] [Tooltip(&quot;mph&quot;)] public int maxNitroSpeed; const int minNitroSpeedExtra = 20; void OnValidate() { // speed check if (maxNitroSpeed &lt; maxCarSpeed + minNitroSpeedExtra) maxNitroSpeed = maxCarSpeed + minNitroSpeedExtra; } }</code> </p>
<h2 id="动态添加tag"><a href="#动态添加tag" class="headerlink" title="动态添加tag"></a>动态添加tag</h2><p><code>csharp #region 动态添加tag static void AddTag(string tag, GameObject obj) { if (!isHasTag(tag)) { SerializedObject tagManager = new SerializedObject(obj);//序列化物体 SerializedProperty it = tagManager.GetIterator();//序列化属性 while (it.NextVisible(true))//下一属性的可见性 { if (it.name == &quot;m_TagString&quot;) { Debug.Log(it.stringValue); it.stringValue = tag; tagManager.ApplyModifiedProperties(); } } } } static bool isHasTag(string tag) { for (int i = 0; i &lt; UnityEditorInternal.InternalEditorUtility.tags.Length; i++) { if (UnityEditorInternal.InternalEditorUtility.tags[i].Equals(tag)) return true; } return false; } #endregion</code> </p>
<h2 id="关于enable-false"><a href="#关于enable-false" class="headerlink" title="关于enable=false"></a>关于enable=false</h2><p>When a Behaviour is disabled, it will still be on the object and you can even change its properties and call its methods, but the engine will no longer call its Update method.<br>When a Renderer is disabled, the object turns invisible.<br>When a Collider is disabled, it won’t cause any collision events to happen.<br>When an UI component is disabled, the player can’t interact with it anymore, but it will still be rendered, unless you also deactivate its renderer.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%EF%BC%9AOnRenderImage%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84RT%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"
    >实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%EF%BC%9AOnRenderImage%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84RT%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2023-07-20T15:00:27.921Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>By Prin@UWA</p>
<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h3 id="windows查看nvidia显卡（GPU）的利用率和温度"><a href="#windows查看nvidia显卡（GPU）的利用率和温度" class="headerlink" title="windows查看nvidia显卡（GPU）的利用率和温度"></a>windows查看nvidia显卡（GPU）的利用率和温度</h3><p>对可执行程序nvidia-smi.exe直接调用就可以显示显卡相关信息：<br>GPU的名称、温度、显存占用情况、GPU利用率、正在工作的GPU进程</p>
<p>笔者的nvidia-smi.exe程序在C:\Windows\System32目录下。</p>
<h3 id="Android上查看程序占用内存大小"><a href="#Android上查看程序占用内存大小" class="headerlink" title="Android上查看程序占用内存大小"></a>Android上查看程序占用内存大小</h3><h4 id="adb-dumpsys-命令查看每个程序的内存信息"><a href="#adb-dumpsys-命令查看每个程序的内存信息" class="headerlink" title="adb dumpsys 命令查看每个程序的内存信息"></a>adb dumpsys 命令查看每个程序的内存信息</h4><p>以下命令查看程序的PID（app_name可以不全）</p>
<pre><code class="lang-csharp">
adb shell top | grep app_name
</code></pre>
<p>以下命令查看程序的内存使用情况</p>
<pre><code class="lang-csharp">
adb shell dumpsys meminfo &lt;package_name&gt;

adb shell dumpsys meminfo &lt;PID&gt;
</code></pre>
<p>Total 的 PSS 信息就是你的应用真正占据的内存大小</p>
<h4 id="查看整体内存信息"><a href="#查看整体内存信息" class="headerlink" title="查看整体内存信息"></a>查看整体内存信息</h4><pre><code class="lang-csharp">
adb shell cat /proc/meminfo
</code></pre>
<p>其他有用命令：</p>
<blockquote>
<ul>
<li><p>adb shell kill PIDNumber 死你想杀死的后台进程来模拟某种 bug 的复现条件。</p>
</li>
<li><p>adb shell ps 查看当前终端中的进程信息</p>
</li>
</ul>
</blockquote>
<h3 id="DontSave——保留对象到新场景"><a href="#DontSave——保留对象到新场景" class="headerlink" title="DontSave——保留对象到新场景"></a>DontSave——保留对象到新场景</h3><p>如果GameObject对象被HideFlags.DontSave标识，则在新scene中GameObject的所有组件将被保留下来</p>
<ol>
<li><p>其子类GameObject对象不会被保留到新scene中</p>
</li>
<li><p>不可以对GameObject对象的某个组件如Transform进行HideFlags.DontSave标识，否则无效。</p>
</li>
<li><p>即使程序已经退出，被HideFlags.DontSave标识的对象会一直存在于程序中，造成内存泄漏，对HideFlags.DontSave标识的对象在不需要或程序退出时需要使用DestroyImmediate手动销毁。</p>
</li>
</ol>
<p>Demo:</p>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

public class DontSave_ts : MonoBehaviour { 

public GameObject go; 

public Transform t; 

void Start()

{ 

//GameObject对象使用HideFlags.DontSave可以在新scene中被保留

go.hideFlags = HideFlags.DontSave; 

GameObject Pl = GameObject.CreatePrimitive(PrimitiveType.Plane); 

Pl.hideFlags = HideFlags.DontSave; 

//不可以对GameObject的组件设置HideFlags.DontSave，否则无效

Transform tf = Instantiate(t, go.transform.position + new Vector3(2.0f, 0.0f, 0.0f), Quaternion.identity) as Transform; 

tf.hideFlags = HideFlags.DontSave; 

//导入名为newScene_unity的新scene

Application.LoadLevel(&quot;newScene2_unity&quot;); 

} 

}
</code></pre>
<p>在场景2中：</p>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

public class NewScene2_ts : MonoBehaviour { 

GameObject cube, plane; 

void Start () { 

Debug.Log(&quot;这是NewScene2！&quot;); 

} 

//当程序退出时用DestroyImmediate()销毁被HideFlags.DontSave标识的对象

//否则即使程序已经退出，被HideFlags.DontSave标识的对象依然在Hierarchy面板中

//即每运行一次程序就会产生多余对象，造成内存泄漏

void OnApplicationQuit()

{ 

cube = GameObject.Find(&quot;Cube0&quot;); 

plane = GameObject.Find(&quot;Plane&quot;); 

if (cube) 

{ 

Debug.Log(&quot;Cube0 DestroyImmediate&quot;); 

DestroyImmediate(cube); 

} 

if (plane) 

{ 

Debug.Log(&quot;Plane DestroyImmediate&quot;); 

DestroyImmediate(plane); 

} 

} 

}
</code></pre>
<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>给场景添加以下脚本：</p>
<pre><code class="lang-csharp">
public class Test_OnRenderImage : MonoBehaviour

{ 

private void OnRenderImage(RenderTexture source, RenderTexture destination)

{ 

Graphics.Blit(source, destination); 

} 

}
</code></pre>
<p>Build后在安卓设备上运行，使用Profiler进行分析，会发现Detailed信息当中多了一张较大的RenderTexture：TempBuffer 1，如下图，其大小为60+MB：</p>
<p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/QQ截图20200921190054.png" alt="Alt text"></p>
<p>而在统计的（Used/Reserved）Unity内存和GfxDriver内存都低与60MB。</p>
<p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Simple.png" alt="Alt text"></p>
<p>也就是说，Unity Profiler并没有把这个RT占用的内存统计到Unity或GfxDriver当中。笔者比较好奇，这个RT是什么情况下才会生成？放在内存的哪一部分？为什么不会统计到Unity或GfxDriver当中？什么样的会统计到什么样的不会被统计到？于是做了如下实验。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>创建空场景，在任意物体上添加上文提到的 <code>Test_OnRenderImage</code> 脚本。</p>
<h3 id="PC平台上测试"><a href="#PC平台上测试" class="headerlink" title="PC平台上测试"></a>PC平台上测试</h3><p>首先在PC Standalone上进行测试。按照是否添加Test_OnRenderImage 脚本和屏幕分辨率的高低进行组合，分别导出4个包，运行时通过<code>nvidia-smi.exe</code>获取显存信息，通过UnityProfiler分析内存情况，实验结果如下（使用黄色填充标注发生变化的值）：</p>
<p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Test_PC.png" alt="Alt text"></p>
<p>（注：TSMU表示Total System Memory Usage）<br>结论：在屏幕上绘制需要把绘制的信息放在 <strong>TempBuffer</strong> 中，也就是一张RenderTexture当中。这张RT存储在 <strong>显存</strong> 当中，其 <strong>大小可以跟所绘制的分辨率有关</strong> ，分辨率越大，其占用空间越大。</p>
<p>在PC平台上，不论是否重写<code>OnRenderImage</code>函数，都会在显存当中存在一个TempBuffer，其占用空间不会被Profiler统计到Unity当中。会在Texture当中统计到，也可以在在Detailed当中找到。</p>
<blockquote>
<p><strong>官方对Profiler的介绍</strong> ：The values in the Profiler are different to those displayed in your operating system’s task manager, because the Memory Profiler does not track all memory usage in your system. This includes memory some drivers and plug-ins use, and memory used for executable code. On platforms that support getting the total memory size of the application from the operating system, the <strong>Total System Memory Usage</strong> is over 0 and is <strong>the same size in a task manager.</strong></p>
</blockquote>
<h3 id="Android平台测试"><a href="#Android平台测试" class="headerlink" title="Android平台测试"></a>Android平台测试</h3><p>在PC平台上的测试已经可以说明TempBuffer的大小与分辨率之间的关系，在Android平台上主要测试OnRenderImage函数与该TempBuffer的存在与否以及与所占据的Android内存之间的关系：</p>
<p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Android.png" alt="Alt text"></p>
<p>（注：程序占用的Android总内存通过命令<code>adb shell dumpsys meminfo &lt;PID&gt;</code>得到。）</p>
<p>结论：通过OnRenderImage函数调用Blit，会在Android设备中产生一张额外的RT（TempBuffer），占用一定的内存，其大小取决于屏幕分辨率。若不调用OnRenderImage函数，就不会生成该RT，不会占据额外内存。</p>
<blockquote>
<p>另外，笔者通过另一个实验证明，若只写OnRenderImage函数，函数体为空，不写Blit，也会生成RT：TempBuffer。只是由于RenderTexture destination为空，屏幕显示黑屏。</p>
<p>OnRenderImage的实现原理可参考：<a href="https://gameinstitute.qq.com/community/detail/112744" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/112744</a></p>
</blockquote>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/29005381" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29005381</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-出错汇总"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E5%87%BA%E9%94%99%E6%B1%87%E6%80%BB/"
    >出错汇总</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E5%87%BA%E9%94%99%E6%B1%87%E6%80%BB/" class="article-date">
  <time datetime="2023-07-20T15:00:27.920Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>csharp //transform.position.x = 1.0;//position 是transform的属性，不是成员变量 var pos = transform.position; pos.x = 1.0f; transform.poition = pos;</code> </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-关于脚本的生命周期、函数的执行顺序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"
    >关于脚本的生命周期、函数的执行顺序</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="article-date">
  <time datetime="2023-07-20T15:00:27.918Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Editor和Engine脚本的执行顺序"><a href="#Editor和Engine脚本的执行顺序" class="headerlink" title="Editor和Engine脚本的执行顺序"></a>Editor和Engine脚本的执行顺序</h2><p>在Editor中，非PlayMode下，编辑器执行函数会在一帧里面跑。<br>进入PlayMode时，会Reload程序集（Assemblies），Reset脚本（Scripts），没有明确的回调函数可以注册，使Editor脚本中函数可以在刚进入PlayMode的时候调用。</p>
<p>脚本使用<code>[InitializeOnLoad]</code>属性，可以使脚本可以在刚进入PlayMode的时候初始化（调用静态构造函数）。而这个初始化的时机处在开始进入PlayMode和真正开始Play之前，此时</p>
<ul>
<li><p>EditorApplication.isPlaying 为 false</p>
</li>
<li><p>EditorApplication.isPlayingOrWillChangePlaymode 为 true</p>
</li>
<li><p>Unity已经完成了程序集的Reload和脚本的Reset</p>
</li>
</ul>
<p>在此时实例化物体，Unity会报错：Some objects were not cleaned up when closing the scene. (Did you spawn new GameObjects from OnDestroy?)。<br>这个时候实例化的物体加不到Hierarchy当中，但是会加载到内存当中，显示在Scene当中，Unity会判断内存当中有一块儿不属于当前场景的Object。 判断的结果类似于内存泄漏。</p>
<p>因此，解决方法是，在Static 实例化方法中，使用<code>EditorApplication.update += Update</code>给编辑器程序的Update注册函数，想要执行的逻辑在Update当中执行，也就是在下一帧（完全进入Play Mode）时执行。<br>静态初始化函数调用后到PlayMode第一次Update的时间段中，bu’y’h</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="lang-csharp">

</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-优化知识点链接收藏"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/"
    >优化知识点链接收藏</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/" class="article-date">
  <time datetime="2023-07-20T15:00:27.916Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Mesh压缩：<a href="https://www.cnblogs.com/murongxiaopifu/p/10447076.html" target="_blank" rel="noopener">https://www.cnblogs.com/murongxiaopifu/p/10447076.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E4%BB%8EEnumerator%E5%88%B0StartCoroutine%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%8F/"
    >从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E4%BB%8EEnumerator%E5%88%B0StartCoroutine%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%8F/" class="article-date">
  <time datetime="2023-07-20T15:00:27.909Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>程、异步执行究竟有什么关系？</p>
<p>程、异步执行究竟有什么关系？</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code class="lang-csharp">
yield return &lt;expression&gt;; 

yield break;
</code></pre>
<p>如果你在语句中使用 yield 上下文关键字，则意味着它在其中出现的方法、运算符或 get 访问器是迭代器，向编译器指示它所在的方法是迭代器块。 </p>
<p>使用 yield return 语句可一次返回一个元素。可通过使用 foreach 语句或 LINQ 查询来使用从迭代器方法返回的序列。 foreach 循环的每次迭代都会调用迭代器方法。 迭代器方法运行到 yield return 语句时，会返回一个 expression，并保留当前在代码中的位置。 下次调用迭代器函数时，将从该位置重新开始执行。</p>
<p>在 yield return 语句中，将计算 expression 并将结果以值的形式返回给枚举器对象；expression 必须可以隐式转换为 yield 类型的迭代器。</p>
<p>可以使用 yield break 语句来终止迭代。</p>
<p>实现原理 - 编辑器遇到上面的情况会将生成一些类来保存yield return的所有调用都一一做分支处理（状态机分支），下次对IEnumerator.moveNext时会从上次的状态开始（如：迭代到第几个）</p>
<h2 id="迭代器模式的实现与Enumerator"><a href="#迭代器模式的实现与Enumerator" class="headerlink" title="迭代器模式的实现与Enumerator"></a>迭代器模式的实现与Enumerator</h2><h3 id="foreach的原理"><a href="#foreach的原理" class="headerlink" title="foreach的原理"></a>foreach的原理</h3><p>在 C# 中，foreach 其实是一个语法糖，在编译成 IL 代码时，foreach 会变成基于迭代器 IEnumerator 的调用方式。</p>
<p>foreach编译成的IL代码如下：</p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615789031828.png" alt="Alt text"></p>
<p>以下两段代码效果相同：</p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615789060736.png" alt="Alt text"></p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615789081096.png" alt="Alt text"></p>
<h3 id="迭代器模式的实现"><a href="#迭代器模式的实现" class="headerlink" title="迭代器模式的实现"></a>迭代器模式的实现</h3><p>有许多种方法可以把对象堆起来成为一个集合，你可以把它们放进数组、链表、树、散列表等等不同的数据结构中，每一种对象的组织方式都有它的优点和适合的使用场景。<br>迭代器模式使我们在遍历集合时，不需要清楚集合的内部实现方式。不同集合存储方式的细节不同，但遍历方式的统一的。</p>
<blockquote>
<p>设计思想原则：隐藏细节，开放接口</p>
</blockquote>
<p>遍历集合时，处理好三件事即可：</p>
<ul>
<li><p>能够以某种顺序一个一个访问集合中的元素</p>
</li>
<li><p>能够获得当前元素的值</p>
</li>
<li><p>能够重新回到集合的开头</p>
</li>
</ul>
<p>为此，IEnumerator接口分别定义了三个方法：MoveNext, get_Current, Reset</p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615789423446.png" alt="Alt text"></p>
<p>.NET 系统库提供的 List、ArrayList、Dictionary 等集合都实现了 Enumerator。以List为例看看具体的实现：<br><code>List&lt;T&gt;</code>实现了<code>IEnumerable&lt;T&gt;</code>和<code>IEnumerable</code>接口，这两个接口也就定义了<code>GetEnumerator</code>方法：</p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615790017077.png" alt="Alt text"></p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615790081591.png" alt="Alt text"></p>
<p>而<code>Enumerator</code>是List类中的一个结构体类型，该结构体实现了<code>IEnumerator</code>接口。</p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615790157682.png" alt="Alt text"></p>
<p>当对<code>List&lt;T&gt;</code>调用GetEnumerator()方法时，返回的的<code>List&lt;T&gt;.Enumerator</code>类的一个对象。</p>
<blockquote>
<p>使用迭代器进行遍历时，不能进行Remove和Add操作，因为这两个操作会导致元素整体移动，导致当前Index指向的元素位置偏移，遍历结果错误。</p>
</blockquote>
<h3 id="自己实现一个List"><a href="#自己实现一个List" class="headerlink" title="自己实现一个List"></a>自己实现一个List</h3><pre><code class="lang-csharp">
using System.Collections; 

using System; 

public class MyList&lt;T&gt; : IEnumerable

{ 

private static readonly T[] _emptyArray = new T[0]; 

private const int _defaultCapacity = 4; 

private T[] _items; 

private int _size; 

private int _version; 

private Func&lt;T, bool&gt; _filterFunc; 

public int Count =&gt; _size; 

IEnumerator IEnumerable.GetEnumerator() 

{ 

return GetEnumerator(); 

} 

public MyList()

{ 

this._items = _emptyArray; 

} 

/// &lt;param name=&quot;func&quot;&gt;&lt;/param&gt;

public MyList(Func&lt;T, bool&gt; func)

{ 

this._items = _emptyArray; 

_filterFunc = func; 

} 

public IEnumerator GetEnumerator()

{ 

return new Enumerator(this); 

} 

public void Add(T item)

{ 

if (this._size == this._items.Length) 

this.EnsureCapacity(this._size + 1); 

this._items[this._size++] = item; 

++this._version; 

} 

/// &lt;summary&gt;

/// 扩容机制

/// &lt;/summary&gt;

/// &lt;param name=&quot;min&quot;&gt;&lt;/param&gt;

private void EnsureCapacity(int min)

{ 

if (this._items.Length &gt;= min) 

return; 

int num = this._items.Length == 0 ? 4 : this._items.Length * 2; 

if ((uint)num &gt; 2146435071U) 

num = 2146435071; 

if (num &lt; min) 

num = min; 

this.Capacity = num; 

} 

public int Capacity 

{ 

get =&gt; this._items.Length; 

set //有点子监听的感觉

{ 

if (value == this._items.Length) 

return; 

if (value &gt; 0) 

{ 

T[] objArray = new T[value]; 

if (this._size &gt; 0) //扩容真正实现在这里

Array.Copy((Array)this._items, 0, (Array)objArray, 0, this._size); 

this._items = objArray; 

} 

else

this._items = _emptyArray; 

} 

} 

/// &lt;summary&gt;

/// 迭代器定义

/// &lt;/summary&gt;

public struct Enumerator : IEnumerator 

{ 

private MyList&lt;T&gt; _list; 

private int _index; 

private int _version; 

private T current; 

internal Enumerator(MyList&lt;T&gt; list)

{ 

this._list = list; 

this._index = 0; 

this._version = list._version; 

this.current = default(T); 

} 

public bool MoveNext()

{ 

if (this._version != _list._version || (uint)this._index &gt;= (uint)_list._size) 

return this.MoveNextRare(); 

this.current = _list._items[this._index]; 

++this._index; 

//当不满足过滤条件时，foreach遍历Current返回为空

if (_list._filterFunc != null &amp;&amp; !_list._filterFunc(this.current)) 

this.current = default(T); 

return true; 

} 

private bool MoveNextRare()

{ 

this._index = this._list._size + 1; 

this.current = default(T); 

return false; 

} 

public object Current =&gt; this.current; 

public void Reset()

{ 

_index = 0; 

current = default(T); 

} 

} 

}
</code></pre>
<h2 id="Enumerator与yield-return"><a href="#Enumerator与yield-return" class="headerlink" title="Enumerator与yield return"></a>Enumerator与yield return</h2><p>You use a yield return statement to <strong>return each element one at a time</strong>.</p>
<p>When a yield return statement is reached in the iterator method, <strong>expression is returned</strong> , and <strong>the current location in code is retained</strong>. Execution is restarted <strong>from that location the next time</strong> that the iterator function is called.</p>
<pre><code class="lang-csharp">
public static void TestGetVs()

{ 

IEnumerator&lt;int&gt; enumerator = GetVs(); 

while(enumerator.MoveNext()) 

{ 

int current = enumerator.Current; 

Debug.Log(current); 

} 

} 

public static IEnumerator&lt;int&gt; GetVs()

{ 

//for (int i = 0; i &lt; 3; i++)

//{

// yield return i;

//}

yield return 3; 

yield return 4; 

yield return 5; 

}
</code></pre>
<p>底层原理：<br>如果写了一个函数，返回值类型为IEnumerator，方法体中有yield return，那么编译器会为这个方法自动定义一个类型，这个类型实现IEnumerator接口。</p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615794880255.png" alt="Alt text"></p>
<p>这个类型有两个字段：</p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615794868354.png" alt="Alt text"></p>
<p>state保存当前执行到的位置，current为当前的返回值。</p>
<p>使用foreach对这个方法的返回值进行遍历，实质上就是对这个迭代器进行遍历。每次调用MoveNext()，从state指向的位置开始执行，直到遇到下一个yield return，将返回的结果存到current当中，保存当前位置到state中。MoveNext函数的IL语言形式如下：</p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615795022810.png" alt="Alt text"></p>
<p>总结：使用IEnumerator与yield return的方式，可以实现有多个返回值的方法，对多个返回值进行遍历，每访问一个值，执行一段代码，不需要先计算出所有的值，再进行遍历。其本质是把函数(例子当中为GetVs)的代码放到Enumerator类型的MoveNext当中，用state进行控制，每调用一次，执行不同的段落。</p>
<h2 id="Unity3D协程"><a href="#Unity3D协程" class="headerlink" title="Unity3D协程"></a>Unity3D协程</h2><p>Ref: <a href="https://www.cnblogs.com/Roz-001/p/11205700.html" target="_blank" rel="noopener">https://www.cnblogs.com/Roz-001/p/11205700.html</a></p>
<p><img src="从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协/1615796287192.png" alt="Alt text"></p>
<p>以上代码，实质上是调用Test2Sceonds方法，返回一个Enumerator对象，然后传递给StartCoroutine方法。</p>
<p>StartCoroutine是在Native层实现的。从行为上来看，当StartCoroutine后，Unity会每一帧执行一次MoveNext。</p>
<p>如果yield return 返回的对象为WaitForSecond等，Unity会据此判断下一次调用MoveNext是什么时候。如以上代码，Unity会在2秒后，再次调用MoveNext。</p>
<h3 id="本质是什么"><a href="#本质是什么" class="headerlink" title="本质是什么"></a>本质是什么</h3><p>协程是一种异步执行代码的方式，是一种假的多线程。本质上，是 <strong>将一件任务，分到多个帧中去执行</strong> 。</p>
<p>多线程（并发）与迭代器、枚举器、容器是毫不相干的两个概念，Unity为什么就把这两个概念联系到一起了呢？为什么实现协程要用到枚举类型？这种实现方案，本质上是用了Enumerator的什么特性呢？这是笔者一直困惑的。</p>
<p>如果一个技术A，要用到技术B，那么A的需求，一定与B的特性是有共同点的，否则A不会用到B。那么我们从这个角度去思考上述问题。</p>
<ul>
<li><p>协程，本质是异步执行，把一个任务（一段代码），分多帧去执行。</p>
</li>
<li><p>.NET当中的Enumerator与yield return的机制，恰好本质上是把一段代码拆分为多个段落（部分），每次调用MoveNext，执行一段逻辑，获取一个返回值。</p>
</li>
</ul>
<p>那么，两个技术自然就关联到了一起——Unity对Enumerator的MoveNext进行调用，就实现了将一个任务分多次去执行的需求。每一帧调用一次MoveNext，就实现了每一帧执行一部分任务。而Native层还对yield return返回的类型进行了判断，根据返回类型的不同 ，控制下一次调用MoveNext的时机，例如，如果返回值是new WaitForSeconds(2)，那么Unity会在2秒后调用下一个MoveNext，并获取返回值。如果返回值是UnityWebRequest.SendWebRequest，那么Unity会在相应的请求执行完后，继续执行后面的部分。</p>
<h3 id="yield-return-的一些特殊含义"><a href="#yield-return-的一些特殊含义" class="headerlink" title="yield return 的一些特殊含义"></a>yield return 的一些特殊含义</h3><pre><code class="lang-csharp">
//程序在下一帧中从当前位置继续执行

yield return 0; 

//程序在下一帧中从当前位置继续执行

yield return null; 

//程序等待N秒后从当前位置继续执行

yield return new WaitForSeconds(N); 

//在所有的渲染以及GUI程序执行完成后从当前位置继续执行

yield new WaitForEndOfFrame(); 

//所有脚本中的FixedUpdate()函数都被执行后从当前位置继续执行

yield new WaitForFixedUpdate(); 

//等待一个网络请求完成后从当前位置继续执行

yield return WWW; 

//等待一个xxx的协程执行完成后从当前位置继续执行

yield return StartCoroutine(xxx); 

//如果使用yield break语句，将会导致协程的执行条件不被满足，不会从当前的位置继续执行程序，而是直接从当前位置跳出函数体，回到函数的根部

yield break; 

yield return IEnumerator自己定义实现类，等待到自定义的时间或事件结束。
</code></pre>
<h3 id="一些Demo"><a href="#一些Demo" class="headerlink" title="一些Demo"></a>一些Demo</h3><pre><code class="lang-csharp">
//下面定义了一个协程函数，注意必须使用IEnumerator作为返还值才能成为协程函数。 

IEnumerator Test() 

{ 

for(int i = 0; i&lt;1000 ; ++i) 

{ 

ans += i; yield return 0;//挂起，下一帧再来从这个位置继续执行。 

} 

j+=2; 

yield return 0;//挂起，下一帧再来从这个位置继续执行。 ++j; 

yield return 0;//挂起，下一帧再来从这个位置继续执行。

}
</code></pre>
<p>Demo1:</p>
<pre><code class="lang-csharp">
//3s后执行Debug.Log

IEnumerator Test()

{ 

for(float timer = 0.0f; timer &lt; 3.0f ; timer += Time.DeltaTime){ 

yield return 0;//挂起，下一帧再来从这个位置继续执行。

} 

Debug.Log(&quot;启动协程3s后&quot;); 

}
</code></pre>
<p>Demo2:</p>
<pre><code class="lang-csharp">
IEnumerator TestWaitForSeconds()

{ 

//3s后执行Debug.Log;

yield return new WaitForSeconds(3.0f); 

Debug.Log(&quot;启动协程3s后&quot;); 

}
</code></pre>
<h3 id="AssetBundle异步加载"><a href="#AssetBundle异步加载" class="headerlink" title="AssetBundle异步加载"></a>AssetBundle异步加载</h3><pre><code class="lang-csharp">
/// &lt;summary&gt;

/// 从文件进行异步加载

/// &lt;/summary&gt;

/// &lt;param name=&quot;abFullPath&quot;&gt;ab包的绝对路径&lt;/param&gt;

/// &lt;param name=&quot;finishCallBack&quot;&gt;完成加载回调，返回加载的AssetBundle&lt;/param&gt;

/// &lt;param name=&quot;updateCallBack&quot;&gt;加载过程中的更新回调，返回加载进度&lt;/param&gt;

/// &lt;returns&gt;&lt;/returns&gt;

IEnumerator LoadABFileAsync(string abFullPath,Action&lt;AssetBundle&gt; finishCallBack, Action&lt;float&gt; updateCallBack=null)

{ 

AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(abFullPath); 

while (!request.isDone) 

{ 

if(updateCallBack != null) 

{ 

updateCallBack(request.progress); 

} 

yield return null; 

} 

yield return request; 

if(finishCallBack!=null) 

finishCallBack(request.assetBundle); 

} 

private void Start()

{ 

assetPath = Application.dataPath + &quot;/../MyAssetBundles/&quot;; 

StartCoroutine(LoadABFileAsync(assetPath + assetBundleName, OnFinish, OnUpdate)); 

} 

private void OnUpdate(float obj)

{ 

Debug.Log(obj); 

} 

private void OnFinish(AssetBundle obj)

{ 

Instantiate(obj.LoadAsset(loadPrefabName)); 

obj.Unload(false); 

}
</code></pre>
<h3 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h3><pre><code class="lang-csharp">
using UnityEngine; 

using UnityEngine.Networking; 

using System.Collections; 

public class TestWebRequest : MonoBehaviour { 

void Start() { 

StartCoroutine(GetText()); 

} 

IEnumerator GetText() { 

UnityWebRequest www = new UnityWebRequest(&quot;http://www.my-server.com&quot;); 

www.downloadHandler = new DownloadHandlerBuffer(); 

yield return www.SendWebRequest(); 

if (www.result != UnityWebRequest.Result.Success) { 

Debug.Log(www.error); 

} 

else { 

// Show results as text

Debug.Log(www.downloadHandler.text); 

// Or retrieve results as binary data

byte[] results = www.downloadHandler.data; 

} 

} 

}
</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/yield" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/yield</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-一些属性"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/"
    >一些属性</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/" class="article-date">
  <time datetime="2023-07-20T15:00:27.908Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="InitializeOnLoad"><a href="#InitializeOnLoad" class="headerlink" title="InitializeOnLoad"></a>InitializeOnLoad</h2><p>InitializeOnLoad 属性应用的对象是 <strong>静态构造函数</strong> ，它可以保证在 <strong>编辑器启动</strong> 的时候调用此函数。调用静态构造函数，就会 <strong>重新初始化静态变量</strong> 。</p>
<p>标注了该属性的类需要 <strong>static constructor</strong> ！</p>
<pre><code class="lang-csharp">
using UnityEngine; 

using UnityEditor; 

[InitializeOnLoad] 

public class Startup { 

static Startup()

{ 

Debug.Log(&quot;Up and running&quot;); 

} 

}
</code></pre>
<p>此外，每次 <strong>重新编译后</strong> ，以及每次 <strong>对Game进行Play时</strong> ，会调用对象的静态构造函数。</p>
<p>即：对于定义了该属性的静态类，只要编辑器在启动状态，就会立即调用该类的静态构造函数。 若一个类刚刚写好，刚刚编译好，也会立即调用qi</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【转载】RenderTexture及其用途"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/20/Unity3D-%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91RenderTexture%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94/"
    >【转载】RenderTexture及其用途</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/20/Unity3D-%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91RenderTexture%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94/" class="article-date">
  <time datetime="2023-07-20T15:00:27.906Z" itemprop="datePublished">2023-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <pre><code>* 转自：https://www.jianshu.com/p/fa73c0f6762d
</code></pre><h2 id="什么是RenderTexture"><a href="#什么是RenderTexture" class="headerlink" title="什么是RenderTexture?"></a>什么是RenderTexture?</h2><p>RenderTexture是unity定义的一种特殊的Texture类型,它是连接着一个FrameBufferObject的存在于GPU端的Texture(Server-Side Texture),从上面对RenderTexture的解释我们了解到要先知道Texture和FrameBufferObject是什么</p>
<h2 id="从Texture到FrameBuffer"><a href="#从Texture到FrameBuffer" class="headerlink" title="从Texture到FrameBuffer"></a>从Texture到FrameBuffer</h2><p>纹理是如何被渲染到屏幕上的 ,起初纹理存在硬盘(RAM)里,它被cpu解压缩(数据在cpu端它就只是二进制数据),如果想要显示它,那么数据将会被发送给(上传到,cpu和gpu之间的通信可以理解成client和server之间的通信)GPU,gpu将它放在显存(VARM)中,显存中有一块内存区域叫做RenderBuffer(渲染缓存),RenderBuffer只是数据缓存,它还不能用作Texture渲染,尽管它现在已经是一个texture了,在这里 texture等待着被渲染,当要渲染这个Texture时,会生成一个FrameBuffer(帧缓存),当这个帧缓存被添加到默认的帧缓存物体上(FrameBufferObject)时,它就会被绘制到屏幕上.FrameBuffer指向的是显存中RenderBuffer的地址,简单的来说,RenderBuffer需要附加在FrameBuffer上,它才能是五颜六色的图片,否则它只是显存上的一堆数据,</p>
<h2 id="FrameBufferObject"><a href="#FrameBufferObject" class="headerlink" title="FrameBufferObject"></a>FrameBufferObject</h2><p>FrameBufferObject是一个集合,集合了FrameBuffer,通过快速刷新Framebuffer实现动态效果,最典型的FBO就是Unity的Main Camera,它是默认的FBO,是gpu里渲染结果的目的地.但是现代gpu通常可以创建很多其他的FBO(Unity中可以创建多个Camera)，这些FBO不连接窗口区域，这种我们创建的FBO的存在目的就是允许我们将渲染结果保存在gpu的一块存储区域，待之后使用,这种用法叫做离屏渲染，这是一个非常有用的东西。Camera 输出的FBO,可以嵌在另一个FBO中,Unity中使用RenderTexture来接收FBO(可视化FBO),Game窗口是一个特殊的RenderTexture,它允许多个FBO叠加渲染,当Camera的RenderTarget都设置为null时表示输出到game窗口(没有摄像机的RenderTaget为null会显示没有摄像机进行渲染),设置不为null表示输出到某个RT.</p>
<h2 id="如何使用FrameBufferObject"><a href="#如何使用FrameBufferObject" class="headerlink" title="如何使用FrameBufferObject?"></a>如何使用FrameBufferObject?</h2><p>1.将这个FBO上的结果传回CPU这边的贴图，在gles中的实现一般是ReadPixels（）这样的函数，这个函数是将当前设为可读的FBO拷贝到cpu这边的一个存储buffer，没错如果当前设为可读的FBO是那个默认FBO，那这个函数就是在截屏，如果是你自己创建的FBO，那就把刚刚绘制到上面的结果从gpu存储拿回内存。</p>
<ol>
<li>将这个FBO上的结果拷贝到一个gpu上的texture，在gles中的实现一般是CopyTexImage2D（），它一般是将可读的FBO的一部分拷贝到存在于gpu上的一个texture对象中，直接考到server-sider就意味着可以马上被gpu渲染使用</li>
</ol>
<p>3.将这个fbo直接关联一个gpu上的texture对象，这样就等于在绘制时就直接绘制到这个texure上，这样也省去了拷贝时间，gles中一般是使用FramebufferTexture2D（）这样的接口。</p>
<h2 id="unity是如何使用FBO的"><a href="#unity是如何使用FBO的" class="headerlink" title="unity是如何使用FBO的?"></a>unity是如何使用FBO的?</h2><p>Unity通过上面说的第三个方法将FBO输出到RenderTexture,在unity里要使用这个FBO,只能基于这个RenderTexture(目前我知道的是这样,可能有我不知道的用法).</p>
<p>在Unity固定渲染管线中(Unity2019.3以后 自定义渲染管线脱离预览版,新的通用渲染管线Camera设置发生了改变,如果依然使用固定渲染管线则以下通用),通过Camera组件来使用FBO,多摄像机使用下,根据ClearFlags来决定渲染内容:</p>
<p>需要强调的是Clear操作, 多Camera下,DepthOnly 和Don’t Clear实际上都使Clear操作失效了 ,</p>
<h2 id="RenderTexture的用途"><a href="#RenderTexture的用途" class="headerlink" title="RenderTexture的用途?"></a>RenderTexture的用途?</h2><p>1.屏幕后处理,3d游戏最基本的后处理是抗锯齿,从Unity的FrameDebugger(可以看到所有FrameBuffer,不管它们属于哪个FBO)中可以看到抗锯齿的操作在OverlayUI之前,所以各位做2d游戏的可以选择把抗锯齿关掉,其他的后处理如bloom,HDR等都是操作屏幕这个默认的RenderTexture,配合上相关效果的Material </p>
<p>2.在Scene中直接将RT作为Texture传给其他材质球,操作是调用Material.SetTexture 为该RT,即可实现在另一个表面渲染另一个Camera的内容.可以制作后视镜功能</p>
<p>3.copy回cpu端的内存:基本操作是在当前帧渲染完毕后(协程中, yield return new WaitForEndOfFrame()),设置RenderTexture.active为目标RenderTexture(因为当前帧已渲染过,所以该RenderTexture不会被渲染).Texture.ReadPixels保存到显存.Texture.GetRawTextureData()读回cpu内存,可以保存到硬盘或者通过互联网通信(在unity中实现的截屏,录屏,实时共享屏幕).</p>
<p>以上2,3都属于离屏渲染的应用.</p>
<h2 id="转自：https-www-jianshu-com-p-fa73c0f6762d"><a href="#转自：https-www-jianshu-com-p-fa73c0f6762d" class="headerlink" title="转自：https://www.jianshu.com/p/fa73c0f6762d"></a>转自：<a href="https://www.jianshu.com/p/fa73c0f6762d" target="_blank" rel="noopener">https://www.jianshu.com/p/fa73c0f6762d</a></h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/3/">3</a><a class="page-number" href="/archives/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/archives/6/">6</a><a class="page-number" href="/archives/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/6/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>