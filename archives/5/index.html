<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-资源与内存-加载、卸载、Destroy"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%86%85%E5%AD%98-%E5%8A%A0%E8%BD%BD%E3%80%81%E5%8D%B8%E8%BD%BD%E3%80%81Destroy/"
    >资源与内存(加载、卸载、Destroy)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%86%85%E5%AD%98-%E5%8A%A0%E8%BD%BD%E3%80%81%E5%8D%B8%E8%BD%BD%E3%80%81Destroy/" class="article-date">
  <time datetime="2023-07-25T12:56:23.369Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Unity文件，文件引用，meta详解"><a href="#Unity文件，文件引用，meta详解" class="headerlink" title="Unity文件，文件引用，meta详解"></a>Unity文件，文件引用，meta详解</h2><h3 id="Assets目录下常见的文件类型"><a href="#Assets目录下常见的文件类型" class="headerlink" title="Assets目录下常见的文件类型"></a>Assets目录下常见的文件类型</h3><h4 id="资源文件-ImportedAsset"><a href="#资源文件-ImportedAsset" class="headerlink" title="资源文件(ImportedAsset)"></a>资源文件(ImportedAsset)</h4><p>创建好的，并且不再修改的文件：FBX文件，贴图文件，音频文件，视频文件，动画文件<br>导入时进行转化，每一个类型都对应一个AssetImporter<br>点击这样的资源，在Inspector面板会出现设置界面</p>
<h4 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h4><p>代码文件包括所有的代码文件，代码库文件，shader文件等，在导入时，unity会进行一次编译。</p>
<h4 id="序列化文件-Native-Asset"><a href="#序列化文件-Native-Asset" class="headerlink" title="序列化文件(Native Asset)"></a>序列化文件(Native Asset)</h4><p>序列化文件通常是指unity能够序列化的文件，一般是unity自身的一些类型。比如prefab(预制体)，unity3d(场景)文件，asset(ScriptableObject)文件.mat文件(材质球)，这些文件能够在运行时直接反序列化为对应类的一个实例。</p>
<h4 id="文本文档"><a href="#文本文档" class="headerlink" title="文本文档"></a>文本文档</h4><p>不是序列化文件，但是unity可以识别为TextAsset。<br>很像资源文件，但是又不需要资源文件那样进行设置和转化。<br>如txt、xml文件等等</p>
<h4 id="非序列化文件"><a href="#非序列化文件" class="headerlink" title="非序列化文件"></a>非序列化文件</h4><p>非序列文件是Unity无法识别的文件，比如文件夹</p>
<h4 id="Meta文件"><a href="#Meta文件" class="headerlink" title="Meta文件"></a>Meta文件</h4><p>meta文件在unity中的作用非常关键，它有2个作用</p>
<ul>
<li><p>定义在它同目录下，同名的非meta文件的唯一ID：GUID。而对于unity的序列化文件来说，引用的对象用的就是这个GUID。所以一旦meta中的GUID变更了，就要注意，它很可能引起一场引用丢失的灾难</p>
</li>
<li><p>存储资源文件的ImportSetting数据。在上文中资源文件是有ImportSetting数据的，这个数据正数存储在meta文件中。ImportSetting中专门有存储Assetbundle相关的数据。这些数据帮助编辑器去搜集所有需要打包的文件并分门别类。所以每一次修改配置都会修改meta文件。</p>
</li>
</ul>
<h3 id="Meta文件详解——Unity-GUID-LocalID系统"><a href="#Meta文件详解——Unity-GUID-LocalID系统" class="headerlink" title="Meta文件详解——Unity GUID/LocalID系统"></a>Meta文件详解——Unity GUID/LocalID系统</h3><p>meta文件——文本文档，YAML格式写的（序列化文件都是用这个格式写）</p>
<h4 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h4><p>guid代表该文件，无论什么类型（甚至是文件夹）。<br>通过GUID就可以找到工程中的这个文件，无论它在项目的什么位置。<br>在编辑器中使用AssetDatabase.GUIDToAssetPath和AssetDatabase.AssetPathToGUID进行互转。</p>
<h4 id="ImportSetting数据"><a href="#ImportSetting数据" class="headerlink" title="ImportSetting数据"></a>ImportSetting数据</h4><p>根据不同的文件类型，它的数据是不同的ImportSetting数据（Inspector面板设置），比如上面的NativeFormatImporter，ModelImporter，AudioImporter等等。把一个文件和这个文件的meta文件从一个Unity工程复制到另一个Unity工程中，它的配置是不会变的。（将fbx和它的meta文件拷贝到另一个工程，不需要重新裁剪动画）</p>
<h4 id="FileID（LocalID）"><a href="#FileID（LocalID）" class="headerlink" title="FileID（LocalID）"></a>FileID（LocalID）</h4><p>如果是一个图集，下面有若干个图片，那么就需要另外一个ID来表示，这就是LocalID（meta文件名为: FileID。）</p>
<ul>
<li><p>对于资源文件，非序列化文件，由于一般不会去更改源文件，所以FileID存储在meta文件中。</p>
</li>
<li><p>对于序列化文件，自身数据里面会存储自身的FileID，也会记录所有子文件的FileID</p>
</li>
</ul>
<blockquote>
<p>所以在每次svn提交时如果发现有meta文件变更，一定要打开看一下。看看这个guid是否被更改。理论上是不需要更改的。</p>
</blockquote>
<h3 id="序列化文件详解——Unity文件引用系统"><a href="#序列化文件详解——Unity文件引用系统" class="headerlink" title="序列化文件详解——Unity文件引用系统"></a>序列化文件详解——Unity文件引用系统</h3><p>用sublime打开一个Scene文件(.unity)，<br>大概的数据：</p>
<ul>
<li><p>OcclusionCullingSettings裁剪数据（菜单Window-&gt;Occlusion面板中的数据）</p>
</li>
<li><p>RenderSettings（菜单Window-&gt;Lighting-&gt;Settings面板中的部分数据）</p>
</li>
<li><p>LightmapSettings（菜单Window-&gt;Lighting-&gt;Settings面板中的其他部分数据）</p>
</li>
<li><p>NavMeshSettings（菜单Window-&gt;Navigation面板中的数据）</p>
</li>
<li><p>之后就是场景中的GameObject的数据</p>
</li>
</ul>
<h4 id="GameObject数据"><a href="#GameObject数据" class="headerlink" title="GameObject数据"></a>GameObject数据</h4><p>Name就是Main Camera<br>某个物体上有4个组件，每个组件有一个FileID，然后在需要引用时，使用这些FileID即可。实例化一个这样的GameObject时，只要依照次序，依次创建物体，组件，初始化数据并进行引用绑定即可在场景中生成一个实例。</p>
<blockquote>
<p>在Inspector面板中的右上角点击，然后选择Debug转成Debug模式下的Inspector面板。<br> 在Hierarchy面板中选中Main Camera可以看到如图所示，所有的组件的LocalIdentfierInFile的值就是刚刚在Sublime中看到的数据</p>
</blockquote>
<ul>
<li><p><strong>InstanceID</strong> 是unity中一个实例的ID。</p>
</li>
<li><p>每一个Unity实例都会有一个InstanceID。在运行时，用UnityEngine.Object的GetInstanceID获取（《Unity编辑器下和运行时的加载过程》）</p>
</li>
</ul>
<h4 id="组件数据"><a href="#组件数据" class="headerlink" title="组件数据"></a>组件数据</h4><p>在GameObject之后就是组件数据。可以结合Unity中这个组件的面板来了解每一个数据的意义。</p>
<blockquote>
<p>组件FlareLayer，在YAML里面只是一个Behaviour（所有Behaviour组件都看不到类型名字），怎么样才能知道他是一个FlareLayer？<br> FileID左边我们看到一个124。每一个unity类型都有一个对应的数字。<br> 参考：<a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/ClassIDReference.html</a></p>
</blockquote>
<p>任何一个文件都可以通过GUID找到，然后通过FileID找到它内部的子文件。所以这样就能识别出这个具体是什么类了。</p>
<h4 id="Prefab数据"><a href="#Prefab数据" class="headerlink" title="Prefab数据"></a>Prefab数据</h4><p>在YAML的最下面有一个数据是Prefab数据，保存了最重要的几个数据：<br>Modification：每个组件的修改数据列表，但凡修改的数据，都会在这里体现。记录了：哪个资源（GUID）的哪个组件(FileID)的哪个成员(PropertyPath)的值(value)发生了改变。<br>ParentPrefab：表示是哪一个Prefab。</p>
<p><img src="资源与内存\(加载、卸载、Destroy\" alt="Alt text"><br>_files/289969-20180402204239871-1854753914.png)</p>
<h2 id="资源导入"><a href="#资源导入" class="headerlink" title="资源导入"></a>资源导入</h2><p>Unity automatically imports assets and manages various kinds of additional data about them for you, such as what import settings should be used to import the asset, and where the asset is used throughout your project. </p>
<h3 id="What-happens-when-Unity-imports-an-Asset"><a href="#What-happens-when-Unity-imports-an-Asset" class="headerlink" title="What happens when Unity imports an Asset?"></a>What happens when Unity imports an Asset?</h3><ol>
<li>A Unique ID is assigned<br>This ID is used internally by Unity to refer to the asset which means the asset can be moved or renamed without references to the asset breaking.</li>
</ol>
<blockquote>
<p>the editor frequently checks the contents of the Assets folder against the list of assets it already knows about.</p>
</blockquote>
<ol>
<li>A .meta file is created</li>
</ol>
<blockquote>
<p>If an asset loses its meta file (for example, if you moved or renamed the asset outside of Unity, without moving/renaming the corresponding .meta file), any reference to that asset will be broken. Unity would generate a new .meta file for the moved/renamed asset as if it were a brand new asset, and delete the old “orphaned” .meta file.</p>
</blockquote>
<ol>
<li>The source asset is processed<br>Unity reads and processes any files that you add to the Assets folder, converting the contents of the file to internal game-ready versions of the data. The actual asset files remain unmodified, and the processed and converted versions of the data are stored in the project’s <strong>Library</strong> folder.</li>
</ol>
<blockquote>
<p>the Photoshop file format is convenient to work with and can be saved directly into your Assets folder, but hardware such as mobile devices and PC graphics cards can’t accept that format directly to render as textures. All the data for Unity’s internal representation of your assets is stored in the Library folder which can be thought of as similar to a cache folder. As a user, you should never have to alter the Library folder manually and attempting to do so may affect the functioning of the project in the Unity editor. However, it is always safe to delete the Library folder (while the project is not open in Unity) as all its data is generated from what is stored in the Assets and ProjectSettings folders. This also means that the Library folder should not be included in version control. </p>
<p>Sometimes multiple assets are created from an import</p>
<ul>
<li><p>A 3D file, such as an FBX, defines Materials and/or contains embedded Textures.</p>
</li>
<li><p>An image file imported as multiple sprites.</p>
</li>
<li><p>A 3D file contains multiple animation timelines, or has multiple separate clips defined within its animation import settings.</p>
</li>
</ul>
</blockquote>
<h3 id="The-import-settings-can-alter-the-processing-of-the-asset"><a href="#The-import-settings-can-alter-the-processing-of-the-asset" class="headerlink" title="The import settings can alter the processing of the asset"></a>The import settings can alter the processing of the asset</h3><p>As well as the unique ID assigned to the asset, the meta files contain values for all the import settings you see in the inspector when you have an asset selected in your project window. For a texture, this includes settings such as the Texture Type, Wrap Mode, Filter Mode and Aniso Level.</p>
<p>If you change the import settings for an asset, those changed settings are stored in the .meta file accompanying the asset. The asset will be re-imported according to your new settings, and the corresponding imported “game-ready” data will be updated in the project’s Library folder.</p>
<h2 id="AssetDatabase"><a href="#AssetDatabase" class="headerlink" title="AssetDatabase"></a>AssetDatabase</h2><p>AssetDatabase is an API which allows you to access the assets contained in your project. Among other things, it provides methods to find and load assets and also to create, delete and modify them. The Unity Editor uses the AssetDatabase internally to keep track of asset files and maintain the linkage between assets and objects that reference them.</p>
<h3 id="Importing-an-Asset"><a href="#Importing-an-Asset" class="headerlink" title="Importing an Asset"></a>Importing an Asset</h3><h3 id="Loading-an-Asset"><a href="#Loading-an-Asset" class="headerlink" title="Loading an Asset"></a>Loading an Asset</h3><h3 id="File-Operations-using-the-AssetDatabase"><a href="#File-Operations-using-the-AssetDatabase" class="headerlink" title="File Operations using the AssetDatabase"></a>File Operations using the AssetDatabase</h3><h3 id="Using-AssetDatabase-Refresh"><a href="#Using-AssetDatabase-Refresh" class="headerlink" title="Using AssetDatabase.Refresh"></a>Using AssetDatabase.Refresh</h3><p>When you have finished modifying assets, you should call AssetDatabase.Refresh to commit your changes to the database and make them visible in the project.</p>
<h3 id="CreateAssets-amp-FindAssets-amp-ScriptableObject"><a href="#CreateAssets-amp-FindAssets-amp-ScriptableObject" class="headerlink" title="CreateAssets &amp; FindAssets &amp; ScriptableObject"></a>CreateAssets &amp; FindAssets &amp; ScriptableObject</h3><ol>
<li><p>对于ScriptableObject，使用CreateInstance来创建Asset实例对象<br><code>testI = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj));</code></p>
</li>
<li><p>对于其他资源类型，使用new来创建对象</p>
</li>
<li><p>然后调用 <code>AssetDatabase.CreateAsset</code>函数，将实例对象作为资源存储在Assets路径当中。</p>
</li>
<li><p>最后使用<code>AssetDatabase.FindAssets</code>获取相应资源的GUID</p>
</li>
<li><p>由 <code>AssetDatabase.GUIDToAssetPath</code> 获取相应资源的路径。</p>
</li>
</ol>
<pre><code class="lang-csharp">
// This script file has two CS classes. The first is a simple Unity ScriptableObject script.

// The class it defines is used by the Example class below.

// (This is a single Unity script file. You could split this file into a ScriptObj.cs and an

// Example.cs file which is more structured.)

using UnityEngine; 

using UnityEditor; 

public class ScriptObj : ScriptableObject

{ 

public void Awake()

{ 

Debug.Log(&quot;ScriptObj created&quot;); 

} 

} 

// Use ScriptObj to show how AssetDabase.FindAssets can be used

public class Example

{ 

static ScriptObj testI; 

static ScriptObj testJ; 

static ScriptObj testK; 

[MenuItem(&quot;Examples/FindAssets Example two&quot;)] 

static void ExampleScript()

{ 

CreateAssets(); 

NamesExample(); 

LabelsExample(); 

TypesExample(); 

} 

static void CreateAssets()

{ 

testI = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); 

AssetDatabase.CreateAsset(testI, &quot;Assets/AssetFolder/testI.asset&quot;); 

testJ = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); 

AssetDatabase.CreateAsset(testJ, &quot;Assets/AssetFolder/testJ.asset&quot;); 

// create an asset in a sub-folder and with a name which contains a space

testK = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); 

AssetDatabase.CreateAsset(testK, &quot;Assets/AssetFolder/SpecialFolder/testK example.asset&quot;); 

// an asset with a material will be used later

Material material = new Material(Shader.Find(&quot;Standard&quot;)); 

AssetDatabase.CreateAsset(material, &quot;Assets/AssetFolder/SpecialFolder/MyMaterial.mat&quot;); 

} 

static void NamesExample()

{ 

Debug.Log(&quot;*** FINDING ASSETS BY NAME ***&quot;); 

string[] results; 

results = AssetDatabase.FindAssets(&quot;testI&quot;); 

foreach (string guid in results) 

{ 

Debug.Log(&quot;testI: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

results = AssetDatabase.FindAssets(&quot;testJ&quot;); 

foreach (string guid in results) 

{ 

Debug.Log(&quot;testJ: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

results = AssetDatabase.FindAssets(&quot;testK example&quot;); 

foreach (string guid in results) 

{ 

Debug.Log(&quot;testK example: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

Debug.Log(&quot;*** More complex asset search ***&quot;); 

// find all assets that contain test (which is all assets)

results = AssetDatabase.FindAssets(&quot;test&quot;); 

foreach (string guid in results) 

{ 

Debug.Log(&quot;name:test - &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

} 

static void LabelsExample()

{ 

Debug.Log(&quot;*** FINDING ASSETS BY LABELS ***&quot;); 

string[] setLabels; 

setLabels = new string[] {&quot;wrapper&quot;}; 

AssetDatabase.SetLabels(testI, setLabels); 

setLabels = new string[] {&quot;bottle&quot;, &quot;banana&quot;, &quot;carrot&quot;}; 

AssetDatabase.SetLabels(testJ, setLabels); 

setLabels = new string[] {&quot;swappable&quot;, &quot;helmet&quot;}; 

AssetDatabase.SetLabels(testK, setLabels); 

// label searching:

// testI has wrapper, testK has swappable, so both have &#39;app&#39;

// testJ has bottle, so have a label searched as &#39;bot&#39;

string[] getGuids = AssetDatabase.FindAssets(&quot;l:app l:bot&quot;); 

foreach (string guid in getGuids) 

{ 

Debug.Log(&quot;label lookup: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

} 

static void TypesExample()

{ 

Debug.Log(&quot;*** FINDING ASSETS BY TYPE ***&quot;); 

string[] guids; 

// search for a ScriptObject called ScriptObj

guids = AssetDatabase.FindAssets(&quot;t:ScriptObj&quot;); 

foreach (string guid in guids) 

{ 

Debug.Log(&quot;ScriptObj: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

guids = AssetDatabase.FindAssets(&quot;t:ScriptObj l:helmet&quot;); 

foreach (string guid in guids) 

{ 

Debug.Log(&quot;ScriptObj+bottle: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

} 

}
</code></pre>
<h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><p><a href="https://blog.csdn.net/qq_35361471/article/details/82854560" target="_blank" rel="noopener">https://blog.csdn.net/qq_35361471/article/details/82854560</a></p>
<h2 id="资源卸载（Unload-amp-Destroy）"><a href="#资源卸载（Unload-amp-Destroy）" class="headerlink" title="资源卸载（Unload &amp; Destroy）"></a>资源卸载（Unload &amp; Destroy）</h2><h3 id="Destroy"><a href="#Destroy" class="headerlink" title="Destroy"></a>Destroy</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>UNITY Destroy()和DestroyImadiate()都不会立即释放对象内存<br>DestroyImadiate是立即将物体从场景hierachy中移除，并标记为 “null”，注意 是带引号的null。这是UNITY内部的一个处理技巧。关于这个技巧有很争议。<br>Destroy要等到帧末才会将物体从场景层级中移除并标记为”null”。</p>
<p>不管如何，二者都只是UNITY引擎层面的标记与处理，但在.NET底层，对象的内存都没有释放，只有手动GC.Collect()或等待NET去GC时才会释放掉对象内存。<br>如果该对象在其他地方还有引用的话，GC也无法将对象的内存释放。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>（1）obj并不会立即销毁，而是需要等待下一个Update更新，所以还是可以被print出来；<br>（2）DestroyImmediate立即对对像进行销毁，print出来是null；<br>（3）Destroy销毁场景中的物体，但内存中还存在，当令它需要销毁时，只是给一个标识。而内存中它依然是存在的，只有当内存不够，或一段时间没有再次被引用时（或者更多合理的条件满足），机制才会将它销毁并释放内存；<br>（4）这样做的目的就是为了避免频繁对内存的读写操作。回收器会定时清理一次内存中引用计数为0的对象，很可能你的要销毁的对象在其他地方还有引用而你自己不清楚，直接销毁可能导致其他地方空引用错误；<br>（5）建议使用平常Destroy函数，而不是DestroyImmediate函数；</p>
<h4 id="作用对象"><a href="#作用对象" class="headerlink" title="作用对象"></a>作用对象</h4><p>GameObject、Component这样的在内存当中的实例，可以直接销毁，销毁掉后对硬盘上的资源是没有影响的。<br>Load进来的资源文件（Texture等）不可以使用DestroyImmediate(obj)直接销毁。如果使用DestroyImmediate(obj, true)接口，可以销毁。对于序列化文件等Unity可以直接识别和接管的文件，相应的资源文件会销毁掉，而对于Texture这样的资源，Unity无法识别资源原始的图片，只能识别导入后加入Library中的文件，则会销毁Library中相应的资源，并断掉对该资源的引用（路径上就找不到该资源了）。而对于图片，由于原始文件没有被销毁，重新打开项目后，该图片会重新被Import进来。</p>
<p>总之，Destroy接口本身是不应该用来销毁资源的。</p>
<p>如果在游戏当中把资源Destroy掉，下次打开游戏，这个资源就没有了，加载不到了。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试代码如下：点ADD按钮不断创建对象，点DEL按钮清除所有对象，通过观察进程内存数值来察看对象内存是否释放。</p>
<pre><code class="lang-csharp">
using System.Collections; 

using System.Collections.Generic; 

using System.Diagnostics; 

using UnityEngine; 

using UnityEngine.UI; 

public class MyGo : MonoBehaviour

{ 

byte[] data = new byte[83000]; 

} 

public class testad : MonoBehaviour { 

Transform objs; 

Text txt; 

Process proc; 

void Start () { 

var btnadd = transform.Find(&quot;btnAdd&quot;).GetComponent&lt;Button&gt;(); 

btnadd.onClick.AddListener(OnClckAdd); 

var btndel = transform.Find(&quot;btnDel&quot;).GetComponent&lt;Button&gt;(); 

btndel.onClick.AddListener(OnClckDel); 

objs = transform.Find(&quot;objs&quot;); 

txt = transform.Find(&quot;Text&quot;).GetComponent&lt;Text&gt;(); 

proc = Process.GetCurrentProcess(); 

} 

void OnClckAdd()

{ 

for (int i = 0; i &lt; 20; ++i) 

{ 

var go = new GameObject(); 

go.AddComponent&lt;MyGo&gt;(); 

go.transform.SetParent(objs); 

} 

} 

void OnClckDel()

{ 

for (int i = objs.childCount - 1; i &gt;= 0; i--) 

{ 

GameObject.DestroyImmediate(objs.GetChild(i).gameObject); 

} 

System.GC.Collect(); 

} 

// Update is called once per frame

float timer = 0; 

void Update () 

{ 

if (timer &gt; 0.5f) 

{ 

timer = 0; 

txt.text = ((int)(proc.WorkingSet64 / 1024)).ToString(); 

} 

timer += Time.deltaTime; 

} 

}
</code></pre>
<h4 id="Resources-UnloadUnusedAssets"><a href="#Resources-UnloadUnusedAssets" class="headerlink" title="Resources.UnloadUnusedAssets"></a>Resources.UnloadUnusedAssets</h4><p>运行中卸载，可能是在帧末尾卸载</p>
<h4 id="Resources-UnloadAsset"><a href="#Resources-UnloadAsset" class="headerlink" title="Resources.UnloadAsset()"></a>Resources.UnloadAsset()</h4><p>对于场景当中的特定资源，如果相机照射到他或者在脚本中有对资源的引用的话就无法卸载。<br>如果相机没有看到他，并且没有被引用到，那么该资源会在内存当中被卸载。而若下次引用到他，或者相机照射到他，那么该资源会被重新加载到内存当中。</p>
<h4 id="EditorUtility-UnloadUnusedAssets"><a href="#EditorUtility-UnloadUnusedAssets" class="headerlink" title="EditorUtility.UnloadUnusedAssets"></a>EditorUtility.UnloadUnusedAssets</h4><p>编辑器下的卸载资源接口。</p>
<h2 id="资源卸载与内存管理问题的处理经验"><a href="#资源卸载与内存管理问题的处理经验" class="headerlink" title="资源卸载与内存管理问题的处理经验"></a>资源卸载与内存管理问题的处理经验</h2><ol>
<li><p>Editor中的脚本对物体的引用无法用Memory Profiler检测到，因为Editor脚本对MemoryProfiler是不可见的。</p>
</li>
<li><p>只要脚本中有对Texture等资源实例的引用，那么相应的资源就无法卸载掉。</p>
</li>
<li><p>EditorUtility.UnloadUnusedAssets确实可以卸载没有被引用的资源对象，但是不会一调用就立即卸载掉，可能稍等一会儿才会卸载掉。所以，在这个函数调用过后立即检测内存，是看不出来卸载的效果的，过一小段时间后，再打印内存，就可以看到卸载的效果。根据对内存的监控可以判断：刚刚调用Unload资源函数的时候，内存不会立即释放，在下次加载资源的时候，会进行内存释放操作。</p>
</li>
<li><p>把加载进内存的对象直接Destroy掉，就不会占用内存，不需要调用Unload函数也可以。 如果把对资源的引用设置为null，不调用unload函数的话，资源会留在内存当中，只有调用unload之后，资源才会被卸载</p>
</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/CodeGize/p/8697227.html" target="_blank" rel="noopener">https://www.cnblogs.com/CodeGize/p/8697227.html</a><br><a href="https://www.cnblogs.com/timeObjserver/p/7575035.html" target="_blank" rel="noopener">https://www.cnblogs.com/timeObjserver/p/7575035.html</a><br><a href="https://docs.unity3d.com/2017.2/Documentation/Manual/BehindtheScenes.html" target="_blank" rel="noopener">https://docs.unity3d.com/2017.2/Documentation/Manual/BehindtheScenes.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-小知识点与小工具"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%B0%8F%E5%B7%A5%E5%85%B7/"
    >小知识点与小工具</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%B0%8F%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2023-07-25T12:56:23.368Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Gizmos"><a href="#Gizmos" class="headerlink" title="Gizmos"></a>Gizmos</h2><p><strong>Gizmos</strong> 在编辑模式下Gizmos可以提供可视化的提示。它们只在Scene场景中显示不在Play模式下显示，但是你可以通过工具栏调整它们。</p>
<p><strong>Gizmos公共类</strong> 允许你绘制图标，线条，和其他的东西。Gizmos在<code>OnDrawGizmos</code>方法中执行绘制，它被Unity编辑器自动调用。另一个可选的方法是<code>OnDrawGizmosSelected</code>，它只能被可选的对象调用。</p>
<p>Demo: 绘制顶点的位置，利用OnDrawGizmos在每个顶点绘制一个小球。</p>
<p><code>csharp private void OnDrawGizmos () { Gizmos.color = Color.black; for (int i = 0; i &lt; vertices.Length; i++) { Gizmos.DrawSphere(vertices[i], 0.1f); } }</code> </p>
<h2 id="OnValidate"><a href="#OnValidate" class="headerlink" title="OnValidate"></a>OnValidate</h2><p>调用时机:</p>
<ul>
<li>脚本被加载时</li>
<li>Inspector 中的任何值被修改时</li>
</ul>
<p>Cases：<br>设置循环值</p>
<p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { public float objectRotation; void OnValidate() { // objectRotation objectRotation = objectRotation % 360; } }</code> </p>
<p>需要设计人员输入 16 到 4096 之间 2的整数次幂时。<br>Unity提供了ClosestPowerOfTwo函数，方便我们取得最接近的值。同时我们使用RangeAttribute 属性来限定一下输入数值的区间，同时能更好的看出来处理后的值跟原始输入值的区别。</p>
<p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { [RangeAttribute(16, 4096)] public int textureSize; void OnValidate() { // textureSize textureSize = Mathf.ClosestPowerOfTwo(textureSize); } }</code> </p>
<p>使用场景 -需要“Nitro”车的速度比其他车的速度大至少20mph.</p>
<p><code>csharp using UnityEngine; using System.Collections; public class OnValidateExample : MonoBehaviour { [RangeAttribute(10, 300)] [Tooltip(&quot;mph&quot;)] public int maxCarSpeed; [RangeAttribute(10, 300)] [Tooltip(&quot;mph&quot;)] public int maxNitroSpeed; const int minNitroSpeedExtra = 20; void OnValidate() { // speed check if (maxNitroSpeed &lt; maxCarSpeed + minNitroSpeedExtra) maxNitroSpeed = maxCarSpeed + minNitroSpeedExtra; } }</code> </p>
<h2 id="动态添加tag"><a href="#动态添加tag" class="headerlink" title="动态添加tag"></a>动态添加tag</h2><p><code>csharp #region 动态添加tag static void AddTag(string tag, GameObject obj) { if (!isHasTag(tag)) { SerializedObject tagManager = new SerializedObject(obj);//序列化物体 SerializedProperty it = tagManager.GetIterator();//序列化属性 while (it.NextVisible(true))//下一属性的可见性 { if (it.name == &quot;m_TagString&quot;) { Debug.Log(it.stringValue); it.stringValue = tag; tagManager.ApplyModifiedProperties(); } } } } static bool isHasTag(string tag) { for (int i = 0; i &lt; UnityEditorInternal.InternalEditorUtility.tags.Length; i++) { if (UnityEditorInternal.InternalEditorUtility.tags[i].Equals(tag)) return true; } return false; } #endregion</code> </p>
<h2 id="关于enable-false"><a href="#关于enable-false" class="headerlink" title="关于enable=false"></a>关于enable=false</h2><p>When a Behaviour is disabled, it will still be on the object and you can even change its properties and call its methods, but the engine will no longer call its Update method.<br>When a Renderer is disabled, the object turns invisible.<br>When a Collider is disabled, it won’t cause any collision events to happen.<br>When an UI component is disabled, the player can’t interact with it anymore, but it will still be rendered, unless you also deactivate its renderer.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-序列化与反序列化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"
    >序列化与反序列化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-date">
  <time datetime="2023-07-25T12:56:23.368Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Ref: <a href="https://zhuanlan.zhihu.com/p/27990334" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27990334</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>序列化</strong> 又称串行化，是.NET运行时环境用来支持用户定义类型的流化的机制。其目的是以某种存储形式使自定义对象持久化，或者将这种对象从一个地方传输到另一个地方。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化是指把 <strong>对象</strong> 转换为 <strong>字节序列</strong> 的过程</p>
<p>对象序列化的最主要的用处就是在 <strong>传递和保存对象</strong> 的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了 <strong>对象的状态以及相关的描述信息</strong> 。序列化机制的核心作用就是对象状态的保存与重建。</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列化是指把 <strong>字节序列</strong> （有序字节流）恢复为 <strong>对象</strong> 的过程</p>
<p>客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化 <strong>重建对象，恢复对象状态</strong></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li><p>永久性保存对象，保存对象的字节序列到本地文件或者数据库中；</p>
</li>
<li><p>通过序列化以字节流的形式使对象在网络中进行传递和接收；</p>
</li>
<li><p>通过序列化在进程间传递对象；</p>
</li>
</ol>
<h2 id="Unity序列化"><a href="#Unity序列化" class="headerlink" title="Unity序列化"></a>Unity序列化</h2><p>Unity的场景文件和预制体默认就是以二进制的文件保存在工程目录下。<br>在 <strong>检视面板</strong> 中可以看到的，就是被 <strong>成功序列化了的参数</strong> 。与序列化相关的常用的关键字如下，可以组合使用。</p>
<ul>
<li><p>SerializeField : 表示变量可被序列化。众所周知，公有变量可以在检视面板中看到并编辑，而私有和保护变量不行。SerializeField与private，protected结合使用可以达到让脚本的变量在检视面板里可视化编辑，同时保持它的私有性的目的。</p>
</li>
<li><p>HideInInspector : 将原本显示在检视面板上的序列化值隐藏起来。</p>
</li>
<li><p>NonSerialized :通过此方法可以将一个公有变量不序列化并且不显示在检视面板中。</p>
</li>
<li><p>Serializable：用在类的前面，表示该类可被序列化。</p>
</li>
</ul>
<p><strong>相关API</strong><br>SerializedObject: <a href="https://docs.unity3d.com/ScriptReference/SerializedObject.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/SerializedObject.html</a><br>SerializedProperty: <a href="https://docs.unity3d.com/ScriptReference/SerializedProperty.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/SerializedProperty.html</a></p>
<blockquote>
<p>注意：并非所有的公有变量都是可以被序列化的。其中const，static是静态的，属于类而非对象，无法序列化。链表和字典在内存中的存储是不连续的，也无法序列化。其中const，static，readonly的区别可参考文章：<a href="https://www.cnblogs.com/suizhikuo/p/4739388.html" target="_blank" rel="noopener">https://www.cnblogs.com/suizhikuo/p/4739388.html</a></p>
</blockquote>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="二进制方法（Binary-Formatter）"><a href="#二进制方法（Binary-Formatter）" class="headerlink" title="二进制方法（Binary Formatter）"></a>二进制方法（Binary Formatter）</h3><pre><code class="lang-csharp">
void WriteTest()

{ 

DemoClass demo = new DemoClass (100, &quot;RCD&quot;); 

FileStream fs = new FileStream (&quot;demo.bin&quot;, FileMode.OpenOrCreate); 

BinaryFormatter bf = new BinaryFormatter (); 

bf.Serialize (fs, demo); 

fs.Close (); 

Debug.LogError (&quot;write done&quot;); 

} 

void ReadTest()

{ 

FileStream fs = new FileStream(&quot;demo.bin&quot;, FileMode.Open); 

BinaryFormatter bf = new BinaryFormatter(); 

DemoClass demo = bf.Deserialize(fs) as DemoClass; 

fs.Close(); 

demo.Output(); 

}
</code></pre>
<blockquote>
<p>注意：二进制方法可以序列化私有变量，不能序列化被[NonSerialized ]修饰的变量且类需要被[Serializable ]标识。</p>
</blockquote>
<h3 id="Xml序列化"><a href="#Xml序列化" class="headerlink" title="Xml序列化"></a>Xml序列化</h3><p>XML(Extensible Markup Language, 可扩展标记语言), 标准通用标记语言(Standard Generalized Markup language, SGML)的子集。是一种用于标记电子文件使其具有结构性的标记语言。<br>提供统一的方法来描述和交换独立于应用程序或供应商的 <strong>结构化数据</strong> 。</p>
<pre><code class="lang-csharp">
using System.IO; 

using System.Xml.Serialization; 

using UnityEditor; 

先定义一个类： 

public class Studnet{ 

public string m_Name = &quot;仑仑&quot;; 

} 

public class SerializeDemo : MonoBehaviour { 

void Start()

{ 

//序列化：

Student student = new Student(); 

//第一要确定储存的位置

//Application.dataPath就是unity中的Asset文件夹 

StreamWriter sw = new StreamWriter(Application.dataPath + &quot;/Demo.xml&quot;); 

//第二要对什么类型序列化

XmlSerializer xs = new XmlSerializer(typeof(Student)); 

//第三对对象序列化

xs.Serialize(sw, student); 

//关闭流

sw.Close(); 

//刷新Asset文件

AssetDatabase.Refresh(); 

//运行程序会在Asset目录下看到Demo.xml文件

//反序列化

//第一确定对哪个文件进行反序列化

StreamReader sr = new StreamReader(Application.dataPath + &quot;/Demo.xml&quot;); 

//第二要确定对什么类型反序列化

XmlSerializer xs1 = new XmlSerializer(typeof(Student)); 

//第三反序列化

Student student1 = xs1.Deserialize(sr) as Student; 

//关闭流

sr.Close(); 

//会在控制台看到 “仑仑”

print(student1.m_Name); 

} 

} 

SerializeDemo
</code></pre>
<h2 id="其他Unity数据存储方法"><a href="#其他Unity数据存储方法" class="headerlink" title="其他Unity数据存储方法"></a>其他Unity数据存储方法</h2><h3 id="ScriptableObject-自动序列化"><a href="#ScriptableObject-自动序列化" class="headerlink" title="ScriptableObject(自动序列化)"></a>ScriptableObject(自动序列化)</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h5><p>需要指定创建的目录和资源名称，如果资源已经存在，则不会创建新资源；</p>
<pre><code class="lang-csharp">
public class MakeScriptableObject { 

[MenuItem(&quot;Assets/Create/My Scriptable Object&quot;)] 

public static void CreateMyAsset()

{ 

MyScriptableObjectClass asset = ScriptableObject.CreateInstance&lt;MyScriptableObjectClass&gt;(); 

AssetDatabase.CreateAsset(asset, &quot;Assets/NewScripableObject.asset&quot;); 

AssetDatabase.SaveAssets(); 

EditorUtility.FocusProjectWindow(); 

Selection.activeObject = asset; 

} 

}
</code></pre>
<h5 id="CreateAssetMenu"><a href="#CreateAssetMenu" class="headerlink" title="CreateAssetMenu"></a>CreateAssetMenu</h5><p>可以在Assets下任意目录创建资源，而且可以创建多个资源；</p>
<pre><code class="lang-csharp">
[CreateAssetMenu(fileName = &quot;data&quot;, menuName = &quot;ScriptableObjects/SpawnManagerScriptableObject&quot;, order = 1)] 

public class SpawnManagerScriptableObject : ScriptableObject { 

public string prefabName; 

public int numberOfPrefabsToCreate; 

public Vector3[] spawnPoints; 

}
</code></pre>
<p>在Assets下创建一个可编程对象资源，设置好所需数据；如果需要在其它脚本中获取该数据，是需要声明一个该类型变量，然后为其赋值或加载该数据资源；然后，就像使用用一个类中的公有变量一样使用即可；</p>
<pre><code class="lang-csharp">
public SpawnManagerScriptableObject spawnManagerValues; 

//spawnManagerValues.prefabName
</code></pre>
<h3 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a>PlayerPrefs</h3><p>Ref: <a href="https://www.jianshu.com/p/579be3b8e1e3" target="_blank" rel="noopener">https://www.jianshu.com/p/579be3b8e1e3</a><br>PlayerPrefs是Unity内置的一个静态类，可以用于存储一些简单的数据类型：int ,string ,float。可以用它来做成计分板这类需要可持续化存储的小地方。</p>
<h4 id="PlayerPrefs数据存储在哪里"><a href="#PlayerPrefs数据存储在哪里" class="headerlink" title="PlayerPrefs数据存储在哪里?"></a>PlayerPrefs数据存储在哪里?</h4><p>1.在Mac OS X上存储在~/Library/PlayerPrefs文件夹，名为unity.[company name].[product name].plist,这里company和product名是在project Setting中设置的<br>2.在windows下，playerPrefs被存储在注册的HKCU\Software[company name][product name]键下，这里company和product名是在project setting中设置的。<br>3.在Android上，数据存储（持久化）在设备上。数据保存在SharedPreferences中。</p>
<h4 id="PlayerPrefs有哪些方法？"><a href="#PlayerPrefs有哪些方法？" class="headerlink" title="PlayerPrefs有哪些方法？"></a>PlayerPrefs有哪些方法？</h4><p>分为五类：SetXXX , GetXXX , DeleteXXX, HasKey , Save.<br>传送门：<a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/PlayerPrefs.html</a></p>
<ol>
<li><p>SetXXX : 是你要储存的数据类型，这里必须是一组键值对，第一个参数是Key,第二个参数是对应的Value。</p>
</li>
<li><p>GetXXX：这里是获取数据的函数，只有一个参数Key,用来获取对应Key的Value.<br>3.HasKey: 这个可以用来做判断。比如有两组数据一组有XX这个Key,另一组没有XX这个Key,这个时候我们就可以对这两组数据进行差异化操作。</p>
</li>
<li><p>DeleteXX:用于删除数据。</p>
</li>
<li><p>Save:用于在突发退出程序时，保存数据以备恢复时使用，但是会导致程序间断所以不建议调用。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-强哥UI课"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E5%BC%BA%E5%93%A5UI%E8%AF%BE/"
    >强哥UI课</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E5%BC%BA%E5%93%A5UI%E8%AF%BE/" class="article-date">
  <time datetime="2023-07-25T12:56:23.368Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><h3 id="Canvas组件"><a href="#Canvas组件" class="headerlink" title="Canvas组件"></a>Canvas组件</h3><p>Render Mode</p>
<ul>
<li><p>Screen Space - Overlay</p>
</li>
<li><p>Screen Space - Camera</p>
</li>
<li><p>World Space</p>
</li>
</ul>
<p>Pixel Perfect 在要提高清晰度的时候才选择。 一般不推荐选择</p>
<h3 id="Rect-Transform"><a href="#Rect-Transform" class="headerlink" title="Rect Transform"></a>Rect Transform</h3><h3 id="CanvasRenderer"><a href="#CanvasRenderer" class="headerlink" title="CanvasRenderer"></a>CanvasRenderer</h3><h3 id="EventSystem-amp-GraphicRaycaster"><a href="#EventSystem-amp-GraphicRaycaster" class="headerlink" title="EventSystem &amp; GraphicRaycaster"></a>EventSystem &amp; GraphicRaycaster</h3><p>找被点中的物体</p>
<h3 id="Event-Trigger"><a href="#Event-Trigger" class="headerlink" title="Event Trigger"></a>Event Trigger</h3><p>这个是UGUI里面封装好的一个Component，里面预设了很多UGUI支持的UI事件，方便大家用来自定义一些消息响应，比如点击事件，也可以用来制作一些特殊的UI响应，例如长按事件</p>
<h2 id="Lesson2"><a href="#Lesson2" class="headerlink" title="Lesson2"></a>Lesson2</h2><h3 id="分辨率适配"><a href="#分辨率适配" class="headerlink" title="分辨率适配"></a>分辨率适配</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%EF%BC%9AOnRenderImage%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84RT%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"
    >实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%EF%BC%9AOnRenderImage%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84RT%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2023-07-25T12:56:23.366Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>By Prin@UWA</p>
<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h3 id="windows查看nvidia显卡（GPU）的利用率和温度"><a href="#windows查看nvidia显卡（GPU）的利用率和温度" class="headerlink" title="windows查看nvidia显卡（GPU）的利用率和温度"></a>windows查看nvidia显卡（GPU）的利用率和温度</h3><p>对可执行程序nvidia-smi.exe直接调用就可以显示显卡相关信息：<br>GPU的名称、温度、显存占用情况、GPU利用率、正在工作的GPU进程</p>
<p>笔者的nvidia-smi.exe程序在C:\Windows\System32目录下。</p>
<h3 id="Android上查看程序占用内存大小"><a href="#Android上查看程序占用内存大小" class="headerlink" title="Android上查看程序占用内存大小"></a>Android上查看程序占用内存大小</h3><h4 id="adb-dumpsys-命令查看每个程序的内存信息"><a href="#adb-dumpsys-命令查看每个程序的内存信息" class="headerlink" title="adb dumpsys 命令查看每个程序的内存信息"></a>adb dumpsys 命令查看每个程序的内存信息</h4><p>以下命令查看程序的PID（app_name可以不全）</p>
<pre><code class="lang-csharp">
adb shell top | grep app_name
</code></pre>
<p>以下命令查看程序的内存使用情况</p>
<pre><code class="lang-csharp">
adb shell dumpsys meminfo &lt;package_name&gt;

adb shell dumpsys meminfo &lt;PID&gt;
</code></pre>
<p>Total 的 PSS 信息就是你的应用真正占据的内存大小</p>
<h4 id="查看整体内存信息"><a href="#查看整体内存信息" class="headerlink" title="查看整体内存信息"></a>查看整体内存信息</h4><pre><code class="lang-csharp">
adb shell cat /proc/meminfo
</code></pre>
<p>其他有用命令：</p>
<blockquote>
<ul>
<li><p>adb shell kill PIDNumber 死你想杀死的后台进程来模拟某种 bug 的复现条件。</p>
</li>
<li><p>adb shell ps 查看当前终端中的进程信息</p>
</li>
</ul>
</blockquote>
<h3 id="DontSave——保留对象到新场景"><a href="#DontSave——保留对象到新场景" class="headerlink" title="DontSave——保留对象到新场景"></a>DontSave——保留对象到新场景</h3><p>如果GameObject对象被HideFlags.DontSave标识，则在新scene中GameObject的所有组件将被保留下来</p>
<ol>
<li><p>其子类GameObject对象不会被保留到新scene中</p>
</li>
<li><p>不可以对GameObject对象的某个组件如Transform进行HideFlags.DontSave标识，否则无效。</p>
</li>
<li><p>即使程序已经退出，被HideFlags.DontSave标识的对象会一直存在于程序中，造成内存泄漏，对HideFlags.DontSave标识的对象在不需要或程序退出时需要使用DestroyImmediate手动销毁。</p>
</li>
</ol>
<p>Demo:</p>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

public class DontSave_ts : MonoBehaviour { 

public GameObject go; 

public Transform t; 

void Start()

{ 

//GameObject对象使用HideFlags.DontSave可以在新scene中被保留

go.hideFlags = HideFlags.DontSave; 

GameObject Pl = GameObject.CreatePrimitive(PrimitiveType.Plane); 

Pl.hideFlags = HideFlags.DontSave; 

//不可以对GameObject的组件设置HideFlags.DontSave，否则无效

Transform tf = Instantiate(t, go.transform.position + new Vector3(2.0f, 0.0f, 0.0f), Quaternion.identity) as Transform; 

tf.hideFlags = HideFlags.DontSave; 

//导入名为newScene_unity的新scene

Application.LoadLevel(&quot;newScene2_unity&quot;); 

} 

}
</code></pre>
<p>在场景2中：</p>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

public class NewScene2_ts : MonoBehaviour { 

GameObject cube, plane; 

void Start () { 

Debug.Log(&quot;这是NewScene2！&quot;); 

} 

//当程序退出时用DestroyImmediate()销毁被HideFlags.DontSave标识的对象

//否则即使程序已经退出，被HideFlags.DontSave标识的对象依然在Hierarchy面板中

//即每运行一次程序就会产生多余对象，造成内存泄漏

void OnApplicationQuit()

{ 

cube = GameObject.Find(&quot;Cube0&quot;); 

plane = GameObject.Find(&quot;Plane&quot;); 

if (cube) 

{ 

Debug.Log(&quot;Cube0 DestroyImmediate&quot;); 

DestroyImmediate(cube); 

} 

if (plane) 

{ 

Debug.Log(&quot;Plane DestroyImmediate&quot;); 

DestroyImmediate(plane); 

} 

} 

}
</code></pre>
<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>给场景添加以下脚本：</p>
<pre><code class="lang-csharp">
public class Test_OnRenderImage : MonoBehaviour

{ 

private void OnRenderImage(RenderTexture source, RenderTexture destination)

{ 

Graphics.Blit(source, destination); 

} 

}
</code></pre>
<p>Build后在安卓设备上运行，使用Profiler进行分析，会发现Detailed信息当中多了一张较大的RenderTexture：TempBuffer 1，如下图，其大小为60+MB：</p>
<p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/QQ截图20200921190054.png" alt="Alt text"></p>
<p>而在统计的（Used/Reserved）Unity内存和GfxDriver内存都低与60MB。</p>
<p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Simple.png" alt="Alt text"></p>
<p>也就是说，Unity Profiler并没有把这个RT占用的内存统计到Unity或GfxDriver当中。笔者比较好奇，这个RT是什么情况下才会生成？放在内存的哪一部分？为什么不会统计到Unity或GfxDriver当中？什么样的会统计到什么样的不会被统计到？于是做了如下实验。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>创建空场景，在任意物体上添加上文提到的 <code>Test_OnRenderImage</code> 脚本。</p>
<h3 id="PC平台上测试"><a href="#PC平台上测试" class="headerlink" title="PC平台上测试"></a>PC平台上测试</h3><p>首先在PC Standalone上进行测试。按照是否添加Test_OnRenderImage 脚本和屏幕分辨率的高低进行组合，分别导出4个包，运行时通过<code>nvidia-smi.exe</code>获取显存信息，通过UnityProfiler分析内存情况，实验结果如下（使用黄色填充标注发生变化的值）：</p>
<p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Test_PC.png" alt="Alt text"></p>
<p>（注：TSMU表示Total System Memory Usage）<br>结论：在屏幕上绘制需要把绘制的信息放在 <strong>TempBuffer</strong> 中，也就是一张RenderTexture当中。这张RT存储在 <strong>显存</strong> 当中，其 <strong>大小可以跟所绘制的分辨率有关</strong> ，分辨率越大，其占用空间越大。</p>
<p>在PC平台上，不论是否重写<code>OnRenderImage</code>函数，都会在显存当中存在一个TempBuffer，其占用空间不会被Profiler统计到Unity当中。会在Texture当中统计到，也可以在在Detailed当中找到。</p>
<blockquote>
<p><strong>官方对Profiler的介绍</strong> ：The values in the Profiler are different to those displayed in your operating system’s task manager, because the Memory Profiler does not track all memory usage in your system. This includes memory some drivers and plug-ins use, and memory used for executable code. On platforms that support getting the total memory size of the application from the operating system, the <strong>Total System Memory Usage</strong> is over 0 and is <strong>the same size in a task manager.</strong></p>
</blockquote>
<h3 id="Android平台测试"><a href="#Android平台测试" class="headerlink" title="Android平台测试"></a>Android平台测试</h3><p>在PC平台上的测试已经可以说明TempBuffer的大小与分辨率之间的关系，在Android平台上主要测试OnRenderImage函数与该TempBuffer的存在与否以及与所占据的Android内存之间的关系：</p>
<p><img src="实验记录：OnRenderImage函数产生的RT及其内存占用与统计相关问题/Android.png" alt="Alt text"></p>
<p>（注：程序占用的Android总内存通过命令<code>adb shell dumpsys meminfo &lt;PID&gt;</code>得到。）</p>
<p>结论：通过OnRenderImage函数调用Blit，会在Android设备中产生一张额外的RT（TempBuffer），占用一定的内存，其大小取决于屏幕分辨率。若不调用OnRenderImage函数，就不会生成该RT，不会占据额外内存。</p>
<blockquote>
<p>另外，笔者通过另一个实验证明，若只写OnRenderImage函数，函数体为空，不写Blit，也会生成RT：TempBuffer。只是由于RenderTexture destination为空，屏幕显示黑屏。</p>
<p>OnRenderImage的实现原理可参考：<a href="https://gameinstitute.qq.com/community/detail/112744" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/112744</a></p>
</blockquote>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/29005381" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29005381</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-优化知识点链接收藏"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/"
    >优化知识点链接收藏</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/" class="article-date">
  <time datetime="2023-07-25T12:56:23.365Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Mesh压缩：<a href="https://www.cnblogs.com/murongxiaopifu/p/10447076.html" target="_blank" rel="noopener">https://www.cnblogs.com/murongxiaopifu/p/10447076.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-关于脚本的生命周期、函数的执行顺序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"
    >关于脚本的生命周期、函数的执行顺序</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="article-date">
  <time datetime="2023-07-25T12:56:23.365Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Editor和Engine脚本的执行顺序"><a href="#Editor和Engine脚本的执行顺序" class="headerlink" title="Editor和Engine脚本的执行顺序"></a>Editor和Engine脚本的执行顺序</h2><p>在Editor中，非PlayMode下，编辑器执行函数会在一帧里面跑。<br>进入PlayMode时，会Reload程序集（Assemblies），Reset脚本（Scripts），没有明确的回调函数可以注册，使Editor脚本中函数可以在刚进入PlayMode的时候调用。</p>
<p>脚本使用<code>[InitializeOnLoad]</code>属性，可以使脚本可以在刚进入PlayMode的时候初始化（调用静态构造函数）。而这个初始化的时机处在开始进入PlayMode和真正开始Play之前，此时</p>
<ul>
<li><p>EditorApplication.isPlaying 为 false</p>
</li>
<li><p>EditorApplication.isPlayingOrWillChangePlaymode 为 true</p>
</li>
<li><p>Unity已经完成了程序集的Reload和脚本的Reset</p>
</li>
</ul>
<p>在此时实例化物体，Unity会报错：Some objects were not cleaned up when closing the scene. (Did you spawn new GameObjects from OnDestroy?)。<br>这个时候实例化的物体加不到Hierarchy当中，但是会加载到内存当中，显示在Scene当中，Unity会判断内存当中有一块儿不属于当前场景的Object。 判断的结果类似于内存泄漏。</p>
<p>因此，解决方法是，在Static 实例化方法中，使用<code>EditorApplication.update += Update</code>给编辑器程序的Update注册函数，想要执行的逻辑在Update当中执行，也就是在下一帧（完全进入Play Mode）时执行。<br>静态初始化函数调用后到PlayMode第一次Update的时间段中，bu’y’h</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="lang-csharp">

</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-出错汇总"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E5%87%BA%E9%94%99%E6%B1%87%E6%80%BB/"
    >出错汇总</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E5%87%BA%E9%94%99%E6%B1%87%E6%80%BB/" class="article-date">
  <time datetime="2023-07-25T12:56:23.365Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>csharp //transform.position.x = 1.0;//position 是transform的属性，不是成员变量 var pos = transform.position; pos.x = 1.0f; transform.poition = pos;</code> </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-一些属性"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/"
    >一些属性</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/" class="article-date">
  <time datetime="2023-07-25T12:56:23.357Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="InitializeOnLoad"><a href="#InitializeOnLoad" class="headerlink" title="InitializeOnLoad"></a>InitializeOnLoad</h2><p>InitializeOnLoad 属性应用的对象是 <strong>静态构造函数</strong> ，它可以保证在 <strong>编辑器启动</strong> 的时候调用此函数。调用静态构造函数，就会 <strong>重新初始化静态变量</strong> 。</p>
<p>标注了该属性的类需要 <strong>static constructor</strong> ！</p>
<pre><code class="lang-csharp">
using UnityEngine; 

using UnityEditor; 

[InitializeOnLoad] 

public class Startup { 

static Startup()

{ 

Debug.Log(&quot;Up and running&quot;); 

} 

}
</code></pre>
<p>此外，每次 <strong>重新编译后</strong> ，以及每次 <strong>对Game进行Play时</strong> ，会调用对象的静态构造函数。</p>
<p>即：对于定义了该属性的静态类，只要编辑器在启动状态，就会立即调用该类的静态构造函数。 若一个类刚刚写好，刚刚编译好，也会立即调用qi</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-【转载】RenderTexture及其用途"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91RenderTexture%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94/"
    >【转载】RenderTexture及其用途</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91RenderTexture%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94/" class="article-date">
  <time datetime="2023-07-25T12:56:23.357Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <pre><code>* 转自：https://www.jianshu.com/p/fa73c0f6762d
</code></pre><h2 id="什么是RenderTexture"><a href="#什么是RenderTexture" class="headerlink" title="什么是RenderTexture?"></a>什么是RenderTexture?</h2><p>RenderTexture是unity定义的一种特殊的Texture类型,它是连接着一个FrameBufferObject的存在于GPU端的Texture(Server-Side Texture),从上面对RenderTexture的解释我们了解到要先知道Texture和FrameBufferObject是什么</p>
<h2 id="从Texture到FrameBuffer"><a href="#从Texture到FrameBuffer" class="headerlink" title="从Texture到FrameBuffer"></a>从Texture到FrameBuffer</h2><p>纹理是如何被渲染到屏幕上的 ,起初纹理存在硬盘(RAM)里,它被cpu解压缩(数据在cpu端它就只是二进制数据),如果想要显示它,那么数据将会被发送给(上传到,cpu和gpu之间的通信可以理解成client和server之间的通信)GPU,gpu将它放在显存(VARM)中,显存中有一块内存区域叫做RenderBuffer(渲染缓存),RenderBuffer只是数据缓存,它还不能用作Texture渲染,尽管它现在已经是一个texture了,在这里 texture等待着被渲染,当要渲染这个Texture时,会生成一个FrameBuffer(帧缓存),当这个帧缓存被添加到默认的帧缓存物体上(FrameBufferObject)时,它就会被绘制到屏幕上.FrameBuffer指向的是显存中RenderBuffer的地址,简单的来说,RenderBuffer需要附加在FrameBuffer上,它才能是五颜六色的图片,否则它只是显存上的一堆数据,</p>
<h2 id="FrameBufferObject"><a href="#FrameBufferObject" class="headerlink" title="FrameBufferObject"></a>FrameBufferObject</h2><p>FrameBufferObject是一个集合,集合了FrameBuffer,通过快速刷新Framebuffer实现动态效果,最典型的FBO就是Unity的Main Camera,它是默认的FBO,是gpu里渲染结果的目的地.但是现代gpu通常可以创建很多其他的FBO(Unity中可以创建多个Camera)，这些FBO不连接窗口区域，这种我们创建的FBO的存在目的就是允许我们将渲染结果保存在gpu的一块存储区域，待之后使用,这种用法叫做离屏渲染，这是一个非常有用的东西。Camera 输出的FBO,可以嵌在另一个FBO中,Unity中使用RenderTexture来接收FBO(可视化FBO),Game窗口是一个特殊的RenderTexture,它允许多个FBO叠加渲染,当Camera的RenderTarget都设置为null时表示输出到game窗口(没有摄像机的RenderTaget为null会显示没有摄像机进行渲染),设置不为null表示输出到某个RT.</p>
<h2 id="如何使用FrameBufferObject"><a href="#如何使用FrameBufferObject" class="headerlink" title="如何使用FrameBufferObject?"></a>如何使用FrameBufferObject?</h2><p>1.将这个FBO上的结果传回CPU这边的贴图，在gles中的实现一般是ReadPixels（）这样的函数，这个函数是将当前设为可读的FBO拷贝到cpu这边的一个存储buffer，没错如果当前设为可读的FBO是那个默认FBO，那这个函数就是在截屏，如果是你自己创建的FBO，那就把刚刚绘制到上面的结果从gpu存储拿回内存。</p>
<ol>
<li>将这个FBO上的结果拷贝到一个gpu上的texture，在gles中的实现一般是CopyTexImage2D（），它一般是将可读的FBO的一部分拷贝到存在于gpu上的一个texture对象中，直接考到server-sider就意味着可以马上被gpu渲染使用</li>
</ol>
<p>3.将这个fbo直接关联一个gpu上的texture对象，这样就等于在绘制时就直接绘制到这个texure上，这样也省去了拷贝时间，gles中一般是使用FramebufferTexture2D（）这样的接口。</p>
<h2 id="unity是如何使用FBO的"><a href="#unity是如何使用FBO的" class="headerlink" title="unity是如何使用FBO的?"></a>unity是如何使用FBO的?</h2><p>Unity通过上面说的第三个方法将FBO输出到RenderTexture,在unity里要使用这个FBO,只能基于这个RenderTexture(目前我知道的是这样,可能有我不知道的用法).</p>
<p>在Unity固定渲染管线中(Unity2019.3以后 自定义渲染管线脱离预览版,新的通用渲染管线Camera设置发生了改变,如果依然使用固定渲染管线则以下通用),通过Camera组件来使用FBO,多摄像机使用下,根据ClearFlags来决定渲染内容:</p>
<p>需要强调的是Clear操作, 多Camera下,DepthOnly 和Don’t Clear实际上都使Clear操作失效了 ,</p>
<h2 id="RenderTexture的用途"><a href="#RenderTexture的用途" class="headerlink" title="RenderTexture的用途?"></a>RenderTexture的用途?</h2><p>1.屏幕后处理,3d游戏最基本的后处理是抗锯齿,从Unity的FrameDebugger(可以看到所有FrameBuffer,不管它们属于哪个FBO)中可以看到抗锯齿的操作在OverlayUI之前,所以各位做2d游戏的可以选择把抗锯齿关掉,其他的后处理如bloom,HDR等都是操作屏幕这个默认的RenderTexture,配合上相关效果的Material </p>
<p>2.在Scene中直接将RT作为Texture传给其他材质球,操作是调用Material.SetTexture 为该RT,即可实现在另一个表面渲染另一个Camera的内容.可以制作后视镜功能</p>
<p>3.copy回cpu端的内存:基本操作是在当前帧渲染完毕后(协程中, yield return new WaitForEndOfFrame()),设置RenderTexture.active为目标RenderTexture(因为当前帧已渲染过,所以该RenderTexture不会被渲染).Texture.ReadPixels保存到显存.Texture.GetRawTextureData()读回cpu内存,可以保存到硬盘或者通过互联网通信(在unity中实现的截屏,录屏,实时共享屏幕).</p>
<p>以上2,3都属于离屏渲染的应用.</p>
<h2 id="转自：https-www-jianshu-com-p-fa73c0f6762d"><a href="#转自：https-www-jianshu-com-p-fa73c0f6762d" class="headerlink" title="转自：https://www.jianshu.com/p/fa73c0f6762d"></a>转自：<a href="https://www.jianshu.com/p/fa73c0f6762d" target="_blank" rel="noopener">https://www.jianshu.com/p/fa73c0f6762d</a></h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/3/">3</a><a class="page-number" href="/archives/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/archives/6/">6</a><a class="page-number" href="/archives/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/6/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>