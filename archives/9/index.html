<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="img/header_img/home-bg-1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">半个出家人</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['The world isn&#39;t split into good people and Death Eaters. We&#39;ve all got both light and dark inside us. What matters is the part we choose to act on. That&#39;s who we really are.', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 80,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://www.vultr.com/?ref=8630075" target="_blank" rel="noopener">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Unity3D-Skinned-Mesh-Renderer"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Skinned-Mesh-Renderer/"
    >Skinned Mesh Renderer</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Skinned-Mesh-Renderer/" class="article-date">
  <time datetime="2023-07-25T12:56:23.270Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Motion-Vector"><a href="#Motion-Vector" class="headerlink" title="Motion Vector"></a>Motion Vector</h2><p><img src="assets/Skinned%20Mesh%20Renderer/1606707414304.png" alt="Alt text"></p>
<p>Motion vectors provide you with a texture with two channels that calculate the positional difference objects render in camera space between this frame and the previous frame.</p>
<blockquote>
<p>In video compression, a motion vector is the key element in the motion estimation process. It is used to represent a macroblock in a picture based on the position of this macroblock (or a similar one) in another picture, called the reference picture. — Wikipedia<br> In video editing motion vectors are used to compress video by storing the changes to an image from one frame to the next. — <a href="https://www.webopedia.com/TERM/M/motion_vector.html" target="_blank" rel="noopener">webopedia</a></p>
</blockquote>
<h3 id="算法的关键点"><a href="#算法的关键点" class="headerlink" title="算法的关键点"></a>算法的关键点</h3><p>In fact all of these terms refer to the process of finding corresponding points between two images or video frames. The points that correspond to each other in two views (images or frames) of a real scene or object are “usually” the same point in that scene or on that object. Before we do motion estimation, we must define our measurement of correspondence, i.e., the matching metric, which is a measurement of how similar two image points are. There is no right or wrong here; the choice of matching metric is usually related to what the final estimated motion is used for as well as the optimisation strategy in the estimation process.</p>
<h3 id="Unity中的Mesh-Renderer-Motion-Vectors"><a href="#Unity中的Mesh-Renderer-Motion-Vectors" class="headerlink" title="Unity中的Mesh Renderer Motion Vectors"></a>Unity中的Mesh Renderer Motion Vectors</h3><p><strong>Motion vectors</strong> track the per-pixel object velocity from one frame to the next in screen space. 描述当前像素下的片元，在相邻两帧之间，屏幕空间位置的差。</p>
<p>实现原理与兼容性 - When set, the camera renders another pass (after opaque but before Image Effects): First, a full screen pass is rendered to reconstruct screen-space motion from the camera movement, then, any moving objects have a custom <strong>pass</strong> to render their object-specific motion. The <strong>buffer</strong> uses the RenderTextureFormat.RGHalf format, so this feature only works on platforms where this format is supported.</p>
<p><strong>Velocity Buffer</strong> - 是一个全屏尺寸的 RenderTexture，motion vector 组成的Buffer。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li><p>Use this velocity to reconstruct previous positions.</p>
</li>
<li><p>Using this information you can apply specific Image Effects such as <strong>motion blur</strong> or <strong>temporal anti-aliasing</strong>.</p>
</li>
</ul>
<h4 id="skinned-motion-vectors"><a href="#skinned-motion-vectors" class="headerlink" title="skinned motion vectors"></a>skinned motion vectors</h4><p>There is a cost to skinned motion vectors, though; they require twice as much memory per skinned mesh because the graphics memory on the GPU becomes double buffered (one buffer for the current frame and one buffer for the previous frame). The buffers track motion between frames; the velocity is the current frame’s position minus the last frame’s position.</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>使用Motion Vector实现相关的后处理特效:<br>相机上的脚本: </p>
<pre><code class="lang-csharp">
using UnityEngine; 

[ExecuteInEditMode] 

[RequireComponent(typeof(Camera))] 

public class DatamoshEffect : MonoBehaviour { 

public Material DMmat; //datamosh material

void Start () { 

this.GetComponent().depthTextureMode=DepthTextureMode.MotionVectors; 

//generate the motion vector texture @ &#39;_CameraMotionVectorsTexture&#39;

} 

private void OnRenderImage(RenderTexture src, RenderTexture dest)

{ 

Graphics.Blit(src,dest,DMmat); 

} 

} 

``` ```csharp 

sampler2D _MainTex; 

sampler2D _CameraMotionVectorsTexture; 

fixed4 frag (v2f i) : SV_Target 

{ 

fixed4 col = tex2D(_MainTex, i.uv); 

float4 mot = tex2D(_CameraMotionVectorsTexture,i.uv); 

col+=mot;//add motion vector values to the current colors

return col; 

} 

``` ```csharp 

fixed4 frag (v2f i) : SV_Target 

{ 

float4 mot = tex2D(_CameraMotionVectorsTexture,i.uv); 

//add motion vectors directly to UV position for sampling color

fixed4 col = tex2D(_MainTex, i.uv+mot.rg); 

return col; 

}
</code></pre>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://gitee.com/xianglinlove/Avatar" target="_blank" rel="noopener">https://gitee.com/xianglinlove/Avatar</a><br><a href="https://zhuanlan.zhihu.com/p/41763382" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41763382</a><br><a href="https://github.com/xieliujian/UnityDemo_Avatar" target="_blank" rel="noopener">https://github.com/xieliujian/UnityDemo_Avatar</a><br><a href="https://blog.uwa4d.com/archives/avartar.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/avartar.html</a><br><a href="https://github.com/zouchunyi/UnityAvater" target="_blank" rel="noopener">https://github.com/zouchunyi/UnityAvater</a></p>
<h2 id="优秀的相关资料"><a href="#优秀的相关资料" class="headerlink" title="优秀的相关资料"></a>优秀的相关资料</h2><p>在 Unity SRP 实现 Temporal Anti-aliasing: <a href="https://zhuanlan.zhihu.com/p/138866533" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138866533</a></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/Motion_vector" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Motion_vector</a><br><a href="https://ompuco.wordpress.com/2018/03/29/creating-your-own-datamosh-effect/" target="_blank" rel="noopener">https://ompuco.wordpress.com/2018/03/29/creating-your-own-datamosh-effect/</a><br><a href="https://www.webopedia.com/TERM/M/motion_vector.html" target="_blank" rel="noopener">https://www.webopedia.com/TERM/M/motion_vector.html</a><br><a href="https://zhuanlan.zhihu.com/p/138866533" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138866533</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Shader变体相关知识与优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Shader%E5%8F%98%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%B8%8E%E4%BC%98%E5%8C%96/"
    >Shader变体相关知识与优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Shader%E5%8F%98%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%B8%8E%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2023-07-25T12:56:23.266Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>标签：</strong>|  <em>优化</em>  </p>
<p>By Prin@UWA on 2020/8/17</p>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h2><h3 id="1-1-Shader相关一些概念"><a href="#1-1-Shader相关一些概念" class="headerlink" title="1.1 Shader相关一些概念"></a>1.1 Shader相关一些概念</h3><ul>
<li><p>着色器资源（Shader asset）: The full file source code with properties（属性）, sub-shader（子着色器）, passes（通道）, and HLSL（HLSL代码）.</p>
</li>
<li><p>着色器片段（Shader snippet）: The HLSL input code with dependencies for a single shader stage.(这个概念定义的不清楚)</p>
</li>
<li><p>着色器阶段（Shader stage）: A specific stage in the GPU rendering pipeline, typically a vertex shader stage and a fragment shader stage.</p>
</li>
<li><p>着色器关键字（Shader keyword）: A preprocessor identifier for compile-time branches across shaders.</p>
</li>
<li><p>着色器关键字集（Shader keyword set）: A specific set of shader keywords identifying a particular code path.</p>
</li>
<li><p>着色器变体（Shader variant）: The platform-specific shader code generated by the Unity shader compiler, for a single shader stage for a specific graphics tier, pass, shader keyword set, etc.</p>
</li>
<li><p>超着色器（Uber shader）: A shader source that can produce many shader variants.</p>
</li>
</ul>
<h4 id="Shader-snippet"><a href="#Shader-snippet" class="headerlink" title="Shader snippet"></a>Shader snippet</h4><p>对于snippet的概念，Unity官方的定义有点ambiguous。对此本文做了细致的研究。</p>
<h5 id="在Unity-Documentation中"><a href="#在Unity-Documentation中" class="headerlink" title="在Unity Documentation中"></a>在Unity Documentation中</h5><blockquote>
<p>Shader code is written by embedding “Cg/HLSL snippets” in the shader text. Snippets are compiled into low-level shader assembly by the Unity editor, and the final shader that is included in your game’s data files only contains this low-level assembly or bytecode, that is platform specific. </p>
<p>HLSL program snippets are written between CGPROGRAM and ENDCG keywords, or alternatively between HLSLPROGRAM and ENDHLSL.</p>
<p>Each snippet must contain at least a vertex program and a fragment program, so #pragma vertex and #pragma fragment directives are required.（<a href="https://docs.unity3d.com/Manual/SL-ShaderPrograms.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/SL-ShaderPrograms.html</a>）</p>
</blockquote>
<p>Shader Snippet就是CGPROGRAM/HLSLPROGRAM 和 ENDCG/ENDHLSL之间的程序片段<br>一个Snippet包含vertex shader和fragment shader 两个阶段（stage）</p>
<h5 id="在Shader-Build-Pipeline中"><a href="#在Shader-Build-Pipeline中" class="headerlink" title="在Shader Build Pipeline中"></a>在Shader Build Pipeline中</h5><p>在Shader编译管线中，一个Snippet对应的是一个单独的Stage。一个pass中，CGPROGRAM和ENDCG之间的部分包含两个snippets，分别是vertex snippet和fragment snippet。<br>对于包含两个stages（snippets）的pass，若关键字组合数为n，则一个snippet生成n个变体，一个pass生成2n个变体。</p>
<p>查看相关API的源码可以验证此结论:</p>
<p><img src="Shader变体相关知识与优化/ShaderSnippetData.png" alt="ShaderSnippetData"></p>
<p><img src="Shader变体相关知识与优化/ShaderType.png" alt="ShaderType"></p>
<p>Snippet类包含ShaderType属性，确定一个snippet是哪个stage的shader（Vertex、Fragment等）</p>
<h4 id="Shader-Variant"><a href="#Shader-Variant" class="headerlink" title="Shader Variant"></a>Shader Variant</h4><p>开发人员在写shader时，往往会在shader片段(Snippet)中定义一些关键字(Keyword)，并在代码中根据关键字开启与否控制物体的渲染过程，这样同一份shader源码可以具备多种不同的功能。最终编译的时候，引擎会根据不同的关键字组合生成多份shader程序(Program)。其中每一种组合对应的程序就是这个shader的一个变体(Variant)。</p>
<p>根据关键字产生shader变体的主要意义有：</p>
<ul>
<li>GPU不擅长处理分支语句（if-else），通过变体可避免分支语句导致的性能下降</li>
</ul>
<blockquote>
<p>GPU使用了不同于CPU的技术来实现分支语句。最坏的情况下，运行一个分支语句的时间相当于运行了所有分支语句的时间。如果在Shader中使用了大量的流程控制语句，那么这个Shader的性能可能会成倍下降。 ——《Unity Shader入门精要》</p>
</blockquote>
<ul>
<li>游戏运行时可在代码中选择shader变体，动态改变着色器功能</li>
</ul>
<p>Unity在打包时会把所有multi_compile产生的shader变体都打进包中</p>
<blockquote>
<p>对所有的宏的值的组合情况都生成一份Shader的变体，这样在使用的时候直接匹配，避免在Shader代码中使用if-else判断语句。if-else在GPU的并行处理中会表现出低效的性能，因为它会把所有的if走一遍(根据条件决定是否真的运行)，再把所有的else走一遍。</p>
</blockquote>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre><code class="lang-csharp">
Shader &quot;MyShaderName&quot;

{ 

Properties 

{ 

// material properties here

} 

SubShader // subshader for graphics hardware A

{ 

Pass 

{ 

// pass commands ...

} 

// more passes if needed

} 

// more subshaders if needed

FallBack &quot;VertexLit&quot; // optional fallback

} 

``` ```csharp 

Pass { 

// ... the usual pass state setup ...

CGPROGRAM 

// compilation directives for this snippet, e.g.:

#pragma vertex vert

#pragma fragment frag

// the Cg/HLSL code itself

ENDCG 

// ... the rest of pass setup ...

} 

``` ```csharp 

Shader &quot;Tutorial/Display Normals&quot; { 

SubShader { 

Pass { 

CGPROGRAM 

#pragma vertex vert

#pragma fragment frag

#include &quot;UnityCG.cginc&quot;

struct v2f { 

float4 pos : SV_POSITION; 

fixed3 color : COLOR0; 

}; 

v2f vert (appdata_base v)

{ 

v2f o; 

o.pos = UnityObjectToClipPos(v.vertex); 

o.color = v.normal * 0.5 \+ 0.5; 

return o; 

} 

fixed4 frag (v2f i) : SV_Target

{ 

return fixed4 (i.color, 1); 

} 

ENDCG 

} 

} 

}
</code></pre>
<h3 id="1-2-compile-directives（编译指令）及变体的生成规则"><a href="#1-2-compile-directives（编译指令）及变体的生成规则" class="headerlink" title="1.2 compile directives（编译指令）及变体的生成规则"></a>1.2 compile directives（编译指令）及变体的生成规则</h3><p>At the start of the snippet, compilation directives can be given as #pragma statements. </p>
<p>shader_feature更适用于材质的关键字，而multi_compile更适用于代码设置的全局关键字</p>
<h4 id="multi-compile"><a href="#multi-compile" class="headerlink" title="multi_compile"></a>multi_compile</h4><p>multi_compile会默认生成所有的变体，因此应当谨慎适用multi_compile，否则将会导致变体数量激增。</p>
<pre><code class="lang-csharp">
#pragma multi_compile TEST_A TEST_B TEST_C 

#pragma multi_compile TEST_D TEST_E
</code></pre>
<p><img src="Shader变体相关知识与优化/QQ截图20200806171125.png" alt="Alt text"></p>
<pre><code class="lang-csharp">
#pragma multi_compile __ TEST_ON
</code></pre>
<p>This directive produces two shader variants: one with nothing defined (__), and one with TEST_ON defined.<br>节省一个变量个数的占用（Unity中关键字有个数限制）<br>如： </p>
<h4 id="shader-feature"><a href="#shader-feature" class="headerlink" title="shader_feature"></a>shader_feature</h4><pre><code class="lang-csharp">
#pragma shader_feature KW1 KW2 

``` ```csharp 

#pragma shader_feature KW_X 

#pragma shader_feature __ KW_X
</code></pre>
<p>shader_feature is very similar to multi_compile. The only difference is that Unity does not include unused variants of shader_feature shaders in the final build.<br>只生成对应的Material上关键字对应的变体。</p>
<ol>
<li><p>预编译语句会默认生成开启第一个关键字的变体</p>
</li>
<li><p>shader<em>feature 预编译语句行至少有两个关键字。如果只定义了一个关键字SF_A，则会默认生成一个下划线关键字” </em>“，默认SF<em>A不开启，生成一份开启关键字”</em> “的变体。如果SF<em>A开启，则会生成分别开启”</em>”和”SF_A”的两份变体</p>
</li>
<li><p>shader_feature 预编译语句行，如果定义了两个关键字”SF_C”和”SF_D”，则不生成下划线关键字。默认第一个关键字 “SF_C” 开启，生成一份变体。如果某个材质开启了”SF_D”，但没有材质开启”SF_C”，依然认为两个关键字都被使用到，生成两份变体。</p>
</li>
<li><p>如果同一个Material开启了同一个shader_feature行的两个关键字”SF_C”和”SF_D”，则认为开启无效，只按照默认情况生成一份变体（SF_C开启的变体）.</p>
</li>
</ol>
<p>我们来看以下案例：<br>Material-M使用原先使用的Shader为Shader-A，其上包含Shader-A中定义的关键字KW1、KW2，如果Material-M的Shader换成了Shader-B，且场景中没有其他Material使用Shader-A，那么，虽然Material-M上还记录了Shader-A中的关键字KW1和KW2，但是并不会对Shader-A生成的变体造成影响，Shader-A不会生成两份变体。<br>即：Unity只会按照Shader实际对应的材质的关键字生成变体，没有使用Shader-A的材质Material-M上的关键字不会影响Shader-A的变体的生成。</p>
<h4 id="Unity内置变体"><a href="#Unity内置变体" class="headerlink" title="Unity内置变体"></a>Unity内置变体</h4><p>multi_compile_fwdbase<br>multi_compile_fwdadd<br>multi_compile_fwdadd_fullshadows<br>multi_compile_fog </p>
<p>Most of the built-in shortcuts produce many shader variants. if you know the project doesn’t need them, you can use #pragma skip_variants to skip compiling some of them.</p>
<pre><code class="lang-csharp">
#pragma multi_compile_fwdadd 

#pragma skip_variants POINT POINT_COOKIE
</code></pre>
<h4 id="local-keyword-vs-global-keyword"><a href="#local-keyword-vs-global-keyword" class="headerlink" title="local keyword vs global keyword"></a>local keyword vs global keyword</h4><p>The main disadvantage of shader_feature and multi_compile is that all keywords defined in them contribute towards Unity’s global keyword count limit (256 global keywords, plus 64 local keywords). </p>
<p>The total number of local and global keywords per shader affects performance: in an ideal set-up, use more local keywords and fewer global keywords, to reduce the total keyword count per shader.</p>
<p>local keyword有助于提高项目的性能，同时也可以减少每个shader中keyword数量。</p>
<p>留坑: 这里笔者还存在两点疑惑</p>
<ol>
<li><p>local keyword 和 global keyword的区别在哪里</p>
</li>
<li><p>If a Material has a local keyword enabled, and its shader changes to one that is no longer declared, Unity creates a new global keyword. 这句话实际是什么意思，它描述的问题笔者没有复现。</p>
</li>
</ol>
<h3 id="1-3-Material-ShaderKeywords启用禁用宏"><a href="#1-3-Material-ShaderKeywords启用禁用宏" class="headerlink" title="1.3 Material ShaderKeywords启用禁用宏"></a>1.3 Material ShaderKeywords启用禁用宏</h3><p>Material所包含的Shader Keywords表示启用shader中对应的宏，Unity会调用当前宏组合所对应的变体来为Material进行渲染。</p>
<p>在Editor下，可以通过将material的inspector调成Debug模式来查看当前material定义的Keywords，也可在此模式下直接定义Keywords，用空格分隔Keyword。<br>在程序中，可用Material.EnableKeyword()、Material.DisableKeyword()、Shader.EnableKeyword()、Shader.DisableKeyword()来启用/禁用相应的宏。</p>
<h3 id="1-4-变体数量"><a href="#1-4-变体数量" class="headerlink" title="1.4 变体数量"></a>1.4 变体数量</h3><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><p><img src="Shader变体相关知识与优化/image7.png" alt="Alt text"></p>
<blockquote>
<p>For each supported graphics API in the project, we need a dedicated set of shader variants. (每个支持的graphics API都需要一套专用的变体集。)Shader data size are directly proportional to the number of supported graphics APIs.</p>
</blockquote>
<h4 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h4><p>在Shader的inspector面板中可以看到Shader的Compiled Code选项，点开后可以看到Shader Variants数量</p>
<h3 id="1-6-Shader-build-pipeline"><a href="#1-6-Shader-build-pipeline" class="headerlink" title="1.6 Shader build pipeline"></a>1.6 Shader build pipeline</h3><p>The shader compilation pipeline in Unity is a black box where each shader in the project is parsed to extract shader snippets before collecting the variant preprocessing instructions, such as multi_compile and shader_feature. This produces a list of compilation parameters, one per shader variant.</p>
<p><img src="Shader变体相关知识与优化/ShaderBuildPipeline.png" alt="Shader Build Pipeline"></p>
<h4 id="Build时，哪些变体会被编译打包？"><a href="#Build时，哪些变体会被编译打包？" class="headerlink" title="Build时，哪些变体会被编译打包？"></a>Build时，哪些变体会被编译打包？</h4><ol>
<li><p>Scenes In Build里面的场景引用到的Shader</p>
</li>
<li><p>Project Settings -&gt; Graphics -&gt; Always Include Shaders中的shader</p>
</li>
<li><p>任意位置的名为Resources的文件夹下的shaders</p>
</li>
<li><p>以上被编译的Shader脚本当中的fallback用到的shaders</p>
</li>
</ol>
<h4 id="自动Shader变体去除"><a href="#自动Shader变体去除" class="headerlink" title="自动Shader变体去除"></a>自动Shader变体去除</h4><p>Unity executes an <strong>automatic shader variant</strong> stripping pass based on two heuristics(启发式方法). </p>
<ul>
<li>Project Settings</li>
</ul>
<blockquote>
<p>例如：如果虚拟现实支持（Virtual Reality Supported）被禁用，则VR着色器变体会被系统地移除掉。</p>
</blockquote>
<ul>
<li>configuration of Shader Stripping section of the Graphics Settings</li>
</ul>
<p>下面这个着色器变体列表，里面的已启用关键字都被自动移除：</p>
<blockquote>
<p>Lightmap modes: LIGHTMAP_ON, DIRLIGHTMAP_COMBINED, DYNAMICLIGHTMAP_ON, LIGHTMAP_SHADOW_MIXING, SHADOWS_SHADOWMASK<br> Fog modes: FOG_LINEAR, FOG_EXP, FOG_EXP2<br> Instancing Variants: INSTANCING_ON</p>
</blockquote>
<p>当虚拟现实支持被禁用时，带有下列内置关键字的着色器变体都会被移除：</p>
<blockquote>
<p>STEREO_INSTANCING_ON, STEREO_MULTIVIEW_ON, STEREO_CUBEMAP_RENDER_ON, UNITY_SINGLE_PASS_STEREO</p>
</blockquote>
<p>当自动移除过程完成后，着色器构建管线会使用剩余编译参数集来安排并行着色器变体编译顺序，并根据平台所拥有的CPU核心线程尽可能多地启动多个同时编译过程。</p>
<h4 id="奇怪的现象——多生成一份Vertex-Shader"><a href="#奇怪的现象——多生成一份Vertex-Shader" class="headerlink" title="奇怪的现象——多生成一份Vertex Shader"></a>奇怪的现象——多生成一份Vertex Shader</h4><p>在Build时，使用OnProcessShader对编译过程生成的变体进行输出，会发现每个Shader都会对Vertex Shader多生成一次 ，如下图，TestShader1只有一份变体。</p>
<p><img src="Shader变体相关知识与优化/QQ截图20201014203947.png" alt="Alt text"></p>
<p>观察编译过程，发现在Building Resources folder时先生成一份Vertex Shader，然后在编译结束后，会生成完整的Shader变体。那么整个编译过程是怎样的呢？为什么会预先生成一份vertex shader？笔者想对Build过程进行探索如下。<br>Building Player显示的编译过程如下：</p>
<ol>
<li><p>Build Player</p>
</li>
<li><p>Buiding scene 0: SampleScene</p>
</li>
<li><p>Material1 - Custom/TestShader2 - Pass 0: Stripping Vertex programs</p>
</li>
<li><p>Building Resources folder</p>
</li>
<li><p>Packaging assets - globalgamemanagers.assets</p>
</li>
<li><p>Standard - FORWARD: Stripping Vertex programs</p>
</li>
<li><p>Skybox/Procedural - Pass 0: Stripping Vertex programs</p>
</li>
<li><p>Legacy Shaders/Diffuse - FORWARD: Stripping Fragment programs</p>
</li>
<li><p>Hidding/Internal-DefferedShading - Pass 0: 1 of 26 vp</p>
</li>
<li><p>Hidden/Internal-ODSWorldTexture - Pass 0: Stripping Vertex programs</p>
</li>
<li><p>Postprocessing Player</p>
</li>
<li><p>Copying files to final destination</p>
</li>
<li><p>Done</p>
</li>
</ol>
<p>就目前得信息来看，可能在Shader变体的预处理阶段会首先生成一份Vertex Shader。</p>
<h3 id="1-7-Shader的build及加载过程"><a href="#1-7-Shader的build及加载过程" class="headerlink" title="1.7 Shader的build及加载过程"></a>1.7 Shader的build及加载过程</h3><h4 id="Editor中"><a href="#Editor中" class="headerlink" title="Editor中"></a>Editor中</h4><ul>
<li><p>At import time, only do minimal processing of the shader (surface shader generation etc.).</p>
</li>
<li><p>Actually compile the shader variants only when needed.</p>
</li>
<li><p>Instead of typical work of compiling 100–10000 internal shaders at import time, this usually ends up compiling just a handful.</p>
</li>
</ul>
<blockquote>
<p>Individual shader variant compilation results are cached in the project, under Library/ShaderCache folder. </p>
</blockquote>
<h4 id="Build时"><a href="#Build时" class="headerlink" title="Build时"></a>Build时</h4><p>每个shader生成哪些变体会决定好，shader生成对应的变体之后，打进包中。<br>All the “not yet compiled” shader variants are compiled, so that they are in the game data even if the editor did not happen to use them.</p>
<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>场景加载时，加载到的object对应的Shader都会加载进内存当中，加载之后就会进行解析(Shader.Parse)<br>实际进行渲染时，会将Shader写入GPU显存中(Shader.CreateGPUProgram)。</p>
<p>根据回答：<a href="https://answer.uwa4d.com/question/5ce5467ad1d3d045c846d769" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5ce5467ad1d3d045c846d769</a><br>Shader进行Parse的时候，会将一部分Shader写入GPU当中，此时生成的GPU程序片段不全，在渲染实际的物体时，一定会将用到的Shader编译结果写入GPU显存。</p>
<p>如果提前进行warmup，就可以提前将GPUProgram写入显存。</p>
<ul>
<li><p>在Unity 4.x中，调用Shader.WarmupAllShaders()，可以自动编译该场景中用到的所有shader。该方法在Unity5中已经废弃</p>
</li>
<li><p>没有使用5.x新的shader(Standard和StandardSpecular)，自定义shader也没有使用大量关键字等还是可以使用Shader::WarmupAllShaders</p>
</li>
<li><p>调用ShaderVariantCollection.WarmUp()函数手动进行预热，编译shader并写入显存</p>
</li>
<li><p>在ProjectSettings-&gt;Graphics中，设置PreloadedShaders，这样可以在加载场景时一并编译需要预加载的shader（是否会warmup不清楚）</p>
</li>
</ul>
<blockquote>
<p>ShaderLab在相关shader加入内存时就已经产生，但如果没有被渲染的话不会触发CreateGPUProgram操作，如果提前在ShaderVariantCollection中收集了相关变体并执行了warmup（预热）的话，第一次渲染时就不会再CreateGPUProgram，对卡顿会有一定好处。因此第一次加载shader先warmup一下，虽然等待的时间长但是仅此一次，当你退出游戏下次再进入也不会再执行warmup，可以有效避免渲染卡顿</p>
</blockquote>
<h2 id="2-面对的问题"><a href="#2-面对的问题" class="headerlink" title="2 面对的问题"></a>2 面对的问题</h2><p>Shaders are small programs that execute on the GPU, and loading them can take some time.<br>大量的Shader变体会造成以下两点问题：</p>
<ul>
<li><p>Build时， <strong>时间长，数据包体大</strong><br>Large numbers of these shader variants increase game build time, and game data size.</p>
</li>
<li><p>Rumtime时， <strong>占用内存高，加载耗时长（卡顿）</strong><br>Loading large numbers of shader variants at runtime is slow and takes up memory.</p>
</li>
</ul>
<p>我们希望 <strong>在保证渲染效果正确的情况下，尽可能地控制项目重shader变体数量，避免产生冗余资源</strong></p>
<h3 id="2-1-变体数与内存、显存的关系"><a href="#2-1-变体数与内存、显存的关系" class="headerlink" title="2.1 变体数与内存、显存的关系"></a>2.1 变体数与内存、显存的关系</h3><p><img src="Shader变体相关知识与优化/QQ截图20200807185651.png" alt="Alt text"></p>
<p>变体数和ShaderLab的内存占用基本成正比，而和GFX无关。说明没有参与渲染的Shader变体是不会经历CreateGPUProgram统计到GFX内存中的。</p>
<blockquote>
<p>一般来说shader片段中multi_compile类关键字每增加一个，或者启用的shader_feature类关键字增加一个，该Shader的变体数量就会x2，是以指数函数的方式增长的。</p>
</blockquote>
<h3 id="2-2-Shader变体的打包方式"><a href="#2-2-Shader变体的打包方式" class="headerlink" title="2.2 Shader变体的打包方式"></a>2.2 Shader变体的打包方式</h3><p>Shader与Material打在一个包中，变体根据material中的keywords自动生成</p>
<ul>
<li><p>多个不同的material包中可能存在相同的shader变体，造成资源冗余</p>
</li>
<li><p>若程序运行时动态改变material的keyword，使用shader_feature定义的宏，其 变体可能并没有被生成</p>
</li>
</ul>
<p>Shader单独打包，使用multi_compile定义的全部宏全部变体都被生成，不会发生需要的变体未生成的情况。</p>
<ul>
<li>生成的变体数量庞大，严重浪费资源</li>
</ul>
<p>Shader单独打包，shader_feature（需要使用ShaderVariantCollection生成变体）与multi_compile（还是生成所有变体）结合使用能够有效控制shader_feature变体数量。</p>
<ul>
<li>容易遗漏需要生成的变体，特别是需要动态替换的变体</li>
</ul>
<h3 id="2-3-Unity-Material关键字的坑"><a href="#2-3-Unity-Material关键字的坑" class="headerlink" title="2.3 Unity Material关键字的坑"></a>2.3 Unity Material关键字的坑</h3><p>实际打进包中的Shader变体数量和在Editor下预览的还是不一样的，实际打进包中的变体数量要多于Editor下预览的，并且发现了有很多隐藏的关键字，这些关键字其实根本没有显式的引用，但是却在打包的时候出现了，并且增加了Shader变体数量。</p>
<p>Unity关键字有个坑：<br>材质球里会记录之前使用的关键字，打个比方 ：Shader A 需要开启关键字 _AKW ，Shader B需要开启关键字 _BKW ，材质球 M 起初使用了Shader A ，开启了关键字_AKW，由于某个原因这个材质球不想使用Shader A 了，切换到Shader B，开启了_BKW，那么这个材质球就会包含_AKW 、_BKW 这两个关键字。</p>
<p>不过如果Shader B中如果没有定义_KWA，则残留的关键字_KWA不会对变体数造成影响。旧的关键字的残留对项目的影响在实际研发中进一步考证。</p>
<h2 id="3-工具与方案"><a href="#3-工具与方案" class="headerlink" title="3 工具与方案"></a>3 工具与方案</h2><h3 id="3-1-Shader变体数量统计小工具"><a href="#3-1-Shader变体数量统计小工具" class="headerlink" title="3.1 Shader变体数量统计小工具"></a>3.1 Shader变体数量统计小工具</h3><pre><code class="lang-csharp">
using UnityEditor; 

using UnityEngine; 

using System.Reflection; 

using System.IO; 

using System.Text; 

public class ShaderVariantCntGetter

{ 

[MenuItem(&quot;Tools/GetShaderVariant&quot;)] 

public static void GetAllShaderVariantCount()

{ 

System.Type t = typeof(Editor).Assembly.GetType(&quot;UnityEditor.ShaderUtil&quot;); 

MethodInfo method = t.GetMethod(&quot;GetVariantCount&quot;, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); 

var shaderList = AssetDatabase.FindAssets(&quot;t:Shader&quot;); 

var output = System.Environment.GetFolderPath(System.Environment.SpecialFolder.DesktopDirectory); 

string pathF = string.Format(&quot;{0}/ShaderVariantCount.csv&quot;, output); 

FileStream fs = new FileStream(pathF, FileMode.Create, FileAccess.Write); 

StreamWriter sw = new StreamWriter(fs, Encoding.UTF8); 

EditorUtility.DisplayProgressBar(&quot;Shader统计文件&quot;, &quot;正在写入统计文件中...&quot;, 0f); 

int ix = 0; 

sw.WriteLine(&quot;ShaderFile, VariantCount&quot;); 

foreach (var i in shaderList) 

{ 

EditorUtility.DisplayProgressBar(&quot;Shader统计文件&quot;, &quot;正在写入统计文件中...&quot;, ix / shaderList.Length); 

var path = AssetDatabase.GUIDToAssetPath(i); 

Shader s = AssetDatabase.LoadAssetAtPath(path, typeof(Shader)) as Shader; 

var variantCount = method.Invoke(null, new System.Object[] { s, true }); 

sw.WriteLine(path + &quot;,&quot; \+ variantCount.ToString()); 

++ix; 

} 

EditorUtility.ClearProgressBar(); 

sw.Close(); 

fs.Close(); 

} 

}
</code></pre>
<h3 id="3-2-Shader-Control"><a href="#3-2-Shader-Control" class="headerlink" title="3.2 Shader Control"></a>3.2 Shader Control</h3><p>查看Shader的变体数量，冗余关键字、查看哪些材质引用了这个Shader的哪些关键字</p>
<p>ShaderControl的Clear All Material功能，批量清除了材质球中残留的关键字。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>Assets -&gt; Browse Shaders</p>
<p>查看：<br>In ‘Build View’ click “Quick Build’ and make a normal build. </p>
<blockquote>
<p>Notice the build completes very fast because this is a special build in which Shader Control only collects data about the shaders.</p>
</blockquote>
<p>剔除：<br>see a list of shaders compiled in your build. You can toggle the “Include” checkbox to include or not that shader or keyword in future builds.</p>
<p>We want to remove some keywords from the source code of the shader so we reduce the total keywords used in our project:</p>
<ol>
<li><p>Select ‘Project View’.</p>
</li>
<li><p>Click “Scan Project”. Shader Control will quickly scan your project for shaders using keywords and will show them.</p>
</li>
<li><p>show used keywords.</p>
</li>
<li><p>Disable any keywords and click “Save”. Colors will change depending on which keywords are enabled in the shader.</p>
</li>
</ol>
<p>The Build View gives you full control on which shaders or keywords are compiled (making the compilation faster and reducing the build size).<br>The Project View gives you full control on keywords in shaders that are in your project by modifying them automatically (reducing count of keywords in your project).</p>
<p>Clean All Materials<br>will scan all materials and prune any disabled keywords. This option is provided to ensure no materials are referncing a disabled shader keyword.<br>批量清除了材质球中残留的关键字。</p>
<h3 id="3-3-ShaderVariantCollection"><a href="#3-3-ShaderVariantCollection" class="headerlink" title="3.3 ShaderVariantCollection"></a>3.3 ShaderVariantCollection</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote>
<p>ShaderVariantCollection records which shader variants are actually used in each shader.</p>
</blockquote>
<h5 id="1-编译时，强制打包要使用的变体"><a href="#1-编译时，强制打包要使用的变体" class="headerlink" title="(1) 编译时，强制打包要使用的变体"></a>(1) 编译时，强制打包要使用的变体</h5><p>有些Shader变体在运行时可能由C#脚本调用到，而在build时无法预知该变体是否会被访问，那么使用SVC可以对这部分变体进行强制打包。</p>
<h5 id="2-运行时warmup"><a href="#2-运行时warmup" class="headerlink" title="(2) 运行时warmup"></a>(2) 运行时warmup</h5><p>This is used for shader preloading (“warmup”), so that a game can make sure “actually required” shader variants are loaded at startup (or level load time), to avoid shader compilation related hiccups later on in the game.<br>取代Shader.WarmupAllShaders()接口，提前warmup防止运行时打嗝（hiccup, 卡顿），又避免Warmup所有的Shader造成时间与内存的浪费。</p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>有了变体集之后，打包shader时，依然对shader进行了长时间的编译。由此推断，SVC无法减少Build时打包的变体数量，需要我们自行过滤排除。<br>在使用ShaderVariantCollection收集变体打包时，只对shader_feature定义的宏有意义，multi_compile的变体不用收集也会被全部打进包体。</p>
<h3 id="3-4-从Shader代码上入手：Improving-shader-code-design"><a href="#3-4-从Shader代码上入手：Improving-shader-code-design" class="headerlink" title="3.4 从Shader代码上入手：Improving shader code design"></a>3.4 从Shader代码上入手：Improving shader code design</h3><ol>
<li><p>First, we should make sure that every keyword is actually useful. If we can guarantee these keywords are never used, then we should remove them. 去除从未使用的关键字</p>
</li>
<li><p>Second, we should combine keywords that effectively produce a single code path. 去除无效的关键字组合</p>
</li>
</ol>
<pre><code class="lang-csharp">
#pragma multi_compile COLOR_ORANGE COLOR_VIOLET COLOR_GREEN COLOR_GRAY // color keywords 

#pragma multi_compile OP_ADD OP_MUL OP_SUB // operator keywords 

``` ```csharp 

#pragma multi_compile ADD_COLOR_ORANGE MUL_COLOR_VIOLET MUL_COLOR_GREEN 

#if defined(ADD_COLOR_ORANGE) 

#define COLOR_ORANGE 

#define OP_ADD 

#elif defined(MUL_COLOR_VIOLET) 

#define COLOR_VIOLET 

#define OP_MUL 

#elif defined(MUL_COLOR_GREEN) 

#define COLOR_GREEN 

#define OP_MUL 

#endif
</code></pre>
<h3 id="3-4-scriptable-shader-variants-stripping-本文简写做SVS"><a href="#3-4-scriptable-shader-variants-stripping-本文简写做SVS" class="headerlink" title="3.4 scriptable shader variants stripping(本文简写做SVS)"></a>3.4 scriptable shader variants stripping(本文简写做SVS)</h3><blockquote>
<p>原Shader编译管线的缺陷——受编译时间的限制<br> Unity can’t automatically select only the necessary shader variants at build time because those shader variants depend on runtime C# execution. </p>
</blockquote>
<p>SVS: Massively reduce Player build time and data size by allowing developers to control which Shader variants are handled by the Unity Shader compiler and included in the Player data.</p>
<p>发布版本：2018.2 beta</p>
<p>功能：</p>
<ul>
<li><p>strip all the shader variants with invalid code paths, </p>
</li>
<li><p>strip shader variants for unused features </p>
</li>
<li><p>create shader build configurations such as “debug” and “release” without affecting iteration time or maintenance complexity.</p>
</li>
</ul>
<p>In Unity 2018.2 beta, the shader pipeline architecture introduces a new <strong>stage</strong> right <strong>before the shader variant compilation scheduling</strong> , allowing users to <strong>control the shader variant compilation</strong>. This new stage is exposed via C# callbacks to user code, and <strong>each callback is executed per shader snippet</strong>.</p>
<p><strong>OnProcessShader</strong> is called right <strong>before the scheduling of the shader variant compilation</strong>.</p>
<p>Each combination of <strong>a Shader</strong> , <strong>a ShaderSnippetData</strong> and <strong>ShaderCompilerData</strong> instances is an identifier for <strong>a single shader variant</strong> that the shader compiler will produce. To strip that shader variant, we only need to remove it from the ShaderCompilerData list.<br>Every single shader variant that the shader compiler should generate will appear in this callback. </p>
<h4 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h4><ol>
<li><p>systematically strip invalid shader variants of a render pipeline due to the various combinations of shader keywords.<br>HDRP和URP分别实现了自己的Shader variants stripping功能。</p>
</li>
<li><p>Another use case is a script to strip all the rendering features of a render pipeline that are not used for a specific project.</p>
</li>
</ol>
<h4 id="Tips-on-writing-SVS-code"><a href="#Tips-on-writing-SVS-code" class="headerlink" title="Tips on writing SVS code"></a>Tips on writing SVS code</h4><p>回调序列：callbackOrder 决定了IPreprocessShaders类中Shader处理函数OnProcessShader的调用顺序(in order of increasing callbackOrder)。因此，可以在Project中写多个类继承IPreprocessShaders，在编译时，编辑器会按照callbackOrder增加的顺序，逐个调用OnProcessShader函数。</p>
<p><strong>separate the scripting per purpose</strong><br>Script 1: Systematically strips all the shader variants with invalid code paths.<br>Script 2: Strips all the debug shader variants.<br>Script 3: Strips all the shader variants in the code base that are not necessary for the current project.<br>Script 4: Logs the remaining shader variants and strips them all for fast iteration time on the stripping scripts.(这个没有看懂)</p>
<h4 id="Process-for-writing-a-SVS-script"><a href="#Process-for-writing-a-SVS-script" class="headerlink" title="Process for writing a SVS script"></a>Process for writing a SVS script</h4><ol>
<li><p>In the Project view, filter for all shaders.</p>
</li>
<li><p>Select a shader and, in the Inspector, click Show to open the list of keywords / variants of that shader. There will be a list of keywords that are always included in the build.</p>
</li>
<li><p>Make sure that you know which specific graphics features the project uses.</p>
</li>
<li><p>Check whether the keywords are used in all shader stages. Only one variant is necessary for stages that don’t use these keywords.</p>
</li>
<li><p>Strip shader variants in the script.</p>
</li>
<li><p>Verify the visuals in the build.</p>
</li>
<li><p>Repeat steps 2–6 for each shader.</p>
</li>
</ol>
<h4 id="应用示例（两个较成熟的stripping实现）"><a href="#应用示例（两个较成熟的stripping实现）" class="headerlink" title="应用示例（两个较成熟的stripping实现）"></a>应用示例（两个较成熟的stripping实现）</h4><p><a href="https://github.com/lujian101/ShaderVariantCollector" target="_blank" rel="noopener">https://github.com/lujian101/ShaderVariantCollector</a><br><a href="https://github.com/SixWays/UnityShaderStripper" target="_blank" rel="noopener">https://github.com/SixWays/UnityShaderStripper</a></p>
<h2 id="4-Others"><a href="#4-Others" class="headerlink" title="4 Others"></a>4 Others</h2><h3 id="4-1-Standard-Shader造成变体数过多的原因"><a href="#4-1-Standard-Shader造成变体数过多的原因" class="headerlink" title="4.1 Standard Shader造成变体数过多的原因"></a>4.1 Standard Shader造成变体数过多的原因</h3><p>由于Standard的变体太多了，所以当引用了Standard的时候，往往会存在多个Standard变体，占用大量的内存。</p>
<h4 id="模型导入导致"><a href="#模型导入导致" class="headerlink" title="模型导入导致"></a>模型导入导致</h4><p>模型导入的时候，“Import Materials”是默认勾选的。所以当模型导入时，Unity会在同目录创建“Materials”目录，并创建相应的材质，而这个材质默认是使用 <strong>Standard</strong> 。<br>解决方法: 把“Import Materials”去掉，并把没有使用的默认材质删除。</p>
<p>问题补充：<br>没有勾选“Import Materials”的模型文件，在实例化Prefab时，ShaderLab会存在一份“Standard”的shader内存，而这个shader的引用是指向一个“Default-Material”文件（可是这文件并不存在）。<br>但是，在模型和Prefab在相同的AssetBundle中，或者使用Resources加载时，却不会有“Standard”和“Default-Material”的出现。</p>
<p>解决方案：在需要模型与Prefab分开打包时，勾选“Import Materials”，直接使用和修改默认生成的材质。</p>
<h4 id="默认模型（Cube、Sphere）创建导致的"><a href="#默认模型（Cube、Sphere）创建导致的" class="headerlink" title="默认模型（Cube、Sphere）创建导致的"></a>默认模型（Cube、Sphere）创建导致的</h4><p>早期场景搭建时，为了方便定位和可视化，曾经使用Cube等系统默认的Mesh作为锚点，然后在启动游戏时禁用掉。<br>由于这些Cube不启用，性能消耗很轻微。所以就没有理会了。<br>可是，就因为是系统默认的Mesh，所以创建时，赋予的材质就是默认的材质“Default-Material”，而这个材质使用的着色器就恰恰是“Standard”。</p>
<p>解决的方案：删掉这些mesh或者是替换材质。</p>
<h3 id="4-2-其他ShaderLab内存优化方案（未研究）"><a href="#4-2-其他ShaderLab内存优化方案（未研究）" class="headerlink" title="4.2 其他ShaderLab内存优化方案（未研究）"></a>4.2 其他ShaderLab内存优化方案（未研究）</h3><p><a href="https://zhuanlan.zhihu.com/p/39337699" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39337699</a></p>
<h2 id="5-其他注意事项"><a href="#5-其他注意事项" class="headerlink" title="5 其他注意事项"></a>5 其他注意事项</h2><ol>
<li><p>内存中ShaderLab的大小和变体成正比关系。从减少内存方面应该尽量减少变体数量，可以使用 #pragma skip_variants。</p>
</li>
<li><p>在使用ShaderVariantCollection收集变体打包时，只对shader_feature定义的宏有意义，multi_compile的变体不用收集也会被全部打进包体。</p>
</li>
<li><p>2018.2新功能OnProcessShader可以移除无用的shader变体。比#pragma skip_variants更合理。</p>
</li>
<li><p>项目前期介入美术效果制作流程，规范shader宏定义使用，防止TA为了美术效果过度使用宏定义的情况，以过往项目经验来看，到后期进行此项工作导致的资源浪费非常之大。</p>
</li>
<li><p>ShaderLab在相关shader加入内存时就已经产生，但如果没有被渲染的话不会触发CreateGPUProgram操作，如果提前在ShaderVariantCollection中收集了相关变体并执行了warmup的话，第一次渲染时就不会再CreateGPUProgram，对卡顿会有一定好处。</p>
</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/27336202" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27336202</a><br><a href="https://www.cnblogs.com/msxh/p/12987632.html" target="_blank" rel="noopener">https://www.cnblogs.com/msxh/p/12987632.html</a><br><a href="https://zhuanlan.zhihu.com/p/68888831" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68888831</a><br><a href="https://www.jianshu.com/p/5a2388c9963a" target="_blank" rel="noopener">https://www.jianshu.com/p/5a2388c9963a</a><br><a href="https://blogs.unity3d.com/cn/2018/05/14/stripping-scriptable-shader-variants/" target="_blank" rel="noopener">https://blogs.unity3d.com/cn/2018/05/14/stripping-scriptable-shader-variants/</a><br><a href="https://docs.unity3d.com/Manual/SL-ShaderPrograms.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/SL-ShaderPrograms.html</a><br><a href="https://docs.unity3d.com/Manual/ShaderTut2.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/ShaderTut2.html</a><br><a href="https://github.com/lujian101/ShaderVariantCollector" target="_blank" rel="noopener">https://github.com/lujian101/ShaderVariantCollector</a><br><a href="http://imgtec.eetrend.com/d6-imgtec/blog/2018-06/16669.html" target="_blank" rel="noopener">http://imgtec.eetrend.com/d6-imgtec/blog/2018-06/16669.html</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/68888831" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68888831</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Project-Settings与优化相关知识点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Project-Settings%E4%B8%8E%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"
    >Project Settings与优化相关知识点</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Project-Settings%E4%B8%8E%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2023-07-25T12:56:23.265Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Managed-code-stripping"><a href="#Managed-code-stripping" class="headerlink" title="Managed code stripping"></a>Managed code stripping</h2><p>unused code from a build -&gt;</p>
<ul>
<li><p>decrease the final build size</p>
</li>
<li><p>while using the IL2CPP - decrease build time because less code needs to be converted to C++ and compiled.</p>
</li>
</ul>
<p><strong>statically analyzing</strong> the code in a Project to detect classes, members of classes, and even portions of functions that can never be reached during execution. </p>
<blockquote>
<p>When your code (or code in a plugin) looks up classes or members dynamically using reflection, the code stripping tool cannot always detect that the Project is using those classes or members, and might remove them. To declare that a Project is using such code, use link.xml files or Preserve attributes.</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-ScriptableObject"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-ScriptableObject/"
    >ScriptableObject</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-ScriptableObject/" class="article-date">
  <time datetime="2023-07-25T12:56:23.265Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>文档：<a href="https://docs.unity3d.com/ScriptReference/ScriptableObject.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/ScriptableObject.html</a><br> <a href="https://docs.unity3d.com/Manual/class-ScriptableObject.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/class-ScriptableObject.html</a></p>
</blockquote>
<p>ScriptableObject类直接继承自Object类；它和MonoBehaviour是并列的，都继承自Object（但MonoBehaviour并不是直接继承自Object）</p>
<p>是一个 <strong>数据容器</strong> ，可以用来存储大量的数据，它是可序列化的。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li><p>存储数据：在游戏运行时创建脚本化对象实例，然后可以将数据保存到本地（如果不保存，它会在游戏结束后销毁）；</p>
</li>
<li><p>减少内存：将数据存储在ScriptableObject对象中，在代码中可以进行引用，来减少工程以及游戏运行时因拷贝值所造成的内存占用；</p>
</li>
</ol>
<blockquote>
<p><strong>ScriptableObject与预制体</strong> ：当你有一个预制体，它附加了一些mono脚本，包含了一些数据，每次我们实例化预制体的时候它都会拷贝assets下原预制体的值生成一份自己的拷贝，然后我们可以修改场景内预制体的值而并不影响assets下预制体的值，这是prefab的特性，对于我们从一个prefab模板生成属性不同的游戏对象是很有用的，但是如果prefab里的脚本数据是不需要修改的，它就会造成很大的资源浪费，尤其在数据很多的时候；为了避免这种问题，我们可以在不需要修改prefab里的脚本数据时，考虑使用ScriptableObject来存储这些重复的数据，然后其它所有预制体都可以使用引用的方式来访问这份数据，这就意味着不管场景中实例了多少预制体，在内存中就只需要有一份数据；它所带给我们的启示就是， <strong>当预制体中的脚本里有大量重复数据时，我们要想着将数据抽离，单独保存在本地</strong></p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li><strong>Unity编辑器外不可操作</strong> ：仅在编辑器中才可以保存修改的数据（因为ScriptableObject对象虽然声明在UnityEngine中，但是它的Scriptable是通过UnityEditor命名空间下的类例如Editor类等来实现的），所以在部署构建的时候不可以用于存储游戏运行时更改的数据，但是可以使用之前存储好的数据。也就是ScriptableObject生成的数据资源文件 <strong>在Editor外具有只读属性</strong> ，如果你需要在游戏中修改数据并存储下来，就不推荐使用ScriptableObject了；</li>
</ol>
<blockquote>
<p>就像我们不可以在游戏运行时修改一个shader资源的代码、不可以修改一个纹理资源的像素内容一样，而在Unity Editor里可以修改ScriptableObject是因为Unity的编辑器对它格式的支持</p>
</blockquote>
<ol>
<li><p>继承自UnityEngine.Object，不必附着在对象上也无需/不能赋给Gameobject或Prefab</p>
</li>
<li><p>可以被serialize，可以在资源面板创建一个对应的.asset文件，把数据存储在资源文件中，通过属性面板可修改数值。该文件表示一个ScriptableObject的对象实例的序列化文件，退出之后也不会丢失。</p>
</li>
<li><p>本身是个类，可以引用，在项目之间共享</p>
</li>
<li><p>回调少 ：OnEnable 、OnDisable、OnDestroy</p>
</li>
<li><p>persistent：当它被绑定到.asset文件或者AssetBundle等资源文件中的时候（它可以通过Resources.UnloadUnusedAssets来被unload出内存。可以通过脚本引用或其他需要的时候被再次load到内存）<br>非persistent：通过CreateInstance&lt;&gt;来创建的时候（它可以通过GC被直接destroy掉（如果没有任何引用的话）。如果不想被GC的话，可以使用HideFlags.HideAndDontSave）</p>
</li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p>unity内置的一种储存容器</p>
</li>
<li><p>PlayMode储存数据更改（再也不怕更改数据没保存了）<br>3</p>
</li>
</ol>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><pre><code class="lang-csharp">
//在游戏运行时创建一个Scriptable类型的实例，不使用时被GC回收；

//静态方法，使用了ScriptableObject类约束的泛型参数T

public static T CreateInstance&lt;T&gt;() where T : ScriptableObject; 

//实例化一个对象，返回一个实例；类似于GameObject的Instantiate()，其它函数也和GameObject类似

public static T Instantiate(T original);
</code></pre>
<p>???<br>ScriptableObject内部实现上也继承自MonoBehavior，它只有四个消息函数，Awake()、OnDestroy()、OnEnable()、OnDisable()；</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h3><p>需要指定创建的目录和资源名称，如果资源已经存在，则不会创建新资源；</p>
<pre><code class="lang-csharp">
public class MakeScriptableObject { 

[MenuItem(&quot;Assets/Create/My Scriptable Object&quot;)] 

public static void CreateMyAsset()

{ 

MyScriptableObjectClass asset = ScriptableObject.CreateInstance&lt;MyScriptableObjectClass&gt;(); 

AssetDatabase.CreateAsset(asset, &quot;Assets/NewScripableObject.asset&quot;); 

AssetDatabase.SaveAssets(); 

EditorUtility.FocusProjectWindow(); 

Selection.activeObject = asset; 

} 

}
</code></pre>
<h3 id="CreateAssetMenu"><a href="#CreateAssetMenu" class="headerlink" title="CreateAssetMenu"></a>CreateAssetMenu</h3><p>可以在Assets下任意目录创建资源，而且可以创建多个资源；</p>
<pre><code class="lang-csharp">
[CreateAssetMenu(fileName = &quot;data&quot;, menuName = &quot;ScriptableObjects/SpawnManagerScriptableObject&quot;, order = 1)] 

public class SpawnManagerScriptableObject : ScriptableObject { 

public string prefabName; 

public int numberOfPrefabsToCreate; 

public Vector3[] spawnPoints; 

}
</code></pre>
<p>在Assets下创建一个可编程对象资源，设置好所需数据；如果需要在其它脚本中获取该数据，是需要声明一个该类型变量，然后为其赋值或加载该数据资源；然后，就像使用用一个类中的公有变量一样使用即可；</p>
<pre><code class="lang-csharp">
public SpawnManagerScriptableObject spawnManagerValues; 

//spawnManagerValues.prefabName
</code></pre>
<h3 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a>动态创建</h3><pre><code class="lang-csharp">
ScriptableObject.CreateInstance&lt;MyScriptableObject &gt;();
</code></pre>
<h3 id="CreateAssets-amp-FindAssets-amp-ScriptableObject"><a href="#CreateAssets-amp-FindAssets-amp-ScriptableObject" class="headerlink" title="CreateAssets &amp; FindAssets &amp; ScriptableObject"></a>CreateAssets &amp; FindAssets &amp; ScriptableObject</h3><ol>
<li><p>对于ScriptableObject，使用CreateInstance来创建Asset实例对象<br><code>testI = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj));</code></p>
</li>
<li><p>对于其他资源类型，使用new来创建对象</p>
</li>
<li><p>然后调用 <code>AssetDatabase.CreateAsset</code>函数，将实例对象作为资源存储在Assets路径当中。</p>
</li>
<li><p>最后使用<code>AssetDatabase.FindAssets</code>获取相应资源的GUID</p>
</li>
<li><p>由 <code>AssetDatabase.GUIDToAssetPath</code> 获取相应资源的路径。</p>
</li>
</ol>
<pre><code class="lang-csharp">
// This script file has two CS classes. The first is a simple Unity ScriptableObject script.

// The class it defines is used by the Example class below.

// (This is a single Unity script file. You could split this file into a ScriptObj.cs and an

// Example.cs file which is more structured.)

using UnityEngine; 

using UnityEditor; 

public class ScriptObj : ScriptableObject

{ 

public void Awake()

{ 

Debug.Log(&quot;ScriptObj created&quot;); 

} 

} 

// Use ScriptObj to show how AssetDabase.FindAssets can be used

public class Example

{ 

static ScriptObj testI; 

static ScriptObj testJ; 

static ScriptObj testK; 

[MenuItem(&quot;Examples/FindAssets Example two&quot;)] 

static void ExampleScript()

{ 

CreateAssets(); 

NamesExample(); 

LabelsExample(); 

TypesExample(); 

} 

static void CreateAssets()

{ 

testI = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); 

AssetDatabase.CreateAsset(testI, &quot;Assets/AssetFolder/testI.asset&quot;); 

testJ = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); 

AssetDatabase.CreateAsset(testJ, &quot;Assets/AssetFolder/testJ.asset&quot;); 

// create an asset in a sub-folder and with a name which contains a space

testK = (ScriptObj)ScriptableObject.CreateInstance(typeof(ScriptObj)); 

AssetDatabase.CreateAsset(testK, &quot;Assets/AssetFolder/SpecialFolder/testK example.asset&quot;); 

// an asset with a material will be used later

Material material = new Material(Shader.Find(&quot;Standard&quot;)); 

AssetDatabase.CreateAsset(material, &quot;Assets/AssetFolder/SpecialFolder/MyMaterial.mat&quot;); 

} 

static void NamesExample()

{ 

Debug.Log(&quot; FINDING ASSETS BY NAME &quot;); 

string[] results; 

results = AssetDatabase.FindAssets(&quot;testI&quot;); 

foreach (string guid in results) 

{ 

Debug.Log(&quot;testI: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

results = AssetDatabase.FindAssets(&quot;testJ&quot;); 

foreach (string guid in results) 

{ 

Debug.Log(&quot;testJ: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

results = AssetDatabase.FindAssets(&quot;testK example&quot;); 

foreach (string guid in results) 

{ 

Debug.Log(&quot;testK example: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

Debug.Log(&quot;*** More complex asset search ***&quot;); 

// find all assets that contain test (which is all assets)

results = AssetDatabase.FindAssets(&quot;test&quot;); 

foreach (string guid in results) 

{ 

Debug.Log(&quot;name:test - &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

} 

static void LabelsExample()

{ 

Debug.Log(&quot; FINDING ASSETS BY LABELS &quot;); 

string[] setLabels; 

setLabels = new string[] {&quot;wrapper&quot;}; 

AssetDatabase.SetLabels(testI, setLabels); 

setLabels = new string[] {&quot;bottle&quot;, &quot;banana&quot;, &quot;carrot&quot;}; 

AssetDatabase.SetLabels(testJ, setLabels); 

setLabels = new string[] {&quot;swappable&quot;, &quot;helmet&quot;}; 

AssetDatabase.SetLabels(testK, setLabels); 

// label searching:

// testI has wrapper, testK has swappable, so both have &#39;app&#39;

// testJ has bottle, so have a label searched as &#39;bot&#39;

string[] getGuids = AssetDatabase.FindAssets(&quot;l:app l:bot&quot;); 

foreach (string guid in getGuids) 

{ 

Debug.Log(&quot;label lookup: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

} 

static void TypesExample()

{ 

Debug.Log(&quot; FINDING ASSETS BY TYPE &quot;); 

string[] guids; 

// search for a ScriptObject called ScriptObj

guids = AssetDatabase.FindAssets(&quot;t:ScriptObj&quot;); 

foreach (string guid in guids) 

{ 

Debug.Log(&quot;ScriptObj: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

guids = AssetDatabase.FindAssets(&quot;t:ScriptObj l:helmet&quot;); 

foreach (string guid in guids) 

{ 

Debug.Log(&quot;ScriptObj+bottle: &quot; \+ AssetDatabase.GUIDToAssetPath(guid)); 

} 

} 

}
</code></pre>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>ScriptableObject的生命周期和其他资源都是类似的：</p>
<p>当它是被绑定到.asset文件或者AssetBundle等资源文件中的时候，它就是persistent的，这意味着<br>它可以通过Resources.UnloadUnusedAssets来被unload出内存<br>可以通过脚本引用或其他需要的时候被再次load到内存<br>如果是通过CreateInstance&lt;&gt;来创建的，它就是非persistent的，这意味着<br>它可以通过GC被直接destroy掉（如果没有任何引用的话）<br>如果不想被GC的话，可以使用HideFlags.HideAndDontSave</p>
<h2 id="其他高级应用Demo"><a href="#其他高级应用Demo" class="headerlink" title="其他高级应用Demo"></a>其他高级应用Demo</h2><p><a href="https://blog.csdn.net/candycat1992/article/details/52181814" target="_blank" rel="noopener">https://blog.csdn.net/candycat1992/article/details/52181814</a></p>
<h3 id="保存信息"><a href="#保存信息" class="headerlink" title="保存信息"></a>保存信息</h3><p>step1.创建你用于共享数据的类（例如EnemyData）</p>
<pre><code class="lang-csharp">
using UnityEngine; 

public class EnemyData: ScriptableObject

{ 

public string name; 

public Color thisColor; 

public Vector3[] spawnPoints; 

}
</code></pre>
<p>step2.新建一个脚本扩展Editor,使编辑器能够创建自定义的ScriptableObject对象</p>
<pre><code class="lang-csharp">
using UnityEngine; 

using UnityEditor; 

//新建一个Editor文件夹，放在里面

public class MakeEnemyData{ 

[MenuItem(&quot;Assets/Editor/Scriptable Object&quot;)] //定义了如何新建的路径

public static void CreateMyAsset()

{ 

//将EnemyData创建为asset

EnemyData asset = ScriptableObject.CreateInstance&lt;EnemyData&gt;(); 

//设置新创建的NewScripableObject文件的初始路径

AssetDatabase.CreateAsset(asset, &quot;Assets/NewScripableObject.asset&quot;); 

AssetDatabase.SaveAssets(); 

EditorUtility.FocusProjectWindow(); 

Selection.activeObject = asset; 

} 

}
</code></pre>
<p>step3. 在需要引用的脚本中引用</p>
<pre><code class="lang-csharp">
using UnityEngine; 

public class EnemyAI : MonoBehaviour { 

public EnemyData data; //data配置的数据就可以被所有相同种类的怪物共享，节省内存

}
</code></pre>
<h3 id="用作配置文件"><a href="#用作配置文件" class="headerlink" title="用作配置文件"></a>用作配置文件</h3><pre><code class="lang-csharp">
[CreateAssetMenu] 

public class GameSettings : ScriptableObject

{ 

[Serializable] 

public class PlayerInfo

{ 

public string Name; 

public Color Color; 

... 

} 

public List&lt;PlayerInfo&gt; players; 

private static GameSettings _instance; 

public static GameSettings Instance 

{ 

get

{ 

if (!_instance) 

_instance = Resources.FindObjectsOfTypeAll&lt;GameSettings&gt;().FirstOrDefault(); 

#if UNITY_EDITOR

if (!_instance) 

InitializeFromDefault(UnityEditor.AssetDatabase.LoadAssetAtPath&lt;GameSettings&gt;(&quot;Assets/Test game settings.asset&quot;)); 

#endif

return _instance; 

} 

} 

public int NumberOfRounds; 

public static void LoadFromJSON(string path)

{ 

if (!_instance) DestroyImmediate(_instance); 

_instance = ScriptableObject.CreateInstance&lt;GameSettings&gt;(); 

JsonUtility.FromJsonOverwrite(System.IO.File.ReadAllText(path), _instance); 

_instance.hideFlags = HideFlags.HideAndDontSave; 

} 

public void SaveToJSON(string path)

{ 

Debug.LogFormat(&quot;Saving game settings to {0}&quot;, path); 

System.IO.File.WriteAllText(path, JsonUtility.ToJson(this, true)); 

} 

public static void InitializeFromDefault(GameSettings settings)

{ 

if (_instance) DestroyImmediate(_instance); 

_instance = Instantiate(settings); 

_instance.hideFlags = HideFlags.HideAndDontSave; 

} 

#if UNITY_EDITOR

[UnityEditor.MenuItem(&quot;Window/Game Settings&quot;)] 

public static void ShowGameSettings()

{ 

UnityEditor.Selection.activeObject = Instance; 

} 

#endif

... 

} 

``` ```csharp 

public class MainMenuController : MonoBehaviour

{ 

public GameSettings GameSettingsTemplate; 

... 

public string SavedSettingsPath { 

get { 

return System.IO.Path.Combine(Application.persistentDataPath, &quot;tanks-settings.json&quot;); 

} 

} 

void Start () { 

if (System.IO.File.Exists(SavedSettingsPath)) 

GameSettings.LoadFromJSON(SavedSettingsPath); 

else

GameSettings.InitializeFromDefault(GameSettingsTemplate); 

foreach(var info in GetComponentsInChildren&lt;PlayerInfoController&gt;()) 

info.Refresh(); 

NumberOfRoundsSlider.value = GameSettings.Instance.NumberOfRounds; 

} 

public void Play()

{ 

GameSettings.Instance.SaveToJSON(SavedSettingsPath); 

GameState.CreateFromSettings(GameSettings.Instance); 

SceneManager.LoadScene(1, LoadSceneMode.Single); 

} 

... 

}
</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="https://blog.csdn.net/qq_36383623/article/details/99649941" target="_blank" rel="noopener">https://blog.csdn.net/qq_36383623/article/details/99649941</a><br><a href="https://blog.csdn.net/candycat1992/article/details/52181814" target="_blank" rel="noopener">https://blog.csdn.net/candycat1992/article/details/52181814</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Overdraw"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Overdraw/"
    >Overdraw</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Overdraw/" class="article-date">
  <time datetime="2023-07-25T12:56:23.264Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>overdraw表示一个像素的重新绘制次数，在像素处理中，overdraw是最常见的性能瓶颈之一。<br>Scene视图的RenderMode-&gt;Overdraw。越亮的区域表示overdraw的程度越高，也就越消耗GPU。</p>
<blockquote>
<p>当然这里的视图只是提供了查看物体遮挡的层数关系，并不是真正的最终屏幕绘制的overdraw。也就是说，可以理解为它显示的是如果没有使用任何深度检验时的overdraw。这种视图是通过把所有对象都渲染成一个透明的轮廓，通过查看透明颜色的累计程度，来判断物体的遮挡。</p>
</blockquote>
<h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><ul>
<li><p>控制绘制顺序:PC上资源无限，一般都是从后往前绘制，但在移动上，尽量从前往后绘制.在Unity中，那些Shader中被设置为“Geometry”队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。尽量减小过度绘制区域:实在需要多层绘制的地方，要尽量减小各部分过度绘制区域，使重合区域小，绘制的像素点也就少一点</p>
</li>
<li><p>注意性能与效果的取舍:UGUI的许多控件有很好的通用性和展示效果，但是可能会耗更多性能</p>
</li>
<li><p>过大的不必要绘制尽量代码实现:例如点击屏幕空白区域返回功能，加透明image会增加很多</p>
</li>
<li><p>UI设计上尽可能简单减少重叠</p>
</li>
</ul>
<h3 id="针对性优化"><a href="#针对性优化" class="headerlink" title="针对性优化"></a>针对性优化</h3><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><p>Outline实现方式是将Text的四个顶点传过去复制四份，设置四份偏移量实现效果，将偏移量设置很大之后，可以看到一个Text周围有四个相同的Text<br>解决方案:<br>1.不使用或者使用Shadow(Shadow通过为图像或者文字的Mesh添加顶点实现阴影效果，Outline继承Shadow，在对象四个角上各添加一个Shadow)<br>2.使用Textmesh Pro(Unity5.5)需要制作相应的字体文件，对于动态生成的文字效果不好，固定字体很好<br>(<a href="https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&amp;utm_medium=referral</a>)<br>3.修改Mesh的UV坐标，提取文字原始UV坐标，扩大文字绘图区域，对文字纹理周围像素点采样，新旧颜色融合<br>(<a href="http://gad.qq.com/article/detail/29266" target="_blank" rel="noopener">http://gad.qq.com/article/detail/29266</a>)</p>
<h4 id="适配IphoneX"><a href="#适配IphoneX" class="headerlink" title="适配IphoneX"></a>适配IphoneX</h4><p>适配的需要加了层背景，不是iPhoneX失活就可以</p>
<h4 id="背景人物mesh"><a href="#背景人物mesh" class="headerlink" title="背景人物mesh"></a>背景人物mesh</h4><p>裁剪小一点更好</p>
<h4 id="Mask组件"><a href="#Mask组件" class="headerlink" title="Mask组件"></a>Mask组件</h4><p>Unity的Mask组件会增加一层Overdraw，还会多增加4个DrawCall<br>解决:<br>1.使用RectMask2D代替，缺点是只能用于矩形<br>2.对于多边形，用MeshMask，红色为UnityMask，蓝色是MeshMask，UnityMask消耗15个DrawCall，Overdraw2次，MeshMask消耗1个DrawCall，1层OverDraw(<a href="https://www.cnblogs.com/leoin2012/p/6822859.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoin2012/p/6822859.html</a>)</p>
<h4 id="Image的slide属性"><a href="#Image的slide属性" class="headerlink" title="Image的slide属性"></a>Image的slide属性</h4><p>对于slide九宫格图片，可以看情况取消fill center属性，那样中心区域会不渲染，中心区域也就镂空，重合面积也会小</p>
<p>1)重合多的地方尽可能不重合<br>2)无用的Image<br>少量的panel或者单纯的空父物体身上加着image，虽然没有给图片，但是还是会渲染<br>3)移动的波浪图片过大过多(修改高度，宽度)<br>4)特效粒子效果优化(<a href="http://www.u3dnotes.com/archives/807" target="_blank" rel="noopener">http://www.u3dnotes.com/archives/807</a>)<br>粒子效果薄弱的可以使用序列帧动画实现</p>
<p>部分小细节：<br>1.slide九宫格图片，取消fill center，中心镂空<br>2.mask尽量不用，可以用rect mask2D 代替<br>3.不用UI/Effect，包括Shadow，Outline，Position As UV1<br>4.不用Image的Tiled类型<br>5.不用Pixel Perfect<br>6.动静分离，动态的在父物体上加个Canvas<br>7.尽量active，不要destroy，也不要设置Alpha=0这样还是会渲染<br>8.不用BestFit(代价高，Unity会为该元素用到的所有字号生成图元保存在Altlas中，增加额外生成时间，还会使得字体对应的atlas变大)<br>9.特效粒子</p>
<p>Ref：<br><a href="https://www.jianshu.com/p/7167c516bd75" target="_blank" rel="noopener">https://www.jianshu.com/p/7167c516bd75</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Profiler使用技巧"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Profiler%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"
    >Profiler使用技巧</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Profiler%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="article-date">
  <time datetime="2023-07-25T12:56:23.264Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>csharp using UnityEngine; using System.Collections; using UnityEngine.Profiling;public class ExampleClass : MonoBehaviour { void Start() { Profiler.logFile = &quot;mylog&quot;; //Also supports passing &quot;myLog.raw&quot; Profiler.enableBinaryLog = true; Profiler.enabled = true; // Optional, if more memory is needed for the buffer Profiler.maxUsedMemory = 256 * 1024 * 1024; // ... // Optional, to close the file when done Profiler.enabled = false; Profiler.logFile = &quot;&quot;; // To start writing to a new log file Profiler.logFile = &quot;myOtherLog&quot;; Profiler.enabled = true; // ... } }</code> </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-NavMesh"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-NavMesh/"
    >NavMesh</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-NavMesh/" class="article-date">
  <time datetime="2023-07-25T12:56:23.257Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="基础知识-寻路算法"><a href="#基础知识-寻路算法" class="headerlink" title="基础知识 - 寻路算法"></a>基础知识 - 寻路算法</h2><h3 id="其他寻路算法"><a href="#其他寻路算法" class="headerlink" title="其他寻路算法"></a>其他寻路算法</h3><p>广度优先（Breadth First）算法 - 从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。</p>
<p>Dijkstra算法 - 加了移动代价的广度优先算法。计算每一个节点距离起点的总移动代价。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。</p>
<blockquote>
<p>如果图形为网格图，并且每个节点之间的移动代价是相等的，那么Dijkstra算法将和广度优先算法变得一样。</p>
</blockquote>
<p>最佳优先（Best First）算法 - 预先计算出每个节点到终点的距离。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级。从起点开始寻路，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。</p>
<ul>
<li><p>优点：这样做可以大大加快路径的搜索速度</p>
</li>
<li><p>缺点：如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径</p>
</li>
</ul>
<h3 id="A-Star算法"><a href="#A-Star算法" class="headerlink" title="A Star算法"></a>A Star算法</h3><p><img src="NavMesh/__SVG__3d425a215e8eeb2a056f553633aaae4a" alt=""><br> =<br><img src="NavMesh/__SVG__f010a0fda7cdcc04209d9381ef5fca27" alt=""><br> +<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2" alt=""></p>
<p><img src="NavMesh/__SVG__3d425a215e8eeb2a056f553633aaae4a_1" alt=""><br> - 节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。   </p>
<p><img src="NavMesh/__SVG__f010a0fda7cdcc04209d9381ef5fca27_1" alt=""><br> - 节点n距离起点的代价。   </p>
<p><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_1" alt=""><br> - 节点n距离终点的预计代价，这也就是A<em>算法的 <em>*启发函数</em></em> 。</p>
<pre><code class="lang-csharp">
* 初始化open_set和close_set； 

* 将起点加入open_set中，并设置优先级为0（优先级最高）； 

* 如果open_set不为空，则从open_set中选取优先级最高的节点n： 

* 如果节点n为终点，则： 

* 从终点开始逐步追踪parent节点，一直达到起点； 

* 返回找到的结果路径，算法结束； 

* 如果节点n不是终点，则： 

* 将节点n从open_set中删除，并加入close_set中； 

* 遍历节点n所有的邻近节点： 

* 如果邻近节点m在close_set中，则： 

* 跳过，选取下一个邻近节点 

* 如果邻近节点m也不在open_set中，则： 

* 设置节点m的parent为节点n 

* 计算节点m的优先级 

* 将节点m加入open_set中
</code></pre>
<ul>
<li><p>在极端情况下，当启发函数<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_2" alt=""><br>始终为0，则将由<br><img src="NavMesh/__SVG__f010a0fda7cdcc04209d9381ef5fca27_2" alt=""><br>决定节点的优先级，此时算法就退化成了Dijkstra算法。</p>
</li>
<li><p>如果<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_3" alt=""><br>始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_4" alt=""><br>的值越小，算法将遍历越多的节点，也就导致算法越慢。</p>
</li>
<li><p>如果<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_5" alt=""><br>完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</p>
</li>
<li><p>如果<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_6" alt=""><br>的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。<br>在另外一个极端情况下，如果<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_7" alt=""><br>相较于<br><img src="NavMesh/__SVG__f010a0fda7cdcc04209d9381ef5fca27_3" alt=""><br>大很多，则此时只有<br><img src="NavMesh/__SVG__72b322da8035af6f39a0a9b5134877a2_8" alt=""><br>产生效果，这也就变成了最佳优先搜索。</p>
</li>
</ul>
<p><strong>通过调节启发函数我们可以控制算法的速度和精确度</strong><br><strong>在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可</strong></p>
<h4 id="启发函数h-n"><a href="#启发函数h-n" class="headerlink" title="启发函数h(n)"></a>启发函数h(n)</h4><p>曼哈顿距离 - 只允许朝上下左右四个方向移动</p>
<p><img src="NavMesh/1620751740246.png" alt="Alt text"></p>
<p>对角距离 - 允许斜着朝邻近的节点移动</p>
<p><img src="NavMesh/1620751750347.png" alt="Alt text"></p>
<p>欧几里得距离 - 两个节点之间的直线距离</p>
<h2 id="Unity-NavMesh"><a href="#Unity-NavMesh" class="headerlink" title="Unity NavMesh"></a>Unity NavMesh</h2><p>The navigation system allows you to create characters that can intelligently move around the game world, using navigation meshes that are created automatically from your Scene geometry. </p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p><strong>NavMesh</strong> (short for Navigation Mesh) - a data structure which describes the walkable surfaces of the game world and allows to find path from one walkable location to another in the game world. The data structure is built, or baked, automatically from your level geometry.</p>
<p>The walkable area is built automatically from the geometry in the scene by testing the locations where the agent can stand. Then the locations are connected to a surface laying on top of the scene geometry. This surface is called the navigation mesh (NavMesh for short).</p>
<p>The NavMesh stores this surface as <strong>convex polygons</strong>. Convex polygons are a useful representation, since we know that <strong>there are no obstructions between any two points inside a polygon</strong>. In addition to the polygon boundaries, <strong>we store information about which polygons are neighbours to each other</strong>. This allows us to reason about the whole walkable area.</p>
<h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><p><strong>NavMesh Agent component</strong> help you to create characters which avoid each other while moving towards their goal. Agents reason about the game world using the NavMesh and they know how to avoid each other as well as moving obstacles.</p>
<p><strong>Off-Mesh Link component</strong> allows you to incorporate navigation shortcuts which cannot be represented using a walkable surface. For example, jumping over a ditch or a fence, or opening a door before walking through it, can be all described as Off-mesh links.<br><strong>NavMesh Obstacle component</strong> allows you to describe moving obstacles the agents should avoid while navigating the world. </p>
<p><img src="NavMesh/1620748376654.png" alt="Alt text"></p>
<h3 id="two-problems"><a href="#two-problems" class="headerlink" title="two problems"></a>two problems</h3><ul>
<li><p>how to reason about the level to find the destination - global and static, in that it takes into account the whole scene.</p>
</li>
<li><p>how to move there - local and dynamic, it only considers the direction to move and how to prevent collisions with other moving agents.</p>
</li>
</ul>
<h2 id="寻路分解"><a href="#寻路分解" class="headerlink" title="寻路分解"></a>寻路分解</h2><h4 id="Finding-Paths"><a href="#Finding-Paths" class="headerlink" title="Finding Paths"></a>Finding Paths</h4><p><img src="NavMesh/1620752340467.png" alt="Alt text"></p>
<p>The sequence of polygons which describe the path from the start to the destination polygon is called a <strong>corridor</strong>. The agent will reach the destination by always steering towards the next visible corner of the corridor. </p>
<h4 id="Following-the-Path"><a href="#Following-the-Path" class="headerlink" title="Following the Path"></a>Following the Path</h4><p><img src="NavMesh/1620752593292.png" alt="Alt text"></p>
<p>When dealing with multiple agents moving at the same time, they will need to deviate from the original path when avoiding each other. Trying to correct such deviations using a path consisting of line segments soon becomes very difficult and error prone.</p>
<p>Since the agent movement in each frame is quite small, we can use the connectivity of the polygons to fix up the corridor in case we need to take a little detour. Then we quickly find the next visible corner to steer towards.</p>
<h4 id="Avoiding-Obstacles"><a href="#Avoiding-Obstacles" class="headerlink" title="Avoiding Obstacles"></a>Avoiding Obstacles</h4><p><img src="NavMesh/1620752915537.png" alt="Alt text"></p>
<p>The steering logic takes the position of the next corner and based on that figures out a desired <strong>direction</strong> and <strong>speed</strong> (or velocity) needed to reach the destination. Using the desired velocity to move the agent can lead to collision with other agents.</p>
<p>Obstacle avoidance chooses a new velocity which balances between <strong>moving in the desired direction</strong> and <strong>preventing future collisions</strong> with other agents and edges of the navigation mesh. Unity is using <strong>reciprocal velocity obstacles (RVO)</strong> to predict and prevent collisions.</p>
<h4 id="Moving-the-Agent"><a href="#Moving-the-Agent" class="headerlink" title="Moving the Agent"></a>Moving the Agent</h4><p>At this stage you can feed the velocity from the simulated agent to the animation system to move the character using <strong>root motion</strong> , or let the <strong>navigation system take care of that</strong>.</p>
<h4 id="Global-and-Local"><a href="#Global-and-Local" class="headerlink" title="Global and Local"></a>Global and Local</h4><p><img src="NavMesh/1620753233885.png" alt="Alt text"></p>
<h4 id="Two-Cases-for-Obstacles"><a href="#Two-Cases-for-Obstacles" class="headerlink" title="Two Cases for Obstacles"></a>Two Cases for Obstacles</h4><h5 id="local-obstacle-avoidance"><a href="#local-obstacle-avoidance" class="headerlink" title="local obstacle avoidance"></a>local obstacle avoidance</h5><p>When an obstacle is moving, it is best handled using local obstacles avoidance. This way the agent can predictively avoid the obstacle. </p>
<h5 id="global-pathfinding"><a href="#global-pathfinding" class="headerlink" title="global pathfinding"></a>global pathfinding</h5><p>静态：When the obstacle becomes stationary, and can be considered to block the path of all agents, the obstacles should affect the global navigation, that is, the navigation mesh.</p>
<p>动态改变：Changing the NavMesh is called carving. The process detects which parts of the obstacle touches the NavMesh and carves holes into the NavMesh. </p>
<h4 id="Off-mesh-Links"><a href="#Off-mesh-Links" class="headerlink" title="Off-mesh Links"></a>Off-mesh Links</h4><p><img src="NavMesh/1620753809200.png" alt="Alt text"></p>
<p>This link can be later accessed when following the path, and the special action can be executed.</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="Building-a-NavMesh"><a href="#Building-a-NavMesh" class="headerlink" title="Building a NavMesh"></a>Building a NavMesh</h3><p>NavMesh Baking - collects the Render Meshes and Terrains of all Game Objects which are marked as Navigation Static, and then processes them to create a navigation mesh that approximates the walkable surfaces of the level.</p>
<p><strong>Window &gt; AI &gt; Navigation</strong></p>
<ol>
<li><p>Select </p>
</li>
<li><p>Check Navigation Static</p>
</li>
<li><p>Adjust<br>Agent Radius<br>Agent Height<br>Max Slope<br>Step Height </p>
</li>
<li><p>Click bake </p>
</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://developer.aliyun.com/article/685477" target="_blank" rel="noopener">https://developer.aliyun.com/article/685477</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Mesh-in-U3D-ToUpdate"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Mesh-in-U3D-ToUpdate/"
    >Mesh in U3D(ToUpdate)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Mesh-in-U3D-ToUpdate/" class="article-date">
  <time datetime="2023-07-25T12:56:23.254Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Unity3D中的 <strong>Mesh(网格)</strong> 事实上就是我们所说的 <strong>三角网格</strong> 。<br>三角网格就是由一系列三角形组成的多边形网格，主要用于模拟复杂物体的表面。</p>
<h2 id="数据结构——索引三角网格"><a href="#数据结构——索引三角网格" class="headerlink" title="数据结构——索引三角网格"></a>数据结构——索引三角网格</h2><p>用c++语言模拟Unity3D中Mesh数据的存储结构。</p>
<pre><code class="lang-csharp">
//顶点表

//-----------------------------------

struct Vertex{ //由于存储三角形顶点级信息

Vector3 p; 

....... //其他信息 纹理映射坐标 法向量 光照信息 

}; 

//三角形表

//-----------------------------------

struct Triangle{ //保存三角形级信息

int vertex[3]; //三个顶点在顶点列表的索引

}; 

//存放三角网格的结构 维护两个表 定点表和三角形表

struct TriangleMesh{ 

int vertexCount; //顶点数

Vertex *vertexList; //顶点存放链表

int *uv; 

int triangleCount; //三角形数量

Triangle *triangleCount; //存放三角形的链表

........ 

};
</code></pre>
<h3 id="vertices"><a href="#vertices" class="headerlink" title="vertices"></a>vertices</h3><pre><code class="lang-csharp">
Vector3[] vertices; //所有的顶点。
</code></pre>
<p>每个三角形面三个顶点，面与面之间不一定共用顶点。<br>法向量相同的两个面可以公用顶点，法向量不同的两个面，在同一个位置会分别有两个顶点数据，坐标相同，法向量不同。</p>
<p>每个顶点包含一个3D位置，一般也会包括 <strong>纹理映射坐标(UV坐标)</strong> ，表面 <strong>法向量</strong> ， <strong>光照值</strong> 等附加信息</p>
<h4 id="为何有冗余顶点"><a href="#为何有冗余顶点" class="headerlink" title="为何有冗余顶点"></a>为何有冗余顶点</h4><p>正方体6个面，每个面由2个三角形组成，所以共需要36个三角形顶点索引。但是正方体只有8个顶点，为什么需要24个顶点坐标数据呢？</p>
<p>答案是：Unity3D的Mesh.triangles是 <strong>三角形索引数组</strong> ，不仅依靠这个索引值 <strong>索引三角形顶点坐标</strong> ，而且 <strong>索引纹理坐标</strong> ， <strong>索引法线向量</strong> 。即正方体的 <strong>每个顶点都参与了3个平面，而这3个平面的法线向量是不同的</strong> ，该顶点在渲染这3个平面的时候需要索引到不同的法线向量。而由于顶点坐标和法线向量是由同一个索引值triangles[Index]取得的，例如，根据triangles[0],triangles[14],triangles[17]在vertices中索引到的顶点都为（0.5，－0.5，0.5），但是在normals中索引到的法向量值各不相同。这就决定了在正方体中一个顶点，需要有 <strong>3份存储</strong> 。（如果你需要创建其它模型，需要根据实际情况决定顶点坐标的冗余度。实质上顶点坐标的冗余正是方便了法线坐标、纹理坐标的存取。）</p>
<h3 id="triangles"><a href="#triangles" class="headerlink" title="triangles"></a>triangles</h3><pre><code class="lang-csharp">
int[] triangles // a list of triangles that contains indices into the vertex array
</code></pre>
<p>三角形的哪一面可见是由顶点序号的方向来确定的。如果顶点顺序是顺时针方向的话那么三角形是正面可见。</p>
<pre><code class="lang-csharp">
mesh.vertices = new Vector3[] {new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 0)}; 

mesh.uv = new Vector2[] {new Vector2(0, 0), new Vector2(0, 1), new Vector2(1, 1)}; 

mesh.triangles = new int[] {0, 1, 2};
</code></pre>
<h4 id="GetBaseVertex"><a href="#GetBaseVertex" class="headerlink" title="GetBaseVertex"></a>GetBaseVertex</h4><p>The base vertex can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers.</p>
<p>Unity Mesh的indexFormat[ format of the mesh index buffer data ]默认是uint16，存储的数值最大为65536，也就是说，索引数组(Index buffer)中的索引值最大为65536，顶点数组的大小如果超过65536，就超出了index的表示范围。因此，Unity的解决方法是</p>
<ol>
<li><p>对于这种情况，Submesh设置一个BaseVertex，其索引值为对这个值的偏移值。</p>
</li>
<li><p>设置indexFormat为32bit的intzhi</p>
</li>
</ol>
<h3 id="normals"><a href="#normals" class="headerlink" title="normals"></a>normals</h3><p>每个顶点对应一个法线，即顶点所在平面的法线</p>
<ul>
<li><p>法线是垂直于面的向量。我们通常使用单位长度的法向量，并向量指向面的外部，而不是内部。</p>
</li>
<li><p>法线可以用于确定光线与顶点的夹角。这个细节的使用取决于Shader。</p>
</li>
</ul>
<blockquote>
<p>作为三角面它永远是平的，因此它不应该需要被提供一个单独的法线信息。然而，我们需要造假。在现实中，顶点是不存在法线的，三角面才有。通过附加自定义顶点法线和三角面插着，我们可以奖状我们有一个平滑的曲面代替一堆平的三角面。这个错觉是令人信服的，只要你不去注意网格锋利的轮廓（锯齿）。</p>
</blockquote>
<p>法线用于规定每个顶点，所以我们必须填充另一个向量数组。另一种选择，我们可以依据网格的三角面来计算出法线。</p>
<h3 id="Tangent"><a href="#Tangent" class="headerlink" title="Tangent"></a>Tangent</h3><blockquote>
<p>tangent: 切线，切面，正切</p>
</blockquote>
<p>法线贴图在切线空间中定义。<br>所以切线是一个三维向量，但是在Unity中它是使用四维向量定义的。第四个值通常是1或者-1，用于控制第三切线空间唯独方向-朝前或朝后,这有助于展示法线贴图，通常用于左右对称的3D模型，像人一样。Untiy的shader执行此计算要求我们使用-1。</p>
<h4 id="法线贴图-Normal-Map"><a href="#法线贴图-Normal-Map" class="headerlink" title="法线贴图(Normal Map)"></a>法线贴图(Normal Map)</h4><p>使用颜色值记录了法相向量</p>
<h3 id="UV坐标-纹理坐标"><a href="#UV坐标-纹理坐标" class="headerlink" title="UV坐标(纹理坐标)"></a>UV坐标(纹理坐标)</h3><p>UV mapping is the 3D modeling process of projecting a 2D image to a 3D model’s surface for <strong>texture mapping</strong>. </p>
<blockquote>
<p>The letters “U” and “V” denote the axes of the 2D texture because “X”, “Y”, and “Z” are already used to denote the axes of the 3D object in model space, while “W” (in addition to XYZ) is used in calculating quaternion rotations, a common operation in computer graphics.</p>
</blockquote>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>U3D中的 <strong>纹理贴图的原理</strong> 应该是你的模型坐标进过顶点变化到投影坐标系，然后在接下来的片段着色的时候通过传递过来的UV值用<code>tex2D(_texName, UV)</code>来获取颜色值，然后渲染到屏幕上。</p>
<p>UV坐标通常在(0,0)到(1,1)之间，它覆盖了整个纹理。超出范围的坐标将造成 <strong>clamped</strong> 或者 <strong>Tiling</strong> 平铺的效果，这去取决于纹理设置。</p>
<h4 id="uv、uv2、uv3、uv4"><a href="#uv、uv2、uv3、uv4" class="headerlink" title="uv、uv2、uv3、uv4"></a>uv、uv2、uv3、uv4</h4><p>如果在模型导入时就存在 uv2，uv3，uv4，那么这是因为在建模软件中添加了这些顶点属性。<br>uv2通常被用于Lightmap，uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。<br>一般来说uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。</p>
<h3 id="colors属性"><a href="#colors属性" class="headerlink" title="colors属性"></a>colors属性</h3><p>在一些建模软件中导出的网格模型(Mesh)可能会带有colors属性，描述每个顶点的颜色。有些Shader可以使用这个属性进行运算与着色。然而很多时候colors属性是用不到的， <strong>如Unity标准着色器就不使用这个属性</strong> 。</p>
<blockquote>
<p>Most shaders choose to ignore vertex color, with exception of sprites shader.<br> 大多数着色器选择忽略顶点颜色，但精灵着色器除外<br> <a href="https://stackoverflow.com/questions/34460587/unity-changing-only-certain-part-of-3d-models-color" target="_blank" rel="noopener">https://stackoverflow.com/questions/34460587/unity-changing-only-certain-part-of-3d-models-color</a></p>
</blockquote>
<p>colors属性与tangents属性一样，如果网格顶点拥有该属性，同样会对内存、物理体积和加载性能造成影响。</p>
<p>默认情况下，在3d建模软件中并不会导出Color属性。以3ds max为例，Color通常是通过modifier添加的，因此只需要在导出前将其删除即可。<br>去除方法：<a href="https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf</a></p>
<blockquote>
<p>注意：切忌将不同属性的网格模型拼合在一起。举个例子 ，100个网格模型进行Static Batching，如果99个模型只有Position和UV两种属性，而剩下1个模型函数有Position、UV、Normal、Tangent和Color五种属性。那么引擎在进行拼合时，会将前99个模型的顶点属性补齐，然后再进行拼合。这样无形中会增加大量的内存占用，从而造成不必要的内存浪费。</p>
</blockquote>
<h3 id="无用属性的去除方法"><a href="#无用属性的去除方法" class="headerlink" title="无用属性的去除方法"></a>无用属性的去除方法</h3><p>1.如果有3dmax的源文件，可以直接在3dmax里操作，在那个channelinfo—清掉那个vc<br>2.如果只有fbx，或者这类文件太多，可以直接下载一个fbx的sdk，拿里面的例子改一下，生成一个exe。然后在unity里直接调用就行了。<br>其实从外包回来的fbx，一般都有问题，要么顶点色，要么会出现uv3、uv4。我这里附上工具和c++、及在unity调用的代码，你可以试一下。如果运行不了，缺dll，你就到网上找一下，多半可以用。 clear_fbx_clr_uv_tool.rar<br>注意这个工具会清掉顶点色和uv3、uv4！！<br>3.印象中在unity里也可以直接清顶点色，好像是meshfiter那里把colors直接置空，再重新保存回去。</p>
<h2 id="Unity-Mesh-API"><a href="#Unity-Mesh-API" class="headerlink" title="Unity Mesh API"></a>Unity Mesh API</h2><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>(1) vertices 网格顶点数组;<br>(2) normals 网格的法线数组;<br>(3) tangents 网格的切线数组;<br>(4) uv 网格的基础纹理坐标;<br>(5) uv2 网格设定的第二个纹理坐标;<br>(6) bounds 网格的包围盒;<br>(7) Colors 网格的顶点颜色数组;<br>(8) triangles 包含所有三角形的顶点索引数组;<br>(9) vectexCount 网格中的顶点数量(只读的);<br>(10) subMeshCount 子网格的数量，每个材质都有一个独立的网格列表;<br>(11) bonesWeights: 每个顶点的骨骼权重;<br>(12) bindposes: 绑定姿势，每个索引绑定的姿势使用具有相同的索引骨骼;</p>
<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>(1) Clear 清空所有的顶点数据和所有的三角形索引;<br>(2) RecalculateBounds 重新计算网格的包围盒;<br>(3) RecalculateNormals 重新计算网格的法线;<br>(4) Optimze 显示优化的网格;<br>(5) GetTriangles 返回网格的三角形列表;<br>(6) SetTriangles 为网格设定三角形列表;<br>(7) CominMeshes组合多个网格到同一个网格;</p>
<h2 id="Model-Import-Settings"><a href="#Model-Import-Settings" class="headerlink" title="Model Import Settings"></a>Model Import Settings</h2><h3 id="Mesh-Compression（通常禁用，优化渲染和发布文件大小时启用）"><a href="#Mesh-Compression（通常禁用，优化渲染和发布文件大小时启用）" class="headerlink" title="Mesh Compression（通常禁用，优化渲染和发布文件大小时启用）"></a>Mesh Compression（通常禁用，优化渲染和发布文件大小时启用）</h3><p>启用网格压缩，unity会按照一定的级别来压缩网格数据，压缩级别越高，网格的精度越低，这对于渲染优化和发布时游戏文件大小的降低很有用，但可能会导致失真。官方的想法是，尽可能的压缩网格，只要模型看起来不至于太奇怪。</p>
<h3 id="Optimize-Mesh"><a href="#Optimize-Mesh" class="headerlink" title="Optimize Mesh"></a>Optimize Mesh</h3><p>优化网格，如果开启，网格的定点和三角形会按照U3D既定的一套规则重新排序用以提高GPU性能。<br>The Optimize Meshes option in a mesh’s import settings will reorganize the vertex data for quicker readability, and sometimes regenerate the low-level rendering style (down to the level of points versus tris versus strips) to optimize the rendering speed of the mesh.</p>
<p>该优化方法也可以在代码中调用：</p>
<pre><code class="lang-csharp">
Mesh mesh = gameObject.GetComponent&lt;MeshFilter&gt;().mesh; 

mesh.Optimize();
</code></pre>
<p>This function causes the geometry and vertices of the mesh to be reordered internally in an attempt to improve vertex cache utilisation on the graphics hardware and thus rendering performance.<br>This operation can take a few seconds or more for complex meshes and should only be used where <strong>the ordering of the geometry and vertices is not significant</strong> as both will change.<br>理论上如果模型对顶点和面片顺序没有要求的话，不会导致显示问题。</p>
<h2 id="相关组件-Components"><a href="#相关组件-Components" class="headerlink" title="相关组件(Components)"></a>相关组件(Components)</h2><h3 id="MeshFiler组件"><a href="#MeshFiler组件" class="headerlink" title="MeshFiler组件"></a>MeshFiler组件</h3><p>MeshFilter 这个组件记录了你想要展示的网格数据</p>
<h3 id="MeshRender组件"><a href="#MeshRender组件" class="headerlink" title="MeshRender组件"></a>MeshRender组件</h3><p>MeshRenderer 使用这个组件告诉网格如何渲染，比如使用哪个材质球，是否接受阴影和其他设置。</p>
<h2 id="Mesh-SubMesh与Material"><a href="#Mesh-SubMesh与Material" class="headerlink" title="Mesh, SubMesh与Material"></a>Mesh, SubMesh与Material</h2><p>在Unity3D中一个Mesh里可以有多个SubMesh，引擎在渲染的时候，每个SubMesh都需要对应一个Material材质球来匹配做渲染。当Mesh有多个SubMesh时，Unity会默认Mesh有相应数量的Materials，Mesh与Material按照相应的顺序一一对应。</p>
<p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1618210128127.png)</p>
<p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1618210138491.png)</p>
<p>如果mesh没有submesh的话，多个材质球就是会渲染多遍，使用的对象就是当前的这个mesh。</p>
<h3 id="拆分SubMesh的意义"><a href="#拆分SubMesh的意义" class="headerlink" title="拆分SubMesh的意义"></a>拆分SubMesh的意义</h3><ol>
<li><p>3D模型制作人员在制作模型的时候，希望一个模型中一部分Mesh用一种材质球来表现效果，另一部分Mesh则用另一种材质球来表现效果，这时就需要将模型拆分开来。因为一个Mesh只能对应一个材质球做渲染，一个材质球只能表现一种效果，当他们需要表现两种完全不同的效果时就需要拆分。</p>
</li>
<li><p>模型中的某部分的贴图，在众多模型中共同使用的频率比较高，为了不重复制作以及减少重复劳动，那么就会让原本可以整体的模型单独拆分出来一部分公共材质的部分让它们都使用同一个材质球。</p>
</li>
<li><p>在制作动画时，由于动画过于复杂导致如果使用同一个模型去表现的话，骨骼数量就会成倍增加。为了能更好的表现动画，也为了能更节省骨骼的使用量，拆分出一部分模型让他们单独成为模型动画的一部分。</p>
</li>
</ol>
<p>拥有多个SubMesh一样可以有动画，另外它还能针对不同部分的Mesh选择有个性化的材质球来表现效果，从功能上来看比单个Mesh要灵活的多。</p>
<h3 id="多个SubMesh的缺点"><a href="#多个SubMesh的缺点" class="headerlink" title="多个SubMesh的缺点"></a>多个SubMesh的缺点</h3><ul>
<li><p>由于每个SubMesh都多出了材质球，导致SubMesh越多，增加的Drawcall也越多。</p>
</li>
<li><p>Mesh中存在多个SubMesh，在动作和拆分材质球渲染上确实有很好的优势，但无法与其他Mesh合并，导致优化的一个重要环节被阻断。</p>
</li>
</ul>
<h3 id="CombineMesh-in-Unity"><a href="#CombineMesh-in-Unity" class="headerlink" title="CombineMesh in Unity"></a>CombineMesh in Unity</h3><pre><code class="lang-csharp">
void CombineMesh()

{ 

MeshFilter[] mfs = GetComponentsInChildren&lt;MeshFilter&gt;(); 

CombineInstance[] combine = new CombineInstance[mfs.Length]; 

Mesh newMesh = new Mesh(); 

for(int i= 0; i&lt;mfs.Length; i++) 

{ 

combine[i].mesh = mfs[i].sharedMesh; 

combine[i].transform = mfs[i].transform.localToWorldMatrix; 

combine[i].subMeshIndex = i;//标识Material的索引位置，可以为0，1，2等

} 

newMesh.CombineMeshes(combine); 

AssetDatabase.CreateAsset(newMesh, &quot;Assets/TestTRS/NewMesh.mesh&quot;); 

}
</code></pre>
<h2 id="Mesh的渲染"><a href="#Mesh的渲染" class="headerlink" title="Mesh的渲染"></a>Mesh的渲染</h2><h3 id="Mesh的坐标与bounds"><a href="#Mesh的坐标与bounds" class="headerlink" title="Mesh的坐标与bounds"></a>Mesh的坐标与bounds</h3><ul>
<li><p>每个Mesh都有Bounds属性，表示Mesh的包围盒。</p>
</li>
<li><p>Unity一个节点在Scene界面的坐标原点，取的是能包含所有子物体的bounds的bounds的中心。也就是对所有子物体的bounds进行Encapsulate后，求得一个大Bounds，取其中心。</p>
</li>
<li><p>修改Mesh的vertices坐标后，Unity并不会重新计算bounds。将修改后的Mesh创建出来，Unity会采用修改前的bounds来计算坐标原点的位置。</p>
</li>
</ul>
<p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1616555830226.png)<br><strong>因此，修改了Mesh的vertices属性后，需要调用RecalculateBounds才能保证包围盒的正确性。</strong></p>
<p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1616555982837.png)</p>
<h4 id="Mesh顶点整体偏移问题及Matrix4x4修正"><a href="#Mesh顶点整体偏移问题及Matrix4x4修正" class="headerlink" title="Mesh顶点整体偏移问题及Matrix4x4修正"></a>Mesh顶点整体偏移问题及Matrix4x4修正</h4><p>如图，世界空间的坐标原点是Cube所在的位置，而将左边的物体A的Position设置为(0, 0, 0)，看起来却回不到世界坐标原点的位置。</p>
<p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1616556303175.png)</p>
<p><img src="Mesh in U3D\(ToUpdate\" alt="Alt text"><br>_files/1616556368115.png)<br>实质上，该GameObject的坐标值确实是世界坐标的原点，而由于Mesh的所有顶点都相对局部坐标原点有一个偏移，因此，Mesh显示的位置不在坐标原点，并且Scene界面的显示的模型坐标系采取的是Mesh的bounds的中心。</p>
<p>修正方法：修改Mesh的vertices，将顶点位置改变，是顶点的bounds的中心回到(0, 0, 0)。</p>
<p>求得当前的bounds的中心center，该center是相对坐标原点有一定的偏移的，使用<code>Matrix4x4.Translate(-center)</code>，即可将所有顶点都进行平移，抵消之前的偏移。</p>
<p>注意：Translate之后，需要重新计算bounds。</p>
<pre><code class="lang-csharp">
void ModifyMesh()

{ 

Mesh mesh = GetComponent&lt;MeshFilter&gt;().sharedMesh; 

mesh.RecalculateBounds(); 

Vector3 center = mesh.bounds.center; 

var m = Matrix4x4.Translate(-center); 

Vector3[] oldVertices = mesh.vertices; 

Vector3[] newVertices = new Vector3[oldVertices.Length]; 

for(int i=0; i&lt;oldVertices.Length; i++) 

{ 

newVertices[i] = m.MultiplyPoint(oldVertices[i]); 

} 

mesh.vertices = newVertices; 

mesh.RecalculateBounds(); 

GetComponent&lt;MeshFilter&gt;().sharedMesh = mesh; 

AssetDatabase.CreateAsset(mesh, &quot;Assets/MeshModified.mesh&quot;); 

}
</code></pre>
<h2 id="Mesh编程"><a href="#Mesh编程" class="headerlink" title="Mesh编程"></a>Mesh编程</h2><h3 id="画面片"><a href="#画面片" class="headerlink" title="画面片"></a>画面片</h3><pre><code class="lang-csharp">
using UnityEngine; 

using UnityEditor; 

using System.Collections; 

public class GenMesh

{ 

[MenuItem(&quot;MeshEditor/GenMesh&quot;)] 

static public void GenMeshM()

{ 

Mesh m1 = CreateRect(); 

AssetDatabase.CreateAsset(m1, &quot;Assets/models/m1.asset&quot;); 

} 

public static Mesh CreateRect()

{ 

Mesh mesh = new Mesh(); 

int particleNum = 10; 

//顶点坐标

Vector3[] verts = new Vector3[4 * particleNum]; 

//uv坐标

Vector2[] uvs = new Vector2[4 * particleNum]; 

//三角形索引

int[] tris = new int[2 * 3 * particleNum]; 

Vector3 position; 

for (int i = 0; i &lt; particleNum; i++) 

{ 

int i4 = i * 4; 

int i6 = i * 6; 

position.x = 5 * i; 

position.y = 5 * i; 

position.z = 0; 

//顶点坐标

verts[i4 + 0] = position; 

verts[i4 + 1] = position + new Vector3(2, 0, 0); 

verts[i4 + 2] = position + new Vector3(2, 2, 0); 

verts[i4 + 3] = position + new Vector3(0, 2, 0); 

//四个顶点在UV坐标系中的位置

uvs[i4 + 0] = new Vector2(0.0f, 0.0f); 

uvs[i4 + 1] = new Vector2(1.0f, 0.0f); 

uvs[i4 + 2] = new Vector2(1.0f, 1.0f); 

uvs[i4 + 3] = new Vector2(0.0f, 1.0f); 

//顺时针绘制三角形0 1 2 / 0 2 3

tris[i6 + 0] = i4 + 0; 

tris[i6 + 1] = i4 + 1; 

tris[i6 + 2] = i4 + 2; 

tris[i6 + 3] = i4 + 0; 

tris[i6 + 4] = i4 + 2; 

tris[i6 + 5] = i4 + 3; 

} 

mesh.vertices = verts; 

mesh.triangles = tris; 

mesh.uv = uvs; 

mesh.RecalculateBounds(); 

return mesh; 

} 

}
</code></pre>
<h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><pre><code class="lang-csharp">
#region 画圆

/// &lt;summary&gt;

/// 画圆

/// &lt;/summary&gt;

/// &lt;param name=&quot;radius&quot;&gt;圆的半径&lt;/param&gt;

/// &lt;param name=&quot;segments&quot;&gt;圆的分割数&lt;/param&gt;

/// &lt;param name=&quot;centerCircle&quot;&gt;圆心得位置&lt;/param&gt;

void DrawCircle(float radius, int segments, Vector3 centerCircle)

{ 

gameObject.AddComponent&lt;MeshFilter&gt;(); 

gameObject.AddComponent&lt;MeshRenderer&gt;(); 

gameObject.GetComponent&lt;MeshRenderer&gt;().material = mat; 

//顶点

Vector3[] vertices = new Vector3[segments + 1]; 

vertices[0] = centerCircle; 

float deltaAngle = Mathf.Deg2Rad * 360f / segments; 

float currentAngle = 0; 

for (int i = 1; i &lt; vertices.Length; i++) 

{ 

float cosA = Mathf.Cos(currentAngle); 

float sinA = Mathf.Sin(currentAngle); 

vertices[i] = new Vector3(cosA * radius + centerCircle.x, sinA * radius + centerCircle.y, 0); 

currentAngle += deltaAngle; 

} 

//三角形

int[] triangles = new int[segments * 3]; 

for (int i = 0, j = 1; i &lt; segments * 3 \- 3; i += 3, j++) 

{ 

triangles[i] = 0; 

triangles[i + 1] = j + 1; 

triangles[i + 2] = j; 

} 

triangles[segments * 3 \- 3] = 0; 

triangles[segments * 3 \- 2] = 1; 

triangles[segments * 3 \- 1] = segments; 

Vector2[] uvs = new Vector2[vertices.Length]; 

for (int i = 0; i &lt; vertices.Length; i++) 

{ 

uvs[i] = new Vector2(vertices[i].x / radius / 2 \+ 0.5f, vertices[i].y / radius / 2 \+ 0.5f); 

} 

Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh; 

mesh.Clear(); 

mesh.vertices = vertices; 

mesh.triangles = triangles; 

mesh.uv = uvs; 

} 

#endregion
</code></pre>
<h3 id="画圆环"><a href="#画圆环" class="headerlink" title="画圆环"></a>画圆环</h3><pre><code class="lang-csharp">
#region 画圆

/// &lt;summary&gt;

/// 画圆

/// &lt;/summary&gt;

/// &lt;param name=&quot;radius&quot;&gt;圆的半径&lt;/param&gt;

/// &lt;param name=&quot;segments&quot;&gt;圆的分割数&lt;/param&gt;

/// &lt;param name=&quot;centerCircle&quot;&gt;圆心得位置&lt;/param&gt;

void DrawCircle(float radius, int segments, Vector3 centerCircle)

{ 

gameObject.AddComponent&lt;MeshFilter&gt;(); 

gameObject.AddComponent&lt;MeshRenderer&gt;(); 

gameObject.GetComponent&lt;MeshRenderer&gt;().material = mat; 

//顶点

Vector3[] vertices = new Vector3[segments + 1]; 

vertices[0] = centerCircle; 

float deltaAngle = Mathf.Deg2Rad * 360f / segments; 

float currentAngle = 0; 

for (int i = 1; i &lt; vertices.Length; i++) 

{ 

float cosA = Mathf.Cos(currentAngle); 

float sinA = Mathf.Sin(currentAngle); 

vertices[i] = new Vector3(cosA * radius + centerCircle.x, sinA * radius + centerCircle.y, 0); 

currentAngle += deltaAngle; 

} 

//三角形

int[] triangles = new int[segments * 3]; 

for (int i = 0, j = 1; i &lt; segments * 3 \- 3; i += 3, j++) 

{ 

triangles[i] = 0; 

triangles[i + 1] = j + 1; 

triangles[i + 2] = j; 

} 

triangles[segments * 3 \- 3] = 0; 

triangles[segments * 3 \- 2] = 1; 

triangles[segments * 3 \- 1] = segments; 

Vector2[] uvs = new Vector2[vertices.Length]; 

for (int i = 0; i &lt; vertices.Length; i++) 

{ 

uvs[i] = new Vector2(vertices[i].x / radius / 2 \+ 0.5f, vertices[i].y / radius / 2 \+ 0.5f); 

} 

Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh; 

mesh.Clear(); 

mesh.vertices = vertices; 

mesh.triangles = triangles; 

mesh.uv = uvs; 

} 

#endregion
</code></pre>
<h3 id="Mesh顶点编辑器"><a href="#Mesh顶点编辑器" class="headerlink" title="Mesh顶点编辑器"></a>Mesh顶点编辑器</h3><p>摘自：<a href="https://gameinstitute.qq.com/community/detail/129174" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/129174</a><br>思路：获取mesh上的所有顶点，然后在每个顶点位置创建一个控制点，控制点可以是任意你喜欢的物体，通过判断控制点的位置信息来修改mesh的顶点位置。<br>把每个顶点的坐标转为字符串，使用该坐标的字符串作为 <strong>key</strong> 来把 <strong>控制点</strong> 与 <strong>顶点数据</strong> 联系起来。</p>
<hr>
<p>控制点：</p>
<pre><code class="lang-csharp">
using System.Collections; 

using System.Collections.Generic; 

using UnityEngine; 

public class MeshEditorPoint : MonoBehaviour ｛ 

//顶点id，（顶点初始位置转字符串）

[HideInInspector] public string pointid; 

//记录坐标点上一次移动的位置，用于判断控制点是否移动

[HideInInspector] private Vector3 lastPosition; 

public delegate void MoveDelegate(string pid,Vector3 pos); 

//控制点移动时的回调

public MoveDelegate onMove = null; 

// Use this for initialization

void Start () ｛

lastPosition = transform.position; 

｝ 

// Update is called once per frame

void Update () ｛

if(transform.position != lastPosition)｛

if(onMove != null) onMove(pointid, transform.localPosition); 

lastPosition = transform.position; 

｝ 

｝ 

｝
</code></pre>
<hr>
<p>顶点编辑器</p>
<pre><code class="lang-csharp">
using System.Collections; 

using System.Collections.Generic; 

using UnityEngine; 

using System.Text; 

using System; 

public class ModelMeshEditor : MonoBehaviour ｛ 

//控制点的大小

public float pointScale = 1.0f; 

private float lastPointScale = 1.0f; 

Mesh mesh; 

//顶点列表

List&lt;Vector3&gt; positionList = new List&lt;Vector3&gt;(); 

//顶点控制物体列表

List&lt;GameObject&gt; positionObjList = new List&lt;GameObject&gt;(); 

/// &lt;summary&gt;

/// key:顶点字符串

/// value:顶点在列表中的位置

/// &lt;/summary&gt;

Dictionary&lt;string, List&lt;int&gt;&gt; pointmap = new Dictionary&lt;string, List&lt;int&gt;&gt;(); 

// Use this for initialization

void Start () ｛

lastPointScale = pointScale; 

mesh = GetComponent&lt;MeshFilter&gt;().sharedMesh; 

CreateEditorPoint(); 

｝ 

//创建控制点

public void CreateEditorPoint()｛

positionList = new List&lt;Vector3&gt;(mesh.vertices); 

for (int i = 0; i &lt; mesh.vertices.Length; i++) 

｛ 

string vstr = Vector2String(mesh.vertices[i]); 

if(!pointmap.ContainsKey(vstr))｛ 

pointmap.Add(vstr,new List&lt;int&gt;()); 

｝ 

pointmap[vstr].Add(i); 

｝ 

foreach (string key in pointmap.Keys) 

｛ 

GameObject editorpoint = (GameObject)Resources.Load(&quot;Prefabs/MeshEditor/MeshEditorPoint&quot;); 

editorpoint = Instantiate(editorpoint); 

editorpoint.transform.parent = transform; 

editorpoint.transform.localPosition = String2Vector(key); 

editorpoint.transform.localScale = new Vector3(1f, 1f, 1f); 

MeshEditorPoint editorPoint = editorpoint.GetComponent&lt;MeshEditorPoint&gt;(); 

editorPoint.onMove = PointMove; 

editorPoint.pointid = key; 

positionObjList.Add(editorpoint); 

｝ 

｝ 

//顶点物体被移动时调用此方法

public void PointMove(string pointid,Vector3 position)｛

if(!pointmap.ContainsKey(pointid))｛

return; 

｝ 

List&lt;int&gt; _list = pointmap[pointid]; 

for (int i = 0; i &lt; _list.Count; i ++)｛ 

positionList[_list[i]] = position; 

｝ 

mesh.vertices = positionList.ToArray(); 

mesh.RecalculateNormals(); 

｝ 

// Update is called once per frame

void Update () ｛

//检测控制点尺寸是否改变

if (Math.Abs(lastPointScale - pointScale) &gt; 0.1f)｛

lastPointScale = pointScale; 

for (int i = 0; i &lt; positionObjList.Count; i ++)｛ 

positionObjList[i].transform.localScale = new Vector3(pointScale, pointScale, pointScale); 

｝ 

｝ 

｝ 

string Vector2String(Vector3 v)｛

StringBuilder str = new StringBuilder(); 

str.Append(v.x).Append(&quot;,&quot;).Append(v.y).Append(&quot;,&quot;).Append(v.z); 

return str.ToString(); 

｝ 

Vector3 String2Vector(string vstr)

｛

try｛

string[] strings = vstr.Split(&#39;,&#39;); 

return new Vector3(float.Parse(strings[0]), float.Parse(strings[1]), float.Parse(strings[2])); 

｝catch(Exception e)｛ 

Debug.LogError(e.ToString()); 

return Vector3.zero; 

｝ 

｝ 

｝
</code></pre>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="3D建模软件"><a href="#3D建模软件" class="headerlink" title="3D建模软件"></a>3D建模软件</h3><p>1:Autodesk 3D Studio Max 支持mac os windows;<br>2: Autodesk 3D Maya 支持windows<br>3: Cinema4D 支持mac os windows<br>4: Blender 开源跨平台的全能三维制作软件, 支持mac os windows, linux;<br>5: Cheetah3D: 支持mac os<br>6: Unity与建模软件的单位比例:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>软件</th>
<th>内部米</th>
<th>导入unity后的尺寸/m</th>
<th>与Unity单位的比例关系  </th>
</tr>
</thead>
<tbody>
<tr>
<td>3Dmax</td>
<td>1</td>
<td>0.01</td>
<td>100:1  </td>
</tr>
<tr>
<td>Maya</td>
<td>1</td>
<td>0.01</td>
<td>1:100  </td>
</tr>
<tr>
<td>Cinema 4D</td>
<td>1</td>
<td>0.01</td>
<td>1:100  </td>
</tr>
<tr>
<td>Light Wave</td>
<td>1</td>
<td>0.01</td>
<td>100:1  </td>
</tr>
</tbody>
</table>
</div>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://www.cnblogs.com/zhanghaipeng-Unity3D/p/4714973.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhanghaipeng-Unity3D/p/4714973.html</a><br><a href="https://blog.csdn.net/qq_29579137/article/details/77369734" target="_blank" rel="noopener">https://blog.csdn.net/qq_29579137/article/details/77369734</a><br><a href="https://www.bbsmax.com/A/QV5ZQvObJy/" target="_blank" rel="noopener">https://www.bbsmax.com/A/QV5ZQvObJy/</a><br><a href="https://blog.csdn.net/nanggong/article/details/54728823" target="_blank" rel="noopener">https://blog.csdn.net/nanggong/article/details/54728823</a><br><a href="https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf" target="_blank" rel="noopener">https://answer.uwa4d.com/question/5a8f77970b827e2c0bfdcfaf</a></p>
<p><a href="http://www.luzexi.com/2018/08/03/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB2" target="_blank" rel="noopener">http://www.luzexi.com/2018/08/03/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB2</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Material"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Material/"
    >Material</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Material/" class="article-date">
  <time datetime="2023-07-25T12:56:23.254Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>材质是一个数据集，主要功能就是给渲染器提供数据和光照算法。贴图就是其中数据的一部分，根据用途不同，贴图也会被分成不同的类型，比方说 Diffuse Map，Specular Map，Normal Map 和 Gloss Map 等等。另外一个重要部分就是光照模型 Shader ，用以实现不同的渲染效果。</p>
<p>将输入的贴图或者颜色，加上对应的Shader，以及对Shader的特定的参数设置，将这些打包在一起就是一个材质了。之后，我们便可以将材质赋予合适的renderer（渲染器）来进行渲染。</p>
<h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3><p>所谓 <strong>着色器(Shader)</strong> 实际上就是一小段程序，它负责将输入的网格(Mesh)以指定的方式和输入的贴图或者颜色等组合作用，然后输出，绘图单元可以依据这个输出来将图像绘制到屏幕上。着色器是一种可以精确控制材质球的工具，通过贴图和着色器的配合开发人员可以创造出非常逼真的模型</p>
<h3 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h3><p>Ref: <a href="https://blog.csdn.net/yuyingwin/article/details/80534970" target="_blank" rel="noopener">https://blog.csdn.net/yuyingwin/article/details/80534970</a></p>
<p>FX: Lighting and glass effects.( 灯光、玻璃)<br>GUI and UI: For user interface graphics.(用于用户界面图形)<br>Mobile: Simplified high-performance shader for mobile devices.(针对移动设备的简化的高性能着色器)<br>Nature: For trees and terrain.(适用于树木和地形)<br>Particles: Particle system effects.(粒子系统特效)<br>Skybox: For rendering background environments behind all geometry(用于渲染所有几何背后的背景环境)<br>Sprites: For use with the 2D sprite system(用于2D精灵系统)<br>Toon: Cartoon-style rendering.(卡通 风格 渲染)<br>Unlit: For rendering that entirely bypasses all light &amp; shadowing(渲染完全绕过所有光影)<br>Legacy: The large collection of older shaders which were superseded by the Standard Shader(被标准着色器取代的大型着色器集合)</p>
<h3 id="Standard-Shader"><a href="#Standard-Shader" class="headerlink" title="Standard Shader"></a>Standard Shader</h3><h4 id="Rendering-Mode"><a href="#Rendering-Mode" class="headerlink" title="Rendering Mode"></a>Rendering Mode</h4><p>Opaque(不透明的)：是默认设置，适用于没有透明区域的普通固体物体<br>Cutout：允许您创建在不透明区域和透明区域之间具有坚硬边缘的透明效果。在这种模式下，没有半透明区域，纹理是100％不透明或不可见的。当使用透明度来创建材质的形状（例如树叶或带孔洞和布块的布料）时，此功能非常有用<br>Transparent：适用于渲染逼真的透明材料，如透明塑料或玻璃。在这种模式下，材质本身会采用透明度值（基于纹理的alpha通道和色调的alpha），但反射和照明高光将以完全清晰的方式保持可见状态，就像真正的透明材质一样<br>Fade：允许透明度值完全淡出对象，包括任何高光反射或可能有的反射。如果您想要将对象淡入或淡出，则此模式非常有用。它不适合渲染逼真的透明材料，如透明塑料或玻璃，因为反射和高光也会消失</p>
<h4 id="Albedo基础贴图"><a href="#Albedo基础贴图" class="headerlink" title="Albedo基础贴图"></a>Albedo基础贴图</h4><p>需要一个“纹理”或是多个这个跟你所需要的Shder有关。</p>
<h4 id="Metallic金属"><a href="#Metallic金属" class="headerlink" title="Metallic金属"></a>Metallic金属</h4><p>Metallic 指出材料是否是金属材质。在金属材料的情况下，Albedo 颜色控制镜面反射的颜色，而大部分光纤将反射未镜面反射。非金属材料将具有与入射光线相同的颜色的镜面反射，并在表面时几乎不会反射。</p>
<p>纹理(Texture) Metallic 分配参数时，Metallic和smoothness 滑块将消失， 材质的金属级别由纹理的红色通道中的值控制(通道一般由 黑、白、灰构成，偏白反射越高)，材质的smoothness级别由纹理的Alpha通道控制.(这以为这 绿色 和 蓝色 通道 被忽略)</p>
<ul>
<li><p>Specular/Metallic Alpha：曲面每个点的平滑度都是单个值，因此数据只需要图像纹理的单个通道。因此。平滑度数据被假定存储在用于Metallic或specular纹理贴图的相同图像纹理的Alpha通道中</p>
</li>
<li><p>Albedo Alpha: 减少纹理的总数，也可以使用不同分辨率的纹理进行Smoothness和Specular/Metallic</p>
</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>HeightMap：高度映射图；灰度图。白色区域代表纹理的高区域，黑色代表低区域。白色的部分纹理偏移大。<br>OcclussionMap: 遮挡贴图. 提供模型的哪些区域接收 高或低 间接光照的信息。OcclussionMap 是灰度图像. 白色表示应该接受完全间接照明的区域，而黑色表示没有间接照明。<br>Emission：发光，控制从表面发射的光的颜色和强度。如果分配给了纹理贴图，则 纹理的全色值将用于发射颜色和亮度。Emission数字之字段仍然存在，可以将其用作乘数来提高或降低材料的整体发光水平。 该处纹理 贴图 必须 背景色是黑色，前景色是非黑色(充满 R,G,B)的才会叠加到Aledo的图片上。None：对象将显示为发射型，但附近物体的照明不受影响 。RealTime：来自此材质的发射光将被添加到场景的实时全局照明计算中，因此附近物体（甚至移动物体）的照明将受到发射光线的影响。 baked：来自这种材料的发射光将被烘焙成场景的静态光照贴图，因此其他附近的静态物体将显示为被该材料点亮，但动态物体不会受到影响。<br>DetailMaps：在Aledo纹理贴图上增添细节贴图；DetailMask：给DetailMaps 添加遮罩，限制细节的显示位置 。 </p>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><ul>
<li><p>Specular镜面反射：使用镜面特性模拟外观</p>
</li>
<li><p>Smoothness 光滑度：设置物体表面的光滑程度</p>
</li>
<li><p>Normal Map法线贴图：描述物体表面的凹凸程度</p>
</li>
<li><p>Emission自发光：控制物体表面自发光的颜色和贴图</p>
<ul>
<li><p>None不影响环境</p>
</li>
<li><p>Realtime实时动态改变</p>
</li>
</ul>
</li>
<li><p>Tiling平铺：沿着不同的轴，纹理平铺个数</p>
</li>
<li><p>Office偏移：滑动纹理</p>
</li>
</ul>
<h4 id="Standard-Specular-setup"><a href="#Standard-Specular-setup" class="headerlink" title="Standard(Specular setup)"></a>Standard(Specular setup)</h4><p>为经典方法选择此着色器。镜面反射颜色用于控制材料中镜面单摄的颜色和强度。例如：这使得有可能具有漫反射不同的颜色的镜面反射。<br>将纹理(Texture)分配给Specular参数时，Specular参数和Smoothness滑块均消失。相反，材质的镜面反射水平由纹理本身的红色，绿色和蓝色通道中的值控制，而光滑度材质的等级由相同纹理的Alpha通道控制。这里，镜面反射和平滑度由颜色和平滑度滑块定义。</p>
<p>tiling缩放：表示贴图在UV坐标的缩放倍数</p>
<h3 id="加载Material"><a href="#加载Material" class="headerlink" title="加载Material"></a>加载Material</h3><pre><code class="lang-csharp">
Material mat = Resources.Load&lt;Material&gt;(&quot;shader path&quot;); 

``` ```csharp 

Material mat = new Material(Shader.Find(&quot;shadername&quot;));
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Unity3D-Map及其与Material、Texture的关系"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/Unity3D-Map%E5%8F%8A%E5%85%B6%E4%B8%8EMaterial%E3%80%81Texture%E7%9A%84%E5%85%B3%E7%B3%BB/"
    >Map及其与Material、Texture的关系</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-Map%E5%8F%8A%E5%85%B6%E4%B8%8EMaterial%E3%80%81Texture%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time datetime="2023-07-25T12:56:23.253Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote>
<p>贴图的英语 Map 其实包含了另一层含义就是“映射”。<br> 贴图指的是映射关系，其功能就是把纹理通过 UV 坐标映射到3D 物体表面。贴图包含了除了纹理以外其他很多信息，比方说 UV 坐标、贴图输入输出控制等等。</p>
</blockquote>
<p>UV坐标：水平方向是U，竖直方向是V。因为图片（纹理）是一个二维的平面，所以只需要UV坐标便可以确定图片的位置。（当然也有三维贴图，要用到UVW坐标，暂时还接触不到。）</p>
<h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>材质 Material包含贴图 Map，贴图包含纹理 Texture。<br>材质(Material)：物体的质地，物体看起来是什么做的<br>贴图(Map)<br>纹理(Texture)：普通的材质图片<br>贴图 + 着色器(Shader) = 材质球</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://gameinstitute.qq.com/community/detail/115074" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/115074</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/archives/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/7/">7</a><a class="page-number" href="/archives/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/archives/10/">10</a><a class="page-number" href="/archives/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/archives/13/">13</a><a class="extend next" rel="next" href="/archives/10/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>