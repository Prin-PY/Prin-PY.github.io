<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>【资源】Asset Bundle(2020-10-25 022900) |  半个出家人</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/img/circle_image.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="半个出家人" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Unity3D-【资源】Asset-Bundle-2020-10-25-022900"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  【资源】Asset Bundle(2020-10-25 022900)
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/Unity3D-%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91Asset-Bundle-2020-10-25-022900/" class="article-date">
  <time datetime="2023-07-25T12:56:23.350Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">27 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="【资源】Asset-Bundle-2020-10-25-02-29-00"><a href="#【资源】Asset-Bundle-2020-10-25-02-29-00" class="headerlink" title="【资源】Asset Bundle(2020-10-25 02:29:00)"></a>【资源】Asset Bundle(2020-10-25 02:29:00)</h1><h1 id="【资源】Asset-Bundle-2020-10-25-02-29-00-1"><a href="#【资源】Asset-Bundle-2020-10-25-02-29-00-1" class="headerlink" title="【资源】Asset Bundle(2020-10-25 02:29:00)"></a>【资源】Asset Bundle(2020-10-25 02:29:00)</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="资源加载的方式"><a href="#资源加载的方式" class="headerlink" title="资源加载的方式"></a>资源加载的方式</h3><p>Resources加载 - Resources.Load()来直接加载Resources文件夹下的资源</p>
<p>AssetBundle</p>
<p>Addressable</p>
<h4 id="Resources加载的缺点"><a href="#Resources加载的缺点" class="headerlink" title="Resources加载的缺点"></a>Resources加载的缺点</h4><ul>
<li><p>对内存管理造成一定的负担。</p>
</li>
<li><p>在打开应用时加载时间很长。</p>
</li>
<li><p>Resources文件夹下的所有资源统一合并到一个序列化文件中（可以看成统一打一个大包，巨型AB包有什么问题它就有什么问题），对资源优化有一定的限制。</p>
</li>
<li><p>不建议大量使用Resources。</p>
</li>
</ul>
<h3 id="AssetBundle是什么"><a href="#AssetBundle是什么" class="headerlink" title="AssetBundle是什么"></a>AssetBundle是什么</h3><h4 id="从资源的角度"><a href="#从资源的角度" class="headerlink" title="从资源的角度"></a>从资源的角度</h4><p>它是一个 <strong>存在于硬盘上的文件</strong> 。可以称之为 <strong>压缩包</strong> 。这个压缩包可以认为是一个文件夹，里面包含了多个文件。这些文件可以分为两类：serialized file 和 resource files。（序列化文件和源文件）</p>
<ul>
<li><p>serialized files：资源被打碎放在一个对象中，最后统一被写进一个单独的文件（只有一个）。相当于是一个头文件，里面记录了关于这个AB的相关信息，当我们调用 <strong>LoadFromFile</strong> 接口加载AB的时候实际上就是去加载的这一部分信息。这部分信息在Profiler里面的SerilizeField选项里。</p>
</li>
<li><p>resource files（Bundle Content ）：某些二进制资源（图片、声音）被单独保存，方便快速加载</p>
</li>
</ul>
<h4 id="从API的角度"><a href="#从API的角度" class="headerlink" title="从API的角度"></a>从API的角度</h4><p>它是一个AssetBundle对象，我们可以通过代码从一个特定的压缩包加载出来的对象。这个对象包含了所有我们当初添加到这个压缩包里面的内容，我们可以通过这个对象加载出来使用。</p>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ol>
<li><p>AssetBundle是一个压缩包包含模型、贴图、预制体、声音、甚至整个场景，可以在游戏运行的时候被加载；</p>
</li>
<li><p>AssetBundle自身保存着互相的依赖关系；</p>
</li>
<li><p>压缩包可以使用LZMA和LZ4压缩算法，减少包大小，更快的进行网络传输；</p>
</li>
<li><p>把一些可以下载内容放在AssetBundle里面，可以减少安装包的大小；</p>
</li>
</ol>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1616396262550.png)</p>
<h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><p>AB包数量较多，包内资源较少 - 加载一个AB包到内存的时间短，玩家不会有卡顿感，但每个资源实际上加载时间变长。热更新灵活，要更新下载的包体较小。IO次数过多，增大了硬件设备耗能和发热压力。</p>
<p>AB包数量较少，包内资源较多 - 加载一个AB包到内存的时间较长，玩家会有卡顿感，但之后包内的每个资源加载很快。热更新不灵活，要更新下载的包体较大。IO次数不多，硬件压力小。</p>
<h3 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h3><ol>
<li><p>把经常更新的资源放在一个单独的包里面，跟不经常更新的包分离</p>
</li>
<li><p>把需要同时加载的资源放在一个包里面</p>
</li>
<li><p>可以把其他包共享的资源放在一个单独的包里面</p>
</li>
<li><p>把一些需要同时加载的小资源打包成一个包</p>
</li>
<li><p>如果对于一个同一个资源有两个版本，可以考虑通过后缀来区分 v1 v2 v3 unity3dv1 unity3dv2</p>
</li>
</ol>
<h4 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h4><p>a. 一个UI界面或者所有UI界面一个包（这个界面里面的贴图和布局信息一个包）<br>b. 一个角色或者所有角色一个包（这个角色里面的模型和动画一个包）<br>c. 所有的场景所共享的部分一个包（包括贴图和模型）</p>
<h4 id="按照类型分组"><a href="#按照类型分组" class="headerlink" title="按照类型分组"></a>按照类型分组</h4><p>所有 <strong>声音</strong> 资源打成一个包，所有 <strong>shader</strong> 打成一个包，所有 <strong>模型</strong> 打成一个包，所有材质打成一个包</p>
<h4 id="按照使用分组"><a href="#按照使用分组" class="headerlink" title="按照使用分组"></a>按照使用分组</h4><p>把在某一时间内使用的所有资源打成一个包。可以按照关卡分，一个关卡所需要的所有资源包括角色、贴图、声音等打成一个包。也可以按照场景分，一个场景所需要的资源一个包</p>
<h3 id="依赖打包"><a href="#依赖打包" class="headerlink" title="依赖打包"></a>依赖打包</h3><p>(Mat + Cube1) (Mat + Cube2)<br>(Mat) (Cube1) (Cube2)<br>Unity会自动识别，共享的依赖如果已经单独打包，则不会重复打包</p>
<h3 id="关于压缩"><a href="#关于压缩" class="headerlink" title="关于压缩"></a>关于压缩</h3><ul>
<li><p>加载时间：当从本地存储或本地缓存加载时，未压缩的AssetBundles加载速度比压缩的AssetBundles快得多。</p>
</li>
<li><p>构建时间：在压缩文件时，LZMA和LZ 4非常慢，统一编辑器依次处理AssetBundles。拥有大量资产Bundles的项目将花费大量的时间压缩它们。</p>
</li>
<li><p>应用程序大小：如果AssetBundles是在应用程序中提供的，那么压缩它们将减少应用程序的总大小。或者，AssetBundles可以在安装后下载。</p>
</li>
<li><p>内存使用：在Unity 5.3之前，Unity的所有解压缩机制都要求在解压缩之前将整个压缩的AssetBundles加载到内存中。如果内存使用很重要，请使用未压缩或LZ 4压缩AssetBundles。</p>
</li>
</ul>
<h4 id="LZMA和LZ4"><a href="#LZMA和LZ4" class="headerlink" title="LZMA和LZ4"></a>LZMA和LZ4</h4><p>LZMA是流压缩方式（stream-based）。流压缩再处理整个数据块时使用同一个字典，它提供了最大可能的压缩率，但是只支持顺序读取。所以加载AB包时，需要将整个包解压之后才能加载包内资源，会造成卡顿和额外内存占用。</p>
<p>LZ4是块压缩方式（chunk-based）。块压缩的数据被分为大小相同的块，并被分别压缩。不需要完整解压就可以加载包内资源。如果需要实时解压随机读取，块压缩是比较好的选择。<br>使用LZ4压缩，可以获得可以跟不压缩想媲美的加载速度，而且比不压缩文件要小。</p>
<p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1616396217868.png)</p>
<h4 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h4><blockquote>
<p>BuildAssetBundles底层会对传入的BuildAssetBundleOptions值进行处理，根据二进制位数来判断使用哪种策略构建AB包。因此如果在构建AB包时想要使用多种策略，用&amp;连接即可。</p>
</blockquote>
<p>BuildAssetBundleOptions.None：使用LZMA算法压缩，压缩的包更小，但是加载时间更长。使用之前需要整体解压。一旦被解压，这个包会使用LZ4重新压缩。。这就是为什么第一次加载时间长，之后加载时间就没那么长了。在下载的时候可以使用LZMA算法，一旦它被下载了之后，它会使用LZ4算法保存到本地上。</p>
<p>BuildAssetBundleOptions.UncompressedAssetBundle：不压缩，包大，加载快</p>
<p>DisableWriteTypeTree - 8：不包含TypeTree信息。虽然可以使得AB包更小，但是对低版本不兼容。不建议使用。</p>
<p>DeterministicAssetBundle - 16：创建一个哈希来映射存储在AB包里的对象的id。</p>
<p>ForceRebuildAssetBundle - 32：强制重建AB包。</p>
<p>IgnoreTypeTreeChanges - 64：当做增量构建检测时，忽略type tree的变化。</p>
<p>AppendHashToAssetBundleName - 128：添加哈希到AB包名。</p>
<p>ChunkBasedCompression - 256：使用LZ4压缩，压缩率没有LZMA高，但是我们可以加载指定资源而不用解压全部。</p>
<p>StrictMode - 512：如果在构建时有任何错误，则不允许构建成功。</p>
<p>DryRunBuild - 1024：干构建。</p>
<p>DisableLoadAssetByFileName - 4069：禁止AB包通过文件名加载资源。</p>
<p>DisableLoadAssetByFileNameWithExtension - 8192：禁止AB包通过文件扩展名加载资源。</p>
<p>AssetBundleStripUnityVersion：构建时从压缩文件和序列化文件的header中移除Unity版本号。</p>
<h3 id="assetBundleVariant-及自动标记打包API"><a href="#assetBundleVariant-及自动标记打包API" class="headerlink" title="assetBundleVariant 及自动标记打包API"></a>assetBundleVariant 及自动标记打包API</h3><p><strong>different AssetBundle variants will have the same internal IDs</strong> 。因此，AssetBundle的后缀名不仅仅是名称那么简单。而加载使用时，就看作不同名称的AB即可。</p>
<blockquote>
<p>注意：assetBundleName中设置后缀名 “Cube.ab”，并不能启到AssetBundle Variant的作用。后缀名应该在AssetImporter.assetBundleVariant中设置。</p>
</blockquote>
<p>variant 的用处：</p>
<ul>
<li><p>好一点设备上可以加载高模，而差一点的设备中只能加载低模</p>
</li>
<li><p>做分包，不同版本包</p>
</li>
<li><p>做多语言包</p>
</li>
</ul>
<p>手动设置name &amp; variant name:</p>
<p><img src="【资源】Asset Bundle\(2020-10-25 022900\" alt="Alt text"><br>_files/1621089585094.png)</p>
<p>代码自动设置：</p>
<pre><code class="lang-csharp">
# region 自动做标记

[MenuItem(&quot;AssetBundle/Set AssetBundle Lables&quot; ,false , 100)] 

public static void SetAssetBundleLables()

{ 

//移除掉所有没有使用的标记

AssetDatabase.RemoveUnusedAssetBundleNames(); 

string assetDirectory = &quot;Assets/Res&quot;; 

DirectoryInfo directoryInfo = new DirectoryInfo(assetDirectory); 

DirectoryInfo[] scenesDirectories = directoryInfo.GetDirectories(); 

foreach (var tempDir in scenesDirectories) 

{ 

string sceneDirectory = assetDirectory + &quot;/&quot; \+ tempDir.Name; 

DirectoryInfo sceneDirectoryInfo = new DirectoryInfo(sceneDirectory); 

if (sceneDirectoryInfo == null) 

{ 

Debug.Log(sceneDirectoryInfo + &quot;不存在&quot;); 

return; 

} 

else

{ 

Dictionary&lt;string , string&gt; namePathDictionary = new Dictionary&lt;string, string&gt;(); 

int index = sceneDirectory.LastIndexOf(&quot;/&quot;); 

string sceneName = sceneDirectory.Substring(index + 1); 

OnSceneFileSystemInfo(sceneDirectoryInfo , sceneName , namePathDictionary); 

OnWriteConfig(sceneName , namePathDictionary); 

} 

} 

AssetDatabase.Refresh(); 

Debug.Log(&quot;设置标记成功...&quot;); 

} 

/// &lt;summary&gt;

/// 记录配置文件

/// &lt;/summary&gt;

/// &lt;param name=&quot;sceneDirectory&quot;&gt;&lt;/param&gt;

/// &lt;param name=&quot;namePathDictionary&quot;&gt;&lt;/param&gt;

private static void OnWriteConfig(string sceneName , Dictionary&lt;string , string&gt; namePathDictionary)

{ 

string path = Application.dataPath + &quot;/AssetBundles/&quot; \+ sceneName ; 

if (!Directory.Exists(path)) Directory.CreateDirectory(path); 

Debug.Log(path); 

using (FileStream fs = new FileStream(path + &quot;/Record.txt&quot;, FileMode.OpenOrCreate , FileAccess.Write)) 

{ 

using (StreamWriter sw = new StreamWriter(fs)) 

{ 

sw.WriteLine(namePathDictionary.Count); 

foreach (KeyValuePair&lt;string , string&gt; kv in namePathDictionary) 

{ 

Debug.Log(kv.Value); 

sw.WriteLine(kv.Key+&quot;/&quot;+kv.Value); 

} 

} 

} 

} 

private static void OnSceneFileSystemInfo(FileSystemInfo fileSystemInfo , string sceneNama , Dictionary&lt;string, string&gt; namePathDictionary)

{ 

if (!fileSystemInfo.Exists) 

{ 

Debug.Log(fileSystemInfo + &quot;不存在&quot;); 

return; 

} 

DirectoryInfo directoryInfo = fileSystemInfo as DirectoryInfo; 

FileSystemInfo[] fileSystemInfos = directoryInfo.GetFileSystemInfos(); 

foreach (var systemInfo in fileSystemInfos) 

{ 

FileInfo fileInfo = systemInfo as FileInfo; 

if (fileInfo == null) 

{ 

OnSceneFileSystemInfo(systemInfo, sceneNama , namePathDictionary); 

} 

else

{ 

SetLables(fileInfo, sceneNama , namePathDictionary); 

} 

} 

} 

/// &lt;summary&gt;

/// 修改资源 assetbundle lables

/// &lt;/summary&gt;

private static void SetLables(FileInfo fileInfo , string sceneName , Dictionary&lt;string, string&gt; namePathDictionary)

{ 

if(fileInfo.Extension == &quot;.meta&quot;)return; 

string bundleName = GetBundleName(fileInfo , sceneName); 

int index = fileInfo.FullName.IndexOf(&quot;Assets&quot;); 

string assetPath = fileInfo.FullName.Substring(index); 

AssetImporter assetImporter = AssetImporter.GetAtPath(assetPath); 

assetImporter.assetBundleName = bundleName; 

if (fileInfo.Extension == &quot;.unity&quot;) 

assetImporter.assetBundleVariant = &quot;u3d&quot;; 

else

assetImporter.assetBundleVariant = &quot;assetbundle&quot;; 

string folderName; 

if (bundleName.Contains(&quot;/&quot;)) 

folderName = bundleName.Split(&#39;/&#39;)[1]; 

else

folderName = bundleName; 

string bundlePath = assetImporter.assetBundleName + &quot;.&quot; \+ assetImporter.assetBundleVariant; 

if (!namePathDictionary.ContainsKey(folderName)) 

namePathDictionary.Add(folderName, bundlePath); 

} 

private static string GetBundleName(FileInfo fileInfo, string sceneName)

{ 

string path = fileInfo.FullName; 

int index = path.IndexOf(sceneName) + sceneName.Length; 

string bundlePath = path.Substring(index + 1); 

bundlePath = bundlePath.Replace(@&quot;\&quot;, &quot;/&quot;); 

if (bundlePath.Contains(&quot;/&quot;)) 

{ 

string[] tmp = bundlePath.Split(&#39;/&#39;); 

return sceneName + &quot;/&quot; \+ tmp[0]; 

} 

return sceneName; 

} 

#endregion
</code></pre>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载流程可归为两步：</p>
<ol>
<li><p>从目标路径读取并创建 AssetBundle 对象</p>
</li>
<li><p>从 AssetBundle 对象中创建 Asset</p>
</li>
</ol>
<h3 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h3><h4 id="LoadFromFile"><a href="#LoadFromFile" class="headerlink" title="LoadFromFile"></a>LoadFromFile</h4><p>从磁盘路径读取 AssetBundle 文件，如果文件内容是以 LZMA 格式压缩的，则会将内容解压进内存保存。未压缩(uncompressed) 和块压缩(chunk-compressed) 的部分将会通过 IO 从磁盘读取。</p>
<p>如果AB包是LZ4加载方式，它只会加载AB包的Header，之后需要什么资源再加载那部分的AB包chunk。极大的减少了内存占用。</p>
<blockquote>
<p>但在Editor环境下，API还是会把整个AssetBundle加载到内存中，不应影响实际运行的设备上的性能。</p>
</blockquote>
<pre><code class="lang-csharp">
public class LoadFromFileExample : MonoBehaviour { 

function Start() { 

var myLoadedAssetBundle 

= AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;)); 

if (myLoadedAssetBundle == null) { 

Debug.Log(&quot;Failed to load AssetBundle!&quot;); 

return; 

} 

var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;); 

Instantiate(prefab); 

} 

}
</code></pre>
<h4 id="LoadFromMemory"><a href="#LoadFromMemory" class="headerlink" title="LoadFromMemory"></a>LoadFromMemory</h4><p>从托管代码的字节数组（C#中的byte[]）中加载AssetBundle。要提前用其它的方式将资源的二进制数组加入到内存中。然后该接口会将源数据从托管代码字节数组复制到新分配的、连续的本机内存块中。</p>
<p>如果AssetBundle使用了LZMA压缩，在复制过程中AssetBundle会被解压；如果使用了LZ4压缩或者没有压缩，AssetBundle会被逐字复制（be copied verbatim）。</p>
<p>当资源有加密需求时，可先把AB读取到内存当中，进行解密后再调用该AssetBundle.LoadFromMemory 进行加载。</p>
<p>此API消耗的最大内存量将至少是AssetBundle的两倍：本机内存中的一个副本，和LoadFromMemory(Async)从托管字节数组中复制的一个副本。</p>
<p>因此，从通过此API创建的AssetBundle加载的资产将在内存中一次在托管代码字节数组中，一次在AssetBundle的栈内存副本中，第三次在GPU或系统内存中，用于Asset本身。</p>
<p>适用于需要对原始数据进行解密的方式。</p>
<blockquote>
<p><strong>若把Start()函数声明成返回IEnumrator，编译器会自动将Start的调用处理成协程的模式</strong></p>
</blockquote>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

using System.IO; 

public class Example : MonoBehaviour

{ 

IEnumerator LoadFromMemoryAsync(string path)

{ 

AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path)); 

yield return createRequest; 

AssetBundle bundle = createRequest.assetBundle; 

var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;); 

Instantiate(prefab); 

} 

}
</code></pre>
<h4 id="LoadFromStream"><a href="#LoadFromStream" class="headerlink" title="LoadFromStream"></a>LoadFromStream</h4><p>AssetBundle.LoadFromStream可进行流式加载，不需要将AB全部读到内存中再解密、加载，而是可以通过每次像Buffer中读一部分，解密一部分的方式进行加载，不会多占用一份很大的内存。如果使用该接口，需要自定义一个继承FileStream类，然在Read和Write方法内对byte数组进行异或加密解密处理。</p>
<blockquote>
<p>与 LoadFromFile 类似， LZMA 格式压缩的会被解压进内存，未压缩(uncompressed) 和块压缩(chunk-compressed) 的部分将会直接通过 Stream 来读取。</p>
<p>在加载AssetBundle或捆绑包中的任何资产时，请勿释放Stream对象。它的寿命应该比AssetBundle长。这意味着在调用AssetBundle.Unload之后处理Stream对象。</p>
</blockquote>
<p><a href="https://www.xuanyusong.com/archives/4607" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4607</a></p>
<h3 id="WWW-LoadFromCacheOrDownload（Obsolete）"><a href="#WWW-LoadFromCacheOrDownload（Obsolete）" class="headerlink" title="WWW.LoadFromCacheOrDownload（Obsolete）"></a>WWW.LoadFromCacheOrDownload（Obsolete）</h3><p>Loading an AB from a remote location will automatically <strong>cache</strong> the AssetBundles. If the AssetBundle is compressed, a worker thread will spin up to decompress the bundle and write it to the cache. <strong>Once a bundle has been decompressed and cached, it will load exactly like AssetBundle.LoadFromFile .</strong></p>
<pre><code class="lang-csharp">
using UnityEngine; 

using System.Collections; 

public class LoadFromCacheOrDownloadExample : MonoBehaviour

{ 

IEnumerator Start ()

{ 

while (!Caching.ready) 

yield return null; 

var www = WWW.LoadFromCacheOrDownload(&quot;http://myserver.com/myassetBundle&quot;, 5); 

yield return www; 

if(!string.IsNullOrEmpty(www.error)) 

{ 

Debug.Log(www.error); 

yield return; 

} 

var myLoadedAssetBundle = www.assetBundle; 

var asset = myLoadedAssetBundle.mainAsset; 

} 

}
</code></pre>
<h3 id="UnityWebRequest-AssetBundleDownloadHandler"><a href="#UnityWebRequest-AssetBundleDownloadHandler" class="headerlink" title="UnityWebRequest - AssetBundleDownloadHandler"></a>UnityWebRequest - AssetBundleDownloadHandler</h3><p>它使用工作线程，将下载的数据流存储到一个固定大小的缓冲区中，然后根据下载处理程序的配置方式将缓冲数据放到临时存储或AssetBundle缓存中。</p>
<p>它使用工作线程，将下载的数据流存储到一个固定大小的缓冲区中，然后根据下载处理程序的配置方式将缓冲数据放到临时存储或AssetBundle缓存中。</p>
<p>所有这些操作都发生在非托管代码中，消除了增加堆内存的风险。此外，该下载处理程序并不会保留所有下载字节的栈内存副本，从而进一步减少了下载AssetBundle的内存开销。</p>
<p>如果将缓存信息提供给UnityWebRequest对象，一旦有请求的AssetBundle已经存在于Unity的缓存中，那么AssetBundle将立即可用，并且此API的行为将会与AssetBundle.LoadFromFile相同操作。</p>
<blockquote>
<p>从服务器下载</p>
<ol>
<li>NetBox可以在本地启动服务器，把当前目录作为服务器端的网站</li>
</ol>
</blockquote>
<pre><code class="lang-csharp">
IEnumerator InstantiateObject()

{ 

string uri = &quot;file:///&quot; \+ Application.dataPath + &quot;/AssetBundles/&quot; \+ assetBundleName; 

UnityEngine.Networking.UnityWebRequest request 

= UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0); 

yield return request.Send(); 

AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request); 

GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); 

GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;); 

Instantiate(cube); 

Instantiate(sprite); 

}
</code></pre>
<h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><ol>
<li><p>一般来说，只要有可能，就应该使用AssetBundle.LoadFromFile。这个API在速度、磁盘使用和运行时内存使用方面是最有效的。</p>
</li>
<li><p>对于必须下载或热更新AssetBundles的项目，强烈建议使用UnityWebRequest。</p>
</li>
<li><p>当使用UnityWebRequest时，要确保下载程序代码在加载AssetBundle后正确地调用Dispose。另外，C#的using语句是确保UnityWebRequest被安全处理的最方便的方法。</p>
</li>
<li><p>对于需要独特的、特定的缓存或下载需求的大项目，可以考虑使用自定义的下载器。编写自定义下载程序是一项重要并且复杂的任务，任何自定义的下载程序都应该与AssetBundle.LoadFromFile保持兼容。</p>
</li>
<li><p>在多数情况下，最好在玩家进入应用程序的性能关键区域（如主游戏关卡或世界）之前加载尽可能多的所需对象。这在移动平台上尤为重要，因为在移动平台上，访问本地存储的速度很慢，并且在运行时加载和卸载对象会触发垃圾回收。</p>
</li>
</ol>
<h3 id="同步和异步的优缺点"><a href="#同步和异步的优缺点" class="headerlink" title="同步和异步的优缺点"></a>同步和异步的优缺点</h3><p>Ref: <a href="https://blog.csdn.net/qq_40093529/article/details/85290686" target="_blank" rel="noopener">https://blog.csdn.net/qq_40093529/article/details/85290686</a><br><strong>异步</strong><br>优点：速度快，与主线程无关，<br>缺点：调用比较麻烦，因为你不知道啥时候你的资源准备好了，最好的做法也是使用回调，这样回调就会很多，很乱个人感觉管理起来很不舒服。</p>
<p><strong>同步</strong><br>优点：管理起来方便，而且资源准备好了是可以及时返回的，<br>缺点：是没有异步快<br>综合上诉，最终我选择了 同步，因为我不希望代码不整洁，也不希望写太多的回调函数来通知调用者，资源准备妥当了。那么问题来了，如何解决同步的缺点呢。也就是卡主线程。之前一直以为corotine这玩意可以帮到我们。但是当我深入理解了coroutine以后发现他其实也是在主线程中的。最终我选择了使用c# 的多线程机制来解决这个问题。</p>
<h3 id="Manifests的加载"><a href="#Manifests的加载" class="headerlink" title="Manifests的加载"></a>Manifests的加载</h3><p>加载Manifests文件可以处理资源的依赖</p>
<pre><code class="lang-csharp">
AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath); 

AssetBundleManifest manifest = 

assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;); 

string[] dependencies = manifest.GetAllDependencies(&quot;assetBundle&quot;); 

//Pass the name of the bundle you want the dependencies for.

foreach(string dependency in dependencies) 

{ 

AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency)); 

}
</code></pre>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>卸载有两个方面</p>
<ol>
<li><p>减少内存使用</p>
</li>
<li><p>有可能导致丢失<br>所以什么时候去卸载资源是我们要关注的</p>
</li>
</ol>
<h3 id="AssetBundle-Unload-true"><a href="#AssetBundle-Unload-true" class="headerlink" title="AssetBundle.Unload(true)"></a>AssetBundle.Unload(true)</h3><p>不仅Object被销毁，而且Instance ID的GUID和Local ID引用变无效。<br>When unloadAllLoadedObjects is true, all objects that were loaded from this bundle will be destroyed as well. If there are GameObjects in your Scene referencing those assets, the references to them will become missing.</p>
<p>卸载所有资源，即使有资源被使用着<br>1. 在关卡切换、场景切换<br>2. 资源没被用的时候调用</p>
<h3 id="AssetBundle-Unload-false"><a href="#AssetBundle-Unload-false" class="headerlink" title="AssetBundle.Unload(false)"></a>AssetBundle.Unload(false)</h3><p>虽Object不被销毁，但Instance ID的GUID和Local ID引用变无效。场景中的物体会与该AB包分离链接。即该物体的instance ID引用的GUID和Local ID会断开引用，无法再通过该instance ID找到GUID和Local ID。<br>如果再次加载该AB包时，分离了链接的物体不会受该新加载的AB包管理。因此如果不注意的话可能会导致一些不可控的问题。Unity中有Resources.UnloadUnusedAssets()方法可以很好地解决这个问题。</p>
<p>When unloadAllLoadedObjects is false, compressed file data inside the bundle itself will be freed, but any instances of objects loaded from this bundle will remain intact.</p>
<p>If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways:</p>
<ol>
<li><p>先去除对不想要的Objects的引用（包括场景和代码当中），然后调用 Resources.UnloadUnusedAssets. </p>
</li>
<li><p>场景切换的时候：Load a scene non-additively. This will destroy all Objects in the current scene and invoke <code>Resources.UnloadUnusedAssets</code> automatically.</p>
</li>
</ol>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>大多数项目应该使用AssetBundle.Unload(True)，并采用一种方法来确保对象不被复制。<br>两种常见的方法是：<br>（1）在应用程序的生命周期内定义一个合适的节点，并在此期间卸载不需要的AssetBundle，例如在关卡切换或加载屏幕期间。这是最简单和最常见的选择。<br>（2）维护单个对象的引用计数，并仅当所有组成对象都未使用时才卸载AssetBundles。这允许应用程序在不重复内存的情况下卸载和重新加载单个对象。</p>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="AssetDatabase"><a href="#AssetDatabase" class="headerlink" title="AssetDatabase"></a>AssetDatabase</h3><pre><code class="lang-csharp">
var names = AssetDatabase.GetAllAssetBundleNames(); 

foreach (var name in names) 

Debug.Log(&quot;AssetBundle: &quot; \+ name);
</code></pre>
<ul>
<li><p>AssetDatabase.GetAllAssetBundleNames() </p>
</li>
<li><p>AssetDatabase.GetAssetPathsFromAssetBundle </p>
</li>
<li><p>AssetDatabase.RemoveAssetBundleName()</p>
</li>
<li><p>AssetDatabase.GetUnusedAssetBundleNames() </p>
</li>
<li><p>AssetDatabase.RemoveUnusedAssetBundleNames() </p>
</li>
<li><p>The callback AssetPostProcessor.OnPostprocessAssetbundleNameChanged is called if user changes the AssetBundle name of an asset.</p>
</li>
</ul>
<h3 id="Asset-PostProcessor"><a href="#Asset-PostProcessor" class="headerlink" title="Asset PostProcessor"></a>Asset PostProcessor</h3><pre><code class="lang-csharp">
using UnityEngine; 

using UnityEditor; 

public class MyPostprocessor : AssetPostprocessor

{ 

void OnPostprocessAssetbundleNameChanged(string path,

string previous, string next)

{ 

Debug.Log(&quot;AB: &quot; \+ path + &quot; old: &quot; \+ previous + &quot; new: &quot; \+ next); 

} 

}
</code></pre>
<h2 id="AB包内部结构"><a href="#AB包内部结构" class="headerlink" title="AB包内部结构"></a>AB包内部结构</h2><p>AssetBundleFileHeader：记录了版本号、压缩等主要描述信息。</p>
<p>AssetFileHeader：包含一个文件列表，记录了每个资源的name、offset、length等信息。</p>
<p>Asset1：</p>
<p>AssetHeader：记录了TypeTree大小、文件大小、format等信息。<br>TypeTree（可选，有不要TypeTree的构建方式）：记录了Asset对象的class ID。Unity可以用class ID来序列化和反序列化一个类。（每个class对应了一个ID，如0是Object类，1是GameObject类等。具体可在Unity官网上查询。）<br>ObjectPath：记录了path ID（资源唯一索引ID）等。<br>AssetRef：记录了AB包对外部资源对引用情况。<br>Asset2…</p>
<p>.manifest文件</p>
<pre><code class="lang-csharp">
`ManifestFileVersion: 0 # 文件版本

CRC: 2657307167 # CRC校验码

Hashes: # 哈希

AssetFileHash: # AB包中所有资源的哈希，可用于增量更新检测

serializedVersion: 2 # Unity序列化版本

Hash: 717e408ba50ee41b0960161fd2d5a827

TypeTreeHash: # AB包中所有类型的哈希，可用于增量更新检测

serializedVersion: 2 # Unity序列化版本

Hash: 8d552bf2f5bdba1177c938cb98ca6f2f

HashAppended: 0

ClassTypes: # TypeTree

\- Class: 1 # GameObject

Script: {instanceID: 0}

\- Class: 21 # Material

Script: {instanceID: 0}

\- Class: 28 # Texture2D

Script: {instanceID: 0}

\- Class: 48 # Shader

Script: {instanceID: 0}

\- Class: 114 # MonoBehaviour

Script: {fileID: 1392445389, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: -765806418, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: -1200242548, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: -146154839, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 708705254, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 1297475563, guid: f70555f144d8491a825f0804e09c671c, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 11500000, guid: 20e8969313b8e4614b498f042e99683a, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 11500000, guid: c86dbe77db44a434bb15895563508b65, type: 3}

\- Class: 114 # MonoBehaviour

Script: {fileID: 11500000, guid: 1a7e2f4cb82d9b94a91270d550c880c0, type: 3}

\- Class: 115 # MonoScript

Script: {instanceID: 0}

\- Class: 128 # Font

Script: {instanceID: 0}

\- Class: 198 # ParticleSystem

Script: {instanceID: 0}

\- Class: 199 # ParticleSystemRenderer

Script: {instanceID: 0}

\- Class: 213 # Sprite

Script: {instanceID: 0}

\- Class: 222 # CanvasRenderer

Script: {instanceID: 0}

\- Class: 224 # RectTransform

Script: {instanceID: 0}

\- Class: 687078895 # SpriteAtlas

Script: {instanceID: 0}

Assets: # 包含资源

- Assets/Bundle/.../a.prefab

- Assets/Bundle/.../b.prefab

- Assets/Bundle/.../c.spriteatlas

Dependencies: # AB包依赖

- /Users/apple/.../AssetBundles/Android/q

- /Users/apple/.../AssetBundles/Android/w

- /Users/apple/.../AssetBundles/Android/e

- /Users/apple/.../AssetBundles/Android/r

- /Users/apple/.../AssetBundles/Android/t`
</code></pre>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h3><p>加密思路：<br>1、在构建完AB包后，可以将AB包中的内容以byte[]形式读取。<br>2、之后选用任意加密方式对该byte[]加密。<br>3、加密完后重新写入AB包中。<br>4、AB包加密完成。</p>
<blockquote>
<p>这样对AB包加密之后，如果使用AssetBundle.LoadFromFile()来加载加密的AB包是会报错的，因为Unity以及无法识别加密过后的内容。</p>
</blockquote>
<p>解密思路：<br>1、先以byte[]形式读取AB包中的内容。<br>2、之后使用对应的解密算法对该byte[]进行解密。<br>3、解密过后的byte[]通过AssetBundle.LoadFromMemory()来进行加载。<br>4、AB包加载完成。</p>
<p>占用内存的峰值至少是他所处理的AssetBundle大小的两倍：一份由此API创建在本机内存中的副本和一份传递给此API的位于托管字节数组中的副本。通过此API从AssetBundle加载的Asset会在内存中被复制3次：在托管代码中的字节数组、本机内存中的副本以及在GPU或系统内存中的Asset本体。</p>
<h3 id="耗费小的思路-偏移量"><a href="#耗费小的思路-偏移量" class="headerlink" title="耗费小的思路-偏移量"></a>耗费小的思路-偏移量</h3><p>在构建完AB包之后，在AB包前插入N个随机byte。AssetBundle.LoadFromFile()的第三个参数是AB包内容的byte偏移量。也就是说从offset个byte开始读取AB包的内容。</p>
<blockquote>
<p>对于资源加密，我们大多数时候能做到的是防小白不防专家，不管你是采用简单的或者复杂的，在反编译高手手里都有点苍白</p>
</blockquote>
<pre><code class="lang-csharp">
public static AssetBundle LoadFromFile(string path, uint crc, ulong offset);
</code></pre>
<p>具体实现可参考：<a href="https://zhuanlan.zhihu.com/p/75964237" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75964237</a></p>
<h3 id="LoadFromStream-1"><a href="#LoadFromStream-1" class="headerlink" title="LoadFromStream"></a>LoadFromStream</h3><p><a href="https://www.xuanyusong.com/archives/4607" target="_blank" rel="noopener">https://www.xuanyusong.com/archives/4607</a></p>
<h2 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h2><p>CRC MD5 SHA1<br>相同点：<br>CRC、MD5、SHA1都是通过对数据进行计算，来生成一个校验值，该校验值用来校验数据的完整性。<br>不同点：</p>
<ol>
<li><p>算法不同。CRC采用多项式除法，MD5和SHA1使用的是替换、轮转等方法；</p>
</li>
<li><p>校验值的长度不同。CRC校验位的长度跟其多项式有关系，一般为16位或32位；MD5是16个字节（128位）；SHA1是20个字节（160位）；</p>
</li>
<li><p>校验值的称呼不同。CRC一般叫做CRC值；MD5和SHA1一般叫做哈希值（Hash）或散列值；</p>
</li>
<li><p>安全性不同。这里的安全性是指检错的能力，即数据的错误能通过校验位检测出来。CRC的安全性跟多项式有很大关系，相对于MD5和SHA1要弱很多；MD5的安全性很高，不过大概在04年的时候被山东大学的王小云破解了；SHA1的安全性最高。</p>
</li>
<li><p>效率不同，CRC的计算效率很高；MD5和SHA1比较慢。</p>
</li>
<li><p>用途不同。CRC一般用作通信数据的校验；MD5和SHA1用于安全（Security）领域，比如文件校验、数字签名等。</p>
</li>
</ol>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="和项目一起安装"><a href="#和项目一起安装" class="headerlink" title="和项目一起安装"></a>和项目一起安装</h3><ul>
<li><p>减少项目构建时间并允许更简单的迭代开发。</p>
</li>
<li><p>发布可更新内容的初始修订版。</p>
</li>
</ul>
<h3 id="安装后再下载它们"><a href="#安装后再下载它们" class="headerlink" title="安装后再下载它们"></a>安装后再下载它们</h3><p>这就允许在安装后再更新游戏内容，而不必强迫用户重新下载整个应用程序。<br>将它们放在某个Web服务器上，并通过UnityWebRequest发布。Unity将自动在本地存储上缓存下载的AssetBundles。如果下载的AssetBundle是LZMA压缩的，那么AssetBundle将以未压缩或重新压缩的形式存储在缓存中，就像LZ 4一样（依赖Caching.compressionEnabled设置），以便将来更快地加载。如果下载的包是LZ 4压缩的，AssetBundles将被压缩存储。如果缓存被填满，Unity将从缓存中删除最近使用最少的AssetBundle。</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>Unity有一个内置的AssetBundle缓存系统，可以用来缓存通过UnityWebRequest API下载的AssetBundles，该API的重载会接受一个AssetBundle版本号作为参数。这个数字不是存储在AssetBundles里的，也不是由AssetBundles系统生成的。</p>
<p>缓存系统跟踪传递给UnityWebRequest的最后一个版本号。当使用版本号调用此API时，缓存系统通过比较版本号来检查是否存在缓存的AssetBundle。如果这些数字匹配，系统将加载缓存的AssetBundle。如果数字不匹配，或者没有缓存的AssetBundle，那么Unity将下载一个新的副本。此新副本将与新的版本号相关联。</p>
<p>缓存系统中的AssetBundle只通过它们的文件名来标识，而不是通过下载它们的完整URL。这意味着具有相同文件名的AssetBundle可以存储在多个不同的位置，例如CDN。只要文件名相同，缓存系统就会将它们识别为相同的AssetBundle。</p>
<h2 id="相关优化"><a href="#相关优化" class="headerlink" title="相关优化"></a>相关优化</h2><h3 id="冗余问题"><a href="#冗余问题" class="headerlink" title="冗余问题"></a>冗余问题</h3><p>在Unity5.0后，BuildAssetBundleOptions.CollectDependencies永久开启，即Unity会自动检测物体引用的资源并且一并打包，防止资源丢失遗漏的问题出现。有些情况下，如果没指定某公共资源的存放在哪个AB包中，这个公共资源就会被自动打进引用它的AB包中，所以出现多个不同的AB包中有重复的资源存在的现象。这就是资源冗余。</p>
<p>a. 把需要共享的资源打包到一起<br>b. 分割包，这些包不是在同一时间使用的<br>c. 把共享部分打包成一个单独的包</p>
<h3 id="图集重复问题"><a href="#图集重复问题" class="headerlink" title="图集重复问题"></a>图集重复问题</h3><p>在Unity当中，Sprite2D会被打包到一个图集当中（由Packing Tag决定）。如果不指定PackingTag，Sprite会打包到同一个图集当中。一个Sprite打包到AssetBundle中时，它所在的整个图集都会被打包进去。<br>解决方法：确保同一个图集当中的图片打包到同一个AssetBundle当中去。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li><p>Android贴图问题</p>
</li>
<li><p>iOS文件处理重复fixed in Unity 5.3.2p2.</p>
</li>
</ul>
<h2 id="UnityAssetBundleBrowserTool"><a href="#UnityAssetBundleBrowserTool" class="headerlink" title="UnityAssetBundleBrowserTool"></a>UnityAssetBundleBrowserTool</h2><h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><p>Build的时候，该文件夹下的所有东西会被原封不动地打包到我们的安装包当中。<br>一般放一些二进制文件、 AssetBundles。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://segmentfault.com/a/1190000038943912" target="_blank" rel="noopener">https://segmentfault.com/a/1190000038943912</a><br><a href="https://blog.uwa4d.com/archives/USparkle_Addressable3.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/USparkle_Addressable3.html</a></p>
<p><a href="https://learn.unity.com/tutorial/assets-resources-and-assetbundles" target="_blank" rel="noopener">https://learn.unity.com/tutorial/assets-resources-and-assetbundles</a></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://www.prince-y-p.com/2023/07/25/Unity3D-%E3%80%90%E8%B5%84%E6%BA%90%E3%80%91Asset-Bundle-2020-10-25-022900/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/07/25/Unity3D-%E4%BB%8EEnumerator%E5%88%B0StartCoroutine%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            从Enumerator到StartCoroutine底层分析——容器的概念枚举器与代码的协
          
        </div>
      </a>
    
    
      <a href="/2023/07/25/Unity3D-%E3%80%90%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E3%80%91%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">【疑难问题处理】异常捕获与处理</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Prin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/img/circle_image.png" alt="半个出家人"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Unreal">虚幻引擎</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>